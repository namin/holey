Starting with 1715 puzzles...
Running benchmarks on 774 puzzles...
Filtered to puzzles of answer types: ['int', 'str', 'float']

Solving puzzle 1/774: Study_1:0
sat_func def sat(s: str):
    return s.count('o') == 1000 and s.count('oo') == 0
modified_func def sat(s: str):
    return (s.count('o') == wrap_int(1000)).__and__(s.count('oo') == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "o") 0))
(assert (>= (str.count x "oo") 0))
(assert (and (= (str.count x "o") 1000) (= (str.count x "oo") 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Study_1:0
One large constant for extrapolation
Solving simpler variation replaced 1000 with 3
sat_func def sat(s: str):
    return s.count('o') == 3 and s.count('oo') == 0
modified_func def sat(s: str):
    return (s.count('o') == wrap_int(3)).__and__(s.count('oo') == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "o") 0))
(assert (>= (str.count x "oo") 0))
(assert (and (= (str.count x "o") 3) (= (str.count x "oo") 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "oBoAo")
)

Found solution oBoAo

Solving puzzle 2/774: Study_2:0
sat_func def sat(s: str):
    return s.count('o') == 1000 and s.count('oo') == 100 and s.count('ho') == 801
modified_func def sat(s: str):
    return (s.count('o') == wrap_int(1000)).__and__(s.count('oo') == wrap_int(100)).__and__(s.count('ho') == wrap_int(801))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "o") 0))
(assert (>= (str.count x "oo") 0))
(assert (>= (str.count x "ho") 0))
(assert (and (and (= (str.count x "o") 1000) (= (str.count x "oo") 100)) (= (str.count x "ho") 801)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Study_2:0
Too many constants for extrapolation

Solving puzzle 3/774: Study_6:0
sat_func def sat(i: int):
    return i % 123 == 4 and i > 10 ** 10
modified_func def sat(i: int):
    return (i % wrap_int(123) == wrap_int(4)).__and__(i > wrap_int(10) ** wrap_int(10))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= (mod x 123) 4) (> x 10000000000)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    10000000003)
)
### output for cvc5
sat
(
(define-fun x () Int 10000000003)
)

Found solution 10000000003
Yes! Solved for puzzle  Study_6:0

Solving puzzle 4/774: Study_7:0
sat_func def sat(s: str):
    return str(8 ** 2888).count(s) > 8 and len(s) == 3
modified_func def sat(s: str):
    return (sym_str(wrap_int(8) ** wrap_int(2888)).count(s) > wrap_int(8)).__and__(sym_len(s) == wrap_int(3))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count "4839243898769310936356356096" x) 0))
(assert (and (> (str.count "4839243898769310936356356096" x) 8) (= (str.len x) 3)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Study_7:0
One large constant for extrapolation
Solving simpler variation replaced 2888 with 3
sat_func def sat(s: str):
    return str(8 ** 3).count(s) > 8 and len(s) == 3
modified_func def sat(s: str):
    return (sym_str(wrap_int(8) ** wrap_int(3)).count(s) > wrap_int(8)).__and__(sym_len(s) == wrap_int(3))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count "6561" x) 0))
(assert (and (> (str.count "6561" x) 8) (= (str.len x) 3)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 18 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Study_7:0

Solving puzzle 5/774: Study_10:0
sat_func def sat(s: str):
    return s in str(8 ** 1818) and s == s[::-1] and len(s) > 11
modified_func def sat(s: str):
    return sym_in(s, sym_str(wrap_int(8) ** wrap_int(1818))).__and__(s == s[::-1]).__and__(sym_len(s) > wrap_int(11))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (and (str.contains "119330382054786800205701376" x) (= x (str.reverse x))) (> (str.len x) 11)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Study_10:0
One large constant for extrapolation
Solving simpler variation replaced 1818 with 3
sat_func def sat(s: str):
    return s in str(8 ** 3) and s == s[::-1] and len(s) > 11
modified_func def sat(s: str):
    return sym_in(s, sym_str(wrap_int(8) ** wrap_int(3))).__and__(s == s[::-1]).__and__(sym_len(s) > wrap_int(11))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (and (str.contains "6561" x) (= x (str.reverse x))) (> (str.len x) 11)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 12 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Study_10:0

Solving puzzle 6/774: Study_13:0
sat_func def sat(x: float):
    return str(x - 3.1415).startswith("123.456")
modified_func def sat(x: float):
    return sym_str(x - 3.1415).startswith('123.456')
### smt2
(set-logic ALL)

(define-fun str.from_real ((r Real)) String
  (let ((is-negative (< r 0.0)))
    (let ((abs-r (ite is-negative (- 0.0 r) r)))
      (let ((int-part (to_int abs-r)))
        (let ((frac-part (- abs-r (to_real int-part))))
          (let ((int-str (str.from_int int-part)))
            (let ((sign-str (ite is-negative "-" "")))
              (let ((decimal-str "."))
                (let ((precision 6.0)) ;; Show 6 decimal places
                  (let ((frac-expanded (to_int (* frac-part (^ 10.0 precision)))))
                    (let ((frac-str (str.from_int frac-expanded)))
                      ;; Combine all parts: sign + integer part + decimal point + fraction part
                      (str.++ sign-str (str.++ int-str (str.++ decimal-str frac-str))))))))))))))

(declare-const x Real)
(assert (str.prefixof "123.456" (str.from_real (- x 3.1415))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () Real (/ 252283913 2000000))
)

Found solution 126.1419565
WARNING: Solution verification failed for puzzle Study_13:0
Too many constants for extrapolation

Solving puzzle 7/774: Study_16:0
sat_func def sat(s: str):
    return float(s) + len(s) == 4.5
modified_func def sat(s: str):
    return sym_float(s) + sym_len(s) == 4.5
### smt2
(set-logic ALL)

(define-fun str.to.float ((s String)) Real
  (let ((dot_pos (str.indexof s "." 0)))
    (ite (= dot_pos (- 1))
      ; No decimal point - convert whole string as integer
      (to_real (str.to_int s))
      ; Has decimal point - handle integer and decimal parts
      (let ((int_part (str.substr s 0 dot_pos))
            (dec_part (str.substr s (+ dot_pos 1) (- (str.len s) (+ dot_pos 1)))))
        (+ (to_real (str.to_int int_part))
           (/ (to_real (str.to_int dec_part))
              (^ 10.0 (- (str.len s) (+ dot_pos 1)))))))))

(declare-const x String)
(assert (= (+ (str.to.float x) (str.len x)) 4.5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "1.5")
  (define-fun /0 ((x!0 Real) (x!1 Real)) Real
    (/ 1.0 2.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:13.52: expecting same arithmetic types to POW")

Found solution 1.5
Yes! Solved for puzzle  Study_16:0

Solving puzzle 8/774: Study_17:0
sat_func def sat(i: int):
    return len(str(i + 1000)) > len(str(i + 1001))
modified_func def sat(i: int):
    return sym_len(sym_str(i + wrap_int(1000))) > sym_len(sym_str(i + wrap_int(1001)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (> (str.len (str.from_int (+ x 1000))) (str.len (str.from_int (+ x 1001)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Study_17:0
Two large constants for extrapolation
Solving simpler variation replaced 1000 with 3 and 1001 with 5
sat_func def sat(i: int):
    return len(str(i + 3)) > len(str(i + 5))
modified_func def sat(i: int):
    return sym_len(sym_str(i + wrap_int(3))) > sym_len(sym_str(i + wrap_int(5)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (> (str.len (str.from_int (+ x 3))) (str.len (str.from_int (+ x 5)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Study_17:0

Solving puzzle 9/774: Study_22:0
sat_func def sat(s: str):
    return s[::2] in s and len(set(s)) == 5
modified_func def sat(s: str):
    return sym_in(s[::2], s).__and__(sym_len(set(s)) == wrap_int(5))
Exception -- for puzzle Study_22:0 Slicing on symbolic strings not fully implemented.

Solving puzzle 10/774: Study_25:0
sat_func def sat(s: str):
    return sorted(s) == sorted('Permute me true') and s == s[::-1]
modified_func def sat(s: str):
    return (sym_sorted(s) == sym_sorted(wrap_str('Permute me true'))).__and__(s == s[::-1])
### smt2
(set-logic ALL)

(define-fun-rec str.min_char ((s String)) String
  (let ((len (str.len s)))
    (ite (<= len 1)
         s
         (let ((first (str.at s 0))
               (rest_min (str.min_char (str.substr s 1 (- len 1)))))
           (ite (str.< first rest_min)
                first
                rest_min)))))

(define-fun-rec str.remove_first_occurrence ((s String) (c String)) String
  (let ((len (str.len s)))
    (ite (= len 0)
         ""
         (ite (= (str.at s 0) c)
              (str.substr s 1 (- len 1))
              (str.++ (str.substr s 0 1) 
                     (str.remove_first_occurrence (str.substr s 1 (- len 1)) c))))))

(define-fun-rec str.sorted ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0)
         ""
         (let ((min_c (str.min_char s)))
           (str.++ min_c (str.sorted (str.remove_first_occurrence s min_c)))))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (= (str.sorted x) "  Peeeemmrrttuu") (= x (str.reverse x))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Study_25:0
Too many constants for extrapolation

Solving puzzle 11/774: Quine:0
sat_func def sat(quine: str):
    return eval(quine) == quine
modified_func def sat(quine: str):
    return eval(quine) == quine
Exception -- for puzzle Quine:0 eval() arg 1 must be a string, bytes or code object

Solving puzzle 12/774: RevQuine:0
sat_func def sat(rev_quine: str):
    return eval(rev_quine[::-1]) == rev_quine
modified_func def sat(rev_quine: str):
    return eval(rev_quine[::-1]) == rev_quine
Exception -- for puzzle RevQuine:0 eval() arg 1 must be a string, bytes or code object

Solving puzzle 13/774: MonkeyAndCoconuts:0
sat_func def sat(n: int):
    for i in range(5):
        assert n % 5 == 1
        n -= 1 + (n - 1) // 5
    return n > 0 and n % 5 == 1
modified_func def sat(n: int):
    for i in sym_range(5):
        _assert(n % wrap_int(5) == wrap_int(1))
        n -= wrap_int(1) + (n - wrap_int(1)) // wrap_int(5)
    return (n > wrap_int(0)).__and__(n % wrap_int(5) == wrap_int(1))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (mod x 5) 1))
(assert (= (mod (- x (+ 1 (div (- x 1) 5))) 5) 1))
(assert (= (mod (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) 5) 1))
(assert (= (mod (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) (+ 1 (div (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) 1) 5))) 5) 1))
(assert (= (mod (- (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) (+ 1 (div (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) 1) 5))) (+ 1 (div (- (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) (+ 1 (div (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) 1) 5))) 1) 5))) 5) 1))
(assert (and (> (- (- (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) (+ 1 (div (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) 1) 5))) (+ 1 (div (- (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) (+ 1 (div (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) 1) 5))) 1) 5))) (+ 1 (div (- (- (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) (+ 1 (div (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) 1) 5))) (+ 1 (div (- (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) (+ 1 (div (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) 1) 5))) 1) 5))) 1) 5))) 0) (= (mod (- (- (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x 1) 5))) 1) 5))) (+ 1 (div (- (- (- x (+ 1 (div (- x 1) 5))) (+ 1 (div (- (- x (+ 1 (div (- x...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    15621)
)
### output for cvc5
sat
(
(define-fun x () Int 15621)
)

Found solution 15621
Yes! Solved for puzzle  MonkeyAndCoconuts:0

Solving puzzle 14/774: Sudoku:0
sat_func def sat(x: str, puz="____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
modified_func def sat(x: str, puz=wrap_str('____9_2___7__________1_8_4____2_78____4_____1____69____2_8___5__6__3_7___49______')):
    _assert(all(sym_generator(((c == wrap_str('_')).__or__(c == s) for c, s in sym_zip(puz, x)))))
    full = set(wrap_str('123456789'))
    for i in sym_range(9):
        _assert({x[i] for i in sym_range(9 * i, 9 * i + 9)} == full, wrap_str('invalid row'))
        _assert({x[i] for i in sym_range(i, i + 81, 9)} == full, wrap_str('invalid column'))
        _assert({x[wrap_int(9) * a + b + i + wrap_int(26) * (i % wrap_int(3))] for a in sym_range(3) for b in sym_range(3)} == full, wrap_str('invalid square'))
    return True
Skipping constant true constraint
Exception -- for puzzle Sudoku:0 Symbolic hash not yet implemented

Solving puzzle 15/774: Sudoku:1
sat_func def sat(x: str, puz="__2__1_3__9_7_____5______8_6___5_______12____2____3_68________9_1_8__4____7____25"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
modified_func def sat(x: str, puz=wrap_str('__2__1_3__9_7_____5______8_6___5_______12____2____3_68________9_1_8__4____7____25')):
    _assert(all(sym_generator(((c == wrap_str('_')).__or__(c == s) for c, s in sym_zip(puz, x)))))
    full = set(wrap_str('123456789'))
    for i in sym_range(9):
        _assert({x[i] for i in sym_range(9 * i, 9 * i + 9)} == full, wrap_str('invalid row'))
        _assert({x[i] for i in sym_range(i, i + 81, 9)} == full, wrap_str('invalid column'))
        _assert({x[wrap_int(9) * a + b + i + wrap_int(26) * (i % wrap_int(3))] for a in sym_range(3) for b in sym_range(3)} == full, wrap_str('invalid square'))
    return True
Skipping constant true constraint
Exception -- for puzzle Sudoku:1 Symbolic hash not yet implemented

Solving puzzle 16/774: Sudoku:2
sat_func def sat(x: str, puz="__721__56__27___________9______5____62______1_1___9___8_____________3197__61__32_"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
modified_func def sat(x: str, puz=wrap_str('__721__56__27___________9______5____62______1_1___9___8_____________3197__61__32_')):
    _assert(all(sym_generator(((c == wrap_str('_')).__or__(c == s) for c, s in sym_zip(puz, x)))))
    full = set(wrap_str('123456789'))
    for i in sym_range(9):
        _assert({x[i] for i in sym_range(9 * i, 9 * i + 9)} == full, wrap_str('invalid row'))
        _assert({x[i] for i in sym_range(i, i + 81, 9)} == full, wrap_str('invalid column'))
        _assert({x[wrap_int(9) * a + b + i + wrap_int(26) * (i % wrap_int(3))] for a in sym_range(3) for b in sym_range(3)} == full, wrap_str('invalid square'))
    return True
Skipping constant true constraint
Exception -- for puzzle Sudoku:2 Symbolic hash not yet implemented

Solving puzzle 17/774: Sudoku:3
sat_func def sat(x: str, puz="_____42______7_____4______9__49___626_8__3___3_7__65_4_5_3__1__1____8_7__________"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
modified_func def sat(x: str, puz=wrap_str('_____42______7_____4______9__49___626_8__3___3_7__65_4_5_3__1__1____8_7__________')):
    _assert(all(sym_generator(((c == wrap_str('_')).__or__(c == s) for c, s in sym_zip(puz, x)))))
    full = set(wrap_str('123456789'))
    for i in sym_range(9):
        _assert({x[i] for i in sym_range(9 * i, 9 * i + 9)} == full, wrap_str('invalid row'))
        _assert({x[i] for i in sym_range(i, i + 81, 9)} == full, wrap_str('invalid column'))
        _assert({x[wrap_int(9) * a + b + i + wrap_int(26) * (i % wrap_int(3))] for a in sym_range(3) for b in sym_range(3)} == full, wrap_str('invalid square'))
    return True
Skipping constant true constraint
Exception -- for puzzle Sudoku:3 Symbolic hash not yet implemented

Solving puzzle 18/774: Sudoku:4
sat_func def sat(x: str, puz="___56_4_7__92_4_65___3______9____2___5_______7___8___1_________43_____5_____76__2"):
    assert all(c == "_" or c == s for (c, s) in zip(puz, x))

    full = set('123456789')
    for i in range(9):
        assert {x[i] for i in range(9 * i, 9 * i + 9)} == full, "invalid row"
        assert {x[i] for i in range(i, i + 81, 9)} == full, "invalid column"
        assert {x[9 * a + b + i + 26 * (i % 3)] for a in range(3) for b in range(3)} == full, "invalid square"

    return True
modified_func def sat(x: str, puz=wrap_str('___56_4_7__92_4_65___3______9____2___5_______7___8___1_________43_____5_____76__2')):
    _assert(all(sym_generator(((c == wrap_str('_')).__or__(c == s) for c, s in sym_zip(puz, x)))))
    full = set(wrap_str('123456789'))
    for i in sym_range(9):
        _assert({x[i] for i in sym_range(9 * i, 9 * i + 9)} == full, wrap_str('invalid row'))
        _assert({x[i] for i in sym_range(i, i + 81, 9)} == full, wrap_str('invalid column'))
        _assert({x[wrap_int(9) * a + b + i + wrap_int(26) * (i % wrap_int(3))] for a in sym_range(3) for b in sym_range(3)} == full, wrap_str('invalid square'))
    return True
Skipping constant true constraint
Exception -- for puzzle Sudoku:4 Symbolic hash not yet implemented

Solving puzzle 19/774: NecklaceSplit:0
sat_func def sat(n: int, lace="bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
modified_func def sat(n: int, lace=wrap_str('bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb')):
    sub = lace[n:n + sym_len(lace) // 2]
    return (n >= wrap_int(0)).__and__(lace.count('r') == wrap_int(2) * sub.count('r')).__and__(lace.count('b') == wrap_int(2) * sub.count('b'))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count "bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb" "r") 0))
(assert (>= (str.count (str.substr "bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb" x (- (+ x (div 76 2)) x)) "r") 0))
(assert (>= (str.count "bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb" "b") 0))
(assert (>= (str.count (str.substr "bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb" x (- (+ x (div 76 2)) x)) "b") 0))
(assert (and (and (>= x 0) (= (str.count "bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb" "r") (* 2 (str.count (str.substr "bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb" x (- (+ x (div 76 2)) x)) "r")))) (= (str.count "bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb" "b") (* 2 (str.count (str.substr "bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb" x (- (+ x (div 76 2)) x)) "b")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle NecklaceSplit:0
Too many constants for extrapolation

Solving puzzle 20/774: NecklaceSplit:1
sat_func def sat(n: int, lace="rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
modified_func def sat(n: int, lace=wrap_str('rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr')):
    sub = lace[n:n + sym_len(lace) // 2]
    return (n >= wrap_int(0)).__and__(lace.count('r') == wrap_int(2) * sub.count('r')).__and__(lace.count('b') == wrap_int(2) * sub.count('b'))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count "rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr" "r") 0))
(assert (>= (str.count (str.substr "rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr" x (- (+ x (div 148 2)) x)) "r") 0))
(assert (>= (str.count "rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr" "b") 0))
(assert (>= (str.count (str.substr "rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr" x (- (+ x (div 148 2)) x)) "b") 0))
(assert (and (and (>= x 0) (= (str.count "rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr" "r") (* 2 (str.count (str.substr "rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr" x (- (+ x (div 148 2)) x)) "r")))) (= (str.count "rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr" "b") (* 2 (str.count (str.substr "rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr" x (- (+ x (div 148 2)) x)) "b")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle NecklaceSplit:1
Too many constants for extrapolation

Solving puzzle 21/774: NecklaceSplit:2
sat_func def sat(n: int, lace="brrrbrrbrbbbbbrrbbrr"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
modified_func def sat(n: int, lace=wrap_str('brrrbrrbrbbbbbrrbbrr')):
    sub = lace[n:n + sym_len(lace) // 2]
    return (n >= wrap_int(0)).__and__(lace.count('r') == wrap_int(2) * sub.count('r')).__and__(lace.count('b') == wrap_int(2) * sub.count('b'))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count "brrrbrrbrbbbbbrrbbrr" "r") 0))
(assert (>= (str.count (str.substr "brrrbrrbrbbbbbrrbbrr" x (- (+ x (div 20 2)) x)) "r") 0))
(assert (>= (str.count "brrrbrrbrbbbbbrrbbrr" "b") 0))
(assert (>= (str.count (str.substr "brrrbrrbrbbbbbrrbbrr" x (- (+ x (div 20 2)) x)) "b") 0))
(assert (and (and (>= x 0) (= (str.count "brrrbrrbrbbbbbrrbbrr" "r") (* 2 (str.count (str.substr "brrrbrrbrbbbbbrrbbrr" x (- (+ x (div 20 2)) x)) "r")))) (= (str.count "brrrbrrbrbbbbbrrbbrr" "b") (* 2 (str.count (str.substr "brrrbrrbrbbbbbrrbbrr" x (- (+ x (div 20 2)) x)) "b")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle NecklaceSplit:2
Too many constants for extrapolation

Solving puzzle 22/774: NecklaceSplit:3
sat_func def sat(n: int, lace="bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
modified_func def sat(n: int, lace=wrap_str('bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr')):
    sub = lace[n:n + sym_len(lace) // 2]
    return (n >= wrap_int(0)).__and__(lace.count('r') == wrap_int(2) * sub.count('r')).__and__(lace.count('b') == wrap_int(2) * sub.count('b'))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count "bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr" "r") 0))
(assert (>= (str.count (str.substr "bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr" x (- (+ x (div 208 2)) x)) "r") 0))
(assert (>= (str.count "bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr" "b") 0))
(assert (>= (str.count (str.substr "bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr" x (- (+ x (div 208 2)) x)) "b") 0))
(assert (and (and (>= x 0) (= (str.count "bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr" "r") (* 2 (str.count (str.substr "bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr" x (- (+ x (div 208 2)) x)) "r")))) (= (str.count "bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr" "b") (* 2 (str.count (str.substr "bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr" ...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle NecklaceSplit:3
Too many constants for extrapolation

Solving puzzle 23/774: NecklaceSplit:4
sat_func def sat(n: int, lace="brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr"):
    sub = lace[n: n + len(lace) // 2]
    return n >= 0 and lace.count("r") == 2 * sub.count("r") and lace.count("b") == 2 * sub.count("b")
modified_func def sat(n: int, lace=wrap_str('brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr')):
    sub = lace[n:n + sym_len(lace) // 2]
    return (n >= wrap_int(0)).__and__(lace.count('r') == wrap_int(2) * sub.count('r')).__and__(lace.count('b') == wrap_int(2) * sub.count('b'))
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count "brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr" "r") 0))
(assert (>= (str.count (str.substr "brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr" x (- (+ x (div 80 2)) x)) "r") 0))
(assert (>= (str.count "brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr" "b") 0))
(assert (>= (str.count (str.substr "brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr" x (- (+ x (div 80 2)) x)) "b") 0))
(assert (and (and (>= x 0) (= (str.count "brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr" "r") (* 2 (str.count (str.substr "brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr" x (- (+ x (div 80 2)) x)) "r")))) (= (str.count "brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr" "b") (* 2 (str.count (str.substr "brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr" x (- (+ x (div 80 2)) x)) "b")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle NecklaceSplit:4
Too many constants for extrapolation

Solving puzzle 24/774: PandigitalSquare:0
sat_func def sat(n: int):
    s = str(n * n)
    for i in "0123456789":
        assert s.count(i) == 1
    return True
modified_func def sat(n: int):
    s = sym_str(n * n)
    for i in wrap_str('0123456789'):
        _assert(s.count(i) == wrap_int(1))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int (* x x)) "0") 0))
(assert (= (str.count (str.from_int (* x x)) "0") 1))
(assert (>= (str.count (str.from_int (* x x)) "1") 0))
(assert (= (str.count (str.from_int (* x x)) "1") 1))
(assert (>= (str.count (str.from_int (* x x)) "2") 0))
(assert (= (str.count (str.from_int (* x x)) "2") 1))
(assert (>= (str.count (str.from_int (* x x)) "3") 0))
(assert (= (str.count (str.from_int (* x x)) "3") 1))
(assert (>= (str.count (str.from_int (* x x)) "4") 0))
(assert (= (str.count (str.from_int (* x x)) "4") 1))
(assert (>= (str.count (str.from_int (* x x)) "5") 0))
(assert (= (str.count (str.from_int (* x x)) "5") 1))
(assert (>= (str.count (str.from_int (* x x)) "6") 0))
(assert (= (str.count (str.from_int (* x x)) "6") 1))
(assert (>= (str.count (str.from_int (* x x)) "7") 0))
(assert (= (str.count (str.from_int (* x x)) "7") 1))
(assert (>= (str.count (str.from_int (* x x)) "8") 0))
(assert (= (str.count (str.from_int (* x x)) "8") 1))
(assert (>= (str.count (str.from_int (* x x)) "9") 0))
(assert (= (str.count (str.from_int (* x x)) "9") 1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle PandigitalSquare:0
One large constant for extrapolation
Solving simpler variation replaced 0123456789 with 3
sat_func def sat(n: int):
    s = str(n * n)
    for i in "3":
        assert s.count(i) == 1
    return True
modified_func def sat(n: int):
    s = sym_str(n * n)
    for i in wrap_str('3'):
        _assert(s.count(i) == wrap_int(1))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int (* x x)) "3") 0))
(assert (= (str.count (str.from_int (* x x)) "3") 1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 6))
)
### output for cvc5
sat
(
(define-fun x () Int (- 6))
)

Found solution -6

Solving puzzle 25/774: CardGame24:0
sat_func def sat(expr: str, nums=[3, 7, 3, 7]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
modified_func def sat(expr: str, nums=wrap_list([wrap_int(3), wrap_int(7), wrap_int(3), wrap_int(7)])):
    _assert((sym_len(nums) == wrap_int(4)).__and__(wrap_int(1) <= min(nums)).__and__(max(nums) <= wrap_int(13)), wrap_str('hint: nums is a list of four ints in 1..13'))
    expr = expr.replace(wrap_str(' '), wrap_str(''))
    digits = wrap_str('')
    for i in sym_range(sym_len(expr)):
        if (i == wrap_int(0)).__or__(sym_in(expr[i - wrap_int(1)], wrap_str('+*-/('))):
            _assert(sym_in(expr[i], wrap_str('123456789(')), wrap_str('Expr cannot contain **, //, or unary -'))
        _assert(sym_in(expr[i], wrap_str('1234567890()+-*/')), wrap_str('Expr can only contain `0123456789()+-*/`'))
        digits += expr[i] if sym_in(expr[i], wrap_str('0123456789')) else wrap_str(' ')
    _assert(sym_sorted(sym_generator((sym_int(s) for s in digits.split()))) == sym_sorted(nums), wrap_str('Each number must occur exactly once'))
    return abs(eval(expr) - 24.0) < 1e-06
Exception -- for puzzle CardGame24:0 eval() arg 1 must be a string, bytes or code object

Solving puzzle 26/774: CardGame24:1
sat_func def sat(expr: str, nums=[1, 3, 7, 13]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
modified_func def sat(expr: str, nums=wrap_list([wrap_int(1), wrap_int(3), wrap_int(7), wrap_int(13)])):
    _assert((sym_len(nums) == wrap_int(4)).__and__(wrap_int(1) <= min(nums)).__and__(max(nums) <= wrap_int(13)), wrap_str('hint: nums is a list of four ints in 1..13'))
    expr = expr.replace(wrap_str(' '), wrap_str(''))
    digits = wrap_str('')
    for i in sym_range(sym_len(expr)):
        if (i == wrap_int(0)).__or__(sym_in(expr[i - wrap_int(1)], wrap_str('+*-/('))):
            _assert(sym_in(expr[i], wrap_str('123456789(')), wrap_str('Expr cannot contain **, //, or unary -'))
        _assert(sym_in(expr[i], wrap_str('1234567890()+-*/')), wrap_str('Expr can only contain `0123456789()+-*/`'))
        digits += expr[i] if sym_in(expr[i], wrap_str('0123456789')) else wrap_str(' ')
    _assert(sym_sorted(sym_generator((sym_int(s) for s in digits.split()))) == sym_sorted(nums), wrap_str('Each number must occur exactly once'))
    return abs(eval(expr) - 24.0) < 1e-06
Exception -- for puzzle CardGame24:1 eval() arg 1 must be a string, bytes or code object

Solving puzzle 27/774: CardGame24:2
sat_func def sat(expr: str, nums=[10, 7, 3, 1]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
modified_func def sat(expr: str, nums=wrap_list([wrap_int(10), wrap_int(7), wrap_int(3), wrap_int(1)])):
    _assert((sym_len(nums) == wrap_int(4)).__and__(wrap_int(1) <= min(nums)).__and__(max(nums) <= wrap_int(13)), wrap_str('hint: nums is a list of four ints in 1..13'))
    expr = expr.replace(wrap_str(' '), wrap_str(''))
    digits = wrap_str('')
    for i in sym_range(sym_len(expr)):
        if (i == wrap_int(0)).__or__(sym_in(expr[i - wrap_int(1)], wrap_str('+*-/('))):
            _assert(sym_in(expr[i], wrap_str('123456789(')), wrap_str('Expr cannot contain **, //, or unary -'))
        _assert(sym_in(expr[i], wrap_str('1234567890()+-*/')), wrap_str('Expr can only contain `0123456789()+-*/`'))
        digits += expr[i] if sym_in(expr[i], wrap_str('0123456789')) else wrap_str(' ')
    _assert(sym_sorted(sym_generator((sym_int(s) for s in digits.split()))) == sym_sorted(nums), wrap_str('Each number must occur exactly once'))
    return abs(eval(expr) - 24.0) < 1e-06
Exception -- for puzzle CardGame24:2 eval() arg 1 must be a string, bytes or code object

Solving puzzle 28/774: CardGame24:3
sat_func def sat(expr: str, nums=[8, 3, 12, 1]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
modified_func def sat(expr: str, nums=wrap_list([wrap_int(8), wrap_int(3), wrap_int(12), wrap_int(1)])):
    _assert((sym_len(nums) == wrap_int(4)).__and__(wrap_int(1) <= min(nums)).__and__(max(nums) <= wrap_int(13)), wrap_str('hint: nums is a list of four ints in 1..13'))
    expr = expr.replace(wrap_str(' '), wrap_str(''))
    digits = wrap_str('')
    for i in sym_range(sym_len(expr)):
        if (i == wrap_int(0)).__or__(sym_in(expr[i - wrap_int(1)], wrap_str('+*-/('))):
            _assert(sym_in(expr[i], wrap_str('123456789(')), wrap_str('Expr cannot contain **, //, or unary -'))
        _assert(sym_in(expr[i], wrap_str('1234567890()+-*/')), wrap_str('Expr can only contain `0123456789()+-*/`'))
        digits += expr[i] if sym_in(expr[i], wrap_str('0123456789')) else wrap_str(' ')
    _assert(sym_sorted(sym_generator((sym_int(s) for s in digits.split()))) == sym_sorted(nums), wrap_str('Each number must occur exactly once'))
    return abs(eval(expr) - 24.0) < 1e-06
Exception -- for puzzle CardGame24:3 eval() arg 1 must be a string, bytes or code object

Solving puzzle 29/774: CardGame24:4
sat_func def sat(expr: str, nums=[10, 12, 1, 7]):
    assert len(nums) == 4 and 1 <= min(nums) and max(nums) <= 13, "hint: nums is a list of four ints in 1..13"
    expr = expr.replace(" ", "")  # ignore whitespace
    digits = ""
    for i in range(len(expr)):
        if i == 0 or expr[i - 1] in "+*-/(":
            assert expr[i] in "123456789(", "Expr cannot contain **, //, or unary -"
        assert expr[i] in "1234567890()+-*/", "Expr can only contain `0123456789()+-*/`"
        digits += expr[i] if expr[i] in "0123456789" else " "
    assert sorted(int(s) for s in digits.split()) == sorted(nums), "Each number must occur exactly once"
    return abs(eval(expr) - 24.0) < 1e-6
modified_func def sat(expr: str, nums=wrap_list([wrap_int(10), wrap_int(12), wrap_int(1), wrap_int(7)])):
    _assert((sym_len(nums) == wrap_int(4)).__and__(wrap_int(1) <= min(nums)).__and__(max(nums) <= wrap_int(13)), wrap_str('hint: nums is a list of four ints in 1..13'))
    expr = expr.replace(wrap_str(' '), wrap_str(''))
    digits = wrap_str('')
    for i in sym_range(sym_len(expr)):
        if (i == wrap_int(0)).__or__(sym_in(expr[i - wrap_int(1)], wrap_str('+*-/('))):
            _assert(sym_in(expr[i], wrap_str('123456789(')), wrap_str('Expr cannot contain **, //, or unary -'))
        _assert(sym_in(expr[i], wrap_str('1234567890()+-*/')), wrap_str('Expr can only contain `0123456789()+-*/`'))
        digits += expr[i] if sym_in(expr[i], wrap_str('0123456789')) else wrap_str(' ')
    _assert(sym_sorted(sym_generator((sym_int(s) for s in digits.split()))) == sym_sorted(nums), wrap_str('Each number must occur exactly once'))
    return abs(eval(expr) - 24.0) < 1e-06
Exception -- for puzzle CardGame24:4 eval() arg 1 must be a string, bytes or code object

Solving puzzle 30/774: Easy63:0
sat_func def sat(s: str):
    return set(s) <= set("18-+*/") and s.count("8") == 2 and s.count("1") == 1 and eval(s) == 63
modified_func def sat(s: str):
    return (set(s) <= set(wrap_str('18-+*/'))).__and__(s.count('8') == wrap_int(2)).__and__(s.count('1') == wrap_int(1)).__and__(eval(s) == wrap_int(63))
Exception -- for puzzle Easy63:0 Symbolic hash not yet implemented

Solving puzzle 31/774: Harder63:0
sat_func def sat(s: str):
    return set(s) <= set("18-+*/") and s.count("8") == 3 and s.count("1") == 1 and eval(s) == 63
modified_func def sat(s: str):
    return (set(s) <= set(wrap_str('18-+*/'))).__and__(s.count('8') == wrap_int(3)).__and__(s.count('1') == wrap_int(1)).__and__(eval(s) == wrap_int(63))
Exception -- for puzzle Harder63:0 Symbolic hash not yet implemented

Solving puzzle 32/774: Frac:0
sat_func def sat(x: float, v=523.12892):
    return 0 <= x < 1 and (v - x).is_integer()
modified_func def sat(x: float, v=523.12892):
    return (wrap_int(0) <= x).__and__(x < wrap_int(1)).__and__((v - x).is_integer())
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (and (<= 0 x) (< x 1)) (= (- 523.12892 x) (to_int (- 523.12892 x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 3223.0 25000.0))
)
### output for cvc5
sat
(
(define-fun x () Real (/ 3223 25000))
)

Found solution 0.12892
Yes! Solved for puzzle  Frac:0

Solving puzzle 33/774: Frac:1
sat_func def sat(x: float, v=93.86070917102649):
    return 0 <= x < 1 and (v - x).is_integer()
modified_func def sat(x: float, v=93.86070917102649):
    return (wrap_int(0) <= x).__and__(x < wrap_int(1)).__and__((v - x).is_integer())
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (and (<= 0 x) (< x 1)) (= (- 93.86070917102649 x) (to_int (- 93.86070917102649 x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 86070917102649.0 100000000000000.0))
)
### output for cvc5
sat
(
(define-fun x () Real (/ 86070917102649 100000000000000))
)

Found solution 0.86070917102649
Yes! Solved for puzzle  Frac:1

Solving puzzle 34/774: Frac:2
sat_func def sat(x: float, v=-6.770237138115334):
    return 0 <= x < 1 and (v - x).is_integer()
modified_func def sat(x: float, v=-6.770237138115334):
    return (wrap_int(0) <= x).__and__(x < wrap_int(1)).__and__((v - x).is_integer())
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (and (<= 0 x) (< x 1)) (= (- -6.770237138115334 x) (to_int (- -6.770237138115334 x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 114881430942333.0 500000000000000.0))
)
### output for cvc5
sat
(
(define-fun x () Real (/ 114881430942333 500000000000000))
)

Found solution 0.229762861884666
Yes! Solved for puzzle  Frac:2

Solving puzzle 35/774: Frac:3
sat_func def sat(x: float, v=61.58244309946389):
    return 0 <= x < 1 and (v - x).is_integer()
modified_func def sat(x: float, v=61.58244309946389):
    return (wrap_int(0) <= x).__and__(x < wrap_int(1)).__and__((v - x).is_integer())
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (and (<= 0 x) (< x 1)) (= (- 61.58244309946389 x) (to_int (- 61.58244309946389 x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 58244309946389.0 100000000000000.0))
)
### output for cvc5
sat
(
(define-fun x () Real (/ 58244309946389 100000000000000))
)

Found solution 0.58244309946389
Yes! Solved for puzzle  Frac:3

Solving puzzle 36/774: Frac:4
sat_func def sat(x: float, v=-80.9341003381162):
    return 0 <= x < 1 and (v - x).is_integer()
modified_func def sat(x: float, v=-80.9341003381162):
    return (wrap_int(0) <= x).__and__(x < wrap_int(1)).__and__((v - x).is_integer())
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (and (<= 0 x) (< x 1)) (= (- -80.9341003381162 x) (to_int (- -80.9341003381162 x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 329498309419.0 5000000000000.0))
)
### output for cvc5
sat
(
(define-fun x () Real (/ 329498309419 5000000000000))
)

Found solution 0.0658996618838
Yes! Solved for puzzle  Frac:4

Solving puzzle 37/774: MinSquaredDeviation:0
sat_func def sat(x: float, nums=[12, -2, 14, 3, -15, 10, -45, 3, 30]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
modified_func def sat(x: float, nums=wrap_list([wrap_int(12), -wrap_int(2), wrap_int(14), wrap_int(3), -wrap_int(15), wrap_int(10), -wrap_int(45), wrap_int(3), wrap_int(30)])):
    return sym_sum(sym_generator(((n - x) ** wrap_int(2) for n in nums))) * sym_len(nums) <= sym_sum(sym_generator(((m - n) ** wrap_int(2) for m in nums for n in nums))) * 0.5 + 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (<= (* (+ (+ (+ (+ (+ (+ (+ (+ (+ (^ (- 12 x) 2) 0) (^ (- -2 x) 2)) (^ (- 14 x) 2)) (^ (- 3 x) 2)) (^ (- -15 x) 2)) (^ (- 10 x) 2)) (^ (- -45 x) 2)) (^ (- 3 x) 2)) (^ (- 30 x) 2)) 9) (+ (* (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 16385 0.25) 512) 134217728) 4) 144115188075855872) 512) 3.814697265625e-06) 6.103515625e-05) 1) 1.52587890625e-05) 0.03125) 8192) 0.000244140625) 8796093022208) 0.03125) 2.3283064365386963e-10) 4) 65536) 1) 2048) 536870912) 16) 576460752303423488) 2048) 1.52587890625e-05) 0.001953125) 32) 0.00048828125) 1) 262144) 0.0078125) 281474976710656) 1) 7.450580596923828e-09) 7.450580596923828e-09) 0.0001220703125) 1.862645149230957e-09) 3.814697265625e-06) 1) 2.9802322387695312e-08) 1073741824) 3.814697265625e-06) 2.842170943040401e-14) 0.25) 4096) 0.0625) 128) 335544...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 504: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.56: expecting same arithmetic types to POW")

Could not find any solution for puzzle MinSquaredDeviation:0
Too many constants for extrapolation

Solving puzzle 38/774: MinSquaredDeviation:1
sat_func def sat(x: float, nums=[-47, -58, -46, -29, 48, -7, 85, -48]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
modified_func def sat(x: float, nums=wrap_list([-wrap_int(47), -wrap_int(58), -wrap_int(46), -wrap_int(29), wrap_int(48), -wrap_int(7), wrap_int(85), -wrap_int(48)])):
    return sym_sum(sym_generator(((n - x) ** wrap_int(2) for n in nums))) * sym_len(nums) <= sym_sum(sym_generator(((m - n) ** wrap_int(2) for m in nums for n in nums))) * 0.5 + 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (<= (* (+ (+ (+ (+ (+ (+ (+ (+ (^ (- -47 x) 2) 0) (^ (- -58 x) 2)) (^ (- -46 x) 2)) (^ (- -29 x) 2)) (^ (- 48 x) 2)) (^ (- -7 x) 2)) (^ (- 85 x) 2)) (^ (- -48 x) 2)) 8) (+ (* (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 2049 0.5) 3.814697265625e-06) 2.524354896707238e-29) 9.094947017729282e-13) 1.8367099231598242e-40) 2) 0.00048828125) 1) 0.000244140625) 1.862645149230957e-09) 1.232595164407831e-32) 4.440892098500626e-16) 8.96831017167883e-44) 0.0009765625) 2) 4096) 1) 7.62939453125e-06) 5.048709793414476e-29) 1.8189894035458565e-12) 3.6734198463196485e-40) 4) 262144) 536870912) 131072) 1) 6.617444900424222e-24) 2.384185791015625e-07) 4.81482486096809e-35) 524288) 39614081257132168796771975168) 81129638414606681695789005144064) 19807040628566084398385987584) 151115727451828646838272) 1) 36028797018963968) 7.275957614183426e-12) 79228162514...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 393: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.54: expecting same arithmetic types to POW")

Could not find any solution for puzzle MinSquaredDeviation:1
Too many constants for extrapolation

Solving puzzle 39/774: MinSquaredDeviation:2
sat_func def sat(x: float, nums=[-76, -99, 72, 33, 21, -54, -21, 24, 97, 89]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
modified_func def sat(x: float, nums=wrap_list([-wrap_int(76), -wrap_int(99), wrap_int(72), wrap_int(33), wrap_int(21), -wrap_int(54), -wrap_int(21), wrap_int(24), wrap_int(97), wrap_int(89)])):
    return sym_sum(sym_generator(((n - x) ** wrap_int(2) for n in nums))) * sym_len(nums) <= sym_sum(sym_generator(((m - n) ** wrap_int(2) for m in nums for n in nums))) * 0.5 + 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (<= (* (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (^ (- -76 x) 2) 0) (^ (- -99 x) 2)) (^ (- 72 x) 2)) (^ (- 33 x) 2)) (^ (- 21 x) 2)) (^ (- -54 x) 2)) (^ (- -21 x) 2)) (^ (- 24 x) 2)) (^ (- 97 x) 2)) (^ (- 89 x) 2)) 10) (+ (* (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 8388609 2.802596928649634e-45) 1.5407439555097887e-33) 6.310887241768095e-30) 2.384185791015625e-07) 2.7755575615628914e-17) 7.888609052210118e-31) 8.352389719038111e-53) 2.1382117680737565e-50) 1.1920928955078125e-07) 1) 3.3409558876152446e-52) 1.8367099231598242e-40) 7.52316384526264e-37) 2.842170943040401e-14) 3.308722450212111e-24) 9.4039548065783e-38) 9.956824444577827e-60) 2.5489470578119236e-57) 356811923176489970264571492362373784095686656) 29931553532536891764811465374029...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 540: unknown constant e-45")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.60: expecting same arithmetic types to POW")

Could not find any solution for puzzle MinSquaredDeviation:2
Too many constants for extrapolation

Solving puzzle 40/774: MinSquaredDeviation:3
sat_func def sat(x: float, nums=[-62, -53, -80]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
modified_func def sat(x: float, nums=wrap_list([-wrap_int(62), -wrap_int(53), -wrap_int(80)])):
    return sym_sum(sym_generator(((n - x) ** wrap_int(2) for n in nums))) * sym_len(nums) <= sym_sum(sym_generator(((m - n) ** wrap_int(2) for m in nums for n in nums))) * 0.5 + 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (<= (* (+ (+ (+ (^ (- -62 x) 2) 0) (^ (- -53 x) 2)) (^ (- -80 x) 2)) 3) (+ (* (+ (+ (+ (+ (+ (+ (+ (+ 1 0.001953125) 262144) 512) 1) 134217728) 3.814697265625e-06) 7.450580596923828e-09) 1) 0.5) 0.0001)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 166: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.39: expecting same arithmetic types to POW")

Could not find any solution for puzzle MinSquaredDeviation:3
Too many constants for extrapolation

Solving puzzle 41/774: MinSquaredDeviation:4
sat_func def sat(x: float, nums=[-76, 76, -88, 37, 7]):
    return sum((n - x) ** 2 for n in nums) * len(nums) <= sum((m - n) ** 2 for m in nums for n in nums) * .5 + 1e-4
modified_func def sat(x: float, nums=wrap_list([-wrap_int(76), wrap_int(76), -wrap_int(88), wrap_int(37), wrap_int(7)])):
    return sym_sum(sym_generator(((n - x) ** wrap_int(2) for n in nums))) * sym_len(nums) <= sym_sum(sym_generator(((m - n) ** wrap_int(2) for m in nums for n in nums))) * 0.5 + 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (<= (* (+ (+ (+ (+ (+ (^ (- -76 x) 2) 0) (^ (- 76 x) 2)) (^ (- -88 x) 2)) (^ (- 37 x) 2)) (^ (- 7 x) 2)) 5) (+ (* (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ 1 1.7516230804060213e-46) 4096) 9.62964972193618e-35) 1.0339757656912846e-25) 5708990770823839524233143877797980545530986496) 1) 23384026197294446691258957323460528314494920687616) 549755813888) 590295810358705651712) 0.000244140625) 4.276423536147513e-50) 1) 2.350988701644575e-38) 2.524354896707238e-29) 10384593717069655257060992658440192) 1.8189894035458565e-12) 42535295865117307932921825928971026432) 1) 1073741824) 9671406556917033397649408) 1.6940658945086007e-21) 39614081257132168796771975168) 9.313225746154785e-10) 1) 0.5) 0.0001)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 214: unknown constant e-46")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.45: expecting same arithmetic types to POW")

Could not find any solution for puzzle MinSquaredDeviation:4
Too many constants for extrapolation

Solving puzzle 42/774: PalindromeContaining:0
sat_func def sat(ans: str, s="so easy", length=20):
    return ans == ans[::-1] and len(ans) == length and s in ans
modified_func def sat(ans: str, s=wrap_str('so easy'), length=wrap_int(20)):
    return (ans == ans[::-1]).__and__(sym_len(ans) == length).__and__(sym_in(s, ans))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (and (= x (str.reverse x)) (= (str.len x) 20)) (str.contains x "so easy")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ysae osABCCBAso easy")
)
### output for cvc5
sat
(
(define-fun x () String "ysae osBACCABso easy")
)

Found solution ysae osABCCBAso easy
Yes! Solved for puzzle  PalindromeContaining:0

Solving puzzle 43/774: PalindromeContaining:1
sat_func def sat(ans: str, s="aabbab", length=12):
    return ans == ans[::-1] and len(ans) == length and s in ans
modified_func def sat(ans: str, s=wrap_str('aabbab'), length=wrap_int(12)):
    return (ans == ans[::-1]).__and__(sym_len(ans) == length).__and__(sym_in(s, ans))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (and (= x (str.reverse x)) (= (str.len x) 12)) (str.contains x "aabbab")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "aabbabbabbaa")
)
### output for cvc5
sat
(
(define-fun x () String "babbaaaabbab")
)

Found solution aabbabbabbaa
Yes! Solved for puzzle  PalindromeContaining:1

Solving puzzle 44/774: PalindromeContaining:2
sat_func def sat(ans: str, s="bbb", length=27):
    return ans == ans[::-1] and len(ans) == length and s in ans
modified_func def sat(ans: str, s=wrap_str('bbb'), length=wrap_int(27)):
    return (ans == ans[::-1]).__and__(sym_len(ans) == length).__and__(sym_in(s, ans))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (and (= x (str.reverse x)) (= (str.len x) 27)) (str.contains x "bbb")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bbbLBCDEFGHIJKJIHGFEDCBLbbb")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution bbbLBCDEFGHIJKJIHGFEDCBLbbb
Yes! Solved for puzzle  PalindromeContaining:2

Solving puzzle 45/774: PalindromeContaining:3
sat_func def sat(ans: str, s="bb", length=38):
    return ans == ans[::-1] and len(ans) == length and s in ans
modified_func def sat(ans: str, s=wrap_str('bb'), length=wrap_int(38)):
    return (ans == ans[::-1]).__and__(sym_len(ans) == length).__and__(sym_in(s, ans))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (and (= x (str.reverse x)) (= (str.len x) 38)) (str.contains x "bb")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle PalindromeContaining:3
Too many constants for extrapolation

Solving puzzle 46/774: PalindromeContaining:4
sat_func def sat(ans: str, s="", length=0):
    return ans == ans[::-1] and len(ans) == length and s in ans
modified_func def sat(ans: str, s=wrap_str(''), length=wrap_int(0)):
    return (ans == ans[::-1]).__and__(sym_len(ans) == length).__and__(sym_in(s, ans))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (and (= x (str.reverse x)) (= (str.len x) 0)) (str.contains x "")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Yes! Solved for puzzle  PalindromeContaining:4

Solving puzzle 47/774: BinaryStrXOR:0
sat_func def sat(str_num: str, nums=['100011101100001', '100101100101110']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('100011101100001'), wrap_str('100101100101110')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "100011101100001") 0))
(assert (> (str.len "100101100101110") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "100011101100001" 2) (python.int "100101100101110" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:0
Two large constants for extrapolation
Solving simpler variation replaced 100011101100001 with 3 and 100101100101110 with 5
sat_func def sat(str_num: str, nums=['3', '5']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('3'), wrap_str('5')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "3") 0))
(assert (> (str.len "5") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "3" 2) (python.int "5" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:0

Solving puzzle 48/774: BinaryStrXOR:1
sat_func def sat(str_num: str, nums=['1101101111', '11001100']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('1101101111'), wrap_str('11001100')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "1101101111") 0))
(assert (> (str.len "11001100") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "1101101111" 2) (python.int "11001100" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:1
Two large constants for extrapolation
Solving simpler variation replaced 11001100 with 3 and 1101101111 with 5
sat_func def sat(str_num: str, nums=['5', '3']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('5'), wrap_str('3')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "5") 0))
(assert (> (str.len "3") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "5" 2) (python.int "3" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:1

Solving puzzle 49/774: BinaryStrXOR:2
sat_func def sat(str_num: str, nums=['11011111', '1101001110']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('11011111'), wrap_str('1101001110')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "11011111") 0))
(assert (> (str.len "1101001110") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "11011111" 2) (python.int "1101001110" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:2
Two large constants for extrapolation
Solving simpler variation replaced 1101001110 with 3 and 11011111 with 5
sat_func def sat(str_num: str, nums=['5', '3']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('5'), wrap_str('3')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "5") 0))
(assert (> (str.len "3") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "5" 2) (python.int "3" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:2

Solving puzzle 50/774: BinaryStrXOR:3
sat_func def sat(str_num: str, nums=['100000001', '1010001001']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('100000001'), wrap_str('1010001001')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "100000001") 0))
(assert (> (str.len "1010001001") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "100000001" 2) (python.int "1010001001" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:3
Two large constants for extrapolation
Solving simpler variation replaced 100000001 with 3 and 1010001001 with 5
sat_func def sat(str_num: str, nums=['3', '5']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('3'), wrap_str('5')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "3") 0))
(assert (> (str.len "5") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "3" 2) (python.int "5" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:3

Solving puzzle 51/774: BinaryStrXOR:4
sat_func def sat(str_num: str, nums=['10010110', '10000']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('10010110'), wrap_str('10000')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "10010110") 0))
(assert (> (str.len "10000") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "10010110" 2) (python.int "10000" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:4
Two large constants for extrapolation
Solving simpler variation replaced 10000 with 3 and 10010110 with 5
sat_func def sat(str_num: str, nums=['5', '3']):
    a, b = nums
    return int(str_num, 2) == int(a, 2) ^ int(b, 2)
modified_func def sat(str_num: str, nums=wrap_list([wrap_str('5'), wrap_str('3')])):
    a, b = nums
    return sym_int(str_num, wrap_int(2)) == sym_int(a, wrap_int(2)) ^ sym_int(b, wrap_int(2))
### smt2
(set-logic ALL)

(define-fun bool-to-int ((b Bool)) Int
  (ite b 1 0))

(define-fun int2bits ((x Int)) Bool
  (= (mod (abs x) 2) 1))

(define-fun python.int.xor ((x Int) (y Int)) Int
  (let ((bits (bool-to-int (xor (int2bits x) (int2bits y)))))
    bits))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (> (str.len "5") 0))
(assert (> (str.len "3") 0))
(assert (= (python.int x 2) (python.int.xor (python.int "5" 2) (python.int "3" 2))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @ground_term_29)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @ground_term_29)))))")

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryStrXOR:4

Solving puzzle 52/774: LongestStr:0
sat_func def sat(ans: str, words=['these', 'are', 'some', 'pretty', 'long', 'words']):
    return ans in words and all(len(ans) >= len(w) for w in words)
modified_func def sat(ans: str, words=wrap_list([wrap_str('these'), wrap_str('are'), wrap_str('some'), wrap_str('pretty'), wrap_str('long'), wrap_str('words')])):
    return sym_in(ans, words).__and__(all(sym_generator((sym_len(ans) >= sym_len(w) for w in words))))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "these") (= x "are") (= x "some") (= x "pretty") (= x "long") (= x "words")) (and (and (and (and (and (>= (str.len x) 5) (>= (str.len x) 3)) (>= (str.len x) 4)) (>= (str.len x) 6)) (>= (str.len x) 4)) (>= (str.len x) 5))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "pretty")
)
### output for cvc5
sat
(
(define-fun x () String "pretty")
)

Found solution pretty
Yes! Solved for puzzle  LongestStr:0

Solving puzzle 53/774: LongestStr:1
sat_func def sat(ans: str, words=['suquojurethy', 'zetenejubichicyj', 'dyzeroquyxipyfe']):
    return ans in words and all(len(ans) >= len(w) for w in words)
modified_func def sat(ans: str, words=wrap_list([wrap_str('suquojurethy'), wrap_str('zetenejubichicyj'), wrap_str('dyzeroquyxipyfe')])):
    return sym_in(ans, words).__and__(all(sym_generator((sym_len(ans) >= sym_len(w) for w in words))))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "suquojurethy") (= x "zetenejubichicyj") (= x "dyzeroquyxipyfe")) (and (and (>= (str.len x) 12) (>= (str.len x) 16)) (>= (str.len x) 15))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "zetenejubichicyj")
)
### output for cvc5
sat
(
(define-fun x () String "zetenejubichicyj")
)

Found solution zetenejubichicyj
Yes! Solved for puzzle  LongestStr:1

Solving puzzle 54/774: LongestStr:2
sat_func def sat(ans: str, words=['thusisequiw', 'tevozequetextupetha', 'texterut', 'zopuhesofowyk', 'chajokapechunekizic', 'hefuhyjiwakifyma', 'thopebom', 'pah']):
    return ans in words and all(len(ans) >= len(w) for w in words)
modified_func def sat(ans: str, words=wrap_list([wrap_str('thusisequiw'), wrap_str('tevozequetextupetha'), wrap_str('texterut'), wrap_str('zopuhesofowyk'), wrap_str('chajokapechunekizic'), wrap_str('hefuhyjiwakifyma'), wrap_str('thopebom'), wrap_str('pah')])):
    return sym_in(ans, words).__and__(all(sym_generator((sym_len(ans) >= sym_len(w) for w in words))))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "thusisequiw") (= x "tevozequetextupetha") (= x "texterut") (= x "zopuhesofowyk") (= x "chajokapechunekizic") (= x "hefuhyjiwakifyma") (= x "thopebom") (= x "pah")) (and (and (and (and (and (and (and (>= (str.len x) 11) (>= (str.len x) 19)) (>= (str.len x) 8)) (>= (str.len x) 13)) (>= (str.len x) 19)) (>= (str.len x) 16)) (>= (str.len x) 8)) (>= (str.len x) 3))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "tevozequetextupetha")
)
### output for cvc5
sat
(
(define-fun x () String "tevozequetextupetha")
)

Found solution tevozequetextupetha
Yes! Solved for puzzle  LongestStr:2

Solving puzzle 55/774: LongestStr:3
sat_func def sat(ans: str, words=['melo', 'zoj', 'wujololyfytew', 'barivitextyte', 'decipywiduvaq', 'ruty', 'gekusoduz']):
    return ans in words and all(len(ans) >= len(w) for w in words)
modified_func def sat(ans: str, words=wrap_list([wrap_str('melo'), wrap_str('zoj'), wrap_str('wujololyfytew'), wrap_str('barivitextyte'), wrap_str('decipywiduvaq'), wrap_str('ruty'), wrap_str('gekusoduz')])):
    return sym_in(ans, words).__and__(all(sym_generator((sym_len(ans) >= sym_len(w) for w in words))))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "melo") (= x "zoj") (= x "wujololyfytew") (= x "barivitextyte") (= x "decipywiduvaq") (= x "ruty") (= x "gekusoduz")) (and (and (and (and (and (and (>= (str.len x) 4) (>= (str.len x) 3)) (>= (str.len x) 13)) (>= (str.len x) 13)) (>= (str.len x) 13)) (>= (str.len x) 4)) (>= (str.len x) 9))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "wujololyfytew")
)
### output for cvc5
sat
(
(define-fun x () String "wujololyfytew")
)

Found solution wujololyfytew
Yes! Solved for puzzle  LongestStr:3

Solving puzzle 56/774: LongestStr:4
sat_func def sat(ans: str, words=['quicydynigatha', 'pethiquifegosych', 'jixotextoxa', 'pe', 'xona', 'cifuco', 'gyrejypifam']):
    return ans in words and all(len(ans) >= len(w) for w in words)
modified_func def sat(ans: str, words=wrap_list([wrap_str('quicydynigatha'), wrap_str('pethiquifegosych'), wrap_str('jixotextoxa'), wrap_str('pe'), wrap_str('xona'), wrap_str('cifuco'), wrap_str('gyrejypifam')])):
    return sym_in(ans, words).__and__(all(sym_generator((sym_len(ans) >= sym_len(w) for w in words))))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "quicydynigatha") (= x "pethiquifegosych") (= x "jixotextoxa") (= x "pe") (= x "xona") (= x "cifuco") (= x "gyrejypifam")) (and (and (and (and (and (and (>= (str.len x) 14) (>= (str.len x) 16)) (>= (str.len x) 11)) (>= (str.len x) 2)) (>= (str.len x) 4)) (>= (str.len x) 6)) (>= (str.len x) 11))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "pethiquifegosych")
)
### output for cvc5
sat
(
(define-fun x () String "pethiquifegosych")
)

Found solution pethiquifegosych
Yes! Solved for puzzle  LongestStr:4

Solving puzzle 57/774: SpaceyRange:0
sat_func def sat(ans: str, n=15):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
modified_func def sat(ans: str, n=wrap_int(15)):
    return [sym_int(i) for i in ans.split(wrap_str(' '))] == list(sym_range(n + 1))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_5 Int)) (=> (and (>= list_pos_5 0) (< list_pos_5 (list.length.string (str.split x " ")))) (> (str.len (list.get.string (str.split x " ") list_pos_5)) 0))))
(assert (forall ((list_pos_5 Int)) (=> (and (>= list_pos_5 0) (< list_pos_5 (list.length.string (str.split x " ")))) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SpaceyRange:0
Too many constants for extrapolation

Solving puzzle 58/774: SpaceyRange:1
sat_func def sat(ans: str, n=54635):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
modified_func def sat(ans: str, n=wrap_int(54635)):
    return [sym_int(i) for i in ans.split(wrap_str(' '))] == list(sym_range(n + 1))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_6 Int)) (=> (and (>= list_pos_6 0) (< list_pos_6 (list.length.string (str.split x " ")))) (> (str.len (list.get.string (str.split x " ") list_pos_6)) 0))))
(assert (forall ((list_pos_6 Int)) (=> (and (>= list_pos_6 0) (< list_pos_6 (list.length.string (str.split x " ")))) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SpaceyRange:1
One large constant for extrapolation
Solving simpler variation replaced 54635 with 3
sat_func def sat(ans: str, n=3):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
modified_func def sat(ans: str, n=wrap_int(3)):
    return [sym_int(i) for i in ans.split(wrap_str(' '))] == list(sym_range(n + 1))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_7 Int)) (=> (and (>= list_pos_7 0) (< list_pos_7 (list.length.string (str.split x " ")))) (> (str.len (list.get.string (str.split x " ") list_pos_7)) 0))))
(assert (forall ((list_pos_7 Int)) (=> (and (>= list_pos_7 0) (< list_pos_7 (list.length.string (str.split x " ")))) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SpaceyRange:1

Solving puzzle 59/774: SpaceyRange:2
sat_func def sat(ans: str, n=83):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
modified_func def sat(ans: str, n=wrap_int(83)):
    return [sym_int(i) for i in ans.split(wrap_str(' '))] == list(sym_range(n + 1))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_8 Int)) (=> (and (>= list_pos_8 0) (< list_pos_8 (list.length.string (str.split x " ")))) (> (str.len (list.get.string (str.split x " ") list_pos_8)) 0))))
(assert (forall ((list_pos_8 Int)) (=> (and (>= list_pos_8 0) (< list_pos_8 (list.length.string (str.split x " ")))) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SpaceyRange:2
Too many constants for extrapolation

Solving puzzle 60/774: SpaceyRange:3
sat_func def sat(ans: str, n=99847):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
modified_func def sat(ans: str, n=wrap_int(99847)):
    return [sym_int(i) for i in ans.split(wrap_str(' '))] == list(sym_range(n + 1))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_9 Int)) (=> (and (>= list_pos_9 0) (< list_pos_9 (list.length.string (str.split x " ")))) (> (str.len (list.get.string (str.split x " ") list_pos_9)) 0))))
(assert (forall ((list_pos_9 Int)) (=> (and (>= list_pos_9 0) (< list_pos_9 (list.length.string (str.split x " ")))) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SpaceyRange:3
One large constant for extrapolation
Solving simpler variation replaced 99847 with 3
sat_func def sat(ans: str, n=3):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
modified_func def sat(ans: str, n=wrap_int(3)):
    return [sym_int(i) for i in ans.split(wrap_str(' '))] == list(sym_range(n + 1))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_10 Int)) (=> (and (>= list_pos_10 0) (< list_pos_10 (list.length.string (str.split x " ")))) (> (str.len (list.get.string (str.split x " ") list_pos_10)) 0))))
(assert (forall ((list_pos_10 Int)) (=> (and (>= list_pos_10 0) (< list_pos_10 (list.length.string (str.split x " ")))) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SpaceyRange:3

Solving puzzle 61/774: SpaceyRange:4
sat_func def sat(ans: str, n=18215):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
modified_func def sat(ans: str, n=wrap_int(18215)):
    return [sym_int(i) for i in ans.split(wrap_str(' '))] == list(sym_range(n + 1))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_11 Int)) (=> (and (>= list_pos_11 0) (< list_pos_11 (list.length.string (str.split x " ")))) (> (str.len (list.get.string (str.split x " ") list_pos_11)) 0))))
(assert (forall ((list_pos_11 Int)) (=> (and (>= list_pos_11 0) (< list_pos_11 (list.length.string (str.split x " ")))) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SpaceyRange:4
One large constant for extrapolation
Solving simpler variation replaced 18215 with 3
sat_func def sat(ans: str, n=3):
    return [int(i) for i in ans.split(' ')] == list(range(n + 1))
modified_func def sat(ans: str, n=wrap_int(3)):
    return [sym_int(i) for i in ans.split(wrap_str(' '))] == list(sym_range(n + 1))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_12 Int)) (=> (and (>= list_pos_12 0) (< list_pos_12 (list.length.string (str.split x " ")))) (> (str.len (list.get.string (str.split x " ") list_pos_12)) 0))))
(assert (forall ((list_pos_12 Int)) (=> (and (>= list_pos_12 0) (< list_pos_12 (list.length.string (str.split x " ")))) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SpaceyRange:4

Solving puzzle 62/774: SortNumbers:0
sat_func def sat(ans: str, s="six one four three two nine eight"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
modified_func def sat(ans: str, s=wrap_str('six one four three two nine eight')):
    nums = wrap_str('zero one two three four five six seven eight nine').split()
    return [nums.index(x) for x in ans.split(wrap_str(' '))] == sym_sorted([nums.index(x) for x in s.split(wrap_str(' '))])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_13 Int)) (=> (and (>= list_pos_13 0) (< list_pos_13 (list.length.string (str.split x " ")))) (=> (and (< (ite false 0 (ite true 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite true 6 (ite false 7 (ite false 8 (ite false 9 -1))))))))))) (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite true 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1))))))))))) (< (ite false 0 (ite false 1 (ite false 2 (ite true 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1))))))))))) (< (ite...
(assert (forall ((list_pos_14 Int)) (=> (and (>= list_pos_14 0) (< list_pos_14 (list.length.string (str.split x " ")))) (forall ((list_pos_13 Int)) (=> (and (>= list_pos_13 0) (< list_pos_13 (list.length.string (str.split x " ")))) (=> (and (not (< (ite false 0 (ite true 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite true 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))))) (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite true 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))))) (not (< (ite false 0 (ite false 1 (ite false 2 (ite true 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite fal...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: '' is not in list
WARNING: Solution verification failed for puzzle SortNumbers:0
Too many constants for extrapolation

Solving puzzle 63/774: SortNumbers:1
sat_func def sat(ans: str, s="nine two four nine zero six six eight"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
modified_func def sat(ans: str, s=wrap_str('nine two four nine zero six six eight')):
    nums = wrap_str('zero one two three four five six seven eight nine').split()
    return [nums.index(x) for x in ans.split(wrap_str(' '))] == sym_sorted([nums.index(x) for x in s.split(wrap_str(' '))])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_15 Int)) (=> (and (>= list_pos_15 0) (< list_pos_15 (list.length.string (str.split x " ")))) (=> (and (< (ite false 0 (ite false 1 (ite true 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1))))))))))) (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite true 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1))))))))))) (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1))))))))))) (< (ite...
(assert (forall ((list_pos_16 Int)) (=> (and (>= list_pos_16 0) (< list_pos_16 (list.length.string (str.split x " ")))) (forall ((list_pos_15 Int)) (=> (and (>= list_pos_15 0) (< list_pos_15 (list.length.string (str.split x " ")))) (=> (and (not (< (ite false 0 (ite false 1 (ite true 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1)))))))))))) (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite true 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))))) (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1)))))))))) (ite false 0 (ite fal...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: '' is not in list
WARNING: Solution verification failed for puzzle SortNumbers:1
Too many constants for extrapolation

Solving puzzle 64/774: SortNumbers:2
sat_func def sat(ans: str, s="nine six two"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
modified_func def sat(ans: str, s=wrap_str('nine six two')):
    nums = wrap_str('zero one two three four five six seven eight nine').split()
    return [nums.index(x) for x in ans.split(wrap_str(' '))] == sym_sorted([nums.index(x) for x in s.split(wrap_str(' '))])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_17 Int)) (=> (and (>= list_pos_17 0) (< list_pos_17 (list.length.string (str.split x " ")))) (=> (and (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite true 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1))))))))))) (< (ite false 0 (ite false 1 (ite true 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite true 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))))) false))))
(assert (forall ((list_pos_18 Int)) (=> (and (>= list_pos_18 0) (< list_pos_18 (list.length.string (str.split x " ")))) (forall ((list_pos_17 Int)) (=> (and (>= list_pos_17 0) (< list_pos_17 (list.length.string (str.split x " ")))) (=> (and (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite true 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1)))))))))))) (not (< (ite false 0 (ite false 1 (ite true 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite true 6 (ite false 7 (ite false 8 (ite false 9 -1))))))))))))) false))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SortNumbers:2
Too many constants for extrapolation

Solving puzzle 65/774: SortNumbers:3
sat_func def sat(ans: str, s="five nine four eight"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
modified_func def sat(ans: str, s=wrap_str('five nine four eight')):
    nums = wrap_str('zero one two three four five six seven eight nine').split()
    return [nums.index(x) for x in ans.split(wrap_str(' '))] == sym_sorted([nums.index(x) for x in s.split(wrap_str(' '))])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_19 Int)) (=> (and (>= list_pos_19 0) (< list_pos_19 (list.length.string (str.split x " ")))) (=> (and (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite true 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1))))))))))) (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1))))))))))) (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite true 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))))) false))))
(assert (forall ((list_pos_20 Int)) (=> (and (>= list_pos_20 0) (< list_pos_20 (list.length.string (str.split x " ")))) (forall ((list_pos_19 Int)) (=> (and (>= list_pos_19 0) (< list_pos_19 (list.length.string (str.split x " ")))) (=> (and (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite true 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))))) (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite true 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite true 9 -1)))))))))))) (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite true 8 (ite false 9 -1)))))))))) (ite false 0 (ite fal...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: '' is not in list
WARNING: Solution verification failed for puzzle SortNumbers:3
Too many constants for extrapolation

Solving puzzle 66/774: SortNumbers:4
sat_func def sat(ans: str, s="seven eight seven zero zero five one"):
    nums = 'zero one two three four five six seven eight nine'.split()
    return [nums.index(x) for x in ans.split(" ")] == sorted([nums.index(x) for x in s.split(" ")])
modified_func def sat(ans: str, s=wrap_str('seven eight seven zero zero five one')):
    nums = wrap_str('zero one two three four five six seven eight nine').split()
    return [nums.index(x) for x in ans.split(wrap_str(' '))] == sym_sorted([nums.index(x) for x in s.split(wrap_str(' '))])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((list_pos_21 Int)) (=> (and (>= list_pos_21 0) (< list_pos_21 (list.length.string (str.split x " ")))) (=> (and (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite true 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite true 7 (ite false 8 (ite false 9 -1))))))))))) (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite true 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite true 8 (ite false 9 -1))))))))))) (< (ite true 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite true 7 (ite false 8 (ite false 9 -1))))))))))) (< (ite...
(assert (forall ((list_pos_22 Int)) (=> (and (>= list_pos_22 0) (< list_pos_22 (list.length.string (str.split x " ")))) (forall ((list_pos_21 Int)) (=> (and (>= list_pos_21 0) (< list_pos_21 (list.length.string (str.split x " ")))) (=> (and (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite true 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite true 7 (ite false 8 (ite false 9 -1)))))))))))) (not (< (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite true 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite true 8 (ite false 9 -1)))))))))))) (not (< (ite true 0 (ite false 1 (ite false 2 (ite false 3 (ite false 4 (ite false 5 (ite false 6 (ite false 7 (ite false 8 (ite false 9 -1)))))))))) (ite false 0 (ite fal...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: '' is not in list
WARNING: Solution verification failed for puzzle SortNumbers:4
Too many constants for extrapolation

Solving puzzle 67/774: LargestDivisor:0
sat_func def sat(d: int, n=123456):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(123456)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 123456)) (and (and (= (mod 123456 x) 0) (< x 123456)) (not (= (mod 123456 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    123456)
)
### output for cvc5
sat
(
(define-fun x () Int 61728)
)

Found solution 123456
WARNING: Solution verification failed for puzzle LargestDivisor:0
One large constant for extrapolation
Solving simpler variation replaced 123456 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 3)) (and (and (= (mod 3 x) 0) (< x 3)) (not (= (mod 3 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3)
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution 3
WARNING: Solution verification failed for puzzle LargestDivisor:0

Solving puzzle 68/774: LargestDivisor:1
sat_func def sat(d: int, n=17836):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(17836)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 17836)) (and (and (= (mod 17836 x) 0) (< x 17836)) (not (= (mod 17836 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    17836)
)
### output for cvc5
sat
(
(define-fun x () Int 8918)
)

Found solution 17836
WARNING: Solution verification failed for puzzle LargestDivisor:1
One large constant for extrapolation
Solving simpler variation replaced 17836 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 3)) (and (and (= (mod 3 x) 0) (< x 3)) (not (= (mod 3 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3)
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution 3
WARNING: Solution verification failed for puzzle LargestDivisor:1

Solving puzzle 69/774: LargestDivisor:2
sat_func def sat(d: int, n=71793):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(71793)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 71793)) (and (and (= (mod 71793 x) 0) (< x 71793)) (not (= (mod 71793 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    71793)
)
### output for cvc5
sat
(
(define-fun x () Int 23931)
)

Found solution 71793
WARNING: Solution verification failed for puzzle LargestDivisor:2
One large constant for extrapolation
Solving simpler variation replaced 71793 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 3)) (and (and (= (mod 3 x) 0) (< x 3)) (not (= (mod 3 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3)
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution 3
WARNING: Solution verification failed for puzzle LargestDivisor:2

Solving puzzle 70/774: LargestDivisor:3
sat_func def sat(d: int, n=15466):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(15466)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 15466)) (and (and (= (mod 15466 x) 0) (< x 15466)) (not (= (mod 15466 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    15466)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 15466
WARNING: Solution verification failed for puzzle LargestDivisor:3
One large constant for extrapolation
Solving simpler variation replaced 15466 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 3)) (and (and (= (mod 3 x) 0) (< x 3)) (not (= (mod 3 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3)
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution 3
WARNING: Solution verification failed for puzzle LargestDivisor:3

Solving puzzle 71/774: LargestDivisor:4
sat_func def sat(d: int, n=57567):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(57567)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 57567)) (and (and (= (mod 57567 x) 0) (< x 57567)) (not (= (mod 57567 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    57567)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 57567
WARNING: Solution verification failed for puzzle LargestDivisor:4
One large constant for extrapolation
Solving simpler variation replaced 57567 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and d < n and all(n % e for e in range(d + 1, n))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(d < n).__and__(all(sym_generator((n % e for e in sym_range(d + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 3)) (and (and (= (mod 3 x) 0) (< x 3)) (not (= (mod 3 i_0) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3)
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution 3
WARNING: Solution verification failed for puzzle LargestDivisor:4

Solving puzzle 72/774: FlipCase:0
sat_func def sat(ans: str, s="FlIp ME!"):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
modified_func def sat(ans: str, s=wrap_str('FlIp ME!')):
    return (sym_len(ans) == sym_len(s)).__and__(all(sym_generator(({c, d} == {d.upper(), d.lower()} for c, d in sym_zip(ans, s)))))
Exception -- for puzzle FlipCase:0 Symbolic hash not yet implemented

Solving puzzle 73/774: FlipCase:1
sat_func def sat(ans: str, s="mKC(K2.a!Z|>sv3izC3!"):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
modified_func def sat(ans: str, s=wrap_str('mKC(K2.a!Z|>sv3izC3!')):
    return (sym_len(ans) == sym_len(s)).__and__(all(sym_generator(({c, d} == {d.upper(), d.lower()} for c, d in sym_zip(ans, s)))))
Exception -- for puzzle FlipCase:1 Symbolic hash not yet implemented

Solving puzzle 74/774: FlipCase:2
sat_func def sat(ans: str, s="K a&3 tE 1tSG B3v3y("):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
modified_func def sat(ans: str, s=wrap_str('K a&3 tE 1tSG B3v3y(')):
    return (sym_len(ans) == sym_len(s)).__and__(all(sym_generator(({c, d} == {d.upper(), d.lower()} for c, d in sym_zip(ans, s)))))
Exception -- for puzzle FlipCase:2 Symbolic hash not yet implemented

Solving puzzle 75/774: FlipCase:3
sat_func def sat(ans: str, s="Sb31E#e<@3u"):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
modified_func def sat(ans: str, s=wrap_str('Sb31E#e<@3u')):
    return (sym_len(ans) == sym_len(s)).__and__(all(sym_generator(({c, d} == {d.upper(), d.lower()} for c, d in sym_zip(ans, s)))))
Exception -- for puzzle FlipCase:3 Symbolic hash not yet implemented

Solving puzzle 76/774: FlipCase:4
sat_func def sat(ans: str, s="q Y*.zv? !3B3::/3%F3"):
    return len(ans) == len(s) and all({c, d} == {d.upper(), d.lower()} for c, d in zip(ans, s))
modified_func def sat(ans: str, s=wrap_str('q Y*.zv? !3B3::/3%F3')):
    return (sym_len(ans) == sym_len(s)).__and__(all(sym_generator(({c, d} == {d.upper(), d.lower()} for c, d in sym_zip(ans, s)))))
Exception -- for puzzle FlipCase:4 Symbolic hash not yet implemented

Solving puzzle 77/774: CatStrings:0
sat_func def sat(cat: str, strings=['Will', 'i', 'am', 'Now', 'here']):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
modified_func def sat(cat: str, strings=wrap_list([wrap_str('Will'), wrap_str('i'), wrap_str('am'), wrap_str('Now'), wrap_str('here')])):
    i = wrap_int(0)
    for s in strings:
        for c in s:
            _assert(cat[i] == c)
            i += wrap_int(1)
    return i == sym_len(cat)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "W"))
(assert (= (python.str.at x 1) "i"))
(assert (= (python.str.at x 2) "l"))
(assert (= (python.str.at x 3) "l"))
(assert (= (python.str.at x 4) "i"))
(assert (= (python.str.at x 5) "a"))
(assert (= (python.str.at x 6) "m"))
(assert (= (python.str.at x 7) "N"))
(assert (= (python.str.at x 8) "o"))
(assert (= (python.str.at x 9) "w"))
(assert (= (python.str.at x 10) "h"))
(assert (= (python.str.at x 11) "e"))
(assert (= (python.str.at x 12) "r"))
(assert (= (python.str.at x 13) "e"))
(assert (= 14 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "WilliamNowhere")
)
### output for cvc5
sat
(
(define-fun x () String "WilliamNowhere")
)

Found solution WilliamNowhere
Yes! Solved for puzzle  CatStrings:0

Solving puzzle 78/774: CatStrings:1
sat_func def sat(cat: str, strings=['dufe', 'keret', 'kothihisedatextumuva', 'pe', 'sicelynyzysukydew', 'zu', 'kathubaki']):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
modified_func def sat(cat: str, strings=wrap_list([wrap_str('dufe'), wrap_str('keret'), wrap_str('kothihisedatextumuva'), wrap_str('pe'), wrap_str('sicelynyzysukydew'), wrap_str('zu'), wrap_str('kathubaki')])):
    i = wrap_int(0)
    for s in strings:
        for c in s:
            _assert(cat[i] == c)
            i += wrap_int(1)
    return i == sym_len(cat)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "d"))
(assert (= (python.str.at x 1) "u"))
(assert (= (python.str.at x 2) "f"))
(assert (= (python.str.at x 3) "e"))
(assert (= (python.str.at x 4) "k"))
(assert (= (python.str.at x 5) "e"))
(assert (= (python.str.at x 6) "r"))
(assert (= (python.str.at x 7) "e"))
(assert (= (python.str.at x 8) "t"))
(assert (= (python.str.at x 9) "k"))
(assert (= (python.str.at x 10) "o"))
(assert (= (python.str.at x 11) "t"))
(assert (= (python.str.at x 12) "h"))
(assert (= (python.str.at x 13) "i"))
(assert (= (python.str.at x 14) "h"))
(assert (= (python.str.at x 15) "i"))
(assert (= (python.str.at x 16) "s"))
(assert (= (python.str.at x 17) "e"))
(assert (= (python.str.at x 18) "d"))
(assert (= (python.str.at x 19) "a"))
(assert (= (python.str.at x 20) "t"))
(assert (= (python.str.at x 21) "e"))
(assert (= (python.str.at x 22) "x"))
(assert (= (python.str.at x 23) "t"))
(assert (= (python.str.at x 24) "u"))
(assert (= (python.str.at x 25) "m"))
(assert (= (python.str.at x 26) "u"))
(assert (= (python.str.at x 27) "v"))
(assert (= (python.str.at x 28) "a"))
(assert (= (python.str.at x 29) "p"))
(assert (= (python.str.at x 30) "e"))
(assert (= (python.str.at x 31) "s"))
(assert (= (python.str.at x 32) "i"))
(assert (= (python.str.at x 33) "c"))
(assert (= (python.str.at x 34) "e"))
(assert (= (python.str.at x 35) "l"))
(assert (= (python.str.at x 36) "y"))
(assert (= (python.str.at x 37) "n"))
(assert (= (python.str.at x 38) "y"))
(assert (= (python.str.at x 39) "z"))
(assert (= (python.str.at x 40) "y"))
(assert (= (python.str.at x 41) "s"))
(assert (= (python.str.at x 42) "u"))
(assert (= (python.str.at x 43) "k"))
(assert (= (python.str.at x 44) "y"))
(assert (= (python.str.at x 45) "d"))
(assert (= (python.str.at x 46) "e"))
(assert (= (python.str.at x 47) "w"))
(assert (= (python.str.at x 48) "z"))
(assert (= (python.str.at x 49) "u"))
(assert (= (python.str.at x 50) "k"))
(assert (= (python.str.at x 51) "a"))
(assert (= (python.str.at x 52) "t"))
(assert (= (python.str.at x 53) "h"))
(assert (= (python.str.at x 54) "u"))
(assert (= (python.str.at x 55) "b"))
(assert (= (python.str.at x 56) "a"))
(assert (= (python.str.at x 57) "k"))
(assert (= (python.str.at x 58) "i"))
(assert (= 59 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "dufekeretkothihisedatextumuvapesicelynyzysukydewzukathubaki")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution dufekeretkothihisedatextumuvapesicelynyzysukydewzukathubaki
Yes! Solved for puzzle  CatStrings:1

Solving puzzle 79/774: CatStrings:2
sat_func def sat(cat: str, strings=[]):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
modified_func def sat(cat: str, strings=wrap_list([])):
    i = wrap_int(0)
    for s in strings:
        for c in s:
            _assert(cat[i] == c)
            i += wrap_int(1)
    return i == sym_len(cat)
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= 0 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Yes! Solved for puzzle  CatStrings:2

Solving puzzle 80/774: CatStrings:3
sat_func def sat(cat: str, strings=['c', 'vawumich', 'textucagidyhikomuro', 'wuchiquusojahoz', 'l']):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
modified_func def sat(cat: str, strings=wrap_list([wrap_str('c'), wrap_str('vawumich'), wrap_str('textucagidyhikomuro'), wrap_str('wuchiquusojahoz'), wrap_str('l')])):
    i = wrap_int(0)
    for s in strings:
        for c in s:
            _assert(cat[i] == c)
            i += wrap_int(1)
    return i == sym_len(cat)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "c"))
(assert (= (python.str.at x 1) "v"))
(assert (= (python.str.at x 2) "a"))
(assert (= (python.str.at x 3) "w"))
(assert (= (python.str.at x 4) "u"))
(assert (= (python.str.at x 5) "m"))
(assert (= (python.str.at x 6) "i"))
(assert (= (python.str.at x 7) "c"))
(assert (= (python.str.at x 8) "h"))
(assert (= (python.str.at x 9) "t"))
(assert (= (python.str.at x 10) "e"))
(assert (= (python.str.at x 11) "x"))
(assert (= (python.str.at x 12) "t"))
(assert (= (python.str.at x 13) "u"))
(assert (= (python.str.at x 14) "c"))
(assert (= (python.str.at x 15) "a"))
(assert (= (python.str.at x 16) "g"))
(assert (= (python.str.at x 17) "i"))
(assert (= (python.str.at x 18) "d"))
(assert (= (python.str.at x 19) "y"))
(assert (= (python.str.at x 20) "h"))
(assert (= (python.str.at x 21) "i"))
(assert (= (python.str.at x 22) "k"))
(assert (= (python.str.at x 23) "o"))
(assert (= (python.str.at x 24) "m"))
(assert (= (python.str.at x 25) "u"))
(assert (= (python.str.at x 26) "r"))
(assert (= (python.str.at x 27) "o"))
(assert (= (python.str.at x 28) "w"))
(assert (= (python.str.at x 29) "u"))
(assert (= (python.str.at x 30) "c"))
(assert (= (python.str.at x 31) "h"))
(assert (= (python.str.at x 32) "i"))
(assert (= (python.str.at x 33) "q"))
(assert (= (python.str.at x 34) "u"))
(assert (= (python.str.at x 35) "u"))
(assert (= (python.str.at x 36) "s"))
(assert (= (python.str.at x 37) "o"))
(assert (= (python.str.at x 38) "j"))
(assert (= (python.str.at x 39) "a"))
(assert (= (python.str.at x 40) "h"))
(assert (= (python.str.at x 41) "o"))
(assert (= (python.str.at x 42) "z"))
(assert (= (python.str.at x 43) "l"))
(assert (= 44 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "cvawumichtextucagidyhikomurowuchiquusojahozl")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution cvawumichtextucagidyhikomurowuchiquusojahozl
Yes! Solved for puzzle  CatStrings:3

Solving puzzle 81/774: CatStrings:4
sat_func def sat(cat: str, strings=['s', 'nutext', 'quoxezenukowyho', 'botidyhu', 'kicethytextithybaqu']):
    i = 0
    for s in strings:
        for c in s:
            assert cat[i] == c
            i += 1
    return i == len(cat)
modified_func def sat(cat: str, strings=wrap_list([wrap_str('s'), wrap_str('nutext'), wrap_str('quoxezenukowyho'), wrap_str('botidyhu'), wrap_str('kicethytextithybaqu')])):
    i = wrap_int(0)
    for s in strings:
        for c in s:
            _assert(cat[i] == c)
            i += wrap_int(1)
    return i == sym_len(cat)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "s"))
(assert (= (python.str.at x 1) "n"))
(assert (= (python.str.at x 2) "u"))
(assert (= (python.str.at x 3) "t"))
(assert (= (python.str.at x 4) "e"))
(assert (= (python.str.at x 5) "x"))
(assert (= (python.str.at x 6) "t"))
(assert (= (python.str.at x 7) "q"))
(assert (= (python.str.at x 8) "u"))
(assert (= (python.str.at x 9) "o"))
(assert (= (python.str.at x 10) "x"))
(assert (= (python.str.at x 11) "e"))
(assert (= (python.str.at x 12) "z"))
(assert (= (python.str.at x 13) "e"))
(assert (= (python.str.at x 14) "n"))
(assert (= (python.str.at x 15) "u"))
(assert (= (python.str.at x 16) "k"))
(assert (= (python.str.at x 17) "o"))
(assert (= (python.str.at x 18) "w"))
(assert (= (python.str.at x 19) "y"))
(assert (= (python.str.at x 20) "h"))
(assert (= (python.str.at x 21) "o"))
(assert (= (python.str.at x 22) "b"))
(assert (= (python.str.at x 23) "o"))
(assert (= (python.str.at x 24) "t"))
(assert (= (python.str.at x 25) "i"))
(assert (= (python.str.at x 26) "d"))
(assert (= (python.str.at x 27) "y"))
(assert (= (python.str.at x 28) "h"))
(assert (= (python.str.at x 29) "u"))
(assert (= (python.str.at x 30) "k"))
(assert (= (python.str.at x 31) "i"))
(assert (= (python.str.at x 32) "c"))
(assert (= (python.str.at x 33) "e"))
(assert (= (python.str.at x 34) "t"))
(assert (= (python.str.at x 35) "h"))
(assert (= (python.str.at x 36) "y"))
(assert (= (python.str.at x 37) "t"))
(assert (= (python.str.at x 38) "e"))
(assert (= (python.str.at x 39) "x"))
(assert (= (python.str.at x 40) "t"))
(assert (= (python.str.at x 41) "i"))
(assert (= (python.str.at x 42) "t"))
(assert (= (python.str.at x 43) "h"))
(assert (= (python.str.at x 44) "y"))
(assert (= (python.str.at x 45) "b"))
(assert (= (python.str.at x 46) "a"))
(assert (= (python.str.at x 47) "q"))
(assert (= (python.str.at x 48) "u"))
(assert (= 49 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "snutextquoxezenukowyhobotidyhukicethytextithybaqu")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution snutextquoxezenukowyhobotidyhukicethytextithybaqu
Yes! Solved for puzzle  CatStrings:4

Solving puzzle 82/774: OddDegreePolynomialRoot:0
sat_func def sat(root: float, coeffs=[1, 2, 3, 17]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
modified_func def sat(root: float, coeffs=wrap_list([wrap_int(1), wrap_int(2), wrap_int(3), wrap_int(17)])):
    return abs(sym_sum(sym_generator((coeff * root ** i for i, coeff in enumerate(coeffs))))) < 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (+ (+ (* 1 (^ x 0)) 0) (* 2 (^ x 1))) (* 3 (^ x 2))) (* 17 (^ x 3))) 0) (+ (+ (+ (+ (* 1 (^ x 0)) 0) (* 2 (^ x 1))) (* 3 (^ x 2))) (* 17 (^ x 3))) (- (+ (+ (+ (+ (* 1 (^ x 0)) 0) (* 2 (^ x 1))) (* 3 (^ x 2))) (* 17 (^ x 3))))) 0.0001))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
  (define-fun ^0 ((x!0 Real) (x!1 Real)) Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.44: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle OddDegreePolynomialRoot:0
Too many constants for extrapolation

Solving puzzle 83/774: OddDegreePolynomialRoot:1
sat_func def sat(root: float, coeffs=[-1, -5, 4, -8, 3, -1, 0, 7]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
modified_func def sat(root: float, coeffs=wrap_list([-wrap_int(1), -wrap_int(5), wrap_int(4), -wrap_int(8), wrap_int(3), -wrap_int(1), wrap_int(0), wrap_int(7)])):
    return abs(sym_sum(sym_generator((coeff * root ** i for i, coeff in enumerate(coeffs))))) < 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (+ (+ (+ (+ (+ (+ (* -1 (^ x 0)) 0) (* -5 (^ x 1))) (* 4 (^ x 2))) (* -8 (^ x 3))) (* 3 (^ x 4))) (* -1 (^ x 5))) (* 0 (^ x 6))) (* 7 (^ x 7))) 0) (+ (+ (+ (+ (+ (+ (+ (+ (* -1 (^ x 0)) 0) (* -5 (^ x 1))) (* 4 (^ x 2))) (* -8 (^ x 3))) (* 3 (^ x 4))) (* -1 (^ x 5))) (* 0 (^ x 6))) (* 7 (^ x 7))) (- (+ (+ (+ (+ (+ (+ (+ (+ (* -1 (^ x 0)) 0) (* -5 (^ x 1))) (* 4 (^ x 2))) (* -8 (^ x 3))) (* 3 (^ x 4))) (* -1 (^ x 5))) (* 0 (^ x 6))) (* 7 (^ x 7))))) 0.0001))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
  (define-fun ^0 ((x!0 Real) (x!1 Real)) Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.57: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle OddDegreePolynomialRoot:1
Too many constants for extrapolation

Solving puzzle 84/774: OddDegreePolynomialRoot:2
sat_func def sat(root: float, coeffs=[7, 1]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
modified_func def sat(root: float, coeffs=wrap_list([wrap_int(7), wrap_int(1)])):
    return abs(sym_sum(sym_generator((coeff * root ** i for i, coeff in enumerate(coeffs))))) < 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (* 7 (^ x 0)) 0) (* 1 (^ x 1))) 0) (+ (+ (* 7 (^ x 0)) 0) (* 1 (^ x 1))) (- (+ (+ (* 7 (^ x 0)) 0) (* 1 (^ x 1))))) 0.0001))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
  (define-fun ^0 ((x!0 Real) (x!1 Real)) Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.38: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle OddDegreePolynomialRoot:2
Too many constants for extrapolation

Solving puzzle 85/774: OddDegreePolynomialRoot:3
sat_func def sat(root: float, coeffs=[1, 4, 1, -7, 5, 0, -10, -9, 4, 9]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
modified_func def sat(root: float, coeffs=wrap_list([wrap_int(1), wrap_int(4), wrap_int(1), -wrap_int(7), wrap_int(5), wrap_int(0), -wrap_int(10), -wrap_int(9), wrap_int(4), wrap_int(9)])):
    return abs(sym_sum(sym_generator((coeff * root ** i for i, coeff in enumerate(coeffs))))) < 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* 1 (^ x 0)) 0) (* 4 (^ x 1))) (* 1 (^ x 2))) (* -7 (^ x 3))) (* 5 (^ x 4))) (* 0 (^ x 5))) (* -10 (^ x 6))) (* -9 (^ x 7))) (* 4 (^ x 8))) (* 9 (^ x 9))) 0) (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* 1 (^ x 0)) 0) (* 4 (^ x 1))) (* 1 (^ x 2))) (* -7 (^ x 3))) (* 5 (^ x 4))) (* 0 (^ x 5))) (* -10 (^ x 6))) (* -9 (^ x 7))) (* 4 (^ x 8))) (* 9 (^ x 9))) (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* 1 (^ x 0)) 0) (* 4 (^ x 1))) (* 1 (^ x 2))) (* -7 (^ x 3))) (* 5 (^ x 4))) (* 0 (^ x 5))) (* -10 (^ x 6))) (* -9 (^ x 7))) (* 4 (^ x 8))) (* 9 (^ x 9))))) 0.0001))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
  (define-fun ^0 ((x!0 Real) (x!1 Real)) Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.62: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle OddDegreePolynomialRoot:3
Too many constants for extrapolation

Solving puzzle 86/774: OddDegreePolynomialRoot:4
sat_func def sat(root: float, coeffs=[7, 8]):
    return abs(sum(coeff * (root ** i) for i, coeff in enumerate(coeffs))) < 1e-4
modified_func def sat(root: float, coeffs=wrap_list([wrap_int(7), wrap_int(8)])):
    return abs(sym_sum(sym_generator((coeff * root ** i for i, coeff in enumerate(coeffs))))) < 0.0001
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (* 7 (^ x 0)) 0) (* 8 (^ x 1))) 0) (+ (+ (* 7 (^ x 0)) 0) (* 8 (^ x 1))) (- (+ (+ (* 7 (^ x 0)) 0) (* 8 (^ x 1))))) 0.0001))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
  (define-fun ^0 ((x!0 Real) (x!1 Real)) Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.38: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle OddDegreePolynomialRoot:4
Too many constants for extrapolation

Solving puzzle 87/774: MaxInt:0
sat_func def sat(m: int, hello=[1, 31, 3, 2, 0, 18, 32, -4, 2, -1000, 3502145, 3502145, 21, 18, 2, 60]):
    return m in hello and not any(m < i for i in hello)
modified_func def sat(m: int, hello=wrap_list([wrap_int(1), wrap_int(31), wrap_int(3), wrap_int(2), wrap_int(0), wrap_int(18), wrap_int(32), -wrap_int(4), wrap_int(2), -wrap_int(1000), wrap_int(3502145), wrap_int(3502145), wrap_int(21), wrap_int(18), wrap_int(2), wrap_int(60)])):
    return sym_in(m, hello).__and__(sym_not(any(sym_generator((m < i for i in hello)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (or (= x 1) (= x 31) (= x 3) (= x 2) (= x 0) (= x 18) (= x 32) (= x -4) (= x 2) (= x -1000) (= x 3502145) (= x 3502145) (= x 21) (= x 18) (= x 2) (= x 60)) (not (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (< x 1) (< x 31)) (< x 3)) (< x 2)) (< x 0)) (< x 18)) (< x 32)) (< x -4)) (< x 2)) (< x -1000)) (< x 3502145)) (< x 3502145)) (< x 21)) (< x 18)) (< x 2)) (< x 60)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3502145)
)
### output for cvc5
sat
(
(define-fun x () Int 3502145)
)

Found solution 3502145
Yes! Solved for puzzle  MaxInt:0

Solving puzzle 88/774: MaxInt:1
sat_func def sat(m: int, hello=[2, 2, 2, -4, -2, -5, -4, 0, -5, -10, 1, -1, -1, 2]):
    return m in hello and not any(m < i for i in hello)
modified_func def sat(m: int, hello=wrap_list([wrap_int(2), wrap_int(2), wrap_int(2), -wrap_int(4), -wrap_int(2), -wrap_int(5), -wrap_int(4), wrap_int(0), -wrap_int(5), -wrap_int(10), wrap_int(1), -wrap_int(1), -wrap_int(1), wrap_int(2)])):
    return sym_in(m, hello).__and__(sym_not(any(sym_generator((m < i for i in hello)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (or (= x 2) (= x 2) (= x 2) (= x -4) (= x -2) (= x -5) (= x -4) (= x 0) (= x -5) (= x -10) (= x 1) (= x -1) (= x -1) (= x 2)) (not (or (or (or (or (or (or (or (or (or (or (or (or (or (< x 2) (< x 2)) (< x 2)) (< x -4)) (< x -2)) (< x -5)) (< x -4)) (< x 0)) (< x -5)) (< x -10)) (< x 1)) (< x -1)) (< x -1)) (< x 2)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2)
)
### output for cvc5
sat
(
(define-fun x () Int 2)
)

Found solution 2
Yes! Solved for puzzle  MaxInt:1

Solving puzzle 89/774: MaxInt:2
sat_func def sat(m: int, hello=[8, -1, -8, 1, -10]):
    return m in hello and not any(m < i for i in hello)
modified_func def sat(m: int, hello=wrap_list([wrap_int(8), -wrap_int(1), -wrap_int(8), wrap_int(1), -wrap_int(10)])):
    return sym_in(m, hello).__and__(sym_not(any(sym_generator((m < i for i in hello)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (or (= x 8) (= x -1) (= x -8) (= x 1) (= x -10)) (not (or (or (or (or (< x 8) (< x -1)) (< x -8)) (< x 1)) (< x -10)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8)
)
### output for cvc5
sat
(
(define-fun x () Int 8)
)

Found solution 8
Yes! Solved for puzzle  MaxInt:2

Solving puzzle 90/774: MaxInt:3
sat_func def sat(m: int, hello=[-8, 1, 9, 4, 4, 0, -1, 8, 2, 3, 5, 9, 2, -1, 9]):
    return m in hello and not any(m < i for i in hello)
modified_func def sat(m: int, hello=wrap_list([-wrap_int(8), wrap_int(1), wrap_int(9), wrap_int(4), wrap_int(4), wrap_int(0), -wrap_int(1), wrap_int(8), wrap_int(2), wrap_int(3), wrap_int(5), wrap_int(9), wrap_int(2), -wrap_int(1), wrap_int(9)])):
    return sym_in(m, hello).__and__(sym_not(any(sym_generator((m < i for i in hello)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (or (= x -8) (= x 1) (= x 9) (= x 4) (= x 4) (= x 0) (= x -1) (= x 8) (= x 2) (= x 3) (= x 5) (= x 9) (= x 2) (= x -1) (= x 9)) (not (or (or (or (or (or (or (or (or (or (or (or (or (or (or (< x -8) (< x 1)) (< x 9)) (< x 4)) (< x 4)) (< x 0)) (< x -1)) (< x 8)) (< x 2)) (< x 3)) (< x 5)) (< x 9)) (< x 2)) (< x -1)) (< x 9)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    9)
)
### output for cvc5
sat
(
(define-fun x () Int 9)
)

Found solution 9
Yes! Solved for puzzle  MaxInt:3

Solving puzzle 91/774: MaxInt:4
sat_func def sat(m: int, hello=[5, 2, -10, -2, -4, 2, 3, -5, 9, 0]):
    return m in hello and not any(m < i for i in hello)
modified_func def sat(m: int, hello=wrap_list([wrap_int(5), wrap_int(2), -wrap_int(10), -wrap_int(2), -wrap_int(4), wrap_int(2), wrap_int(3), -wrap_int(5), wrap_int(9), wrap_int(0)])):
    return sym_in(m, hello).__and__(sym_not(any(sym_generator((m < i for i in hello)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (or (= x 5) (= x 2) (= x -10) (= x -2) (= x -4) (= x 2) (= x 3) (= x -5) (= x 9) (= x 0)) (not (or (or (or (or (or (or (or (or (or (< x 5) (< x 2)) (< x -10)) (< x -2)) (< x -4)) (< x 2)) (< x 3)) (< x -5)) (< x 9)) (< x 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    9)
)
### output for cvc5
sat
(
(define-fun x () Int 9)
)

Found solution 9
Yes! Solved for puzzle  MaxInt:4

Solving puzzle 92/774: ThreeCycle:0
sat_func def sat(s: str, target="Hello world"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
modified_func def sat(s: str, target=wrap_str('Hello world')):

    def cycle3(trip):
        return trip if sym_len(trip) != wrap_int(3) else trip[wrap_int(2)] + trip[:2]
    return target == wrap_str('').join(sym_generator((cycle3(s[i:i + 3]) for i in sym_range(0, sym_len(s), 3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(declare-const k_1 Int)
(declare-const k_3 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (= (str.len (python.str.substr x i_0 (+ i_0 3))) 3)) (= "Hello world" (python.join (cons (python.str.substr x i_0 (+ i_0 3)) (as nil (List String))) ""))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 0) (< i_2 (str.len x))) (>= k_3 0)) (= i_2 (+ 0 (* k_3 3)))) (< k_3 (div (- (str.len x) 0) 3))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (not (= (str.len (python.str.substr x i_2 (+ i_2 3))) 3))) (= "Hello world" (python.join (cons (str.++ (python.str.at (python.str.substr x i_2 (+ i_2 3)) 2) (python.str.substr (python.str.substr x i_2 (+ i_2 3)) 0 2)) (as nil (List String))) ""))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "D")
  (define-fun k_1 () Int
    (- 1))
  (define-fun k_3 () Int
    23975)
)
### output for cvc5
sat
(
(define-fun x () String "")
(define-fun k_1 () Int 0)
(define-fun k_3 () Int 0)
)

Found solution D
WARNING: Solution verification failed for puzzle ThreeCycle:0
Too many constants for extrapolation

Solving puzzle 93/774: ThreeCycle:1
sat_func def sat(s: str, target="rugetytextirocuterup"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
modified_func def sat(s: str, target=wrap_str('rugetytextirocuterup')):

    def cycle3(trip):
        return trip if sym_len(trip) != wrap_int(3) else trip[wrap_int(2)] + trip[:2]
    return target == wrap_str('').join(sym_generator((cycle3(s[i:i + 3]) for i in sym_range(0, sym_len(s), 3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(declare-const k_1 Int)
(declare-const k_3 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (= (str.len (python.str.substr x i_0 (+ i_0 3))) 3)) (= "rugetytextirocuterup" (python.join (cons (python.str.substr x i_0 (+ i_0 3)) (as nil (List String))) ""))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 0) (< i_2 (str.len x))) (>= k_3 0)) (= i_2 (+ 0 (* k_3 3)))) (< k_3 (div (- (str.len x) 0) 3))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (not (= (str.len (python.str.substr x i_2 (+ i_2 3))) 3))) (= "rugetytextirocuterup" (python.join (cons (str.++ (python.str.at (python.str.substr x i_2 (+ i_2 3)) 2) (python.str.substr (python.str.substr x i_2 (+ i_2 3)) 0 2)) (as nil (List String))) ""))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "D")
  (define-fun k_1 () Int
    0)
  (define-fun k_3 () Int
    1)
)
### output for cvc5
sat
(
(define-fun x () String "")
(define-fun k_1 () Int 0)
(define-fun k_3 () Int 0)
)

Found solution D
WARNING: Solution verification failed for puzzle ThreeCycle:1
Too many constants for extrapolation

Solving puzzle 94/774: ThreeCycle:2
sat_func def sat(s: str, target="torusajidapaficiretoh"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
modified_func def sat(s: str, target=wrap_str('torusajidapaficiretoh')):

    def cycle3(trip):
        return trip if sym_len(trip) != wrap_int(3) else trip[wrap_int(2)] + trip[:2]
    return target == wrap_str('').join(sym_generator((cycle3(s[i:i + 3]) for i in sym_range(0, sym_len(s), 3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(declare-const k_1 Int)
(declare-const k_3 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (= (str.len (python.str.substr x i_0 (+ i_0 3))) 3)) (= "torusajidapaficiretoh" (python.join (cons (python.str.substr x i_0 (+ i_0 3)) (as nil (List String))) ""))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 0) (< i_2 (str.len x))) (>= k_3 0)) (= i_2 (+ 0 (* k_3 3)))) (< k_3 (div (- (str.len x) 0) 3))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (not (= (str.len (python.str.substr x i_2 (+ i_2 3))) 3))) (= "torusajidapaficiretoh" (python.join (cons (str.++ (python.str.at (python.str.substr x i_2 (+ i_2 3)) 2) (python.str.substr (python.str.substr x i_2 (+ i_2 3)) 0 2)) (as nil (List String))) ""))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "D")
  (define-fun k_1 () Int
    (- 2))
  (define-fun k_3 () Int
    5744)
)
### output for cvc5
sat
(
(define-fun x () String "")
(define-fun k_1 () Int 0)
(define-fun k_3 () Int 0)
)

Found solution D
WARNING: Solution verification failed for puzzle ThreeCycle:2
Too many constants for extrapolation

Solving puzzle 95/774: ThreeCycle:3
sat_func def sat(s: str, target="quitextaf"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
modified_func def sat(s: str, target=wrap_str('quitextaf')):

    def cycle3(trip):
        return trip if sym_len(trip) != wrap_int(3) else trip[wrap_int(2)] + trip[:2]
    return target == wrap_str('').join(sym_generator((cycle3(s[i:i + 3]) for i in sym_range(0, sym_len(s), 3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(declare-const k_1 Int)
(declare-const k_3 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (= (str.len (python.str.substr x i_0 (+ i_0 3))) 3)) (= "quitextaf" (python.join (cons (python.str.substr x i_0 (+ i_0 3)) (as nil (List String))) ""))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 0) (< i_2 (str.len x))) (>= k_3 0)) (= i_2 (+ 0 (* k_3 3)))) (< k_3 (div (- (str.len x) 0) 3))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (not (= (str.len (python.str.substr x i_2 (+ i_2 3))) 3))) (= "quitextaf" (python.join (cons (str.++ (python.str.at (python.str.substr x i_2 (+ i_2 3)) 2) (python.str.substr (python.str.substr x i_2 (+ i_2 3)) 0 2)) (as nil (List String))) ""))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "D")
  (define-fun k_1 () Int
    (- 1))
  (define-fun k_3 () Int
    23975)
)
### output for cvc5
sat
(
(define-fun x () String "")
(define-fun k_1 () Int 0)
(define-fun k_3 () Int 0)
)

Found solution D
WARNING: Solution verification failed for puzzle ThreeCycle:3
Too many constants for extrapolation

Solving puzzle 96/774: ThreeCycle:4
sat_func def sat(s: str, target="thoqui"):

    def cycle3(trip):
        return trip if len(trip) != 3 else trip[2] + trip[:2]

    return target == "".join(cycle3(s[i: i + 3]) for i in range(0, len(s), 3))
modified_func def sat(s: str, target=wrap_str('thoqui')):

    def cycle3(trip):
        return trip if sym_len(trip) != wrap_int(3) else trip[wrap_int(2)] + trip[:2]
    return target == wrap_str('').join(sym_generator((cycle3(s[i:i + 3]) for i in sym_range(0, sym_len(s), 3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(declare-const k_1 Int)
(declare-const k_3 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (= (str.len (python.str.substr x i_0 (+ i_0 3))) 3)) (= "thoqui" (python.join (cons (python.str.substr x i_0 (+ i_0 3)) (as nil (List String))) ""))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 0) (< i_2 (str.len x))) (>= k_3 0)) (= i_2 (+ 0 (* k_3 3)))) (< k_3 (div (- (str.len x) 0) 3))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 0) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 0 (* k_1 3)))) (< k_1 (div (- (str.len x) 0) 3))) (=> (not (not (= (str.len (python.str.substr x i_2 (+ i_2 3))) 3))) (= "thoqui" (python.join (cons (str.++ (python.str.at (python.str.substr x i_2 (+ i_2 3)) 2) (python.str.substr (python.str.substr x i_2 (+ i_2 3)) 0 2)) (as nil (List String))) ""))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "D")
  (define-fun k_1 () Int
    (- 2))
  (define-fun k_3 () Int
    23975)
)
### output for cvc5
sat
(
(define-fun x () String "")
(define-fun k_1 () Int 0)
(define-fun k_3 () Int 0)
)

Found solution D
WARNING: Solution verification failed for puzzle ThreeCycle:4
Too many constants for extrapolation

Solving puzzle 97/774: PrimeFib:0
sat_func def sat(n: int, lower=123456):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
modified_func def sat(n: int, lower=wrap_int(123456)):
    _assert(any(sym_generator(((i ** 0.5).is_integer() for i in wrap_list([wrap_int(5) * n * n - wrap_int(4), wrap_int(5) * n * n + wrap_int(4)])))), wrap_str('n must be a Fibonacci number'))
    _assert(all(sym_generator((n % i for i in sym_range(2, sym_int(n ** 0.5) + 1)))), wrap_str('n must be prime'))
    return n > lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= (^ (- (* (* 5 x) x) 4) 0.5) (to_int (^ (- (* (* 5 x) x) 4) 0.5))) (= (^ (+ (* (* 5 x) x) 4) 0.5) (to_int (^ (+ (* (* 5 x) x) 4) 0.5)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (not (= (mod x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (> x 123456))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 7 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeFib:0
One large constant for extrapolation
Solving simpler variation replaced 123456 with 3
sat_func def sat(n: int, lower=3):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
modified_func def sat(n: int, lower=wrap_int(3)):
    _assert(any(sym_generator(((i ** 0.5).is_integer() for i in wrap_list([wrap_int(5) * n * n - wrap_int(4), wrap_int(5) * n * n + wrap_int(4)])))), wrap_str('n must be a Fibonacci number'))
    _assert(all(sym_generator((n % i for i in sym_range(2, sym_int(n ** 0.5) + 1)))), wrap_str('n must be prime'))
    return n > lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= (^ (- (* (* 5 x) x) 4) 0.5) (to_int (^ (- (* (* 5 x) x) 4) 0.5))) (= (^ (+ (* (* 5 x) x) 4) 0.5) (to_int (^ (+ (* (* 5 x) x) 4) 0.5)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (not (= (mod x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (> x 3))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 7 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeFib:0

Solving puzzle 98/774: PrimeFib:1
sat_func def sat(n: int, lower=3):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
modified_func def sat(n: int, lower=wrap_int(3)):
    _assert(any(sym_generator(((i ** 0.5).is_integer() for i in wrap_list([wrap_int(5) * n * n - wrap_int(4), wrap_int(5) * n * n + wrap_int(4)])))), wrap_str('n must be a Fibonacci number'))
    _assert(all(sym_generator((n % i for i in sym_range(2, sym_int(n ** 0.5) + 1)))), wrap_str('n must be prime'))
    return n > lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= (^ (- (* (* 5 x) x) 4) 0.5) (to_int (^ (- (* (* 5 x) x) 4) 0.5))) (= (^ (+ (* (* 5 x) x) 4) 0.5) (to_int (^ (+ (* (* 5 x) x) 4) 0.5)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (not (= (mod x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (> x 3))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 7 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeFib:1
Too many constants for extrapolation

Solving puzzle 99/774: PrimeFib:2
sat_func def sat(n: int, lower=458):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
modified_func def sat(n: int, lower=wrap_int(458)):
    _assert(any(sym_generator(((i ** 0.5).is_integer() for i in wrap_list([wrap_int(5) * n * n - wrap_int(4), wrap_int(5) * n * n + wrap_int(4)])))), wrap_str('n must be a Fibonacci number'))
    _assert(all(sym_generator((n % i for i in sym_range(2, sym_int(n ** 0.5) + 1)))), wrap_str('n must be prime'))
    return n > lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= (^ (- (* (* 5 x) x) 4) 0.5) (to_int (^ (- (* (* 5 x) x) 4) 0.5))) (= (^ (+ (* (* 5 x) x) 4) 0.5) (to_int (^ (+ (* (* 5 x) x) 4) 0.5)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (not (= (mod x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (> x 458))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 7 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeFib:2
One large constant for extrapolation
Solving simpler variation replaced 458 with 3
sat_func def sat(n: int, lower=3):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
modified_func def sat(n: int, lower=wrap_int(3)):
    _assert(any(sym_generator(((i ** 0.5).is_integer() for i in wrap_list([wrap_int(5) * n * n - wrap_int(4), wrap_int(5) * n * n + wrap_int(4)])))), wrap_str('n must be a Fibonacci number'))
    _assert(all(sym_generator((n % i for i in sym_range(2, sym_int(n ** 0.5) + 1)))), wrap_str('n must be prime'))
    return n > lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= (^ (- (* (* 5 x) x) 4) 0.5) (to_int (^ (- (* (* 5 x) x) 4) 0.5))) (= (^ (+ (* (* 5 x) x) 4) 0.5) (to_int (^ (+ (* (* 5 x) x) 4) 0.5)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (not (= (mod x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (> x 3))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 7 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeFib:2

Solving puzzle 100/774: PrimeFib:3
sat_func def sat(n: int, lower=384):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
modified_func def sat(n: int, lower=wrap_int(384)):
    _assert(any(sym_generator(((i ** 0.5).is_integer() for i in wrap_list([wrap_int(5) * n * n - wrap_int(4), wrap_int(5) * n * n + wrap_int(4)])))), wrap_str('n must be a Fibonacci number'))
    _assert(all(sym_generator((n % i for i in sym_range(2, sym_int(n ** 0.5) + 1)))), wrap_str('n must be prime'))
    return n > lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= (^ (- (* (* 5 x) x) 4) 0.5) (to_int (^ (- (* (* 5 x) x) 4) 0.5))) (= (^ (+ (* (* 5 x) x) 4) 0.5) (to_int (^ (+ (* (* 5 x) x) 4) 0.5)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (not (= (mod x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (> x 384))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 7 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeFib:3
One large constant for extrapolation
Solving simpler variation replaced 384 with 3
sat_func def sat(n: int, lower=3):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
modified_func def sat(n: int, lower=wrap_int(3)):
    _assert(any(sym_generator(((i ** 0.5).is_integer() for i in wrap_list([wrap_int(5) * n * n - wrap_int(4), wrap_int(5) * n * n + wrap_int(4)])))), wrap_str('n must be a Fibonacci number'))
    _assert(all(sym_generator((n % i for i in sym_range(2, sym_int(n ** 0.5) + 1)))), wrap_str('n must be prime'))
    return n > lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= (^ (- (* (* 5 x) x) 4) 0.5) (to_int (^ (- (* (* 5 x) x) 4) 0.5))) (= (^ (+ (* (* 5 x) x) 4) 0.5) (to_int (^ (+ (* (* 5 x) x) 4) 0.5)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (not (= (mod x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (> x 3))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 7 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeFib:3

Solving puzzle 101/774: PrimeFib:4
sat_func def sat(n: int, lower=4):
    assert any((i ** 0.5).is_integer() for i in [5 * n * n - 4, 5 * n * n + 4]), "n must be a Fibonacci number"
    assert all(n % i for i in range(2, int(n ** 0.5) + 1)), "n must be prime"
    return n > lower
modified_func def sat(n: int, lower=wrap_int(4)):
    _assert(any(sym_generator(((i ** 0.5).is_integer() for i in wrap_list([wrap_int(5) * n * n - wrap_int(4), wrap_int(5) * n * n + wrap_int(4)])))), wrap_str('n must be a Fibonacci number'))
    _assert(all(sym_generator((n % i for i in sym_range(2, sym_int(n ** 0.5) + 1)))), wrap_str('n must be prime'))
    return n > lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= (^ (- (* (* 5 x) x) 4) 0.5) (to_int (^ (- (* (* 5 x) x) 4) 0.5))) (= (^ (+ (* (* 5 x) x) 4) 0.5) (to_int (^ (+ (* (* 5 x) x) 4) 0.5)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (not (= (mod x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ x 0.5)) 1))) (> x 4))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 7 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeFib:4
Too many constants for extrapolation

Solving puzzle 102/774: NumPasses:0
sat_func def sat(count: int, n=981):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
modified_func def sat(count: int, n=wrap_int(981)):
    for i in sym_range(n):
        for j in sym_range(n):
            count -= wrap_int(1)
    return count == wrap_int(0)
Exception -- for puzzle NumPasses:0 maximum recursion depth exceeded

Solving puzzle 103/774: NumPasses:1
sat_func def sat(count: int, n=123):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
modified_func def sat(count: int, n=wrap_int(123)):
    for i in sym_range(n):
        for j in sym_range(n):
            count -= wrap_int(1)
    return count == wrap_int(0)
Exception -- for puzzle NumPasses:1 maximum recursion depth exceeded

Solving puzzle 104/774: NumPasses:2
sat_func def sat(count: int, n=239):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
modified_func def sat(count: int, n=wrap_int(239)):
    for i in sym_range(n):
        for j in sym_range(n):
            count -= wrap_int(1)
    return count == wrap_int(0)
Exception -- for puzzle NumPasses:2 maximum recursion depth exceeded

Solving puzzle 105/774: NumPasses:3
sat_func def sat(count: int, n=378):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
modified_func def sat(count: int, n=wrap_int(378)):
    for i in sym_range(n):
        for j in sym_range(n):
            count -= wrap_int(1)
    return count == wrap_int(0)
Exception -- for puzzle NumPasses:3 maximum recursion depth exceeded

Solving puzzle 106/774: NumPasses:4
sat_func def sat(count: int, n=501):
    for i in range(n):
        for j in range(n):
            count -= 1
    return count == 0
modified_func def sat(count: int, n=wrap_int(501)):
    for i in sym_range(n):
        for j in sym_range(n):
            count -= wrap_int(1)
    return count == wrap_int(0)
Exception -- for puzzle NumPasses:4 maximum recursion depth exceeded

Solving puzzle 107/774: ChangeBase:0
sat_func def sat(s: str, n=142, base=7):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(142), base=wrap_int(7)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 7) 142))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "\u{be}")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @quantifiers_skolemize_6)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @quantifiers_skolemize_6)))))")

Found solution 
Exception in checking result: invalid literal for int() with base 7: ''
WARNING: Solution verification failed for puzzle ChangeBase:0
One large constant for extrapolation
Solving simpler variation replaced 142 with 3
sat_func def sat(s: str, n=3, base=7):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(3), base=wrap_int(7)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 7) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "3")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @quantifiers_skolemize_6)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @quantifiers_skolemize_6)))))")

Found solution 3

Solving puzzle 108/774: ChangeBase:1
sat_func def sat(s: str, n=85328, base=2):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(85328), base=wrap_int(2)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 2) 85328))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_6)))))")

Could not find any solution for puzzle ChangeBase:1
One large constant for extrapolation
Solving simpler variation replaced 85328 with 3
sat_func def sat(s: str, n=3, base=2):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(3), base=wrap_int(2)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 2) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "11")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_6)))))")

Found solution 11

Solving puzzle 109/774: ChangeBase:2
sat_func def sat(s: str, n=9576751, base=10):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(9576751), base=wrap_int(10)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 10) 9576751))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "9576751")
)
### output for cvc5
sat
(
(define-fun x () String "9576751")
)

Found solution 9576751
Yes! Solved for puzzle  ChangeBase:2

Solving puzzle 110/774: ChangeBase:3
sat_func def sat(s: str, n=5160280, base=5):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(5160280), base=wrap_int(5)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 5) 5160280))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @quantifiers_skolemize_6)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @quantifiers_skolemize_6)))))")

Could not find any solution for puzzle ChangeBase:3
One large constant for extrapolation
Solving simpler variation replaced 5160280 with 3
sat_func def sat(s: str, n=3, base=5):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(3), base=wrap_int(5)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 5) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "3")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @quantifiers_skolemize_6)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @quantifiers_skolemize_6)))))")

Found solution 3

Solving puzzle 111/774: ChangeBase:4
sat_func def sat(s: str, n=4884658, base=6):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(4884658), base=wrap_int(6)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 6) 4884658))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @quantifiers_skolemize_6)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @quantifiers_skolemize_6)))))")

Could not find any solution for puzzle ChangeBase:4
One large constant for extrapolation
Solving simpler variation replaced 4884658 with 3
sat_func def sat(s: str, n=3, base=6):
    return int(s, base) == n
modified_func def sat(s: str, n=wrap_int(3), base=wrap_int(6)):
    return sym_int(s, base) == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 6) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "3")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (to_real (str-to-int_arg_1_3 @quantifiers_skolemize_6)) (to_real (+ (- 1) (str.len (str-to-int_arg_0_2 @quantifiers_skolemize_6)))))")

Found solution 3

Solving puzzle 112/774: TriangleArea:0
sat_func def sat(height: int, area=1319098728582, base=45126):
    return base * height == 2 * area
modified_func def sat(height: int, area=wrap_int(1319098728582), base=wrap_int(45126)):
    return base * height == wrap_int(2) * area
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (* 45126 x) 2638197457164))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    58462914)
)
### output for cvc5
sat
(
(define-fun x () Int 58462914)
)

Found solution 58462914
Yes! Solved for puzzle  TriangleArea:0

Solving puzzle 113/774: TriangleArea:1
sat_func def sat(height: int, area=2642925075, base=211434006):
    return base * height == 2 * area
modified_func def sat(height: int, area=wrap_int(2642925075), base=wrap_int(211434006)):
    return base * height == wrap_int(2) * area
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (* 211434006 x) 5285850150))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    25)
)
### output for cvc5
sat
(
(define-fun x () Int 25)
)

Found solution 25
Yes! Solved for puzzle  TriangleArea:1

Solving puzzle 114/774: TriangleArea:2
sat_func def sat(height: int, area=5529468804, base=18936537):
    return base * height == 2 * area
modified_func def sat(height: int, area=wrap_int(5529468804), base=wrap_int(18936537)):
    return base * height == wrap_int(2) * area
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (* 18936537 x) 11058937608))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    584)
)
### output for cvc5
sat
(
(define-fun x () Int 584)
)

Found solution 584
Yes! Solved for puzzle  TriangleArea:2

Solving puzzle 115/774: TriangleArea:3
sat_func def sat(height: int, area=1238452500, base=600):
    return base * height == 2 * area
modified_func def sat(height: int, area=wrap_int(1238452500), base=wrap_int(600)):
    return base * height == wrap_int(2) * area
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (* 600 x) 2476905000))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    4128175)
)
### output for cvc5
sat
(
(define-fun x () Int 4128175)
)

Found solution 4128175
Yes! Solved for puzzle  TriangleArea:3

Solving puzzle 116/774: TriangleArea:4
sat_func def sat(height: int, area=32576448, base=147072):
    return base * height == 2 * area
modified_func def sat(height: int, area=wrap_int(32576448), base=wrap_int(147072)):
    return base * height == wrap_int(2) * area
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (* 147072 x) 65152896))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    443)
)
### output for cvc5
sat
(
(define-fun x () Int 443)
)

Found solution 443
Yes! Solved for puzzle  TriangleArea:4

Solving puzzle 117/774: Median:0
sat_func def sat(x: int, nums=[132666041, 237412, 28141, -12, 11939, 912414, 17], upper=133658965):
    dev = sum(n - x for n in nums)
    return dev <= upper
modified_func def sat(x: int, nums=wrap_list([wrap_int(132666041), wrap_int(237412), wrap_int(28141), -wrap_int(12), wrap_int(11939), wrap_int(912414), wrap_int(17)]), upper=wrap_int(133658965)):
    dev = sym_sum(sym_generator((n - x for n in nums)))
    return dev <= upper
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (+ (+ (+ (+ (+ (+ (+ (- 132666041 x) 0) (- 237412 x)) (- 28141 x)) (- -12 x)) (- 11939 x)) (- 912414 x)) (- 17 x)) 133658965))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    28141)
)
### output for cvc5
sat
(
(define-fun x () Int 28141)
)

Found solution 28141
Yes! Solved for puzzle  Median:0

Solving puzzle 118/774: Median:1
sat_func def sat(x: int, nums=[-8813279918, 7464351342, 8037181984, 8564600186, 660800781], upper=-21408102335):
    dev = sum(n - x for n in nums)
    return dev <= upper
modified_func def sat(x: int, nums=wrap_list([-wrap_int(8813279918), wrap_int(7464351342), wrap_int(8037181984), wrap_int(8564600186), wrap_int(660800781)]), upper=-wrap_int(21408102335)):
    dev = sym_sum(sym_generator((n - x for n in nums)))
    return dev <= upper
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (+ (+ (+ (+ (+ (- -8813279918 x) 0) (- 7464351342 x)) (- 8037181984 x)) (- 8564600186 x)) (- 660800781 x)) -21408102335))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    7464351342)
)
### output for cvc5
sat
(
(define-fun x () Int 7464351342)
)

Found solution 7464351342
Yes! Solved for puzzle  Median:1

Solving puzzle 119/774: Median:2
sat_func def sat(x: int, nums=[], upper=0):
    dev = sum(n - x for n in nums)
    return dev <= upper
modified_func def sat(x: int, nums=wrap_list([]), upper=wrap_int(0)):
    dev = sym_sum(sym_generator((n - x for n in nums)))
    return dev <= upper
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  Median:2

Solving puzzle 120/774: Median:3
sat_func def sat(x: int, nums=[-2350083760, -34560579, 3780403495, -9390708907, 2424237816, -6782611896, 624505871], upper=-11486893907):
    dev = sum(n - x for n in nums)
    return dev <= upper
modified_func def sat(x: int, nums=wrap_list([-wrap_int(2350083760), -wrap_int(34560579), wrap_int(3780403495), -wrap_int(9390708907), wrap_int(2424237816), -wrap_int(6782611896), wrap_int(624505871)]), upper=-wrap_int(11486893907)):
    dev = sym_sum(sym_generator((n - x for n in nums)))
    return dev <= upper
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (+ (+ (+ (+ (+ (+ (+ (- -2350083760 x) 0) (- -34560579 x)) (- 3780403495 x)) (- -9390708907 x)) (- 2424237816 x)) (- -6782611896 x)) (- 624505871 x)) -11486893907))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 34560579))
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution -34560579
Yes! Solved for puzzle  Median:3

Solving puzzle 121/774: Median:4
sat_func def sat(x: int, nums=[-2410166269, 5887293672], upper=-8297459941):
    dev = sum(n - x for n in nums)
    return dev <= upper
modified_func def sat(x: int, nums=wrap_list([-wrap_int(2410166269), wrap_int(5887293672)]), upper=-wrap_int(8297459941)):
    dev = sym_sum(sym_generator((n - x for n in nums)))
    return dev <= upper
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (+ (+ (- -2410166269 x) 0) (- 5887293672 x)) -8297459941))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    5887293672)
)
### output for cvc5
sat
(
(define-fun x () Int 5887293672)
)

Found solution 5887293672
Yes! Solved for puzzle  Median:4

Solving puzzle 122/774: ShiftChars:0
sat_func def sat(orig: str, result="Hello, world!", shift=7):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
modified_func def sat(orig: str, result=wrap_str('Hello, world!'), shift=wrap_int(7)):
    n = sym_len(result)
    _assert(sym_len(orig) == n)
    return all(sym_generator((sym_ord(orig[i]) + shift == sym_ord(result[i]) for i in sym_range(n))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (str.len x) 13))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (= (+ (str.to_code (python.str.at x 0)) 7) 72) (= (+ (str.to_code (python.str.at x 1)) 7) 101)) (= (+ (str.to_code (python.str.at x 2)) 7) 108)) (= (+ (str.to_code (python.str.at x 3)) 7) 108)) (= (+ (str.to_code (python.str.at x 4)) 7) 111)) (= (+ (str.to_code (python.str.at x 5)) 7) 44)) (= (+ (str.to_code (python.str.at x 6)) 7) 32)) (= (+ (str.to_code (python.str.at x 7)) 7) 119)) (= (+ (str.to_code (python.str.at x 8)) 7) 111)) (= (+ (str.to_code (python.str.at x 9)) 7) 114)) (= (+ (str.to_code (python.str.at x 10)) 7) 108)) (= (+ (str.to_code (python.str.at x 11)) 7) 100)) (= (+ (str.to_code (python.str.at x 12)) 7) 33)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A^eeh%\u{19}phke]\u{1a}")
)
### output for cvc5
sat
(
(define-fun x () String "A^eeh%\u{19}phke]\u{1a}")
)

Found solution A^eeh%phke]
Yes! Solved for puzzle  ShiftChars:0

Solving puzzle 123/774: ShiftChars:1
sat_func def sat(orig: str, result="rupomykecykynuric", shift=-9):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
modified_func def sat(orig: str, result=wrap_str('rupomykecykynuric'), shift=-wrap_int(9)):
    n = sym_len(result)
    _assert(sym_len(orig) == n)
    return all(sym_generator((sym_ord(orig[i]) + shift == sym_ord(result[i]) for i in sym_range(n))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (str.len x) 17))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (+ (str.to_code (python.str.at x 0)) -9) 114) (= (+ (str.to_code (python.str.at x 1)) -9) 117)) (= (+ (str.to_code (python.str.at x 2)) -9) 112)) (= (+ (str.to_code (python.str.at x 3)) -9) 111)) (= (+ (str.to_code (python.str.at x 4)) -9) 109)) (= (+ (str.to_code (python.str.at x 5)) -9) 121)) (= (+ (str.to_code (python.str.at x 6)) -9) 107)) (= (+ (str.to_code (python.str.at x 7)) -9) 101)) (= (+ (str.to_code (python.str.at x 8)) -9) 99)) (= (+ (str.to_code (python.str.at x 9)) -9) 121)) (= (+ (str.to_code (python.str.at x 10)) -9) 107)) (= (+ (str.to_code (python.str.at x 11)) -9) 121)) (= (+ (str.to_code (python.str.at x 12)) -9) 110)) (= (+ (str.to_code (python.str.at x 13)) -9) 117)) (= (+ (str.to_code (python.str.at x 14)) -9) 114)) (= (+ (str.to_code (python.str.at x 15)) -9) 105)) (= (+ (str.to_code (python.str.at x 16)) -9) 99)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "{~yxv\u{82}tnl\u{82}t\u{82}w~{rl")
)
### output for cvc5
sat
(
(define-fun x () String "{~yxv\u{82}tnl\u{82}t\u{82}w~{rl")
)

Found solution {~yxvtnltw~{rl
Yes! Solved for puzzle  ShiftChars:1

Solving puzzle 124/774: ShiftChars:2
sat_func def sat(orig: str, result="vicyza", shift=7):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
modified_func def sat(orig: str, result=wrap_str('vicyza'), shift=wrap_int(7)):
    n = sym_len(result)
    _assert(sym_len(orig) == n)
    return all(sym_generator((sym_ord(orig[i]) + shift == sym_ord(result[i]) for i in sym_range(n))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (str.len x) 6))
(assert (and (and (and (and (and (= (+ (str.to_code (python.str.at x 0)) 7) 118) (= (+ (str.to_code (python.str.at x 1)) 7) 105)) (= (+ (str.to_code (python.str.at x 2)) 7) 99)) (= (+ (str.to_code (python.str.at x 3)) 7) 121)) (= (+ (str.to_code (python.str.at x 4)) 7) 122)) (= (+ (str.to_code (python.str.at x 5)) 7) 97)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ob\rsZ")
)
### output for cvc5
sat
(
(define-fun x () String "ob\u{5c}rsZ")
)

Found solution obsZ
Exception in checking result: 
WARNING: Solution verification failed for puzzle ShiftChars:2
Too many constants for extrapolation

Solving puzzle 125/774: ShiftChars:3
sat_func def sat(orig: str, result="nihyzatijyjoke", shift=8):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
modified_func def sat(orig: str, result=wrap_str('nihyzatijyjoke'), shift=wrap_int(8)):
    n = sym_len(result)
    _assert(sym_len(orig) == n)
    return all(sym_generator((sym_ord(orig[i]) + shift == sym_ord(result[i]) for i in sym_range(n))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (str.len x) 14))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (= (+ (str.to_code (python.str.at x 0)) 8) 110) (= (+ (str.to_code (python.str.at x 1)) 8) 105)) (= (+ (str.to_code (python.str.at x 2)) 8) 104)) (= (+ (str.to_code (python.str.at x 3)) 8) 121)) (= (+ (str.to_code (python.str.at x 4)) 8) 122)) (= (+ (str.to_code (python.str.at x 5)) 8) 97)) (= (+ (str.to_code (python.str.at x 6)) 8) 116)) (= (+ (str.to_code (python.str.at x 7)) 8) 105)) (= (+ (str.to_code (python.str.at x 8)) 8) 106)) (= (+ (str.to_code (python.str.at x 9)) 8) 121)) (= (+ (str.to_code (python.str.at x 10)) 8) 106)) (= (+ (str.to_code (python.str.at x 11)) 8) 111)) (= (+ (str.to_code (python.str.at x 12)) 8) 107)) (= (+ (str.to_code (python.str.at x 13)) 8) 101)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "fa`qrYlabqbgc]")
)
### output for cvc5
sat
(
(define-fun x () String "fa`qrYlabqbgc]")
)

Found solution fa`qrYlabqbgc]
Yes! Solved for puzzle  ShiftChars:3

Solving puzzle 126/774: ShiftChars:4
sat_func def sat(orig: str, result="tuthijotext", shift=6):
    n = len(result)
    assert len(orig) == n
    return all(ord(orig[i]) + shift == ord(result[i]) for i in range(n))
modified_func def sat(orig: str, result=wrap_str('tuthijotext'), shift=wrap_int(6)):
    n = sym_len(result)
    _assert(sym_len(orig) == n)
    return all(sym_generator((sym_ord(orig[i]) + shift == sym_ord(result[i]) for i in sym_range(n))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (str.len x) 11))
(assert (and (and (and (and (and (and (and (and (and (and (= (+ (str.to_code (python.str.at x 0)) 6) 116) (= (+ (str.to_code (python.str.at x 1)) 6) 117)) (= (+ (str.to_code (python.str.at x 2)) 6) 116)) (= (+ (str.to_code (python.str.at x 3)) 6) 104)) (= (+ (str.to_code (python.str.at x 4)) 6) 105)) (= (+ (str.to_code (python.str.at x 5)) 6) 106)) (= (+ (str.to_code (python.str.at x 6)) 6) 111)) (= (+ (str.to_code (python.str.at x 7)) 6) 116)) (= (+ (str.to_code (python.str.at x 8)) 6) 101)) (= (+ (str.to_code (python.str.at x 9)) 6) 120)) (= (+ (str.to_code (python.str.at x 10)) 6) 116)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "nonbcdin_rn")
)
### output for cvc5
sat
(
(define-fun x () String "nonbcdin_rn")
)

Found solution nonbcdin_rn
Yes! Solved for puzzle  ShiftChars:4

Solving puzzle 127/774: RemoveVowels:0
sat_func def sat(txt: str, text="Hello, world!"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
modified_func def sat(txt: str, text=wrap_str('Hello, world!')):
    n = wrap_int(0)
    for c in text:
        if c.lower() not in wrap_str('aeiou'):
            _assert(txt[n] == c)
            n += wrap_int(1)
    _assert(n == sym_len(txt))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "H"))
(assert (= (python.str.at x 1) "l"))
(assert (= (python.str.at x 2) "l"))
(assert (= (python.str.at x 3) ","))
(assert (= (python.str.at x 4) " "))
(assert (= (python.str.at x 5) "w"))
(assert (= (python.str.at x 6) "r"))
(assert (= (python.str.at x 7) "l"))
(assert (= (python.str.at x 8) "d"))
(assert (= (python.str.at x 9) "!"))
(assert (= 10 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "Hll, wrld!")
)
### output for cvc5
sat
(
(define-fun x () String "Hll, wrld!")
)

Found solution Hll, wrld!
Yes! Solved for puzzle  RemoveVowels:0

Solving puzzle 128/774: RemoveVowels:1
sat_func def sat(txt: str, text="GUSUXeGePUJibAqUojo"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
modified_func def sat(txt: str, text=wrap_str('GUSUXeGePUJibAqUojo')):
    n = wrap_int(0)
    for c in text:
        if c.lower() not in wrap_str('aeiou'):
            _assert(txt[n] == c)
            n += wrap_int(1)
    _assert(n == sym_len(txt))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "G"))
(assert (= (python.str.at x 1) "S"))
(assert (= (python.str.at x 2) "X"))
(assert (= (python.str.at x 3) "G"))
(assert (= (python.str.at x 4) "P"))
(assert (= (python.str.at x 5) "J"))
(assert (= (python.str.at x 6) "b"))
(assert (= (python.str.at x 7) "q"))
(assert (= (python.str.at x 8) "j"))
(assert (= 9 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "GSXGPJbqj")
)
### output for cvc5
sat
(
(define-fun x () String "GSXGPJbqj")
)

Found solution GSXGPJbqj
Yes! Solved for puzzle  RemoveVowels:1

Solving puzzle 129/774: RemoveVowels:2
sat_func def sat(txt: str, text="CAsaVyVOTHobAHEwIhI"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
modified_func def sat(txt: str, text=wrap_str('CAsaVyVOTHobAHEwIhI')):
    n = wrap_int(0)
    for c in text:
        if c.lower() not in wrap_str('aeiou'):
            _assert(txt[n] == c)
            n += wrap_int(1)
    _assert(n == sym_len(txt))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "C"))
(assert (= (python.str.at x 1) "s"))
(assert (= (python.str.at x 2) "V"))
(assert (= (python.str.at x 3) "y"))
(assert (= (python.str.at x 4) "V"))
(assert (= (python.str.at x 5) "T"))
(assert (= (python.str.at x 6) "H"))
(assert (= (python.str.at x 7) "b"))
(assert (= (python.str.at x 8) "H"))
(assert (= (python.str.at x 9) "w"))
(assert (= (python.str.at x 10) "h"))
(assert (= 11 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "CsVyVTHbHwh")
)
### output for cvc5
sat
(
(define-fun x () String "CsVyVTHbHwh")
)

Found solution CsVyVTHbHwh
Yes! Solved for puzzle  RemoveVowels:2

Solving puzzle 130/774: RemoveVowels:3
sat_func def sat(txt: str, text="TeX"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
modified_func def sat(txt: str, text=wrap_str('TeX')):
    n = wrap_int(0)
    for c in text:
        if c.lower() not in wrap_str('aeiou'):
            _assert(txt[n] == c)
            n += wrap_int(1)
    _assert(n == sym_len(txt))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "T"))
(assert (= (python.str.at x 1) "X"))
(assert (= 2 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "TX")
)
### output for cvc5
sat
(
(define-fun x () String "TX")
)

Found solution TX
Yes! Solved for puzzle  RemoveVowels:3

Solving puzzle 131/774: RemoveVowels:4
sat_func def sat(txt: str, text="Q"):
    n = 0
    for c in text:
        if c.lower() not in "aeiou":
            assert txt[n] == c
            n += 1
    assert n == len(txt)
    return True
modified_func def sat(txt: str, text=wrap_str('Q')):
    n = wrap_int(0)
    for c in text:
        if c.lower() not in wrap_str('aeiou'):
            _assert(txt[n] == c)
            n += wrap_int(1)
    _assert(n == sym_len(txt))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "Q"))
(assert (= 1 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "Q")
)
### output for cvc5
sat
(
(define-fun x () String "Q")
)

Found solution Q
Yes! Solved for puzzle  RemoveVowels:4

Solving puzzle 132/774: ListTotal:0
sat_func def sat(n: int, nums=[10, 42, 17, 9, 1315182, 184, 102, 29, 15, 39, 755]):
    return sum(nums + [-n]) == 0
modified_func def sat(n: int, nums=wrap_list([wrap_int(10), wrap_int(42), wrap_int(17), wrap_int(9), wrap_int(1315182), wrap_int(184), wrap_int(102), wrap_int(29), wrap_int(15), wrap_int(39), wrap_int(755)])):
    return sym_sum(nums + wrap_list([-n])) == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ 1316384 (- x)) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1316384)
)
### output for cvc5
sat
(
(define-fun x () Int 1316384)
)

Found solution 1316384
Yes! Solved for puzzle  ListTotal:0

Solving puzzle 133/774: ListTotal:1
sat_func def sat(n: int, nums=[40388491, -864787067, 862143530, 604555885, -81302113, 717834573]):
    return sum(nums + [-n]) == 0
modified_func def sat(n: int, nums=wrap_list([wrap_int(40388491), -wrap_int(864787067), wrap_int(862143530), wrap_int(604555885), -wrap_int(81302113), wrap_int(717834573)])):
    return sym_sum(nums + wrap_list([-n])) == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ 1278833299 (- x)) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1278833299)
)
### output for cvc5
sat
(
(define-fun x () Int 1278833299)
)

Found solution 1278833299
Yes! Solved for puzzle  ListTotal:1

Solving puzzle 134/774: ListTotal:2
sat_func def sat(n: int, nums=[-93, 35, -95, -7, -85, 2]):
    return sum(nums + [-n]) == 0
modified_func def sat(n: int, nums=wrap_list([-wrap_int(93), wrap_int(35), -wrap_int(95), -wrap_int(7), -wrap_int(85), wrap_int(2)])):
    return sym_sum(nums + wrap_list([-n])) == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ -243 (- x)) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 243))
)
### output for cvc5
sat
(
(define-fun x () Int (- 243))
)

Found solution -243
Yes! Solved for puzzle  ListTotal:2

Solving puzzle 135/774: ListTotal:3
sat_func def sat(n: int, nums=[-2040052, -6582681, -6604315, 1042475, 7287312, 8050849, 5566992, 4332017]):
    return sum(nums + [-n]) == 0
modified_func def sat(n: int, nums=wrap_list([-wrap_int(2040052), -wrap_int(6582681), -wrap_int(6604315), wrap_int(1042475), wrap_int(7287312), wrap_int(8050849), wrap_int(5566992), wrap_int(4332017)])):
    return sym_sum(nums + wrap_list([-n])) == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ 11052597 (- x)) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    11052597)
)
### output for cvc5
sat
(
(define-fun x () Int 11052597)
)

Found solution 11052597
Yes! Solved for puzzle  ListTotal:3

Solving puzzle 136/774: ListTotal:4
sat_func def sat(n: int, nums=[-1, -1, -1, -1, 0, 0]):
    return sum(nums + [-n]) == 0
modified_func def sat(n: int, nums=wrap_list([-wrap_int(1), -wrap_int(1), -wrap_int(1), -wrap_int(1), wrap_int(0), wrap_int(0)])):
    return sym_sum(nums + wrap_list([-n])) == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ -4 (- x)) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 4))
)
### output for cvc5
sat
(
(define-fun x () Int (- 4))
)

Found solution -4
Yes! Solved for puzzle  ListTotal:4

Solving puzzle 137/774: DiffChars:0
sat_func def sat(c: str, a="the quick brown fox jumped over the lazy dog", b="how vexingly quick daft zebras jump"):
    return (c in a) != (c in b)
modified_func def sat(c: str, a=wrap_str('the quick brown fox jumped over the lazy dog'), b=wrap_str('how vexingly quick daft zebras jump')):
    return sym_in(c, a) != sym_in(c, b)
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle DiffChars:0
Too many constants for extrapolation

Solving puzzle 138/774: DiffChars:1
sat_func def sat(c: str, a="jyhud", b="nexysezomevus"):
    return (c in a) != (c in b)
modified_func def sat(c: str, a=wrap_str('jyhud'), b=wrap_str('nexysezomevus')):
    return sym_in(c, a) != sym_in(c, b)
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle DiffChars:1
Too many constants for extrapolation

Solving puzzle 139/774: DiffChars:2
sat_func def sat(c: str, a="vofawawumovisajuryt", b="t"):
    return (c in a) != (c in b)
modified_func def sat(c: str, a=wrap_str('vofawawumovisajuryt'), b=wrap_str('t')):
    return sym_in(c, a) != sym_in(c, b)
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle DiffChars:2
Too many constants for extrapolation

Solving puzzle 140/774: DiffChars:3
sat_func def sat(c: str, a="textuzaxoch", b="acehmottuxxz"):
    return (c in a) != (c in b)
modified_func def sat(c: str, a=wrap_str('textuzaxoch'), b=wrap_str('acehmottuxxz')):
    return sym_in(c, a) != sym_in(c, b)
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle DiffChars:3
Too many constants for extrapolation

Solving puzzle 141/774: DiffChars:4
sat_func def sat(c: str, a="quytextila", b="mydyhopakokinavo"):
    return (c in a) != (c in b)
modified_func def sat(c: str, a=wrap_str('quytextila'), b=wrap_str('mydyhopakokinavo')):
    return sym_in(c, a) != sym_in(c, b)
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle DiffChars:4
Too many constants for extrapolation

Solving puzzle 142/774: Monotonic:0
sat_func def sat(direction: str, nums=[2, 4, 17, 29, 31, 1000, 416629]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
modified_func def sat(direction: str, nums=wrap_list([wrap_int(2), wrap_int(4), wrap_int(17), wrap_int(29), wrap_int(31), wrap_int(1000), wrap_int(416629)])):
    if direction == wrap_str('increasing'):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    if direction == wrap_str('decreasing'):
        return all(sym_generator((nums[i + wrap_int(1)] < nums[i] for i in sym_range(sym_len(nums) - 1))))
Exception -- for puzzle Monotonic:0 some arg is none: (MockExpr(op='and', args=(MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('increasing',), _name=None)), _name=None),), _name=None), MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('decreasing',), _name=None)), _name=None),), _name=None)), _name=None), None)

Solving puzzle 143/774: Monotonic:1
sat_func def sat(direction: str, nums=[540, 713, 887, 964]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
modified_func def sat(direction: str, nums=wrap_list([wrap_int(540), wrap_int(713), wrap_int(887), wrap_int(964)])):
    if direction == wrap_str('increasing'):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    if direction == wrap_str('decreasing'):
        return all(sym_generator((nums[i + wrap_int(1)] < nums[i] for i in sym_range(sym_len(nums) - 1))))
Exception -- for puzzle Monotonic:1 some arg is none: (MockExpr(op='and', args=(MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('increasing',), _name=None)), _name=None),), _name=None), MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('decreasing',), _name=None)), _name=None),), _name=None)), _name=None), None)

Solving puzzle 144/774: Monotonic:2
sat_func def sat(direction: str, nums=[764, 291, 171]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
modified_func def sat(direction: str, nums=wrap_list([wrap_int(764), wrap_int(291), wrap_int(171)])):
    if direction == wrap_str('increasing'):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    if direction == wrap_str('decreasing'):
        return all(sym_generator((nums[i + wrap_int(1)] < nums[i] for i in sym_range(sym_len(nums) - 1))))
Exception -- for puzzle Monotonic:2 some arg is none: (MockExpr(op='and', args=(MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('increasing',), _name=None)), _name=None),), _name=None), MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('decreasing',), _name=None)), _name=None),), _name=None)), _name=None), None)

Solving puzzle 145/774: Monotonic:3
sat_func def sat(direction: str, nums=[74, 168, 229, 302, 430, 450, 481, 783]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
modified_func def sat(direction: str, nums=wrap_list([wrap_int(74), wrap_int(168), wrap_int(229), wrap_int(302), wrap_int(430), wrap_int(450), wrap_int(481), wrap_int(783)])):
    if direction == wrap_str('increasing'):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    if direction == wrap_str('decreasing'):
        return all(sym_generator((nums[i + wrap_int(1)] < nums[i] for i in sym_range(sym_len(nums) - 1))))
Exception -- for puzzle Monotonic:3 some arg is none: (MockExpr(op='and', args=(MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('increasing',), _name=None)), _name=None),), _name=None), MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('decreasing',), _name=None)), _name=None),), _name=None)), _name=None), None)

Solving puzzle 146/774: Monotonic:4
sat_func def sat(direction: str, nums=[826, 784, 726, 537, 536, 392, 250, 241, 161]):
    if direction == "increasing":
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    if direction == "decreasing":
        return all(nums[i + 1] < nums[i] for i in range(len(nums) - 1))
modified_func def sat(direction: str, nums=wrap_list([wrap_int(826), wrap_int(784), wrap_int(726), wrap_int(537), wrap_int(536), wrap_int(392), wrap_int(250), wrap_int(241), wrap_int(161)])):
    if direction == wrap_str('increasing'):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    if direction == wrap_str('decreasing'):
        return all(sym_generator((nums[i + wrap_int(1)] < nums[i] for i in sym_range(sym_len(nums) - 1))))
Exception -- for puzzle Monotonic:4 some arg is none: (MockExpr(op='and', args=(MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('increasing',), _name=None)), _name=None),), _name=None), MockExpr(op='not', args=(MockExpr(op='=', args=(MockExpr(op='String', args=('x',), _name=None), MockExpr(op='str.val', args=('decreasing',), _name=None)), _name=None),), _name=None)), _name=None), None)

Solving puzzle 147/774: LargestPrimeFactor:0
sat_func def sat(p: int, n=101076):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(101076)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 101076)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 101076 x) 0)) (> x 0)) (not (= (ite (not (= (mod 101076 i_1) 0)) (mod 101076 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:0
One large constant for extrapolation
Solving simpler variation replaced 101076 with 3
sat_func def sat(p: int, n=3):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(3)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 3)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 3 x) 0)) (> x 0)) (not (= (ite (not (= (mod 3 i_1) 0)) (mod 3 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:0

Solving puzzle 148/774: LargestPrimeFactor:1
sat_func def sat(p: int, n=15132):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(15132)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 15132)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 15132 x) 0)) (> x 0)) (not (= (ite (not (= (mod 15132 i_1) 0)) (mod 15132 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:1
One large constant for extrapolation
Solving simpler variation replaced 15132 with 3
sat_func def sat(p: int, n=3):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(3)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 3)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 3 x) 0)) (> x 0)) (not (= (ite (not (= (mod 3 i_1) 0)) (mod 3 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:1

Solving puzzle 149/774: LargestPrimeFactor:2
sat_func def sat(p: int, n=22184):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(22184)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 22184)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 22184 x) 0)) (> x 0)) (not (= (ite (not (= (mod 22184 i_1) 0)) (mod 22184 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:2
One large constant for extrapolation
Solving simpler variation replaced 22184 with 3
sat_func def sat(p: int, n=3):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(3)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 3)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 3 x) 0)) (> x 0)) (not (= (ite (not (= (mod 3 i_1) 0)) (mod 3 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:2

Solving puzzle 150/774: LargestPrimeFactor:3
sat_func def sat(p: int, n=70875):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(70875)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 70875)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 70875 x) 0)) (> x 0)) (not (= (ite (not (= (mod 70875 i_1) 0)) (mod 70875 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:3
One large constant for extrapolation
Solving simpler variation replaced 70875 with 3
sat_func def sat(p: int, n=3):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(3)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 3)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 3 x) 0)) (> x 0)) (not (= (ite (not (= (mod 3 i_1) 0)) (mod 3 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:3

Solving puzzle 151/774: LargestPrimeFactor:4
sat_func def sat(p: int, n=63088):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(63088)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 63088)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 63088 x) 0)) (> x 0)) (not (= (ite (not (= (mod 63088 i_1) 0)) (mod 63088 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:4
One large constant for extrapolation
Solving simpler variation replaced 63088 with 3
sat_func def sat(p: int, n=3):

    def is_prime(m):
        return all(m % i for i in range(2, m - 1))

    return is_prime(p) and n % p == 0 and p > 0 and all(n % i or not is_prime(i) for i in range(p + 1, n))
modified_func def sat(p: int, n=wrap_int(3)):

    def is_prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    return is_prime(p).__and__(n % p == wrap_int(0)).__and__(p > wrap_int(0)).__and__(all(sym_generator(((n % i).__or__(sym_not(is_prime(i))) for i in sym_range(p + 1, n)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (- i_1 1))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ x 1)) (< i_1 3)) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (- x 1))) (and (and (and (not (= (mod x i_0) 0)) (= (mod 3 x) 0)) (> x 0)) (not (= (ite (not (= (mod 3 i_1) 0)) (mod 3 i_1) (not (not (= (mod i_1 i_2) 0)))) 0))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 58: unknown constant i_1")
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.59: Symbol 'i_1' not declared as a variable")

Could not find any solution for puzzle LargestPrimeFactor:4

Solving puzzle 152/774: CircularShiftNum:0
sat_func def sat(shifted: str, n=124582369835, shift=3):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
modified_func def sat(shifted: str, n=wrap_int(124582369835), shift=wrap_int(3)):
    if shift > sym_len(sym_str(n)):
        return n == sym_int(shifted[::-1])
    return n == sym_int(shifted[-shift:] + shifted[:-shift])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (> (str.len (str.++ (python.str.substr x -3 (str.len x)) (python.str.substr x 0 -3))) 0))
(assert (= 124582369835 (python.int (str.++ (python.str.substr x -3 (str.len x)) (python.str.substr x 0 -3)) 10)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "582369835124")
)
### output for cvc5
sat
(
(define-fun x () String "582369835124")
)

Found solution 582369835124
Yes! Solved for puzzle  CircularShiftNum:0

Solving puzzle 153/774: CircularShiftNum:1
sat_func def sat(shifted: str, n=6852918492, shift=12):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
modified_func def sat(shifted: str, n=wrap_int(6852918492), shift=wrap_int(12)):
    if shift > sym_len(sym_str(n)):
        return n == sym_int(shifted[::-1])
    return n == sym_int(shifted[-shift:] + shifted[:-shift])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (> (str.len (str.reverse x)) 0))
(assert (= 6852918492 (python.int (str.reverse x) 10)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "2948192586")
)
### output for cvc5
sat
(
(define-fun x () String "2948192586")
)

Found solution 2948192586
Yes! Solved for puzzle  CircularShiftNum:1

Solving puzzle 154/774: CircularShiftNum:2
sat_func def sat(shifted: str, n=32928510691049616, shift=28):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
modified_func def sat(shifted: str, n=wrap_int(32928510691049616), shift=wrap_int(28)):
    if shift > sym_len(sym_str(n)):
        return n == sym_int(shifted[::-1])
    return n == sym_int(shifted[-shift:] + shifted[:-shift])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (> (str.len (str.reverse x)) 0))
(assert (= 32928510691049616 (python.int (str.reverse x) 10)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle CircularShiftNum:2
One large constant for extrapolation
Solving simpler variation replaced 32928510691049616 with 3
sat_func def sat(shifted: str, n=3, shift=28):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
modified_func def sat(shifted: str, n=wrap_int(3), shift=wrap_int(28)):
    if shift > sym_len(sym_str(n)):
        return n == sym_int(shifted[::-1])
    return n == sym_int(shifted[-shift:] + shifted[:-shift])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (> (str.len (str.reverse x)) 0))
(assert (= 3 (python.int (str.reverse x) 10)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "3")
)
### output for cvc5
sat
(
(define-fun x () String "3")
)

Found solution 3

Solving puzzle 155/774: CircularShiftNum:3
sat_func def sat(shifted: str, n=237, shift=26):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
modified_func def sat(shifted: str, n=wrap_int(237), shift=wrap_int(26)):
    if shift > sym_len(sym_str(n)):
        return n == sym_int(shifted[::-1])
    return n == sym_int(shifted[-shift:] + shifted[:-shift])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (> (str.len (str.reverse x)) 0))
(assert (= 237 (python.int (str.reverse x) 10)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "732")
)
### output for cvc5
sat
(
(define-fun x () String "732")
)

Found solution 732
Yes! Solved for puzzle  CircularShiftNum:3

Solving puzzle 156/774: CircularShiftNum:4
sat_func def sat(shifted: str, n=6, shift=26):
    if shift > len(str(n)):
        return n == int(shifted[::-1])
    return n == int(shifted[-shift:] + shifted[:-shift])
modified_func def sat(shifted: str, n=wrap_int(6), shift=wrap_int(26)):
    if shift > sym_len(sym_str(n)):
        return n == sym_int(shifted[::-1])
    return n == sym_int(shifted[-shift:] + shifted[:-shift])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (> (str.len (str.reverse x)) 0))
(assert (= 6 (python.int (str.reverse x) 10)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "6")
)
### output for cvc5
sat
(
(define-fun x () String "6")
)

Found solution 6
Yes! Solved for puzzle  CircularShiftNum:4

Solving puzzle 157/774: CharSum:0
sat_func def sat(tot: int, s="Add ME uP AND YOU WILL GET A BIG NUMBER!"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
modified_func def sat(tot: int, s=wrap_str('Add ME uP AND YOU WILL GET A BIG NUMBER!')):
    for c in s:
        if c.isupper():
            tot -= sym_ord(c)
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- x 65) 77) 69) 80) 65) 78) 68) 89) 79) 85) 87) 73) 76) 76) 71) 69) 84) 65) 66) 73) 71) 78) 85) 77) 66) 69) 82) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2023)
)
### output for cvc5
sat
(
(define-fun x () Int 2023)
)

Found solution 2023
Yes! Solved for puzzle  CharSum:0

Solving puzzle 158/774: CharSum:1
sat_func def sat(tot: int, s="VRkmX=(1oF#l"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
modified_func def sat(tot: int, s=wrap_str('VRkmX=(1oF#l')):
    for c in s:
        if c.isupper():
            tot -= sym_ord(c)
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- x 86) 82) 88) 70) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    326)
)
### output for cvc5
sat
(
(define-fun x () Int 326)
)

Found solution 326
Yes! Solved for puzzle  CharSum:1

Solving puzzle 159/774: CharSum:2
sat_func def sat(tot: int, s="*?sAJJ;FY8c!7zFwA"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
modified_func def sat(tot: int, s=wrap_str('*?sAJJ;FY8c!7zFwA')):
    for c in s:
        if c.isupper():
            tot -= sym_ord(c)
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- (- (- (- x 65) 74) 74) 70) 89) 70) 65) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    507)
)
### output for cvc5
sat
(
(define-fun x () Int 507)
)

Found solution 507
Yes! Solved for puzzle  CharSum:2

Solving puzzle 160/774: CharSum:3
sat_func def sat(tot: int, s="Vmv%e8d3P"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
modified_func def sat(tot: int, s=wrap_str('Vmv%e8d3P')):
    for c in s:
        if c.isupper():
            tot -= sym_ord(c)
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- x 86) 80) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    166)
)
### output for cvc5
sat
(
(define-fun x () Int 166)
)

Found solution 166
Yes! Solved for puzzle  CharSum:3

Solving puzzle 161/774: CharSum:4
sat_func def sat(tot: int, s="K8B"):
    for c in s:
        if c.isupper():
            tot -= ord(c)
    return tot == 0
modified_func def sat(tot: int, s=wrap_str('K8B')):
    for c in s:
        if c.isupper():
            tot -= sym_ord(c)
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- x 75) 66) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    141)
)
### output for cvc5
sat
(
(define-fun x () Int 141)
)

Found solution 141
Yes! Solved for puzzle  CharSum:4

Solving puzzle 162/774: MissingBananas:0
sat_func def sat(bananas: int, bowl="5024 apples and 12189 oranges", total=12491241):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
modified_func def sat(bananas: int, bowl=wrap_str('5024 apples and 12189 oranges'), total=wrap_int(12491241)):
    bowl += wrap_str(' and ') + sym_str(bananas) + wrap_str(' bananas')
    return sym_sum([sym_int(s) for s in bowl.split() if s.isdigit()]) == total
### smt2
(set-logic ALL)

(define-fun str.isdigit ((s String)) Bool
  (forall ((i Int))
    (=> (and (<= 0 i) (< i (str.len s)))
        (let ((c (str.at s i)))
          (str.is_digit c)))))


(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x Int)
(assert (forall ((list_pos_23 Int)) (=> (and (>= list_pos_23 0) (< list_pos_23 (list.length.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_23)) (> (str.len (list.get.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_23)) 0)))))
(assert (forall ((list_pos_23 Int)) (=> (and (>= list_pos_23 0) (< list_pos_23 (list.length.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_23)) (= (+ (python.int (list.get.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_23) 10) 0) 12491241)))))
(assert (forall ((list_pos_24 Int)) (=> (and (>= list_pos_24 0) (< list_pos_24 (list.length.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (forall ((list_pos_23 Int)) (=> (and (>= list_pos_23 0) (< list_pos_23 (list.length.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (not (str.isdigit (list.get.string (str.split (str.++ "5024 apples and 12189 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_24))) false))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle MissingBananas:0
Too many constants for extrapolation

Solving puzzle 163/774: MissingBananas:1
sat_func def sat(bananas: int, bowl="7 apples and 9 oranges", total=21):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
modified_func def sat(bananas: int, bowl=wrap_str('7 apples and 9 oranges'), total=wrap_int(21)):
    bowl += wrap_str(' and ') + sym_str(bananas) + wrap_str(' bananas')
    return sym_sum([sym_int(s) for s in bowl.split() if s.isdigit()]) == total
### smt2
(set-logic ALL)

(define-fun str.isdigit ((s String)) Bool
  (forall ((i Int))
    (=> (and (<= 0 i) (< i (str.len s)))
        (let ((c (str.at s i)))
          (str.is_digit c)))))


(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x Int)
(assert (forall ((list_pos_25 Int)) (=> (and (>= list_pos_25 0) (< list_pos_25 (list.length.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_25)) (> (str.len (list.get.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_25)) 0)))))
(assert (forall ((list_pos_25 Int)) (=> (and (>= list_pos_25 0) (< list_pos_25 (list.length.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_25)) (= (+ (python.int (list.get.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_25) 10) 0) 21)))))
(assert (forall ((list_pos_26 Int)) (=> (and (>= list_pos_26 0) (< list_pos_26 (list.length.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (forall ((list_pos_25 Int)) (=> (and (>= list_pos_25 0) (< list_pos_25 (list.length.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (not (str.isdigit (list.get.string (str.split (str.++ "7 apples and 9 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_26))) false))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle MissingBananas:1
Too many constants for extrapolation

Solving puzzle 164/774: MissingBananas:2
sat_func def sat(bananas: int, bowl="508738582 apples and 346410095 oranges", total=1452490389):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
modified_func def sat(bananas: int, bowl=wrap_str('508738582 apples and 346410095 oranges'), total=wrap_int(1452490389)):
    bowl += wrap_str(' and ') + sym_str(bananas) + wrap_str(' bananas')
    return sym_sum([sym_int(s) for s in bowl.split() if s.isdigit()]) == total
### smt2
(set-logic ALL)

(define-fun str.isdigit ((s String)) Bool
  (forall ((i Int))
    (=> (and (<= 0 i) (< i (str.len s)))
        (let ((c (str.at s i)))
          (str.is_digit c)))))


(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x Int)
(assert (forall ((list_pos_27 Int)) (=> (and (>= list_pos_27 0) (< list_pos_27 (list.length.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_27)) (> (str.len (list.get.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_27)) 0)))))
(assert (forall ((list_pos_27 Int)) (=> (and (>= list_pos_27 0) (< list_pos_27 (list.length.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_27)) (= (+ (python.int (list.get.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_27) 10) 0) 1452490389)))))
(assert (forall ((list_pos_28 Int)) (=> (and (>= list_pos_28 0) (< list_pos_28 (list.length.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (forall ((list_pos_27 Int)) (=> (and (>= list_pos_27 0) (< list_pos_27 (list.length.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (not (str.isdigit (list.get.string (str.split (str.++ "508738582 apples and 346410095 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_28))) false))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle MissingBananas:2
Too many constants for extrapolation

Solving puzzle 165/774: MissingBananas:3
sat_func def sat(bananas: int, bowl="28767 apples and 49488 oranges", total=112303):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
modified_func def sat(bananas: int, bowl=wrap_str('28767 apples and 49488 oranges'), total=wrap_int(112303)):
    bowl += wrap_str(' and ') + sym_str(bananas) + wrap_str(' bananas')
    return sym_sum([sym_int(s) for s in bowl.split() if s.isdigit()]) == total
### smt2
(set-logic ALL)

(define-fun str.isdigit ((s String)) Bool
  (forall ((i Int))
    (=> (and (<= 0 i) (< i (str.len s)))
        (let ((c (str.at s i)))
          (str.is_digit c)))))


(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x Int)
(assert (forall ((list_pos_29 Int)) (=> (and (>= list_pos_29 0) (< list_pos_29 (list.length.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_29)) (> (str.len (list.get.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_29)) 0)))))
(assert (forall ((list_pos_29 Int)) (=> (and (>= list_pos_29 0) (< list_pos_29 (list.length.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_29)) (= (+ (python.int (list.get.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_29) 10) 0) 112303)))))
(assert (forall ((list_pos_30 Int)) (=> (and (>= list_pos_30 0) (< list_pos_30 (list.length.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (forall ((list_pos_29 Int)) (=> (and (>= list_pos_29 0) (< list_pos_29 (list.length.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (not (str.isdigit (list.get.string (str.split (str.++ "28767 apples and 49488 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_30))) false))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle MissingBananas:3
Too many constants for extrapolation

Solving puzzle 166/774: MissingBananas:4
sat_func def sat(bananas: int, bowl="29991 apples and 99737 oranges", total=155600):
    bowl += f" and {bananas} bananas"
    return sum([int(s) for s in bowl.split() if s.isdigit()]) == total
modified_func def sat(bananas: int, bowl=wrap_str('29991 apples and 99737 oranges'), total=wrap_int(155600)):
    bowl += wrap_str(' and ') + sym_str(bananas) + wrap_str(' bananas')
    return sym_sum([sym_int(s) for s in bowl.split() if s.isdigit()]) == total
### smt2
(set-logic ALL)

(define-fun str.isdigit ((s String)) Bool
  (forall ((i Int))
    (=> (and (<= 0 i) (< i (str.len s)))
        (let ((c (str.at s i)))
          (str.is_digit c)))))


(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x Int)
(assert (forall ((list_pos_31 Int)) (=> (and (>= list_pos_31 0) (< list_pos_31 (list.length.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_31)) (> (str.len (list.get.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_31)) 0)))))
(assert (forall ((list_pos_31 Int)) (=> (and (>= list_pos_31 0) (< list_pos_31 (list.length.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (str.isdigit (list.get.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_31)) (= (+ (python.int (list.get.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_31) 10) 0) 155600)))))
(assert (forall ((list_pos_32 Int)) (=> (and (>= list_pos_32 0) (< list_pos_32 (list.length.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (forall ((list_pos_31 Int)) (=> (and (>= list_pos_31 0) (< list_pos_31 (list.length.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ")))) (=> (not (str.isdigit (list.get.string (str.split (str.++ "29991 apples and 99737 oranges" (str.++ (str.++ " and " (str.from_int x)) " bananas")) " ") list_pos_32))) false))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle MissingBananas:4
Too many constants for extrapolation

Solving puzzle 167/774: GreatestHIndex:0
sat_func def sat(h: int, seq=[3, 1, 4, 17, 5, 17, 2, 1, 41, 32, 2, 5, 5, 5, 5]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
modified_func def sat(h: int, seq=wrap_list([wrap_int(3), wrap_int(1), wrap_int(4), wrap_int(17), wrap_int(5), wrap_int(17), wrap_int(2), wrap_int(1), wrap_int(41), wrap_int(32), wrap_int(2), wrap_int(5), wrap_int(5), wrap_int(5), wrap_int(5)])):
    for i in seq:
        _assert(sym_not((i > wrap_int(0)).__and__(i > h).__and__(seq.count(i) >= i)))
    return (h == -wrap_int(1)).__or__((seq.count(h) >= h).__and__(h > wrap_int(0)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (not (and (and true (> 3 x)) false)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 4 x)) false)))
(assert (not (and (and true (> 17 x)) false)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 17 x)) false)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 41 x)) false)))
(assert (not (and (and true (> 32 x)) false)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (or (= x -1) (and (>= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 3 x) 1 0) (ite (= 1 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 17 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 17 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 41 x) 1 0)) (ite (= 32 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 5 x) 1 0)) x) (> x 0))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    5)
)
### output for cvc5
sat
(
(define-fun x () Int 5)
)

Found solution 5
Yes! Solved for puzzle  GreatestHIndex:0

Solving puzzle 168/774: GreatestHIndex:1
sat_func def sat(h: int, seq=[5, 5, 4, 4, 0, 1, 3, 7, 2, 1, 0, 1, 8, 7, 2, 7, 4, 5, 2, 7, 5, 1, 9, 4, 7, 6, 3, 0, 1, 0, 6, 8, 0, 8, 9, 8, 3, 9, 4, 4, 4, 3, 8, 9, 5, 2, 5, 7, 9, 6, 2, 3, 0, 6, 0, 7, 8, 2, 2, 5, 1, 6, 1, 7, 8, 7, 6, 7]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
modified_func def sat(h: int, seq=wrap_list([wrap_int(5), wrap_int(5), wrap_int(4), wrap_int(4), wrap_int(0), wrap_int(1), wrap_int(3), wrap_int(7), wrap_int(2), wrap_int(1), wrap_int(0), wrap_int(1), wrap_int(8), wrap_int(7), wrap_int(2), wrap_int(7), wrap_int(4), wrap_int(5), wrap_int(2), wrap_int(7), wrap_int(5), wrap_int(1), wrap_int(9), wrap_int(4), wrap_int(7), wrap_int(6), wrap_int(3), wrap_int(0), wrap_int(1), wrap_int(0), wrap_int(6), wrap_int(8), wrap_int(0), wrap_int(8), wrap_int(9), wrap_int(8), wrap_int(3), wrap_int(9), wrap_int(4), wrap_int(4), wrap_int(4), wrap_int(3), wrap_int(8), wrap_int(9), wrap_int(5), wrap_int(2), wrap_int(5), wrap_int(7), wrap_int(9), wrap_int(6), wrap_int(2), wrap_int(3), wrap_int(0), wrap_int(6), wrap_int(0), wrap_int(7), wrap_int(8), wrap_int(2), wrap_int(2), wrap_int(5), wrap_int(1), wrap_int(6), wrap_int(1), wrap_int(7), wrap_int(8), wrap_int(7), wrap_int(6), wrap_int(7)])):
    for i in seq:
        _assert(sym_not((i > wrap_int(0)).__and__(i > h).__and__(seq.count(i) >= i)))
    return (h == -wrap_int(1)).__or__((seq.count(h) >= h).__and__(h > wrap_int(0)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (or (= x -1) (and (>= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 5 x) 1 0) (ite (= 5 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 3 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 9 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 3 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 9 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 3 x) 1 0)) (ite (= 9 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 4 ...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    7)
)
### output for cvc5
sat
(
(define-fun x () Int 7)
)

Found solution 7
Yes! Solved for puzzle  GreatestHIndex:1

Solving puzzle 169/774: GreatestHIndex:2
sat_func def sat(h: int, seq=[3, 9, 0, 8, 2, 9, 6, 1, 8, 3, 5, 5, 4, 9, 0, 1, 0, 3, 4, 8, 7, 2, 4, 7, 1, 1, 7, 2, 1, 4, 1, 0]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
modified_func def sat(h: int, seq=wrap_list([wrap_int(3), wrap_int(9), wrap_int(0), wrap_int(8), wrap_int(2), wrap_int(9), wrap_int(6), wrap_int(1), wrap_int(8), wrap_int(3), wrap_int(5), wrap_int(5), wrap_int(4), wrap_int(9), wrap_int(0), wrap_int(1), wrap_int(0), wrap_int(3), wrap_int(4), wrap_int(8), wrap_int(7), wrap_int(2), wrap_int(4), wrap_int(7), wrap_int(1), wrap_int(1), wrap_int(7), wrap_int(2), wrap_int(1), wrap_int(4), wrap_int(1), wrap_int(0)])):
    for i in seq:
        _assert(sym_not((i > wrap_int(0)).__and__(i > h).__and__(seq.count(i) >= i)))
    return (h == -wrap_int(1)).__or__((seq.count(h) >= h).__and__(h > wrap_int(0)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 6 x)) false)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 5 x)) false)))
(assert (not (and (and true (> 5 x)) false)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 8 x)) false)))
(assert (not (and (and true (> 7 x)) false)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 7 x)) false)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 7 x)) false)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (or (= x -1) (and (>= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 3 x) 1 0) (ite (= 9 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 9 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 3 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 9 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 3 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 0 x) 1 0)) x) (> x 0))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    4)
)
### output for cvc5
sat
(
(define-fun x () Int 4)
)

Found solution 4
Yes! Solved for puzzle  GreatestHIndex:2

Solving puzzle 170/774: GreatestHIndex:3
sat_func def sat(h: int, seq=[7, 4, 1, 8, 6, 6, 6, 8, 5, 5, 8, 3, 0, 7, 2, 7, 2, 4, 5, 8, 6, 1, 1, 0, 0, 8, 8, 1, 5, 2, 1, 1, 7, 1, 3, 5, 6, 1, 7, 9, 6, 2, 6, 4, 7, 4, 3, 1, 2, 3, 9, 7, 7, 1, 7, 8, 6, 5, 9, 1, 6, 3, 4, 2, 4, 1, 7, 6, 3, 2, 5, 6, 1, 3, 9, 4, 9, 6, 9, 8, 1, 2, 3, 8]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
modified_func def sat(h: int, seq=wrap_list([wrap_int(7), wrap_int(4), wrap_int(1), wrap_int(8), wrap_int(6), wrap_int(6), wrap_int(6), wrap_int(8), wrap_int(5), wrap_int(5), wrap_int(8), wrap_int(3), wrap_int(0), wrap_int(7), wrap_int(2), wrap_int(7), wrap_int(2), wrap_int(4), wrap_int(5), wrap_int(8), wrap_int(6), wrap_int(1), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(8), wrap_int(8), wrap_int(1), wrap_int(5), wrap_int(2), wrap_int(1), wrap_int(1), wrap_int(7), wrap_int(1), wrap_int(3), wrap_int(5), wrap_int(6), wrap_int(1), wrap_int(7), wrap_int(9), wrap_int(6), wrap_int(2), wrap_int(6), wrap_int(4), wrap_int(7), wrap_int(4), wrap_int(3), wrap_int(1), wrap_int(2), wrap_int(3), wrap_int(9), wrap_int(7), wrap_int(7), wrap_int(1), wrap_int(7), wrap_int(8), wrap_int(6), wrap_int(5), wrap_int(9), wrap_int(1), wrap_int(6), wrap_int(3), wrap_int(4), wrap_int(2), wrap_int(4), wrap_int(1), wrap_int(7), wrap_int(6), wrap_int(3), wrap_int(2), wrap_int(5), wrap_int(6), wrap_int(1), wrap_int(3), wrap_int(9), wrap_int(4), wrap_int(9), wrap_int(6), wrap_int(9), wrap_int(8), wrap_int(1), wrap_int(2), wrap_int(3), wrap_int(8)])):
    for i in seq:
        _assert(sym_not((i > wrap_int(0)).__and__(i > h).__and__(seq.count(i) >= i)))
    return (h == -wrap_int(1)).__or__((seq.count(h) >= h).__and__(h > wrap_int(0)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 8 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 8 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 8 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 8 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and false (> 0 x)) true)))
(assert (not (and (and true (> 8 x)) true)))
(assert (not (and (and true (> 8 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 8 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 7 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 5 x)) true)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 4 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 6 x)) true)))
(assert (not (and (and true (> 9 x)) false)))
(assert (not (and (and true (> 8 x)) true)))
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 3 x)) true)))
(assert (not (and (and true (> 8 x)) true)))
(assert (or (= x -1) (and (>= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 7 x) 1 0) (ite (= 4 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 3 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 4 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 0 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 8 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 2 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 7 x) 1 0)) (ite (= 1 x) 1 0)) (ite (= 3 x) 1 0)) (ite (= 5 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 1 x) 1 0)) ...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8)
)
### output for cvc5
sat
(
(define-fun x () Int 8)
)

Found solution 8
Yes! Solved for puzzle  GreatestHIndex:3

Solving puzzle 171/774: GreatestHIndex:4
sat_func def sat(h: int, seq=[1, 2, 6, 2]):
    for i in seq:
        assert not (i > 0 and i > h and seq.count(i) >= i)
    return h == -1 or seq.count(h) >= h > 0
modified_func def sat(h: int, seq=wrap_list([wrap_int(1), wrap_int(2), wrap_int(6), wrap_int(2)])):
    for i in seq:
        _assert(sym_not((i > wrap_int(0)).__and__(i > h).__and__(seq.count(i) >= i)))
    return (h == -wrap_int(1)).__or__((seq.count(h) >= h).__and__(h > wrap_int(0)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (not (and (and true (> 1 x)) true)))
(assert (not (and (and true (> 2 x)) true)))
(assert (not (and (and true (> 6 x)) false)))
(assert (not (and (and true (> 2 x)) true)))
(assert (or (= x -1) (and (>= (+ (+ (+ (ite (= 1 x) 1 0) (ite (= 2 x) 1 0)) (ite (= 6 x) 1 0)) (ite (= 2 x) 1 0)) x) (> x 0))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2)
)
### output for cvc5
sat
(
(define-fun x () Int 2)
)

Found solution 2
Yes! Solved for puzzle  GreatestHIndex:4

Solving puzzle 172/774: InvestigateCrash:0
sat_func def sat(problem: int, weights=[1, 2, 5, 2, 1, 17], max_weight=100):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
modified_func def sat(problem: int, weights=wrap_list([wrap_int(1), wrap_int(2), wrap_int(5), wrap_int(2), wrap_int(1), wrap_int(17)]), max_weight=wrap_int(100)):
    if problem == -wrap_int(1):
        return sym_sum(weights) > max_weight
    return weights[problem] != weights[-wrap_int(1) - problem]
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) false))
(assert (=> (not (= x -1)) (< x 6)))
(assert (=> (not (= x -1)) (> x -6)))
(assert (=> (not (= x -1)) (< (- -1 x) 6)))
(assert (=> (not (= x -1)) (> (- -1 x) -6)))
(assert (=> (not (= x -1)) (not (= (ite (or (= x 5) (= x -1)) 17 (ite (or (= x 4) (= x -2)) 1 (ite (or (= x 3) (= x -3)) 2 (ite (or (= x 2) (= x -4)) 5 (ite (or (= x 1) (= x -5)) 2 1))))) (ite (or (= (- -1 x) 5) (= (- -1 x) -1)) 17 (ite (or (= (- -1 x) 4) (= (- -1 x) -2)) 1 (ite (or (= (- -1 x) 3) (= (- -1 x) -3)) 2 (ite (or (= (- -1 x) 2) (= (- -1 x) -4)) 5 (ite (or (= (- -1 x) 1) (= (- -1 x) -5)) 2 1)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 4))
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution -4
Yes! Solved for puzzle  InvestigateCrash:0

Solving puzzle 173/774: InvestigateCrash:1
sat_func def sat(problem: int, weights=[17, 97, 77, 13, 13, 77, 13, 17], max_weight=314):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
modified_func def sat(problem: int, weights=wrap_list([wrap_int(17), wrap_int(97), wrap_int(77), wrap_int(13), wrap_int(13), wrap_int(77), wrap_int(13), wrap_int(17)]), max_weight=wrap_int(314)):
    if problem == -wrap_int(1):
        return sym_sum(weights) > max_weight
    return weights[problem] != weights[-wrap_int(1) - problem]
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) true))
(assert (=> (not (= x -1)) (< x 8)))
(assert (=> (not (= x -1)) (> x -8)))
(assert (=> (not (= x -1)) (< (- -1 x) 8)))
(assert (=> (not (= x -1)) (> (- -1 x) -8)))
(assert (=> (not (= x -1)) (not (= (ite (or (= x 7) (= x -1)) 17 (ite (or (= x 6) (= x -2)) 13 (ite (or (= x 5) (= x -3)) 77 (ite (or (= x 4) (= x -4)) 13 (ite (or (= x 3) (= x -5)) 13 (ite (or (= x 2) (= x -6)) 77 (ite (or (= x 1) (= x -7)) 97 17))))))) (ite (or (= (- -1 x) 7) (= (- -1 x) -1)) 17 (ite (or (= (- -1 x) 6) (= (- -1 x) -2)) 13 (ite (or (= (- -1 x) 5) (= (- -1 x) -3)) 77 (ite (or (= (- -1 x) 4) (= (- -1 x) -4)) 13 (ite (or (= (- -1 x) 3) (= (- -1 x) -5)) 13 (ite (or (= (- -1 x) 2) (= (- -1 x) -6)) 77 (ite (or (= (- -1 x) 1) (= (- -1 x) -7)) 97 17)))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1)
)
### output for cvc5
sat
(
(define-fun x () Int (- 2))
)

Found solution 1
Yes! Solved for puzzle  InvestigateCrash:1

Solving puzzle 174/774: InvestigateCrash:2
sat_func def sat(problem: int, weights=[51, 23, 10, 4, 7, 56, 12, 4, 10, 23, 51], max_weight=276):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
modified_func def sat(problem: int, weights=wrap_list([wrap_int(51), wrap_int(23), wrap_int(10), wrap_int(4), wrap_int(7), wrap_int(56), wrap_int(12), wrap_int(4), wrap_int(10), wrap_int(23), wrap_int(51)]), max_weight=wrap_int(276)):
    if problem == -wrap_int(1):
        return sym_sum(weights) > max_weight
    return weights[problem] != weights[-wrap_int(1) - problem]
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) false))
(assert (=> (not (= x -1)) (< x 11)))
(assert (=> (not (= x -1)) (> x -11)))
(assert (=> (not (= x -1)) (< (- -1 x) 11)))
(assert (=> (not (= x -1)) (> (- -1 x) -11)))
(assert (=> (not (= x -1)) (not (= (ite (or (= x 10) (= x -1)) 51 (ite (or (= x 9) (= x -2)) 23 (ite (or (= x 8) (= x -3)) 10 (ite (or (= x 7) (= x -4)) 4 (ite (or (= x 6) (= x -5)) 12 (ite (or (= x 5) (= x -6)) 56 (ite (or (= x 4) (= x -7)) 7 (ite (or (= x 3) (= x -8)) 4 (ite (or (= x 2) (= x -9)) 10 (ite (or (= x 1) (= x -10)) 23 51)))))))))) (ite (or (= (- -1 x) 10) (= (- -1 x) -1)) 51 (ite (or (= (- -1 x) 9) (= (- -1 x) -2)) 23 (ite (or (= (- -1 x) 8) (= (- -1 x) -3)) 10 (ite (or (= (- -1 x) 7) (= (- -1 x) -4)) 4 (ite (or (= (- -1 x) 6) (= (- -1 x) -5)) 12 (ite (or (= (- -1 x) 5) (= (- -1 x) -6)) 56 (ite (or (= (- -1 x) 4) (= (- -1 x) -7)) 7 (ite (or (= (- -1 x) 3) (= (- -1 x) -8)) 4 (ite (or (= (- -1 x) 2) (= (- -1 x) -9)) 10 (ite (or (= (- -1 x) 1) (= (- -1 x) -10)) 23 51))))))))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 5))
)
### output for cvc5
sat
(
(define-fun x () Int (- 5))
)

Found solution -5
Yes! Solved for puzzle  InvestigateCrash:2

Solving puzzle 175/774: InvestigateCrash:3
sat_func def sat(problem: int, weights=[22, 81, 93, 22], max_weight=222):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
modified_func def sat(problem: int, weights=wrap_list([wrap_int(22), wrap_int(81), wrap_int(93), wrap_int(22)]), max_weight=wrap_int(222)):
    if problem == -wrap_int(1):
        return sym_sum(weights) > max_weight
    return weights[problem] != weights[-wrap_int(1) - problem]
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) false))
(assert (=> (not (= x -1)) (< x 4)))
(assert (=> (not (= x -1)) (> x -4)))
(assert (=> (not (= x -1)) (< (- -1 x) 4)))
(assert (=> (not (= x -1)) (> (- -1 x) -4)))
(assert (=> (not (= x -1)) (not (= (ite (or (= x 3) (= x -1)) 22 (ite (or (= x 2) (= x -2)) 93 (ite (or (= x 1) (= x -3)) 81 22))) (ite (or (= (- -1 x) 3) (= (- -1 x) -1)) 22 (ite (or (= (- -1 x) 2) (= (- -1 x) -2)) 93 (ite (or (= (- -1 x) 1) (= (- -1 x) -3)) 81 22)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2)
)
### output for cvc5
sat
(
(define-fun x () Int (- 2))
)

Found solution 2
Yes! Solved for puzzle  InvestigateCrash:3

Solving puzzle 176/774: InvestigateCrash:4
sat_func def sat(problem: int, weights=[43, 37, 79, 37, 20], max_weight=222):
    if problem == -1:
        return sum(weights) > max_weight
    return weights[problem] != weights[- 1 - problem]
modified_func def sat(problem: int, weights=wrap_list([wrap_int(43), wrap_int(37), wrap_int(79), wrap_int(37), wrap_int(20)]), max_weight=wrap_int(222)):
    if problem == -wrap_int(1):
        return sym_sum(weights) > max_weight
    return weights[problem] != weights[-wrap_int(1) - problem]
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) false))
(assert (=> (not (= x -1)) (< x 5)))
(assert (=> (not (= x -1)) (> x -5)))
(assert (=> (not (= x -1)) (< (- -1 x) 5)))
(assert (=> (not (= x -1)) (> (- -1 x) -5)))
(assert (=> (not (= x -1)) (not (= (ite (or (= x 4) (= x -1)) 20 (ite (or (= x 3) (= x -2)) 37 (ite (or (= x 2) (= x -3)) 79 (ite (or (= x 1) (= x -4)) 37 43)))) (ite (or (= (- -1 x) 4) (= (- -1 x) -1)) 20 (ite (or (= (- -1 x) 3) (= (- -1 x) -2)) 37 (ite (or (= (- -1 x) 2) (= (- -1 x) -3)) 79 (ite (or (= (- -1 x) 1) (= (- -1 x) -4)) 37 43))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  InvestigateCrash:4

Solving puzzle 177/774: ClosestPalindrome:0
sat_func def sat(pal: str, s="palindromordinals"):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
modified_func def sat(pal: str, s=wrap_str('palindromordinals')):
    _assert((pal == pal[::-1]).__and__(sym_len(pal) == sym_len(s)))
    return sym_sum(sym_generator((a != b for a, b in sym_zip(pal, s)))) == sym_sum(sym_generator((a != b for a, b in sym_zip(s, s[::-1])))) // wrap_int(2)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(declare-const sum_1 Int)
(assert (and (= x (str.reverse x)) (= (str.len x) 17)))
(assert (= sum_1 (+ (ite (not (= (python.str.at x 0) (python.str.at "palindromordinals" 0))) 1 0) (ite (not (= (python.str.at x 1) (python.str.at "palindromordinals" 1))) 1 0) (ite (not (= (python.str.at x 2) (python.str.at "palindromordinals" 2))) 1 0) (ite (not (= (python.str.at x 3) (python.str.at "palindromordinals" 3))) 1 0) (ite (not (= (python.str.at x 4) (python.str.at "palindromordinals" 4))) 1 0) (ite (not (= (python.str.at x 5) (python.str.at "palindromordinals" 5))) 1 0) (ite (not (= (python.str.at x 6) (python.str.at "palindromordinals" 6))) 1 0) (ite (not (= (python.str.at x 7) (python.str.at "palindromordinals" 7))) 1 0) (ite (not (= (python.str.at x 8) (python.str.at "palindromordinals" 8))) 1 0) (ite (not (= (python.str.at x 9) (python.str.at "palindromordinals" 9))) 1 0) (ite (not (= (python.str.at x 10) (python.str.at "palindromordinals" 10))) 1 0) (ite (not (= (python.str.at x 11) (python.str.at "palindromordinals" 11))) 1 0) (ite (not (= (python.str.at x 12) (pytho...
(assert (= sum_1 (div 10 2)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun sum_1 () Int
    5)
  (define-fun x () String
    "planndromordnnalp")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution planndromordnnalp
Yes! Solved for puzzle  ClosestPalindrome:0

Solving puzzle 178/774: ClosestPalindrome:1
sat_func def sat(pal: str, s="ti="):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
modified_func def sat(pal: str, s=wrap_str('ti=')):
    _assert((pal == pal[::-1]).__and__(sym_len(pal) == sym_len(s)))
    return sym_sum(sym_generator((a != b for a, b in sym_zip(pal, s)))) == sym_sum(sym_generator((a != b for a, b in sym_zip(s, s[::-1])))) // wrap_int(2)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(declare-const sum_1 Int)
(assert (and (= x (str.reverse x)) (= (str.len x) 3)))
(assert (= sum_1 (+ (ite (not (= (python.str.at x 0) (python.str.at "ti=" 0))) 1 0) (ite (not (= (python.str.at x 1) (python.str.at "ti=" 1))) 1 0) (ite (not (= (python.str.at x 2) (python.str.at "ti=" 2))) 1 0))))
(assert (= sum_1 (div 2 2)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "tit")
  (define-fun sum_1 () Int
    1)
)
### output for cvc5
sat
(
(define-fun x () String "=i=")
(define-fun sum_1 () Int 1)
)

Found solution tit
Yes! Solved for puzzle  ClosestPalindrome:1

Solving puzzle 179/774: ClosestPalindrome:2
sat_func def sat(pal: str, s="bC"):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
modified_func def sat(pal: str, s=wrap_str('bC')):
    _assert((pal == pal[::-1]).__and__(sym_len(pal) == sym_len(s)))
    return sym_sum(sym_generator((a != b for a, b in sym_zip(pal, s)))) == sym_sum(sym_generator((a != b for a, b in sym_zip(s, s[::-1])))) // wrap_int(2)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(declare-const sum_1 Int)
(assert (and (= x (str.reverse x)) (= (str.len x) 2)))
(assert (= sum_1 (+ (ite (not (= (python.str.at x 0) (python.str.at "bC" 0))) 1 0) (ite (not (= (python.str.at x 1) (python.str.at "bC" 1))) 1 0))))
(assert (= sum_1 (div 2 2)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bb")
  (define-fun sum_1 () Int
    1)
)
### output for cvc5
sat
(
(define-fun x () String "CC")
(define-fun sum_1 () Int 1)
)

Found solution bb
Yes! Solved for puzzle  ClosestPalindrome:2

Solving puzzle 180/774: ClosestPalindrome:3
sat_func def sat(pal: str, s="chachatexc0vchX)e1"):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
modified_func def sat(pal: str, s=wrap_str('chachatexc0vchX)e1')):
    _assert((pal == pal[::-1]).__and__(sym_len(pal) == sym_len(s)))
    return sym_sum(sym_generator((a != b for a, b in sym_zip(pal, s)))) == sym_sum(sym_generator((a != b for a, b in sym_zip(s, s[::-1])))) // wrap_int(2)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(declare-const sum_1 Int)
(assert (and (= x (str.reverse x)) (= (str.len x) 18)))
(assert (= sum_1 (+ (ite (not (= (python.str.at x 0) (python.str.at "chachatexc0vchX)e1" 0))) 1 0) (ite (not (= (python.str.at x 1) (python.str.at "chachatexc0vchX)e1" 1))) 1 0) (ite (not (= (python.str.at x 2) (python.str.at "chachatexc0vchX)e1" 2))) 1 0) (ite (not (= (python.str.at x 3) (python.str.at "chachatexc0vchX)e1" 3))) 1 0) (ite (not (= (python.str.at x 4) (python.str.at "chachatexc0vchX)e1" 4))) 1 0) (ite (not (= (python.str.at x 5) (python.str.at "chachatexc0vchX)e1" 5))) 1 0) (ite (not (= (python.str.at x 6) (python.str.at "chachatexc0vchX)e1" 6))) 1 0) (ite (not (= (python.str.at x 7) (python.str.at "chachatexc0vchX)e1" 7))) 1 0) (ite (not (= (python.str.at x 8) (python.str.at "chachatexc0vchX)e1" 8))) 1 0) (ite (not (= (python.str.at x 9) (python.str.at "chachatexc0vchX)e1" 9))) 1 0) (ite (not (= (python.str.at x 10) (python.str.at "chachatexc0vchX)e1" 10))) 1 0) (ite (not (= (python.str.at x 11) (python.str.at "chachatexc0vchX)e1" 11))) 1 0) (ite (not (= (python.str.at ...
(assert (= sum_1 (div 16 2)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "1haXhatexxetahXah1")
  (define-fun sum_1 () Int
    8)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 1haXhatexxetahXah1
Yes! Solved for puzzle  ClosestPalindrome:3

Solving puzzle 181/774: ClosestPalindrome:4
sat_func def sat(pal: str, s="w"):
    assert pal == pal[::-1] and len(pal) == len(s)
    return sum(a != b for a, b in zip(pal, s)) == sum(a != b for a, b in zip(s, s[::-1])) // 2
modified_func def sat(pal: str, s=wrap_str('w')):
    _assert((pal == pal[::-1]).__and__(sym_len(pal) == sym_len(s)))
    return sym_sum(sym_generator((a != b for a, b in sym_zip(pal, s)))) == sym_sum(sym_generator((a != b for a, b in sym_zip(s, s[::-1])))) // wrap_int(2)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(declare-const sum_1 Int)
(assert (and (= x (str.reverse x)) (= (str.len x) 1)))
(assert (= sum_1 (+ (ite (not (= (python.str.at x 0) (python.str.at "w" 0))) 1 0))))
(assert (= sum_1 (div 0 2)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "w")
  (define-fun sum_1 () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:17.82: invalid kind 'ADD', expected Terms with kind ADD must have at least 2 children and at most 67108863 children (the one under construction has 1)")

Found solution w
Yes! Solved for puzzle  ClosestPalindrome:4

Solving puzzle 182/774: IntegerLog:0
sat_func def sat(x: int, a=3, n=1290070078170102666248196035845070394933441741644993085810116441344597492642263849):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(3), n=wrap_int(1290070078170102666248196035845070394933441741644993085810116441344597492642263849)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 3 x) 1290070078170102666248196035845070394933441741644993085810116441344597492642263849))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 3 x)")

Could not find any solution for puzzle IntegerLog:0
One large constant for extrapolation
Solving simpler variation replaced 1290070078170102666248196035845070394933441741644993085810116441344597492642263849 with 3
sat_func def sat(x: int, a=3, n=3):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(3), n=wrap_int(3)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 3 x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 3 x)")

Could not find any solution for puzzle IntegerLog:0

Solving puzzle 183/774: IntegerLog:1
sat_func def sat(x: int, a=4, n=49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(4), n=wrap_int(49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 4 x) 49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 4 x)")

Could not find any solution for puzzle IntegerLog:1
One large constant for extrapolation
Solving simpler variation replaced 49947976805055875702105555676690660891977570282639538413746511354005947821116249921924897649015871538557230897942505966327167610868612564900642816 with 3
sat_func def sat(x: int, a=4, n=3):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(4), n=wrap_int(3)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 4 x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 4 x)")

Could not find any solution for puzzle IntegerLog:1

Solving puzzle 184/774: IntegerLog:2
sat_func def sat(x: int, a=2, n=4611686018427387904):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(2), n=wrap_int(4611686018427387904)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 2 x) 4611686018427387904))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2 x)")

Could not find any solution for puzzle IntegerLog:2
One large constant for extrapolation
Solving simpler variation replaced 4611686018427387904 with 3
sat_func def sat(x: int, a=2, n=3):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(2), n=wrap_int(3)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 2 x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2 x)")

Could not find any solution for puzzle IntegerLog:2

Solving puzzle 185/774: IntegerLog:3
sat_func def sat(x: int, a=7, n=619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(7), n=wrap_int(619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 7 x) 619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 7 x)")

Could not find any solution for puzzle IntegerLog:3
One large constant for extrapolation
Solving simpler variation replaced 619664992585427611791050679609026893099690427802915014534984716820652776102999166869953170315965558474401 with 3
sat_func def sat(x: int, a=7, n=3):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(7), n=wrap_int(3)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 7 x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 7 x)")

Could not find any solution for puzzle IntegerLog:3

Solving puzzle 186/774: IntegerLog:4
sat_func def sat(x: int, a=3, n=273892744995340833777347939263771534786080723599733441):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(3), n=wrap_int(273892744995340833777347939263771534786080723599733441)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 3 x) 273892744995340833777347939263771534786080723599733441))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 3 x)")

Could not find any solution for puzzle IntegerLog:4
One large constant for extrapolation
Solving simpler variation replaced 273892744995340833777347939263771534786080723599733441 with 3
sat_func def sat(x: int, a=3, n=3):
    return a ** x == n
modified_func def sat(x: int, a=wrap_int(3), n=wrap_int(3)):
    return a ** x == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ 3 x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 5 column 10: model is not available")
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 3 x)")

Could not find any solution for puzzle IntegerLog:4

Solving puzzle 187/774: CubeRoot:0
sat_func def sat(x: int, n=42714774173606970182754018064350848294149432972747296768):
    return x ** 3 == n
modified_func def sat(x: int, n=wrap_int(42714774173606970182754018064350848294149432972747296768)):
    return x ** wrap_int(3) == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 3) 42714774173606970182754018064350848294149432972747296768))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3495634671232462032)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 3495634671232462032
Yes! Solved for puzzle  CubeRoot:0

Solving puzzle 188/774: CubeRoot:1
sat_func def sat(x: int, n=-469541313747981125):
    return x ** 3 == n
modified_func def sat(x: int, n=-wrap_int(469541313747981125)):
    return x ** wrap_int(3) == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 3) -469541313747981125))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 777245))
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution -777245
Yes! Solved for puzzle  CubeRoot:1

Solving puzzle 189/774: CubeRoot:2
sat_func def sat(x: int, n=963966660871383014273727008911874274513660721639801945125024924885086622296):
    return x ** 3 == n
modified_func def sat(x: int, n=wrap_int(963966660871383014273727008911874274513660721639801945125024924885086622296)):
    return x ** wrap_int(3) == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 3) 963966660871383014273727008911874274513660721639801945125024924885086622296))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    9878416608492391523536166)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 9878416608492391523536166
Yes! Solved for puzzle  CubeRoot:2

Solving puzzle 190/774: CubeRoot:3
sat_func def sat(x: int, n=-858580967744947820888627092732831059532555665642825043140896515384975483968):
    return x ** 3 == n
modified_func def sat(x: int, n=-wrap_int(858580967744947820888627092732831059532555665642825043140896515384975483968)):
    return x ** wrap_int(3) == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 3) -858580967744947820888627092732831059532555665642825043140896515384975483968))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 9504452087740620424872132))
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution -9504452087740620424872132
Yes! Solved for puzzle  CubeRoot:3

Solving puzzle 191/774: CubeRoot:4
sat_func def sat(x: int, n=-1649412660748961726580117293638546881248424191676176072):
    return x ** 3 == n
modified_func def sat(x: int, n=-wrap_int(1649412660748961726580117293638546881248424191676176072)):
    return x ** wrap_int(3) == n
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 3) -1649412660748961726580117293638546881248424191676176072))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1181525523993989138))
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution -1181525523993989138
Yes! Solved for puzzle  CubeRoot:4

Solving puzzle 192/774: Binarize:0
sat_func def sat(b: str, n=5324680297138495285):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(5324680297138495285)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_2 Int)) (=> (and (>= str_pos_2 0) (< str_pos_2 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_2)))))
(assert (forall ((str_pos_2 Int)) (=> (and (>= str_pos_2 0) (< str_pos_2 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_2 Int)) (=> (and (>= str_pos_2 0) (< str_pos_2 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_3)) 0))))))
(assert (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_2 Int)) (=> (and (>= str_pos_2 0) (< str_pos_2 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_3) 10)) 5324680297138495285))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:0
One large constant for extrapolation
Solving simpler variation replaced 5324680297138495285 with 3
sat_func def sat(b: str, n=3):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(3)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_4 Int)) (=> (and (>= str_pos_4 0) (< str_pos_4 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_4)))))
(assert (forall ((str_pos_4 Int)) (=> (and (>= str_pos_4 0) (< str_pos_4 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_4 Int)) (=> (and (>= str_pos_4 0) (< str_pos_4 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_5)) 0))))))
(assert (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_4 Int)) (=> (and (>= str_pos_4 0) (< str_pos_4 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_5) 10)) 3))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:0

Solving puzzle 193/774: Binarize:1
sat_func def sat(b: str, n=88465169532890):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(88465169532890)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_6 Int)) (=> (and (>= str_pos_6 0) (< str_pos_6 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_6)))))
(assert (forall ((str_pos_6 Int)) (=> (and (>= str_pos_6 0) (< str_pos_6 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_6 Int)) (=> (and (>= str_pos_6 0) (< str_pos_6 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_7)) 0))))))
(assert (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_6 Int)) (=> (and (>= str_pos_6 0) (< str_pos_6 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_7) 10)) 88465169532890))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:1
One large constant for extrapolation
Solving simpler variation replaced 88465169532890 with 3
sat_func def sat(b: str, n=3):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(3)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_8 Int)) (=> (and (>= str_pos_8 0) (< str_pos_8 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_8)))))
(assert (forall ((str_pos_8 Int)) (=> (and (>= str_pos_8 0) (< str_pos_8 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_8 Int)) (=> (and (>= str_pos_8 0) (< str_pos_8 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_9)) 0))))))
(assert (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_8 Int)) (=> (and (>= str_pos_8 0) (< str_pos_8 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_9) 10)) 3))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:1

Solving puzzle 194/774: Binarize:2
sat_func def sat(b: str, n=0):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(0)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_10 Int)) (=> (and (>= str_pos_10 0) (< str_pos_10 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_10)))))
(assert (forall ((str_pos_10 Int)) (=> (and (>= str_pos_10 0) (< str_pos_10 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_10 Int)) (=> (and (>= str_pos_10 0) (< str_pos_10 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_11)) 0))))))
(assert (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_10 Int)) (=> (and (>= str_pos_10 0) (< str_pos_10 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_11) 10)) 0))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits0bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:2
Too many constants for extrapolation

Solving puzzle 195/774: Binarize:3
sat_func def sat(b: str, n=16655679678386282):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(16655679678386282)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_12 Int)) (=> (and (>= str_pos_12 0) (< str_pos_12 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_12)))))
(assert (forall ((str_pos_12 Int)) (=> (and (>= str_pos_12 0) (< str_pos_12 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_12 Int)) (=> (and (>= str_pos_12 0) (< str_pos_12 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_13)) 0))))))
(assert (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_12 Int)) (=> (and (>= str_pos_12 0) (< str_pos_12 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_13) 10)) 16655679678386282))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:3
One large constant for extrapolation
Solving simpler variation replaced 16655679678386282 with 3
sat_func def sat(b: str, n=3):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(3)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_14 Int)) (=> (and (>= str_pos_14 0) (< str_pos_14 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_14)))))
(assert (forall ((str_pos_14 Int)) (=> (and (>= str_pos_14 0) (< str_pos_14 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_14 Int)) (=> (and (>= str_pos_14 0) (< str_pos_14 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_15)) 0))))))
(assert (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_14 Int)) (=> (and (>= str_pos_14 0) (< str_pos_14 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_15) 10)) 3))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:3

Solving puzzle 196/774: Binarize:4
sat_func def sat(b: str, n=2900):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(2900)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_16 Int)) (=> (and (>= str_pos_16 0) (< str_pos_16 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_16)))))
(assert (forall ((str_pos_16 Int)) (=> (and (>= str_pos_16 0) (< str_pos_16 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_16 Int)) (=> (and (>= str_pos_16 0) (< str_pos_16 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_17)) 0))))))
(assert (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_16 Int)) (=> (and (>= str_pos_16 0) (< str_pos_16 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_17) 10)) 2900))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:4
One large constant for extrapolation
Solving simpler variation replaced 2900 with 3
sat_func def sat(b: str, n=3):
    assert b[:4] == b[-4:] == 'bits'
    inside = b[4:-4]
    assert all(c in "01" for c in inside)
    assert inside[0] == "1" or len(inside) == 1
    m = 0
    for c in inside:
        m = 2 * m + int(c)
    return m == n
modified_func def sat(b: str, n=wrap_int(3)):
    _assert((b[:4] == b[-4:]).__and__(b[-4:] == wrap_str('bits')))
    inside = b[4:-4]
    _assert(all(sym_generator((sym_in(c, wrap_str('01')) for c in inside))))
    _assert((inside[wrap_int(0)] == wrap_str('1')).__or__(sym_len(inside) == wrap_int(1)))
    m = wrap_int(0)
    for c in inside:
        m = wrap_int(2) * m + sym_int(c)
    return m == n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (and (= (python.str.substr x 0 4) (python.str.substr x -4 (str.len x))) (= (python.str.substr x -4 (str.len x)) "bits")))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (python.str.substr x 4 -4)))) (str.contains "01" (python.str.at (python.str.substr x 4 -4) str_pos_18)))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (python.str.substr x 4 -4)))) (or (= (python.str.at (python.str.substr x 4 -4) 0) "1") (= (str.len (python.str.substr x 4 -4)) 1)))))
(assert (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (python.str.substr x 4 -4)))) (> (str.len (python.str.at (python.str.substr x 4 -4) str_pos_19)) 0))))))
(assert (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (python.str.substr x 4 -4)))) (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (python.str.substr x 4 -4)))) (= (+ 0 (python.int (python.str.at (python.str.substr x 4 -4) str_pos_19) 10)) 3))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bits")
)
### output for cvc5
unknown
(
(define-fun x () String "bits")
)

Found solution bits
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle Binarize:4

Solving puzzle 197/774: FactorString:0
sat_func def sat(factor: str, s="catscatcatscatcatscat"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
modified_func def sat(factor: str, s=wrap_str('catscatcatscatcatscat')):
    return (sym_len(factor) < sym_len(s)).__and__(s == factor * (sym_len(s) // sym_len(factor)))
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (and (< (str.len x) 21) (= "catscatcatscatcatscat" (str_multiply x (div 21 (str.len x))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Could not find any solution for puzzle FactorString:0
Too many constants for extrapolation

Solving puzzle 198/774: FactorString:1
sat_func def sat(factor: str, s="pamithelozefefitextpamithelozefefitext"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
modified_func def sat(factor: str, s=wrap_str('pamithelozefefitextpamithelozefefitext')):
    return (sym_len(factor) < sym_len(s)).__and__(s == factor * (sym_len(s) // sym_len(factor)))
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (and (< (str.len x) 38) (= "pamithelozefefitextpamithelozefefitext" (str_multiply x (div 38 (str.len x))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Could not find any solution for puzzle FactorString:1
Too many constants for extrapolation

Solving puzzle 199/774: FactorString:2
sat_func def sat(factor: str, s="mahermahermahermahermahermahermahermaher"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
modified_func def sat(factor: str, s=wrap_str('mahermahermahermahermahermahermahermaher')):
    return (sym_len(factor) < sym_len(s)).__and__(s == factor * (sym_len(s) // sym_len(factor)))
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (and (< (str.len x) 40) (= "mahermahermahermahermahermahermahermaher" (str_multiply x (div 40 (str.len x))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Could not find any solution for puzzle FactorString:2
Too many constants for extrapolation

Solving puzzle 200/774: FactorString:3
sat_func def sat(factor: str, s="mapychysmapychysmapychysmapychysmapychysmapychys"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
modified_func def sat(factor: str, s=wrap_str('mapychysmapychysmapychysmapychysmapychysmapychys')):
    return (sym_len(factor) < sym_len(s)).__and__(s == factor * (sym_len(s) // sym_len(factor)))
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (and (< (str.len x) 48) (= "mapychysmapychysmapychysmapychysmapychysmapychys" (str_multiply x (div 48 (str.len x))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "mapychysmapychysmapychys")
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    2)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    48)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution mapychysmapychysmapychys
Yes! Solved for puzzle  FactorString:3

Solving puzzle 201/774: FactorString:4
sat_func def sat(factor: str, s="thihathihathihathihathihathiha"):
    return len(factor) < len(s) and s == factor * (len(s) // len(factor))
modified_func def sat(factor: str, s=wrap_str('thihathihathihathihathihathiha')):
    return (sym_len(factor) < sym_len(s)).__and__(s == factor * (sym_len(s) // sym_len(factor)))
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (and (< (str.len x) 30) (= "thihathihathihathihathihathiha" (str_multiply x (div 30 (str.len x))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Could not find any solution for puzzle FactorString:4
Too many constants for extrapolation

Solving puzzle 202/774: BitSum:0
sat_func def sat(n: int, b=107, s=25):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(107), s=wrap_int(25)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_20)) 0))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 107) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_20) 10) 0) 25)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle BitSum:0
One large constant for extrapolation
Solving simpler variation replaced 107 with 3
sat_func def sat(n: int, b=3, s=25):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(3), s=wrap_int(25)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_21)) 0))))
(assert (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 3) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_21) 10) 0) 25)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle BitSum:0

Solving puzzle 203/774: BitSum:1
sat_func def sat(n: int, b=59, s=51):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(59), s=wrap_int(51)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_22)) 0))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 59) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_22) 10) 0) 51)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle BitSum:1
Too many constants for extrapolation

Solving puzzle 204/774: BitSum:2
sat_func def sat(n: int, b=825, s=653):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(825), s=wrap_int(653)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_23)) 0))))
(assert (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 825) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_23) 10) 0) 653)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle BitSum:2
Two large constants for extrapolation
Solving simpler variation replaced 653 with 3 and 825 with 5
sat_func def sat(n: int, b=5, s=3):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(5), s=wrap_int(3)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_24)) 0))))
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 5) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_24) 10) 0) 3)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle BitSum:2

Solving puzzle 205/774: BitSum:3
sat_func def sat(n: int, b=354, s=287):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(354), s=wrap_int(287)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_25 Int)) (=> (and (>= str_pos_25 0) (< str_pos_25 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_25)) 0))))
(assert (forall ((str_pos_25 Int)) (=> (and (>= str_pos_25 0) (< str_pos_25 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 354) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_25) 10) 0) 287)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle BitSum:3
Two large constants for extrapolation
Solving simpler variation replaced 287 with 3 and 354 with 5
sat_func def sat(n: int, b=5, s=3):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(5), s=wrap_int(3)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_26)) 0))))
(assert (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 5) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_26) 10) 0) 3)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle BitSum:3

Solving puzzle 206/774: BitSum:4
sat_func def sat(n: int, b=256, s=1):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(256), s=wrap_int(1)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_27 Int)) (=> (and (>= str_pos_27 0) (< str_pos_27 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_27)) 0))))
(assert (forall ((str_pos_27 Int)) (=> (and (>= str_pos_27 0) (< str_pos_27 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 256) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_27) 10) 0) 1)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle BitSum:4
One large constant for extrapolation
Solving simpler variation replaced 256 with 3
sat_func def sat(n: int, b=3, s=1):
    n_str = bin(n)[2:]  # n in binary
    return len(n_str) == b and sum(int(i) for i in n_str) == s
modified_func def sat(n: int, b=wrap_int(3), s=wrap_int(1)):
    n_str = sym_bin(n)[2:]
    return (sym_len(n_str) == b).__and__(sym_sum(sym_generator((sym_int(i) for i in n_str))) == s)
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x Int)
(assert (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (> (str.len (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_28)) 0))))
(assert (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (bin x) 2 (str.len (bin x)))))) (and (= (str.len (python.str.substr (bin x) 2 (str.len (bin x)))) 3) (= (+ (python.int (python.str.at (python.str.substr (bin x) 2 (str.len (bin x))) str_pos_28) 10) 0) 1)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 50 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle BitSum:4

Solving puzzle 207/774: EvenOddSum:0
sat_func def sat(even_odd_sum: int, nums=[2341, 125146894, 12521, -12451293476325, 535284623934, 132974693614350]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
modified_func def sat(even_odd_sum: int, nums=wrap_list([wrap_int(2341), wrap_int(125146894), wrap_int(12521), -wrap_int(12451293476325), wrap_int(535284623934), wrap_int(132974693614350)])):
    for i in nums[1::2]:
        if i % wrap_int(2) == wrap_int(0):
            even_odd_sum -= i
    return even_odd_sum == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- x 125146894) 132974693614350) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    132974818761244)
)
### output for cvc5
sat
(
(define-fun x () Int 132974818761244)
)

Found solution 132974818761244
Yes! Solved for puzzle  EvenOddSum:0

Solving puzzle 208/774: EvenOddSum:1
sat_func def sat(even_odd_sum: int, nums=[63, 11, -95, 69, 73, -43, 69, -26, -49, 36, 83, 21, -26, 11]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
modified_func def sat(even_odd_sum: int, nums=wrap_list([wrap_int(63), wrap_int(11), -wrap_int(95), wrap_int(69), wrap_int(73), -wrap_int(43), wrap_int(69), -wrap_int(26), -wrap_int(49), wrap_int(36), wrap_int(83), wrap_int(21), -wrap_int(26), wrap_int(11)])):
    for i in nums[1::2]:
        if i % wrap_int(2) == wrap_int(0):
            even_odd_sum -= i
    return even_odd_sum == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- x -26) 36) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    10)
)
### output for cvc5
sat
(
(define-fun x () Int 10)
)

Found solution 10
Yes! Solved for puzzle  EvenOddSum:1

Solving puzzle 209/774: EvenOddSum:2
sat_func def sat(even_odd_sum: int, nums=[29, -100, 94, -10, -97, -70, 86, 69, -61, 44, 48, -12, 92]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
modified_func def sat(even_odd_sum: int, nums=wrap_list([wrap_int(29), -wrap_int(100), wrap_int(94), -wrap_int(10), -wrap_int(97), -wrap_int(70), wrap_int(86), wrap_int(69), -wrap_int(61), wrap_int(44), wrap_int(48), -wrap_int(12), wrap_int(92)])):
    for i in nums[1::2]:
        if i % wrap_int(2) == wrap_int(0):
            even_odd_sum -= i
    return even_odd_sum == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- (- x -100) -10) -70) 44) -12) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 148))
)
### output for cvc5
sat
(
(define-fun x () Int (- 148))
)

Found solution -148
Yes! Solved for puzzle  EvenOddSum:2

Solving puzzle 210/774: EvenOddSum:3
sat_func def sat(even_odd_sum: int, nums=[-75, -2, 68, 36, -4, 58, -42, -92, 28, 59, -66, 52]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
modified_func def sat(even_odd_sum: int, nums=wrap_list([-wrap_int(75), -wrap_int(2), wrap_int(68), wrap_int(36), -wrap_int(4), wrap_int(58), -wrap_int(42), -wrap_int(92), wrap_int(28), wrap_int(59), -wrap_int(66), wrap_int(52)])):
    for i in nums[1::2]:
        if i % wrap_int(2) == wrap_int(0):
            even_odd_sum -= i
    return even_odd_sum == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- (- x -2) 36) 58) -92) 52) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    52)
)
### output for cvc5
sat
(
(define-fun x () Int 52)
)

Found solution 52
Yes! Solved for puzzle  EvenOddSum:3

Solving puzzle 211/774: EvenOddSum:4
sat_func def sat(even_odd_sum: int, nums=[48, -42, -19, -82, -71, -57, -85, 61, 61, -86]):
    for i in nums[1::2]:
        if i % 2 == 0:
            even_odd_sum -= i
    return even_odd_sum == 0
modified_func def sat(even_odd_sum: int, nums=wrap_list([wrap_int(48), -wrap_int(42), -wrap_int(19), -wrap_int(82), -wrap_int(71), -wrap_int(57), -wrap_int(85), wrap_int(61), wrap_int(61), -wrap_int(86)])):
    for i in nums[1::2]:
        if i % wrap_int(2) == wrap_int(0):
            even_odd_sum -= i
    return even_odd_sum == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- x -42) -82) -86) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 210))
)
### output for cvc5
sat
(
(define-fun x () Int (- 210))
)

Found solution -210
Yes! Solved for puzzle  EvenOddSum:4

Solving puzzle 212/774: AntiShuffle:0
sat_func def sat(s: str, orig="Hello world!!!"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
modified_func def sat(s: str, orig=wrap_str('Hello world!!!')):
    for a, b in sym_zip(s.split(wrap_str(' ')), orig.split(wrap_str(' '))):
        for i in sym_range(sym_len(a) - 1):
            _assert(a[i] <= a[i + wrap_int(1)], wrap_str('characters must s-words be in increasing order'))
        _assert((sym_len(a) == sym_len(b)).__and__(all(sym_generator((a.count(c) == b.count(c) for c in b)))), wrap_str('must have same chars'))
    return sym_len(s) == sym_len(orig)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (< zip_pos_0 2))
(assert (> zip_pos_0 -2))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (or (str.< (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1))) (= (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1)))))))
(assert (forall ((str_pos_29 Int)) (=> (and (>= str_pos_29 0) (< str_pos_29 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello")))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (list.get.string (str.split x " ") zip_pos_0) (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello") str_pos_29)) 0))))))
(assert (forall ((str_pos_29 Int)) (=> (and (>= str_pos_29 0) (< str_pos_29 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello")))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello") (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello") str_pos_29)) 0))))))
(assert (forall ((str_pos_29 Int)) (=> (and (>= str_pos_29 0) (< str_pos_29 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello")))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (and (= (str.len (list.get.string (str.split x " ") zip_pos_0)) (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello"))) (= (str.count (list.get.string (str.split x " ") zip_pos_0) (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello") str_pos_29)) (str.count (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello") (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello") str_pos_29)))))))))
(assert (forall ((str_pos_29 Int)) (=> (and (>= str_pos_29 0) (< str_pos_29 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "world!!!" "Hello")))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (= (str.len x) 14))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 153 column 11: unknown constant zip_pos_0")
(error "line 154 column 11: unknown constant zip_pos_0")
(error "line 155 column 102: unknown constant zip_pos_0")
(error "line 156 column 97: unknown constant zip_pos_0")
(error "line 157 column 97: unknown constant zip_pos_0")
(error "line 158 column 97: unknown constant zip_pos_0")
(error "line 159 column 97: unknown constant zip_pos_0")
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
(error "Parse Error: tmp.smt2:153.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle AntiShuffle:0
Too many constants for extrapolation

Solving puzzle 213/774: AntiShuffle:1
sat_func def sat(s: str, orig="YOU CAN rearrange my letters, yes you can!"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
modified_func def sat(s: str, orig=wrap_str('YOU CAN rearrange my letters, yes you can!')):
    for a, b in sym_zip(s.split(wrap_str(' ')), orig.split(wrap_str(' '))):
        for i in sym_range(sym_len(a) - 1):
            _assert(a[i] <= a[i + wrap_int(1)], wrap_str('characters must s-words be in increasing order'))
        _assert((sym_len(a) == sym_len(b)).__and__(all(sym_generator((a.count(c) == b.count(c) for c in b)))), wrap_str('must have same chars'))
    return sym_len(s) == sym_len(orig)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (< zip_pos_0 8))
(assert (> zip_pos_0 -8))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (or (str.< (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1))) (= (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1)))))))
(assert (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "can!" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "you" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "yes" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "letters," (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "my" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "rearrange" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "CAN" "YOU")))))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (list.get.string (str.split x " ") zip_pos_0) (python.str.at (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "can!" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "you" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "yes" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "letters," (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "my" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "rearrange" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "CAN" "YOU...
(assert (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "can!" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "you" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "yes" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "letters," (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "my" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "rearrange" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "CAN" "YOU")))))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "can!" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "you" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "yes" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "letters," (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "my" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "rearrange" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "CAN" "YOU"))))))) (python.str.at (ite (or (= zip_pos_0 7) (= zip_pos_0...
(assert (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "can!" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "you" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "yes" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "letters," (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "my" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "rearrange" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "CAN" "YOU")))))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (and (= (str.len (list.get.string (str.split x " ") zip_pos_0)) (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "can!" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "you" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "yes" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "letters," (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "my" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "rearrange" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "CAN" "YOU"))...
(assert (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "can!" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "you" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "yes" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "letters," (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "my" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "rearrange" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "CAN" "YOU")))))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (= (str.len x) 42))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 153 column 11: unknown constant zip_pos_0")
(error "line 154 column 11: unknown constant zip_pos_0")
(error "line 155 column 102: unknown constant zip_pos_0")
(error "line 156 column 97: unknown constant zip_pos_0")
(error "line 157 column 97: unknown constant zip_pos_0")
(error "line 158 column 97: unknown constant zip_pos_0")
(error "line 159 column 97: unknown constant zip_pos_0")
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
(error "Parse Error: tmp.smt2:153.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle AntiShuffle:1
Too many constants for extrapolation

Solving puzzle 214/774: AntiShuffle:2
sat_func def sat(s: str, orig="caN you handlE LONGGGGGGGGGGGG strings?"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
modified_func def sat(s: str, orig=wrap_str('caN you handlE LONGGGGGGGGGGGG strings?')):
    for a, b in sym_zip(s.split(wrap_str(' ')), orig.split(wrap_str(' '))):
        for i in sym_range(sym_len(a) - 1):
            _assert(a[i] <= a[i + wrap_int(1)], wrap_str('characters must s-words be in increasing order'))
        _assert((sym_len(a) == sym_len(b)).__and__(all(sym_generator((a.count(c) == b.count(c) for c in b)))), wrap_str('must have same chars'))
    return sym_len(s) == sym_len(orig)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (< zip_pos_0 5))
(assert (> zip_pos_0 -5))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (or (str.< (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1))) (= (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1)))))))
(assert (forall ((str_pos_31 Int)) (=> (and (>= str_pos_31 0) (< str_pos_31 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "you" "caN"))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (list.get.string (str.split x " ") zip_pos_0) (python.str.at (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "you" "caN")))) str_pos_31)) 0))))))
(assert (forall ((str_pos_31 Int)) (=> (and (>= str_pos_31 0) (< str_pos_31 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "you" "caN"))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "you" "caN")))) (python.str.at (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "you" "caN")))) str_pos_31)) 0))))))
(assert (forall ((str_pos_31 Int)) (=> (and (>= str_pos_31 0) (< str_pos_31 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "you" "caN"))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (and (= (str.len (list.get.string (str.split x " ") zip_pos_0)) (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "you" "caN")))))) (= (str.count (list.get.string (str.split x " ") zip_pos_0) (python.str.at (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_...
(assert (forall ((str_pos_31 Int)) (=> (and (>= str_pos_31 0) (< str_pos_31 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "strings?" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "LONGGGGGGGGGGGG" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "handlE" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "you" "caN"))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (= (str.len x) 39))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 153 column 11: unknown constant zip_pos_0")
(error "line 154 column 11: unknown constant zip_pos_0")
(error "line 155 column 102: unknown constant zip_pos_0")
(error "line 156 column 97: unknown constant zip_pos_0")
(error "line 157 column 97: unknown constant zip_pos_0")
(error "line 158 column 97: unknown constant zip_pos_0")
(error "line 159 column 97: unknown constant zip_pos_0")
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
(error "Parse Error: tmp.smt2:153.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle AntiShuffle:2
Too many constants for extrapolation

Solving puzzle 215/774: AntiShuffle:3
sat_func def sat(s: str, orig="how bout    spaces and weird punctuation!?$%@#%"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
modified_func def sat(s: str, orig=wrap_str('how bout    spaces and weird punctuation!?$%@#%')):
    for a, b in sym_zip(s.split(wrap_str(' ')), orig.split(wrap_str(' '))):
        for i in sym_range(sym_len(a) - 1):
            _assert(a[i] <= a[i + wrap_int(1)], wrap_str('characters must s-words be in increasing order'))
        _assert((sym_len(a) == sym_len(b)).__and__(all(sym_generator((a.count(c) == b.count(c) for c in b)))), wrap_str('must have same chars'))
    return sym_len(s) == sym_len(orig)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (< zip_pos_0 9))
(assert (> zip_pos_0 -9))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (or (str.< (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1))) (= (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1)))))))
(assert (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (ite (or (= zip_pos_0 8) (= zip_pos_0 -1)) "punctuation!?$%@#%" (ite (or (= zip_pos_0 7) (= zip_pos_0 -2)) "weird" (ite (or (= zip_pos_0 6) (= zip_pos_0 -3)) "and" (ite (or (= zip_pos_0 5) (= zip_pos_0 -4)) "spaces" (ite (or (= zip_pos_0 4) (= zip_pos_0 -5)) "" (ite (or (= zip_pos_0 3) (= zip_pos_0 -6)) "" (ite (or (= zip_pos_0 2) (= zip_pos_0 -7)) "" (ite (or (= zip_pos_0 1) (= zip_pos_0 -8)) "bout" "how"))))))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (list.get.string (str.split x " ") zip_pos_0) (python.str.at (ite (or (= zip_pos_0 8) (= zip_pos_0 -1)) "punctuation!?$%@#%" (ite (or (= zip_pos_0 7) (= zip_pos_0 -2)) "weird" (ite (or (= zip_pos_0 6) (= zip_pos_0 -3)) "and" (ite (or (= zip_pos_0 5) (= zip_pos_0 -4)) "spaces" (ite (or (= zip_pos_0 4) (= zip_pos_0 -5)) "" (ite (or (= zip_pos_0 3) (= zip_pos_0 -6)) ""...
(assert (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (ite (or (= zip_pos_0 8) (= zip_pos_0 -1)) "punctuation!?$%@#%" (ite (or (= zip_pos_0 7) (= zip_pos_0 -2)) "weird" (ite (or (= zip_pos_0 6) (= zip_pos_0 -3)) "and" (ite (or (= zip_pos_0 5) (= zip_pos_0 -4)) "spaces" (ite (or (= zip_pos_0 4) (= zip_pos_0 -5)) "" (ite (or (= zip_pos_0 3) (= zip_pos_0 -6)) "" (ite (or (= zip_pos_0 2) (= zip_pos_0 -7)) "" (ite (or (= zip_pos_0 1) (= zip_pos_0 -8)) "bout" "how"))))))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (ite (or (= zip_pos_0 8) (= zip_pos_0 -1)) "punctuation!?$%@#%" (ite (or (= zip_pos_0 7) (= zip_pos_0 -2)) "weird" (ite (or (= zip_pos_0 6) (= zip_pos_0 -3)) "and" (ite (or (= zip_pos_0 5) (= zip_pos_0 -4)) "spaces" (ite (or (= zip_pos_0 4) (= zip_pos_0 -5)) "" (ite (or (= zip_pos_0 3) (= zip_pos_0 -6)) "" (ite (or (= zip_pos_0 2) (= zip_pos_0 -7)) "" (ite (or (= zi...
(assert (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (ite (or (= zip_pos_0 8) (= zip_pos_0 -1)) "punctuation!?$%@#%" (ite (or (= zip_pos_0 7) (= zip_pos_0 -2)) "weird" (ite (or (= zip_pos_0 6) (= zip_pos_0 -3)) "and" (ite (or (= zip_pos_0 5) (= zip_pos_0 -4)) "spaces" (ite (or (= zip_pos_0 4) (= zip_pos_0 -5)) "" (ite (or (= zip_pos_0 3) (= zip_pos_0 -6)) "" (ite (or (= zip_pos_0 2) (= zip_pos_0 -7)) "" (ite (or (= zip_pos_0 1) (= zip_pos_0 -8)) "bout" "how"))))))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (and (= (str.len (list.get.string (str.split x " ") zip_pos_0)) (str.len (ite (or (= zip_pos_0 8) (= zip_pos_0 -1)) "punctuation!?$%@#%" (ite (or (= zip_pos_0 7) (= zip_pos_0 -2)) "weird" (ite (or (= zip_pos_0 6) (= zip_pos_0 -3)) "and" (ite (or (= zip_pos_0 5) (= zip_pos_0 -4)) "spaces" (ite (or (= zip_pos_0 4) (= zip_pos_0 -5)) "" (ite (or (= zip_pos_0 3) (= zip_pos_0 -6)) "" (i...
(assert (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (ite (or (= zip_pos_0 8) (= zip_pos_0 -1)) "punctuation!?$%@#%" (ite (or (= zip_pos_0 7) (= zip_pos_0 -2)) "weird" (ite (or (= zip_pos_0 6) (= zip_pos_0 -3)) "and" (ite (or (= zip_pos_0 5) (= zip_pos_0 -4)) "spaces" (ite (or (= zip_pos_0 4) (= zip_pos_0 -5)) "" (ite (or (= zip_pos_0 3) (= zip_pos_0 -6)) "" (ite (or (= zip_pos_0 2) (= zip_pos_0 -7)) "" (ite (or (= zip_pos_0 1) (= zip_pos_0 -8)) "bout" "how"))))))))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (= (str.len x) 47))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 153 column 11: unknown constant zip_pos_0")
(error "line 154 column 11: unknown constant zip_pos_0")
(error "line 155 column 102: unknown constant zip_pos_0")
(error "line 156 column 97: unknown constant zip_pos_0")
(error "line 157 column 97: unknown constant zip_pos_0")
(error "line 158 column 97: unknown constant zip_pos_0")
(error "line 159 column 97: unknown constant zip_pos_0")
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
(error "Parse Error: tmp.smt2:153.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle AntiShuffle:3
Too many constants for extrapolation

Solving puzzle 216/774: AntiShuffle:4
sat_func def sat(s: str, orig="ruhixuthuciji kebelobawitextythuch quozo"):
    for a, b in zip(s.split(' '), orig.split(' ')):
        for i in range(len(a) - 1):
            assert a[i] <= a[i + 1], "characters must s-words be in increasing order"
        assert len(a) == len(b) and all(a.count(c) == b.count(c) for c in b), "must have same chars"
    return len(s) == len(orig)
modified_func def sat(s: str, orig=wrap_str('ruhixuthuciji kebelobawitextythuch quozo')):
    for a, b in sym_zip(s.split(wrap_str(' ')), orig.split(wrap_str(' '))):
        for i in sym_range(sym_len(a) - 1):
            _assert(a[i] <= a[i + wrap_int(1)], wrap_str('characters must s-words be in increasing order'))
        _assert((sym_len(a) == sym_len(b)).__and__(all(sym_generator((a.count(c) == b.count(c) for c in b)))), wrap_str('must have same chars'))
    return sym_len(s) == sym_len(orig)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (< zip_pos_0 3))
(assert (> zip_pos_0 -3))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (or (str.< (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1))) (= (python.str.at (list.get.string (str.split x " ") zip_pos_0) i_1) (python.str.at (list.get.string (str.split x " ") zip_pos_0) (+ i_1 1)))))))
(assert (forall ((str_pos_33 Int)) (=> (and (>= str_pos_33 0) (< str_pos_33 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji"))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (list.get.string (str.split x " ") zip_pos_0) (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji")) str_pos_33)) 0))))))
(assert (forall ((str_pos_33 Int)) (=> (and (>= str_pos_33 0) (< str_pos_33 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji"))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (>= (str.count (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji")) (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji")) str_pos_33)) 0))))))
(assert (forall ((str_pos_33 Int)) (=> (and (>= str_pos_33 0) (< str_pos_33 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji"))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (and (= (str.len (list.get.string (str.split x " ") zip_pos_0)) (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji")))) (= (str.count (list.get.string (str.split x " ") zip_pos_0) (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji")) str_pos_33)) (str.count (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji")) (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0...
(assert (forall ((str_pos_33 Int)) (=> (and (>= str_pos_33 0) (< str_pos_33 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "quozo" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "kebelobawitextythuch" "ruhixuthuciji"))))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (- (str.len (list.get.string (str.split x " ") zip_pos_0)) 1))) (= (str.len x) 40))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 153 column 11: unknown constant zip_pos_0")
(error "line 154 column 11: unknown constant zip_pos_0")
(error "line 155 column 102: unknown constant zip_pos_0")
(error "line 156 column 97: unknown constant zip_pos_0")
(error "line 157 column 97: unknown constant zip_pos_0")
(error "line 158 column 97: unknown constant zip_pos_0")
(error "line 159 column 97: unknown constant zip_pos_0")
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
(error "Parse Error: tmp.smt2:153.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle AntiShuffle:4
Too many constants for extrapolation

Solving puzzle 217/774: SubstitutionCypher:0
sat_func def sat(encrypted: str, orig="Hello, world!"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
modified_func def sat(encrypted: str, orig=wrap_str('Hello, world!')):
    _assert(sym_len(encrypted) == sym_len(orig))
    return all(sym_generator((sym_chr(sym_ord(a) - wrap_int(2) * wrap_int(2)) == b for a, b in sym_zip(encrypted, orig))))
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 13))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ABCDEFGHIJKML")
)
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAA")
)

Found solution ABCDEFGHIJKML
WARNING: Solution verification failed for puzzle SubstitutionCypher:0
Solving simpler variation replaced Hello, world! with Hel!
sat_func def sat(encrypted: str, orig="Hel!"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
modified_func def sat(encrypted: str, orig=wrap_str('Hel!')):
    _assert(sym_len(encrypted) == sym_len(orig))
    return all(sym_generator((sym_chr(sym_ord(a) - wrap_int(2) * wrap_int(2)) == b for a, b in sym_zip(encrypted, orig))))
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 4))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ABDC")
)
### output for cvc5
sat
(
(define-fun x () String "AAAA")
)

Found solution ABDC
WARNING: Solution verification failed for puzzle SubstitutionCypher:0

Solving puzzle 218/774: SubstitutionCypher:1
sat_func def sat(encrypted: str, orig=""):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
modified_func def sat(encrypted: str, orig=wrap_str('')):
    _assert(sym_len(encrypted) == sym_len(orig))
    return all(sym_generator((sym_chr(sym_ord(a) - wrap_int(2) * wrap_int(2)) == b for a, b in sym_zip(encrypted, orig))))
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Yes! Solved for puzzle  SubstitutionCypher:1

Solving puzzle 219/774: SubstitutionCypher:2
sat_func def sat(encrypted: str, orig="byfykovevuvyxanofi lygolono pyzuh t"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
modified_func def sat(encrypted: str, orig=wrap_str('byfykovevuvyxanofi lygolono pyzuh t')):
    _assert(sym_len(encrypted) == sym_len(orig))
    return all(sym_generator((sym_chr(sym_ord(a) - wrap_int(2) * wrap_int(2)) == b for a, b in sym_zip(encrypted, orig))))
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 35))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abc")
)
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
)

Found solution ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abc
WARNING: Solution verification failed for puzzle SubstitutionCypher:2
Too many constants for extrapolation

Solving puzzle 220/774: SubstitutionCypher:3
sat_func def sat(encrypted: str, orig="dogyvotitonucuxecequ jahuzowiz jyna"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
modified_func def sat(encrypted: str, orig=wrap_str('dogyvotitonucuxecequ jahuzowiz jyna')):
    _assert(sym_len(encrypted) == sym_len(orig))
    return all(sym_generator((sym_chr(sym_ord(a) - wrap_int(2) * wrap_int(2)) == b for a, b in sym_zip(encrypted, orig))))
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 35))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abc")
)
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
)

Found solution ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abc
WARNING: Solution verification failed for puzzle SubstitutionCypher:3
Too many constants for extrapolation

Solving puzzle 221/774: SubstitutionCypher:4
sat_func def sat(encrypted: str, orig="chodatext quycimoquytunek"):
    assert len(encrypted) == len(orig)
    return all(chr(ord(a) - 2 * 2) == b for a, b in zip(encrypted, orig))
modified_func def sat(encrypted: str, orig=wrap_str('chodatext quycimoquytunek')):
    _assert(sym_len(encrypted) == sym_len(orig))
    return all(sym_generator((sym_chr(sym_ord(a) - wrap_int(2) * wrap_int(2)) == b for a, b in sym_zip(encrypted, orig))))
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 25))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ABCDEFGHIJKLMNOPQRSTUVWXY")
)
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAA")
)

Found solution ABCDEFGHIJKLMNOPQRSTUVWXY
WARNING: Solution verification failed for puzzle SubstitutionCypher:4
Too many constants for extrapolation

Solving puzzle 222/774: SecondSmallestUnique:0
sat_func def sat(n: int, nums=[17, -1023589211, -293485382500, 31, -293485382500, 105762, 94328103589]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
modified_func def sat(n: int, nums=wrap_list([wrap_int(17), -wrap_int(1023589211), -wrap_int(293485382500), wrap_int(31), -wrap_int(293485382500), wrap_int(105762), wrap_int(94328103589)])):
    _assert(sym_in(n, nums))
    return sym_len({i for i in nums if i <= n}) == wrap_int(2)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= x 17) (= x -1023589211) (= x -293485382500) (= x 31) (= x -293485382500) (= x 105762) (= x 94328103589)))
(assert (=> (and (<= 17 x) (<= -1023589211 x) (<= -293485382500 x) (<= 31 x) (<= -293485382500 x) (<= 105762 x) (<= 94328103589 x)) false))
(assert (or (= x 17) (= x -1023589211) (= x -293485382500) (= x 31) (= x -293485382500) (= x 105762) (= x 94328103589)))
(assert (=> (and (not (<= 17 x)) (not (<= -1023589211 x)) (not (<= -293485382500 x)) (not (<= 31 x)) (not (<= -293485382500 x)) (not (<= 105762 x)) (not (<= 94328103589 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1023589211))
)
### output for cvc5
sat
(
(define-fun x () Int 17)
)

Found solution -1023589211
Yes! Solved for puzzle  SecondSmallestUnique:0

Solving puzzle 223/774: SecondSmallestUnique:1
sat_func def sat(n: int, nums=[-3, -4, -3, 8, -9]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
modified_func def sat(n: int, nums=wrap_list([-wrap_int(3), -wrap_int(4), -wrap_int(3), wrap_int(8), -wrap_int(9)])):
    _assert(sym_in(n, nums))
    return sym_len({i for i in nums if i <= n}) == wrap_int(2)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= x -3) (= x -4) (= x -3) (= x 8) (= x -9)))
(assert (=> (and (<= -3 x) (<= -4 x) (<= -3 x) (<= 8 x) (<= -9 x)) false))
(assert (or (= x -3) (= x -4) (= x -3) (= x 8) (= x -9)))
(assert (=> (and (not (<= -3 x)) (not (<= -4 x)) (not (<= -3 x)) (not (<= 8 x)) (not (<= -9 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 9))
)
### output for cvc5
sat
(
(define-fun x () Int (- 3))
)

Found solution -9
WARNING: Solution verification failed for puzzle SecondSmallestUnique:1
Too many constants for extrapolation

Solving puzzle 224/774: SecondSmallestUnique:2
sat_func def sat(n: int, nums=[0, -5, -7, -5, 0, -2, 6, -8]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
modified_func def sat(n: int, nums=wrap_list([wrap_int(0), -wrap_int(5), -wrap_int(7), -wrap_int(5), wrap_int(0), -wrap_int(2), wrap_int(6), -wrap_int(8)])):
    _assert(sym_in(n, nums))
    return sym_len({i for i in nums if i <= n}) == wrap_int(2)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= x 0) (= x -5) (= x -7) (= x -5) (= x 0) (= x -2) (= x 6) (= x -8)))
(assert (=> (and (<= 0 x) (<= -5 x) (<= -7 x) (<= -5 x) (<= 0 x) (<= -2 x) (<= 6 x) (<= -8 x)) false))
(assert (or (= x 0) (= x -5) (= x -7) (= x -5) (= x 0) (= x -2) (= x 6) (= x -8)))
(assert (=> (and (not (<= 0 x)) (not (<= -5 x)) (not (<= -7 x)) (not (<= -5 x)) (not (<= 0 x)) (not (<= -2 x)) (not (<= 6 x)) (not (<= -8 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 5))
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution -5
WARNING: Solution verification failed for puzzle SecondSmallestUnique:2
Too many constants for extrapolation

Solving puzzle 225/774: SecondSmallestUnique:3
sat_func def sat(n: int, nums=[6, 5]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
modified_func def sat(n: int, nums=wrap_list([wrap_int(6), wrap_int(5)])):
    _assert(sym_in(n, nums))
    return sym_len({i for i in nums if i <= n}) == wrap_int(2)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= x 6) (= x 5)))
(assert (=> (and (<= 6 x) (<= 5 x)) true))
(assert (or (= x 6) (= x 5)))
(assert (=> (and (not (<= 6 x)) (not (<= 5 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    5)
)
### output for cvc5
sat
(
(define-fun x () Int 6)
)

Found solution 5
WARNING: Solution verification failed for puzzle SecondSmallestUnique:3
Too many constants for extrapolation

Solving puzzle 226/774: SecondSmallestUnique:4
sat_func def sat(n: int, nums=[4, -8, 8, 4]):
    assert n in nums
    return len({i for i in nums if i <= n}) == 2
modified_func def sat(n: int, nums=wrap_list([wrap_int(4), -wrap_int(8), wrap_int(8), wrap_int(4)])):
    _assert(sym_in(n, nums))
    return sym_len({i for i in nums if i <= n}) == wrap_int(2)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (or (= x 4) (= x -8) (= x 8) (= x 4)))
(assert (=> (and (<= 4 x) (<= -8 x) (<= 8 x) (<= 4 x)) false))
(assert (or (= x 4) (= x -8) (= x 8) (= x 4)))
(assert (=> (and (not (<= 4 x)) (not (<= -8 x)) (not (<= 8 x)) (not (<= 4 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    4)
)
### output for cvc5
sat
(
(define-fun x () Int 4)
)

Found solution 4
Yes! Solved for puzzle  SecondSmallestUnique:4

Solving puzzle 227/774: WeirdDecodeVowels:0
sat_func def sat(s: str, target="Hello, world!"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
modified_func def sat(s: str, target=wrap_str('Hello, world!')):
    subs = {sym_ord(c): sym_ord(c) + wrap_int(2) for c in wrap_str('aeiouAEIOU')}
    return s.swapcase() == target.translate(subs)
concrete_subs {97: 99, 101: 103, 105: 107, 111: 113, 117: 119, 65: 67, 69: 71, 73: 75, 79: 81, 85: 87}
### smt2
(set-logic ALL)

(define-fun is_upper ((c String)) Bool
  (and 
    (>= (str.to_code c) 65)
    (<= (str.to_code c) 90)))

(define-fun is_lower ((c String)) Bool
  (and
    (>= (str.to_code c) 97)
    (<= (str.to_code c) 122)))

(define-fun to_lower ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (+ code 32))))

(define-fun to_upper ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (- code 32))))

(define-fun swapcase_char ((c String)) String
  (ite (is_upper c)
       (to_lower c)
       (ite (is_lower c)
            (to_upper c)
            c)))

(define-fun-rec swapcase_helper ((i Int) (n Int) (s String)) String
  (ite (>= i n)
       ""
       (str.++ (swapcase_char (str.at s i))
               (swapcase_helper (+ i 1) n s))))

(define-fun swapcase ((s String)) String
  (swapcase_helper 0 (str.len s) s))

(declare-const x String)
(assert (= (swapcase x) "Hgllq, wqrld!"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle WeirdDecodeVowels:0
Solving simpler variation replaced Hello, world! with Hel!
sat_func def sat(s: str, target="Hel!"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
modified_func def sat(s: str, target=wrap_str('Hel!')):
    subs = {sym_ord(c): sym_ord(c) + wrap_int(2) for c in wrap_str('aeiouAEIOU')}
    return s.swapcase() == target.translate(subs)
concrete_subs {97: 99, 101: 103, 105: 107, 111: 113, 117: 119, 65: 67, 69: 71, 73: 75, 79: 81, 85: 87}
### smt2
(set-logic ALL)

(define-fun is_upper ((c String)) Bool
  (and 
    (>= (str.to_code c) 65)
    (<= (str.to_code c) 90)))

(define-fun is_lower ((c String)) Bool
  (and
    (>= (str.to_code c) 97)
    (<= (str.to_code c) 122)))

(define-fun to_lower ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (+ code 32))))

(define-fun to_upper ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (- code 32))))

(define-fun swapcase_char ((c String)) String
  (ite (is_upper c)
       (to_lower c)
       (ite (is_lower c)
            (to_upper c)
            c)))

(define-fun-rec swapcase_helper ((i Int) (n Int) (s String)) String
  (ite (>= i n)
       ""
       (str.++ (swapcase_char (str.at s i))
               (swapcase_helper (+ i 1) n s))))

(define-fun swapcase ((s String)) String
  (swapcase_helper 0 (str.len s) s))

(declare-const x String)
(assert (= (swapcase x) "Hgl!"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "hGL!")
)
### output for cvc5
sat
(
(define-fun x () String "hGL!")
)

Found solution hGL!

Solving puzzle 228/774: WeirdDecodeVowels:1
sat_func def sat(s: str, target="This is a good test"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
modified_func def sat(s: str, target=wrap_str('This is a good test')):
    subs = {sym_ord(c): sym_ord(c) + wrap_int(2) for c in wrap_str('aeiouAEIOU')}
    return s.swapcase() == target.translate(subs)
concrete_subs {97: 99, 101: 103, 105: 107, 111: 113, 117: 119, 65: 67, 69: 71, 73: 75, 79: 81, 85: 87}
### smt2
(set-logic ALL)

(define-fun is_upper ((c String)) Bool
  (and 
    (>= (str.to_code c) 65)
    (<= (str.to_code c) 90)))

(define-fun is_lower ((c String)) Bool
  (and
    (>= (str.to_code c) 97)
    (<= (str.to_code c) 122)))

(define-fun to_lower ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (+ code 32))))

(define-fun to_upper ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (- code 32))))

(define-fun swapcase_char ((c String)) String
  (ite (is_upper c)
       (to_lower c)
       (ite (is_lower c)
            (to_upper c)
            c)))

(define-fun-rec swapcase_helper ((i Int) (n Int) (s String)) String
  (ite (>= i n)
       ""
       (str.++ (swapcase_char (str.at s i))
               (swapcase_helper (+ i 1) n s))))

(define-fun swapcase ((s String)) String
  (swapcase_helper 0 (str.len s) s))

(declare-const x String)
(assert (= (swapcase x) "Thks ks c gqqd tgst"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle WeirdDecodeVowels:1
Too many constants for extrapolation

Solving puzzle 229/774: WeirdDecodeVowels:2
sat_func def sat(s: str, target=""):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
modified_func def sat(s: str, target=wrap_str('')):
    subs = {sym_ord(c): sym_ord(c) + wrap_int(2) for c in wrap_str('aeiouAEIOU')}
    return s.swapcase() == target.translate(subs)
concrete_subs {97: 99, 101: 103, 105: 107, 111: 113, 117: 119, 65: 67, 69: 71, 73: 75, 79: 81, 85: 87}
### smt2
(set-logic ALL)

(define-fun is_upper ((c String)) Bool
  (and 
    (>= (str.to_code c) 65)
    (<= (str.to_code c) 90)))

(define-fun is_lower ((c String)) Bool
  (and
    (>= (str.to_code c) 97)
    (<= (str.to_code c) 122)))

(define-fun to_lower ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (+ code 32))))

(define-fun to_upper ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (- code 32))))

(define-fun swapcase_char ((c String)) String
  (ite (is_upper c)
       (to_lower c)
       (ite (is_lower c)
            (to_upper c)
            c)))

(define-fun-rec swapcase_helper ((i Int) (n Int) (s String)) String
  (ite (>= i n)
       ""
       (str.++ (swapcase_char (str.at s i))
               (swapcase_helper (+ i 1) n s))))

(define-fun swapcase ((s String)) String
  (swapcase_helper 0 (str.len s) s))

(declare-const x String)
(assert (= (swapcase x) ""))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Yes! Solved for puzzle  WeirdDecodeVowels:2

Solving puzzle 230/774: WeirdDecodeVowels:3
sat_func def sat(s: str, target="That last test was a bad test!"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
modified_func def sat(s: str, target=wrap_str('That last test was a bad test!')):
    subs = {sym_ord(c): sym_ord(c) + wrap_int(2) for c in wrap_str('aeiouAEIOU')}
    return s.swapcase() == target.translate(subs)
concrete_subs {97: 99, 101: 103, 105: 107, 111: 113, 117: 119, 65: 67, 69: 71, 73: 75, 79: 81, 85: 87}
### smt2
(set-logic ALL)

(define-fun is_upper ((c String)) Bool
  (and 
    (>= (str.to_code c) 65)
    (<= (str.to_code c) 90)))

(define-fun is_lower ((c String)) Bool
  (and
    (>= (str.to_code c) 97)
    (<= (str.to_code c) 122)))

(define-fun to_lower ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (+ code 32))))

(define-fun to_upper ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (- code 32))))

(define-fun swapcase_char ((c String)) String
  (ite (is_upper c)
       (to_lower c)
       (ite (is_lower c)
            (to_upper c)
            c)))

(define-fun-rec swapcase_helper ((i Int) (n Int) (s String)) String
  (ite (>= i n)
       ""
       (str.++ (swapcase_char (str.at s i))
               (swapcase_helper (+ i 1) n s))))

(define-fun swapcase ((s String)) String
  (swapcase_helper 0 (str.len s) s))

(declare-const x String)
(assert (= (swapcase x) "Thct lcst tgst wcs c bcd tgst!"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle WeirdDecodeVowels:3
Too many constants for extrapolation

Solving puzzle 231/774: WeirdDecodeVowels:4
sat_func def sat(s: str, target="pneumonoultramicroscopicsilicovolanoconiosis"):
    subs = {ord(c): ord(c) + 2 for c in "aeiouAEIOU"}
    return s.swapcase() == target.translate(subs)
modified_func def sat(s: str, target=wrap_str('pneumonoultramicroscopicsilicovolanoconiosis')):
    subs = {sym_ord(c): sym_ord(c) + wrap_int(2) for c in wrap_str('aeiouAEIOU')}
    return s.swapcase() == target.translate(subs)
concrete_subs {97: 99, 101: 103, 105: 107, 111: 113, 117: 119, 65: 67, 69: 71, 73: 75, 79: 81, 85: 87}
### smt2
(set-logic ALL)

(define-fun is_upper ((c String)) Bool
  (and 
    (>= (str.to_code c) 65)
    (<= (str.to_code c) 90)))

(define-fun is_lower ((c String)) Bool
  (and
    (>= (str.to_code c) 97)
    (<= (str.to_code c) 122)))

(define-fun to_lower ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (+ code 32))))

(define-fun to_upper ((c String)) String
  (let ((code (str.to_code c)))
    (str.from_code (- code 32))))

(define-fun swapcase_char ((c String)) String
  (ite (is_upper c)
       (to_lower c)
       (ite (is_lower c)
            (to_upper c)
            c)))

(define-fun-rec swapcase_helper ((i Int) (n Int) (s String)) String
  (ite (>= i n)
       ""
       (str.++ (swapcase_char (str.at s i))
               (swapcase_helper (+ i 1) n s))))

(define-fun swapcase ((s String)) String
  (swapcase_helper 0 (str.len s) s))

(declare-const x String)
(assert (= (swapcase x) "pngwmqnqwltrcmkcrqscqpkcsklkcqvqlcnqcqnkqsks"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle WeirdDecodeVowels:4
Too many constants for extrapolation

Solving puzzle 232/774: OddCase:0
sat_func def sat(different: str, d={'cat': 'CAT', 'tree': 'T', 'pick me': 'not', 'OK': 'red', 'blah': 'blah', 'z': 'Z'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
modified_func def sat(different: str, d={wrap_str('cat'): wrap_str('CAT'), wrap_str('tree'): wrap_str('T'), wrap_str('pick me'): wrap_str('not'), wrap_str('OK'): wrap_str('red'), wrap_str('blah'): wrap_str('blah'), wrap_str('z'): wrap_str('Z')}):
    return sym_in(different, d).__and__(all(sym_generator((k.islower() != different.islower() for k in d if k != different))))
Exception -- for puzzle OddCase:0 'dict' object has no attribute 'contains'

Solving puzzle 233/774: OddCase:1
sat_func def sat(different: str, d={'den': 'fymehihyxuro', 'madufitextuthohyv': 'sofekuhepokosixyzoza', 'xechygo': 'kythubehuzagu', 'xukefulete': 'hugevybelypyrer', 'maw': 'vaveraral', 'hichaquidyto': 'quisi', 'remenidasohijetybah': 'bukomegewisevoxoz', 'kyte': 'fonecohynipesewyth', 'cax': 'bilesequ', 'caduquetextan': 'juzedabaz', 'THEMITOTH': 'xotugythuzu'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
modified_func def sat(different: str, d={wrap_str('den'): wrap_str('fymehihyxuro'), wrap_str('madufitextuthohyv'): wrap_str('sofekuhepokosixyzoza'), wrap_str('xechygo'): wrap_str('kythubehuzagu'), wrap_str('xukefulete'): wrap_str('hugevybelypyrer'), wrap_str('maw'): wrap_str('vaveraral'), wrap_str('hichaquidyto'): wrap_str('quisi'), wrap_str('remenidasohijetybah'): wrap_str('bukomegewisevoxoz'), wrap_str('kyte'): wrap_str('fonecohynipesewyth'), wrap_str('cax'): wrap_str('bilesequ'), wrap_str('caduquetextan'): wrap_str('juzedabaz'), wrap_str('THEMITOTH'): wrap_str('xotugythuzu')}):
    return sym_in(different, d).__and__(all(sym_generator((k.islower() != different.islower() for k in d if k != different))))
Exception -- for puzzle OddCase:1 'dict' object has no attribute 'contains'

Solving puzzle 234/774: OddCase:2
sat_func def sat(different: str, d={'CHIRATICHUHUQUYZYPYW': 'kopakyquotyhaquome', 'QUEBYTEXTEXUROBEK': 'tituxa', 'ZUVU': 'xupovutexti', 'NATEXTESYTUBUMY': 'ponusewaquufot', 'THUK': 'gyvy', 'CETEXTOFENAXIXANEKA': 'xyjytextecywykoquo', 'SEKAMIWEHYTHYTEXTUCU': 'jehu', 'H': 'quicyquohofowejivun', 'KYTEXTIBAXUTAV': 'nygutextin', 'LYQUA': 'biruji', 'tizenyry': 'xavyquukoc'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
modified_func def sat(different: str, d={wrap_str('CHIRATICHUHUQUYZYPYW'): wrap_str('kopakyquotyhaquome'), wrap_str('QUEBYTEXTEXUROBEK'): wrap_str('tituxa'), wrap_str('ZUVU'): wrap_str('xupovutexti'), wrap_str('NATEXTESYTUBUMY'): wrap_str('ponusewaquufot'), wrap_str('THUK'): wrap_str('gyvy'), wrap_str('CETEXTOFENAXIXANEKA'): wrap_str('xyjytextecywykoquo'), wrap_str('SEKAMIWEHYTHYTEXTUCU'): wrap_str('jehu'), wrap_str('H'): wrap_str('quicyquohofowejivun'), wrap_str('KYTEXTIBAXUTAV'): wrap_str('nygutextin'), wrap_str('LYQUA'): wrap_str('biruji'), wrap_str('tizenyry'): wrap_str('xavyquukoc')}):
    return sym_in(different, d).__and__(all(sym_generator((k.islower() != different.islower() for k in d if k != different))))
Exception -- for puzzle OddCase:2 'dict' object has no attribute 'contains'

Solving puzzle 235/774: OddCase:3
sat_func def sat(different: str, d={'CHEWA': 'geratenegafa', 'WATHYHUVOTEXTINO': 'th', 'DIFUS': 'zetextatasohunibathe', 'TUBEZA': 'rajytextar', 'NEZALEQUAZAHEKAGUPU': 'bequexucoxy', 'SEBOLIZEDUL': 'wyxufyhodymube', 'ZU': 'conuhywumychogije', 'DE': 'lebemypovoke', 'DEBURUGINOC': 'gequilithyjyvymufi', 'TEXTURAFA': 'textejesyko', 'rixechy': 'fate'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
modified_func def sat(different: str, d={wrap_str('CHEWA'): wrap_str('geratenegafa'), wrap_str('WATHYHUVOTEXTINO'): wrap_str('th'), wrap_str('DIFUS'): wrap_str('zetextatasohunibathe'), wrap_str('TUBEZA'): wrap_str('rajytextar'), wrap_str('NEZALEQUAZAHEKAGUPU'): wrap_str('bequexucoxy'), wrap_str('SEBOLIZEDUL'): wrap_str('wyxufyhodymube'), wrap_str('ZU'): wrap_str('conuhywumychogije'), wrap_str('DE'): wrap_str('lebemypovoke'), wrap_str('DEBURUGINOC'): wrap_str('gequilithyjyvymufi'), wrap_str('TEXTURAFA'): wrap_str('textejesyko'), wrap_str('rixechy'): wrap_str('fate')}):
    return sym_in(different, d).__and__(all(sym_generator((k.islower() != different.islower() for k in d if k != different))))
Exception -- for puzzle OddCase:3 'dict' object has no attribute 'contains'

Solving puzzle 236/774: OddCase:4
sat_func def sat(different: str, d={'quicaboguc': 'su', 'sacylir': 'tholubakypynythiryr', 'vijuchox': 'matextyquorewetytefy', 'lechi': 'nuch', 'viz': 'cheferopa', 'textowikalihehupyxi': 'quuchonasufexi', 'wuhujasi': 'f', 'tytextedoma': 'zifehabumabocate', 'gaviquolaxagihisice': 'sulywuzoquo', 'muvequo': 'juxachameje', 'B': 'quanesyfeku'}):
    return different in d and all(k.islower() != different.islower() for k in d if k != different)
modified_func def sat(different: str, d={wrap_str('quicaboguc'): wrap_str('su'), wrap_str('sacylir'): wrap_str('tholubakypynythiryr'), wrap_str('vijuchox'): wrap_str('matextyquorewetytefy'), wrap_str('lechi'): wrap_str('nuch'), wrap_str('viz'): wrap_str('cheferopa'), wrap_str('textowikalihehupyxi'): wrap_str('quuchonasufexi'), wrap_str('wuhujasi'): wrap_str('f'), wrap_str('tytextedoma'): wrap_str('zifehabumabocate'), wrap_str('gaviquolaxagihisice'): wrap_str('sulywuzoquo'), wrap_str('muvequo'): wrap_str('juxachameje'), wrap_str('B'): wrap_str('quanesyfeku')}):
    return sym_in(different, d).__and__(all(sym_generator((k.islower() != different.islower() for k in d if k != different))))
Exception -- for puzzle OddCase:4 'dict' object has no attribute 'contains'

Solving puzzle 237/774: UnitsProduct:0
sat_func def sat(prod: int, nums=[17, 24, 39, 15, 11, 201, 97, 65, 18]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
modified_func def sat(prod: int, nums=wrap_list([wrap_int(17), wrap_int(24), wrap_int(39), wrap_int(15), wrap_int(11), wrap_int(201), wrap_int(97), wrap_int(65), wrap_int(18)])):
    if sym_not(all(nums)):
        return prod == wrap_int(0)
    for n in nums:
        k = abs(n % wrap_int(10))
        if k == wrap_int(0):
            return prod == wrap_int(0)
        _assert(prod % k == wrap_int(0))
        prod //= k
    return prod == wrap_int(1)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true)) (= x 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod x 7) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod (div x 7) 4) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod (div (div x 7) 4) 9) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod (div (div (div x 7) 4) 9) 5) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod (div (div (div (div x 7) 4) 9) 5) 1) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod (div (div (div (div (div x 7) 4) 9) 5) 1) 1) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod (div (div (div (div (div (div x 7) 4) 9) 5) 1) 1) 7) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod (div (div (div (div (div (div (div x 7) 4) 9) 5) 1) 1) 7) 5) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (mod (div (div (div (div (div (div (div (div x 7) 4) 9) 5) 1) 1) 7) 5) 8) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true))) (= (div (div (div (div (div (div (div (div (div x 7) 4) 9) 5) 1) 1) 7) 5) 8) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    352800)
)
### output for cvc5
sat
(
(define-fun x () Int 352800)
)

Found solution 352800
Yes! Solved for puzzle  UnitsProduct:0

Solving puzzle 238/774: UnitsProduct:1
sat_func def sat(prod: int, nums=[1, 9, 96, 79, 86, -30, -33, 63, 39, 35]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
modified_func def sat(prod: int, nums=wrap_list([wrap_int(1), wrap_int(9), wrap_int(96), wrap_int(79), wrap_int(86), -wrap_int(30), -wrap_int(33), wrap_int(63), wrap_int(39), wrap_int(35)])):
    if sym_not(all(nums)):
        return prod == wrap_int(0)
    for n in nums:
        k = abs(n % wrap_int(10))
        if k == wrap_int(0):
            return prod == wrap_int(0)
        _assert(prod % k == wrap_int(0))
        prod //= k
    return prod == wrap_int(1)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true)) (= x 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod x 1) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod (div x 1) 9) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod (div (div x 1) 9) 6) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod (div (div (div x 1) 9) 6) 9) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod (div (div (div (div x 1) 9) 6) 9) 6) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (div (div (div (div (div x 1) 9) 6) 9) 6) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  UnitsProduct:1

Solving puzzle 239/774: UnitsProduct:2
sat_func def sat(prod: int, nums=[-29, -50, -4, 79, 2, 19, 34, 9, 27, -42]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
modified_func def sat(prod: int, nums=wrap_list([-wrap_int(29), -wrap_int(50), -wrap_int(4), wrap_int(79), wrap_int(2), wrap_int(19), wrap_int(34), wrap_int(9), wrap_int(27), -wrap_int(42)])):
    if sym_not(all(nums)):
        return prod == wrap_int(0)
    for n in nums:
        k = abs(n % wrap_int(10))
        if k == wrap_int(0):
            return prod == wrap_int(0)
        _assert(prod % k == wrap_int(0))
        prod //= k
    return prod == wrap_int(1)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true)) (= x 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod x 1) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (div x 1) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  UnitsProduct:2

Solving puzzle 240/774: UnitsProduct:3
sat_func def sat(prod: int, nums=[-28, -34, 90, 0, -38, -39, -13, 13, 56, 50]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
modified_func def sat(prod: int, nums=wrap_list([-wrap_int(28), -wrap_int(34), wrap_int(90), wrap_int(0), -wrap_int(38), -wrap_int(39), -wrap_int(13), wrap_int(13), wrap_int(56), wrap_int(50)])):
    if sym_not(all(nums)):
        return prod == wrap_int(0)
    for n in nums:
        k = abs(n % wrap_int(10))
        if k == wrap_int(0):
            return prod == wrap_int(0)
        _assert(prod % k == wrap_int(0))
        prod //= k
    return prod == wrap_int(1)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (not (and (and (and (and (and (and (and (and (and true true) true) false) true) true) true) true) true) true)) (= x 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) false) true) true) true) true) true) true))) (= (mod x 2) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) false) true) true) true) true) true) true))) (= (mod (div x 2) 6) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) false) true) true) true) true) true) true))) (= (div (div x 2) 6) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  UnitsProduct:3

Solving puzzle 241/774: UnitsProduct:4
sat_func def sat(prod: int, nums=[81, 36, -53, 17, 40, -30, -20, 13, -16, -18]):
    if not all(nums):
        return prod == 0
    for n in nums:
        k = abs(n % 10)
        if k == 0:
            return prod == 0
        assert prod % k == 0
        prod //= k
    return prod == 1
modified_func def sat(prod: int, nums=wrap_list([wrap_int(81), wrap_int(36), -wrap_int(53), wrap_int(17), wrap_int(40), -wrap_int(30), -wrap_int(20), wrap_int(13), -wrap_int(16), -wrap_int(18)])):
    if sym_not(all(nums)):
        return prod == wrap_int(0)
    for n in nums:
        k = abs(n % wrap_int(10))
        if k == wrap_int(0):
            return prod == wrap_int(0)
        _assert(prod % k == wrap_int(0))
        prod //= k
    return prod == wrap_int(1)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true)) (= x 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod x 1) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod (div x 1) 6) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod (div (div x 1) 6) 7) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (mod (div (div (div x 1) 6) 7) 7) 0)))
(assert (=> (not (not (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))) (= (div (div (div (div x 1) 6) 7) 7) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  UnitsProduct:4

Solving puzzle 242/774: ClosestInteger:0
sat_func def sat(n: int, x=329437923.5):
    return abs(n - x) <= 0.5
modified_func def sat(n: int, x=329437923.5):
    return abs(n - x) <= 0.5
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (ite (>= (- x 329437923.5) 0) (- x 329437923.5) (- (- x 329437923.5))) 0.5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    329437923)
)
### output for cvc5
sat
(
(define-fun x () Int 329437924)
)

Found solution 329437923
Yes! Solved for puzzle  ClosestInteger:0

Solving puzzle 243/774: ClosestInteger:1
sat_func def sat(n: int, x=3557710970.9527555):
    return abs(n - x) <= 0.5
modified_func def sat(n: int, x=3557710970.9527555):
    return abs(n - x) <= 0.5
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (ite (>= (- x 3557710970.9527555) 0) (- x 3557710970.9527555) (- (- x 3557710970.9527555))) 0.5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3557710971)
)
### output for cvc5
sat
(
(define-fun x () Int 3557710971)
)

Found solution 3557710971
Yes! Solved for puzzle  ClosestInteger:1

Solving puzzle 244/774: ClosestInteger:2
sat_func def sat(n: int, x=-250406.87146656853):
    return abs(n - x) <= 0.5
modified_func def sat(n: int, x=-250406.87146656853):
    return abs(n - x) <= 0.5
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (ite (>= (- x -250406.87146656853) 0) (- x -250406.87146656853) (- (- x -250406.87146656853))) 0.5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 250407))
)
### output for cvc5
sat
(
(define-fun x () Int (- 250407))
)

Found solution -250407
Yes! Solved for puzzle  ClosestInteger:2

Solving puzzle 245/774: ClosestInteger:3
sat_func def sat(n: int, x=346686.79646634863):
    return abs(n - x) <= 0.5
modified_func def sat(n: int, x=346686.79646634863):
    return abs(n - x) <= 0.5
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (ite (>= (- x 346686.79646634863) 0) (- x 346686.79646634863) (- (- x 346686.79646634863))) 0.5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    346687)
)
### output for cvc5
sat
(
(define-fun x () Int 346687)
)

Found solution 346687
Yes! Solved for puzzle  ClosestInteger:3

Solving puzzle 246/774: ClosestInteger:4
sat_func def sat(n: int, x=1087254.523941833):
    return abs(n - x) <= 0.5
modified_func def sat(n: int, x=1087254.523941833):
    return abs(n - x) <= 0.5
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (<= (ite (>= (- x 1087254.523941833) 0) (- x 1087254.523941833) (- (- x 1087254.523941833))) 0.5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1087255)
)
### output for cvc5
sat
(
(define-fun x () Int 1087255)
)

Found solution 1087255
Yes! Solved for puzzle  ClosestInteger:4

Solving puzzle 247/774: BiggestEven:0
sat_func def sat(x: int, a=145, b=24126846790974):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
modified_func def sat(x: int, a=wrap_int(145), b=wrap_int(24126846790974)):
    if x == -wrap_int(1):
        return all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(a, b + 1))))
    return (a <= x).__and__(x <= b).__and__(all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(x + 1, b + 1)))))
Timed out for puzzle BiggestEven:0

Solving puzzle 248/774: BiggestEven:1
sat_func def sat(x: int, a=17, b=17):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
modified_func def sat(x: int, a=wrap_int(17), b=wrap_int(17)):
    if x == -wrap_int(1):
        return all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(a, b + 1))))
    return (a <= x).__and__(x <= b).__and__(all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(x + 1, b + 1)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) true))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 18)) (=> (not (= x -1)) (and (and (<= 17 x) (<= x 17)) (= (mod i_0 2) 1))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    18)
)
### output for cvc5
sat
(
(define-fun x () Int (- 1))
)

Found solution 18
WARNING: Solution verification failed for puzzle BiggestEven:1
Too many constants for extrapolation

Solving puzzle 249/774: BiggestEven:2
sat_func def sat(x: int, a=-10, b=-6):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
modified_func def sat(x: int, a=-wrap_int(10), b=-wrap_int(6)):
    if x == -wrap_int(1):
        return all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(a, b + 1))))
    return (a <= x).__and__(x <= b).__and__(all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(x + 1, b + 1)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) (and (and (and (and false true) false) true) false)))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 -5)) (=> (not (= x -1)) (and (and (<= -10 x) (<= x -6)) (= (mod i_0 2) 1))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 5))
)
### output for cvc5
sat
(
(define-fun x () Int (- 6))
)

Found solution -5
WARNING: Solution verification failed for puzzle BiggestEven:2
Too many constants for extrapolation

Solving puzzle 250/774: BiggestEven:3
sat_func def sat(x: int, a=100, b=84):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
modified_func def sat(x: int, a=wrap_int(100), b=wrap_int(84)):
    if x == -wrap_int(1):
        return all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(a, b + 1))))
    return (a <= x).__and__(x <= b).__and__(all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(x + 1, b + 1)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) true))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 85)) (=> (not (= x -1)) (and (and (<= 100 x) (<= x 84)) (= (mod i_0 2) 1))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    100)
)
### output for cvc5
sat
(
(define-fun x () Int (- 1))
)

Found solution 100
WARNING: Solution verification failed for puzzle BiggestEven:3
One large constant for extrapolation
Solving simpler variation replaced 100 with 3
sat_func def sat(x: int, a=3, b=84):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
modified_func def sat(x: int, a=wrap_int(3), b=wrap_int(84)):
    if x == -wrap_int(1):
        return all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(a, b + 1))))
    return (a <= x).__and__(x <= b).__and__(all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(x + 1, b + 1)))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x -1) (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and true false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false) true) false)))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (+ x 1)) (< i_0 85)) (=> (not (= x -1)) (and (and (<= 3 x) (<= x 84)) (= (mod i_0 2) 1))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    85)
)
### output for cvc5
sat
(
(define-fun x () Int 84)
)

Found solution 85
WARNING: Solution verification failed for puzzle BiggestEven:3

Solving puzzle 251/774: BiggestEven:4
sat_func def sat(x: int, a=0, b=323523571223):
    if x == -1:
        return all(i % 2 == 1 for i in range(a, b + 1))
    return a <= x <= b and all(i % 2 == 1 for i in range(x + 1, b + 1))
modified_func def sat(x: int, a=wrap_int(0), b=wrap_int(323523571223)):
    if x == -wrap_int(1):
        return all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(a, b + 1))))
    return (a <= x).__and__(x <= b).__and__(all(sym_generator((i % wrap_int(2) == wrap_int(1) for i in sym_range(x + 1, b + 1)))))
Timed out for puzzle BiggestEven:4

Solving puzzle 252/774: BinaryAverage:0
sat_func def sat(s: str, a=-103252, b=10657):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
modified_func def sat(s: str, a=-wrap_int(103252), b=wrap_int(10657)):
    n = sym_int(s, wrap_int(2))
    r = sym_range(a, b)
    if sym_len(r) == wrap_int(0):
        return n == -wrap_int(1)
    mu = sym_sum(r) / sym_len(r)
    return abs(mu - n) <= min(abs(mu - n - wrap_int(1)), abs(mu - n + wrap_int(1)))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (=> (< (ite (>= (+ (- -46298.0 (python.int x 2)) 1) 0) (+ (- -46298.0 (python.int x 2)) 1) (- (+ (- -46298.0 (python.int x 2)) 1))) (ite (>= (- (- -46298.0 (python.int x 2)) 1) 0) (- (- -46298.0 (python.int x 2)) 1) (- (- (- -46298.0 (python.int x 2)) 1)))) (<= (ite (>= (- -46298.0 (python.int x 2)) 0) (- -46298.0 (python.int x 2)) (- (- -46298.0 (python.int x 2)))) (ite (>= (+ (- -46298.0 (python.int x 2)) 1) 0) (+ (- -46298.0 (python.int x 2)) 1) (- (+ (- -46298.0 (python.int x 2)) 1))))))
(assert (> (str.len x) 0))
(assert (=> (not (< (ite (>= (+ (- -46298.0 (python.int x 2)) 1) 0) (+ (- -46298.0 (python.int x 2)) 1) (- (+ (- -46298.0 (python.int x 2)) 1))) (ite (>= (- (- -46298.0 (python.int x 2)) 1) 0) (- (- -46298.0 (python.int x 2)) 1) (- (- (- -46298.0 (python.int x 2)) 1))))) (<= (ite (>= (- -46298.0 (python.int x 2)) 0) (- -46298.0 (python.int x 2)) (- (- -46298.0 (python.int x 2)))) (ite (>= (- (- -46298.0 (python.int x 2)) 1) 0) (- (- -46298.0 (python.int x 2)) 1) (- (- (- -46298.0 (python.int x 2)) 1))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_9)))))")

Could not find any solution for puzzle BinaryAverage:0
Two large constants for extrapolation
Solving simpler variation replaced 103252 with 3 and 10657 with 5
sat_func def sat(s: str, a=-3, b=5):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
modified_func def sat(s: str, a=-wrap_int(3), b=wrap_int(5)):
    n = sym_int(s, wrap_int(2))
    r = sym_range(a, b)
    if sym_len(r) == wrap_int(0):
        return n == -wrap_int(1)
    mu = sym_sum(r) / sym_len(r)
    return abs(mu - n) <= min(abs(mu - n - wrap_int(1)), abs(mu - n + wrap_int(1)))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (=> (< (ite (>= (+ (- 0.5 (python.int x 2)) 1) 0) (+ (- 0.5 (python.int x 2)) 1) (- (+ (- 0.5 (python.int x 2)) 1))) (ite (>= (- (- 0.5 (python.int x 2)) 1) 0) (- (- 0.5 (python.int x 2)) 1) (- (- (- 0.5 (python.int x 2)) 1)))) (<= (ite (>= (- 0.5 (python.int x 2)) 0) (- 0.5 (python.int x 2)) (- (- 0.5 (python.int x 2)))) (ite (>= (+ (- 0.5 (python.int x 2)) 1) 0) (+ (- 0.5 (python.int x 2)) 1) (- (+ (- 0.5 (python.int x 2)) 1))))))
(assert (> (str.len x) 0))
(assert (=> (not (< (ite (>= (+ (- 0.5 (python.int x 2)) 1) 0) (+ (- 0.5 (python.int x 2)) 1) (- (+ (- 0.5 (python.int x 2)) 1))) (ite (>= (- (- 0.5 (python.int x 2)) 1) 0) (- (- 0.5 (python.int x 2)) 1) (- (- (- 0.5 (python.int x 2)) 1))))) (<= (ite (>= (- 0.5 (python.int x 2)) 0) (- 0.5 (python.int x 2)) (- (- 0.5 (python.int x 2)))) (ite (>= (- (- 0.5 (python.int x 2)) 1) 0) (- (- 0.5 (python.int x 2)) 1) (- (- (- 0.5 (python.int x 2)) 1))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "A")
)
### output for cvc5
sat
(
(define-fun x () String "A")
)

Found solution A
Exception in checking result: invalid literal for int() with base 2: 'A'
WARNING: Solution verification failed for puzzle BinaryAverage:0

Solving puzzle 253/774: BinaryAverage:1
sat_func def sat(s: str, a=70421, b=70421):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
modified_func def sat(s: str, a=wrap_int(70421), b=wrap_int(70421)):
    n = sym_int(s, wrap_int(2))
    r = sym_range(a, b)
    if sym_len(r) == wrap_int(0):
        return n == -wrap_int(1)
    mu = sym_sum(r) / sym_len(r)
    return abs(mu - n) <= min(abs(mu - n - wrap_int(1)), abs(mu - n + wrap_int(1)))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 2) -1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_6)))))")

Could not find any solution for puzzle BinaryAverage:1
One large constant for extrapolation
Solving simpler variation replaced 70421 with 3
sat_func def sat(s: str, a=3, b=3):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
modified_func def sat(s: str, a=wrap_int(3), b=wrap_int(3)):
    n = sym_int(s, wrap_int(2))
    r = sym_range(a, b)
    if sym_len(r) == wrap_int(0):
        return n == -wrap_int(1)
    mu = sym_sum(r) / sym_len(r)
    return abs(mu - n) <= min(abs(mu - n - wrap_int(1)), abs(mu - n + wrap_int(1)))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 2) -1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_6)))))")

Could not find any solution for puzzle BinaryAverage:1

Solving puzzle 254/774: BinaryAverage:2
sat_func def sat(s: str, a=-10299, b=-10300):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
modified_func def sat(s: str, a=-wrap_int(10299), b=-wrap_int(10300)):
    n = sym_int(s, wrap_int(2))
    r = sym_range(a, b)
    if sym_len(r) == wrap_int(0):
        return n == -wrap_int(1)
    mu = sym_sum(r) / sym_len(r)
    return abs(mu - n) <= min(abs(mu - n - wrap_int(1)), abs(mu - n + wrap_int(1)))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 2) -1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_6)))))")

Could not find any solution for puzzle BinaryAverage:2
Two large constants for extrapolation
Solving simpler variation replaced 10299 with 3 and 10300 with 5
sat_func def sat(s: str, a=-3, b=-5):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
modified_func def sat(s: str, a=-wrap_int(3), b=-wrap_int(5)):
    n = sym_int(s, wrap_int(2))
    r = sym_range(a, b)
    if sym_len(r) == wrap_int(0):
        return n == -wrap_int(1)
    mu = sym_sum(r) / sym_len(r)
    return abs(mu - n) <= min(abs(mu - n - wrap_int(1)), abs(mu - n + wrap_int(1)))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (= (python.int x 2) -1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_6)))))")

Could not find any solution for puzzle BinaryAverage:2

Solving puzzle 255/774: BinaryAverage:3
sat_func def sat(s: str, a=0, b=52):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
modified_func def sat(s: str, a=wrap_int(0), b=wrap_int(52)):
    n = sym_int(s, wrap_int(2))
    r = sym_range(a, b)
    if sym_len(r) == wrap_int(0):
        return n == -wrap_int(1)
    mu = sym_sum(r) / sym_len(r)
    return abs(mu - n) <= min(abs(mu - n - wrap_int(1)), abs(mu - n + wrap_int(1)))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (=> (< (ite (>= (+ (- 25.5 (python.int x 2)) 1) 0) (+ (- 25.5 (python.int x 2)) 1) (- (+ (- 25.5 (python.int x 2)) 1))) (ite (>= (- (- 25.5 (python.int x 2)) 1) 0) (- (- 25.5 (python.int x 2)) 1) (- (- (- 25.5 (python.int x 2)) 1)))) (<= (ite (>= (- 25.5 (python.int x 2)) 0) (- 25.5 (python.int x 2)) (- (- 25.5 (python.int x 2)))) (ite (>= (+ (- 25.5 (python.int x 2)) 1) 0) (+ (- 25.5 (python.int x 2)) 1) (- (+ (- 25.5 (python.int x 2)) 1))))))
(assert (> (str.len x) 0))
(assert (=> (not (< (ite (>= (+ (- 25.5 (python.int x 2)) 1) 0) (+ (- 25.5 (python.int x 2)) 1) (- (+ (- 25.5 (python.int x 2)) 1))) (ite (>= (- (- 25.5 (python.int x 2)) 1) 0) (- (- 25.5 (python.int x 2)) 1) (- (- (- 25.5 (python.int x 2)) 1))))) (<= (ite (>= (- 25.5 (python.int x 2)) 0) (- 25.5 (python.int x 2)) (- (- 25.5 (python.int x 2)))) (ite (>= (- (- 25.5 (python.int x 2)) 1) 0) (- (- 25.5 (python.int x 2)) 1) (- (- (- 25.5 (python.int x 2)) 1))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "1AB11")
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_9)))))")

Found solution 1AB11
Exception in checking result: invalid literal for int() with base 2: '1AB11'
WARNING: Solution verification failed for puzzle BinaryAverage:3
Too many constants for extrapolation

Solving puzzle 256/774: BinaryAverage:4
sat_func def sat(s: str, a=-89, b=0):
    n = int(s, 2)
    r = range(a, b)
    if len(r) == 0:
        return n == -1
    mu = sum(r) / len(r)
    return abs(mu - n) <= min(abs(mu - n - 1), abs(mu - n + 1))
modified_func def sat(s: str, a=-wrap_int(89), b=wrap_int(0)):
    n = sym_int(s, wrap_int(2))
    r = sym_range(a, b)
    if sym_len(r) == wrap_int(0):
        return n == -wrap_int(1)
    mu = sym_sum(r) / sym_len(r)
    return abs(mu - n) <= min(abs(mu - n - wrap_int(1)), abs(mu - n + wrap_int(1)))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len x) 0))
(assert (=> (< (ite (>= (+ (- -45.0 (python.int x 2)) 1) 0) (+ (- -45.0 (python.int x 2)) 1) (- (+ (- -45.0 (python.int x 2)) 1))) (ite (>= (- (- -45.0 (python.int x 2)) 1) 0) (- (- -45.0 (python.int x 2)) 1) (- (- (- -45.0 (python.int x 2)) 1)))) (<= (ite (>= (- -45.0 (python.int x 2)) 0) (- -45.0 (python.int x 2)) (- (- -45.0 (python.int x 2)))) (ite (>= (+ (- -45.0 (python.int x 2)) 1) 0) (+ (- -45.0 (python.int x 2)) 1) (- (+ (- -45.0 (python.int x 2)) 1))))))
(assert (> (str.len x) 0))
(assert (=> (not (< (ite (>= (+ (- -45.0 (python.int x 2)) 1) 0) (+ (- -45.0 (python.int x 2)) 1) (- (+ (- -45.0 (python.int x 2)) 1))) (ite (>= (- (- -45.0 (python.int x 2)) 1) 0) (- (- -45.0 (python.int x 2)) 1) (- (- (- -45.0 (python.int x 2)) 1))))) (<= (ite (>= (- -45.0 (python.int x 2)) 0) (- -45.0 (python.int x 2)) (- (- -45.0 (python.int x 2)))) (ite (>= (- (- -45.0 (python.int x 2)) 1) 0) (- (- -45.0 (python.int x 2)) 1) (- (- (- -45.0 (python.int x 2)) 1))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2.0 (to_real (+ (- 1) (str.len (bin-to-int_arg_0_4 @quantifiers_skolemize_9)))))")

Could not find any solution for puzzle BinaryAverage:4
Too many constants for extrapolation

Solving puzzle 257/774: CharCounts:0
sat_func def sat(s: str, counts={'a': 4, 'b': 17, 'd': 101, 'e': 0, 'f': 12}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
modified_func def sat(s: str, counts={wrap_str('a'): wrap_int(4), wrap_str('b'): wrap_int(17), wrap_str('d'): wrap_int(101), wrap_str('e'): wrap_int(0), wrap_str('f'): wrap_int(12)}):
    chars = s.split()
    for c in chars:
        _assert(chars.count(c) == counts[c])
    return sym_len(chars) == sym_sum(counts.values())
Exception -- for puzzle CharCounts:0 Symbolic hash not yet implemented

Solving puzzle 258/774: CharCounts:1
sat_func def sat(s: str, counts={'z': 0, 'e': 0, 'd': 7, 'o': 3, 'y': 8, 'w': 3, 'a': 0}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
modified_func def sat(s: str, counts={wrap_str('z'): wrap_int(0), wrap_str('e'): wrap_int(0), wrap_str('d'): wrap_int(7), wrap_str('o'): wrap_int(3), wrap_str('y'): wrap_int(8), wrap_str('w'): wrap_int(3), wrap_str('a'): wrap_int(0)}):
    chars = s.split()
    for c in chars:
        _assert(chars.count(c) == counts[c])
    return sym_len(chars) == sym_sum(counts.values())
Exception -- for puzzle CharCounts:1 Symbolic hash not yet implemented

Solving puzzle 259/774: CharCounts:2
sat_func def sat(s: str, counts={'s': 8, 'z': 6, 'd': 1, 'o': 6}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
modified_func def sat(s: str, counts={wrap_str('s'): wrap_int(8), wrap_str('z'): wrap_int(6), wrap_str('d'): wrap_int(1), wrap_str('o'): wrap_int(6)}):
    chars = s.split()
    for c in chars:
        _assert(chars.count(c) == counts[c])
    return sym_len(chars) == sym_sum(counts.values())
Exception -- for puzzle CharCounts:2 Symbolic hash not yet implemented

Solving puzzle 260/774: CharCounts:3
sat_func def sat(s: str, counts={'c': 5, 'p': 6, 'j': 0, 'g': 1, 'w': 4, 'k': 8}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
modified_func def sat(s: str, counts={wrap_str('c'): wrap_int(5), wrap_str('p'): wrap_int(6), wrap_str('j'): wrap_int(0), wrap_str('g'): wrap_int(1), wrap_str('w'): wrap_int(4), wrap_str('k'): wrap_int(8)}):
    chars = s.split()
    for c in chars:
        _assert(chars.count(c) == counts[c])
    return sym_len(chars) == sym_sum(counts.values())
Exception -- for puzzle CharCounts:3 Symbolic hash not yet implemented

Solving puzzle 261/774: CharCounts:4
sat_func def sat(s: str, counts={'c': 2}):
    chars = s.split()
    for c in chars:
        assert chars.count(c) == counts[c]
    return len(chars) == sum(counts.values())
modified_func def sat(s: str, counts={wrap_str('c'): wrap_int(2)}):
    chars = s.split()
    for c in chars:
        _assert(chars.count(c) == counts[c])
    return sym_len(chars) == sym_sum(counts.values())
Exception -- for puzzle CharCounts:4 Symbolic hash not yet implemented

Solving puzzle 262/774: VowelSandwich:0
sat_func def sat(ham: str, s="Any vowel is OK"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
modified_func def sat(ham: str, s=wrap_str('Any vowel is OK')):
    vows = wrap_str('aeiou')
    cons = wrap_str('bcdfghjklmnpqrstvwxz')
    return sym_in(ham, s).__and__(sym_in(ham[wrap_int(0)].lower(), cons)).__and__(sym_in(ham[wrap_int(1)].lower(), vows)).__and__(sym_in(ham[wrap_int(2)].lower(), cons))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x String)
(assert (and (and (and (str.contains "Any vowel is OK" x) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 0)))) (str.contains "aeiou" (str.lower (python.str.at x 1)))) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 2)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle VowelSandwich:0
Too many constants for extrapolation

Solving puzzle 263/774: VowelSandwich:1
sat_func def sat(ham: str, s="wOwwwww!"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
modified_func def sat(ham: str, s=wrap_str('wOwwwww!')):
    vows = wrap_str('aeiou')
    cons = wrap_str('bcdfghjklmnpqrstvwxz')
    return sym_in(ham, s).__and__(sym_in(ham[wrap_int(0)].lower(), cons)).__and__(sym_in(ham[wrap_int(1)].lower(), vows)).__and__(sym_in(ham[wrap_int(2)].lower(), cons))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x String)
(assert (and (and (and (str.contains "wOwwwww!" x) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 0)))) (str.contains "aeiou" (str.lower (python.str.at x 1)))) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 2)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle VowelSandwich:1
Too many constants for extrapolation

Solving puzzle 264/774: VowelSandwich:2
sat_func def sat(ham: str, s="do pyp you know ?"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
modified_func def sat(ham: str, s=wrap_str('do pyp you know ?')):
    vows = wrap_str('aeiou')
    cons = wrap_str('bcdfghjklmnpqrstvwxz')
    return sym_in(ham, s).__and__(sym_in(ham[wrap_int(0)].lower(), cons)).__and__(sym_in(ham[wrap_int(1)].lower(), vows)).__and__(sym_in(ham[wrap_int(2)].lower(), cons))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x String)
(assert (and (and (and (str.contains "do pyp you know ?" x) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 0)))) (str.contains "aeiou" (str.lower (python.str.at x 1)))) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 2)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle VowelSandwich:2
Too many constants for extrapolation

Solving puzzle 265/774: VowelSandwich:3
sat_func def sat(ham: str, s="zocofiwihilyfizi ku pivanydebodygawepu nyfanusocosypinezaz pune"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
modified_func def sat(ham: str, s=wrap_str('zocofiwihilyfizi ku pivanydebodygawepu nyfanusocosypinezaz pune')):
    vows = wrap_str('aeiou')
    cons = wrap_str('bcdfghjklmnpqrstvwxz')
    return sym_in(ham, s).__and__(sym_in(ham[wrap_int(0)].lower(), cons)).__and__(sym_in(ham[wrap_int(1)].lower(), vows)).__and__(sym_in(ham[wrap_int(2)].lower(), cons))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x String)
(assert (and (and (and (str.contains "zocofiwihilyfizi ku pivanydebodygawepu nyfanusocosypinezaz pune" x) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 0)))) (str.contains "aeiou" (str.lower (python.str.at x 1)))) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 2)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle VowelSandwich:3
Too many constants for extrapolation

Solving puzzle 266/774: VowelSandwich:4
sat_func def sat(ham: str, s="citextitozuwatextoq hutextawicogylalex wi wamu"):
    vows = "aeiou"
    cons = "bcdfghjklmnpqrstvwxz"
    return ham in s and ham[0].lower() in cons and ham[1].lower() in vows and ham[2].lower() in cons
modified_func def sat(ham: str, s=wrap_str('citextitozuwatextoq hutextawicogylalex wi wamu')):
    vows = wrap_str('aeiou')
    cons = wrap_str('bcdfghjklmnpqrstvwxz')
    return sym_in(ham, s).__and__(sym_in(ham[wrap_int(0)].lower(), cons)).__and__(sym_in(ham[wrap_int(1)].lower(), vows)).__and__(sym_in(ham[wrap_int(2)].lower(), cons))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x String)
(assert (and (and (and (str.contains "citextitozuwatextoq hutextawicogylalex wi wamu" x) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 0)))) (str.contains "aeiou" (str.lower (python.str.at x 1)))) (str.contains "bcdfghjklmnpqrstvwxz" (str.lower (python.str.at x 2)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle VowelSandwich:4
Too many constants for extrapolation

Solving puzzle 267/774: ParenthesesPermutation:0
sat_func def sat(perm: str, s="))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  (((((((((("):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
modified_func def sat(perm: str, s=wrap_str('))(  )()()() )))(( ))))((( )))))(((( ))))))))((((((( ))))))((((( )))))))(((((( )))))))))(((((((  ((((((((((')):
    _assert(sym_sorted(perm.split()) == sym_sorted(s.split()), wrap_str("Must be a permutation of the space-delimited 'groups'"))
    return all(sym_generator((perm[:i].count('(') >= perm[:i].count(')') for i in sym_range(sym_len(perm)))))
Exception -- for puzzle ParenthesesPermutation:0 Cannot convert symbolic integer to index

Solving puzzle 268/774: ParenthesesPermutation:1
sat_func def sat(perm: str, s=" (( ()(())())() ())(())))(()()) (((((((()(()))(( ()()))) )())))) ()()()(((())()"):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
modified_func def sat(perm: str, s=wrap_str(' (( ()(())())() ())(())))(()()) (((((((()(()))(( ()()))) )())))) ()()()(((())()')):
    _assert(sym_sorted(perm.split()) == sym_sorted(s.split()), wrap_str("Must be a permutation of the space-delimited 'groups'"))
    return all(sym_generator((perm[:i].count('(') >= perm[:i].count(')') for i in sym_range(sym_len(perm)))))
Exception -- for puzzle ParenthesesPermutation:1 Cannot convert symbolic integer to index

Solving puzzle 269/774: ParenthesesPermutation:2
sat_func def sat(perm: str, s="()()(( ))"):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
modified_func def sat(perm: str, s=wrap_str('()()(( ))')):
    _assert(sym_sorted(perm.split()) == sym_sorted(s.split()), wrap_str("Must be a permutation of the space-delimited 'groups'"))
    return all(sym_generator((perm[:i].count('(') >= perm[:i].count(')') for i in sym_range(sym_len(perm)))))
Exception -- for puzzle ParenthesesPermutation:2 Cannot convert symbolic integer to index

Solving puzzle 270/774: ParenthesesPermutation:3
sat_func def sat(perm: str, s=""):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
modified_func def sat(perm: str, s=wrap_str('')):
    _assert(sym_sorted(perm.split()) == sym_sorted(s.split()), wrap_str("Must be a permutation of the space-delimited 'groups'"))
    return all(sym_generator((perm[:i].count('(') >= perm[:i].count(')') for i in sym_range(sym_len(perm)))))
Exception -- for puzzle ParenthesesPermutation:3 Cannot convert symbolic integer to index

Solving puzzle 271/774: ParenthesesPermutation:4
sat_func def sat(perm: str, s="()(()())( )()"):
    assert sorted(perm.split()) == sorted(s.split()), "Must be a permutation of the space-delimited 'groups'"
    return all(perm[:i].count("(") >= perm[:i].count(")") for i in range(len(perm)))
modified_func def sat(perm: str, s=wrap_str('()(()())( )()')):
    _assert(sym_sorted(perm.split()) == sym_sorted(s.split()), wrap_str("Must be a permutation of the space-delimited 'groups'"))
    return all(sym_generator((perm[:i].count('(') >= perm[:i].count(')') for i in sym_range(sym_len(perm)))))
Exception -- for puzzle ParenthesesPermutation:4 Cannot convert symbolic integer to index

Solving puzzle 272/774: OddEvenSum:0
sat_func def sat(tot: int, nums=[18, 42152, 125023521, -1221873620123, 17, 19]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
modified_func def sat(tot: int, nums=wrap_list([wrap_int(18), wrap_int(42152), wrap_int(125023521), -wrap_int(1221873620123), wrap_int(17), wrap_int(19)])):
    for i in nums[::2]:
        if i % wrap_int(2) == wrap_int(1):
            tot -= i
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- x 125023521) 17) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    125023538)
)
### output for cvc5
sat
(
(define-fun x () Int 125023538)
)

Found solution 125023538
Yes! Solved for puzzle  OddEvenSum:0

Solving puzzle 273/774: OddEvenSum:1
sat_func def sat(tot: int, nums=[-52, 89, -74, -27]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
modified_func def sat(tot: int, nums=wrap_list([-wrap_int(52), wrap_int(89), -wrap_int(74), -wrap_int(27)])):
    for i in nums[::2]:
        if i % wrap_int(2) == wrap_int(1):
            tot -= i
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  OddEvenSum:1

Solving puzzle 274/774: OddEvenSum:2
sat_func def sat(tot: int, nums=[-95, -24, -50, -51, -18, -77, -61, 64, 7]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
modified_func def sat(tot: int, nums=wrap_list([-wrap_int(95), -wrap_int(24), -wrap_int(50), -wrap_int(51), -wrap_int(18), -wrap_int(77), -wrap_int(61), wrap_int(64), wrap_int(7)])):
    for i in nums[::2]:
        if i % wrap_int(2) == wrap_int(1):
            tot -= i
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- x -95) -61) 7) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 149))
)
### output for cvc5
sat
(
(define-fun x () Int (- 149))
)

Found solution -149
Yes! Solved for puzzle  OddEvenSum:2

Solving puzzle 275/774: OddEvenSum:3
sat_func def sat(tot: int, nums=[-85, -83, 62, -27, -37, -76, -10, 40, 34, -20]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
modified_func def sat(tot: int, nums=wrap_list([-wrap_int(85), -wrap_int(83), wrap_int(62), -wrap_int(27), -wrap_int(37), -wrap_int(76), -wrap_int(10), wrap_int(40), wrap_int(34), -wrap_int(20)])):
    for i in nums[::2]:
        if i % wrap_int(2) == wrap_int(1):
            tot -= i
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- x -85) -37) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 122))
)
### output for cvc5
sat
(
(define-fun x () Int (- 122))
)

Found solution -122
Yes! Solved for puzzle  OddEvenSum:3

Solving puzzle 276/774: OddEvenSum:4
sat_func def sat(tot: int, nums=[-11, -9, -29, 30, -70]):
    for i in nums[::2]:
        if i % 2 == 1:
            tot -= i
    return tot == 0
modified_func def sat(tot: int, nums=wrap_list([-wrap_int(11), -wrap_int(9), -wrap_int(29), wrap_int(30), -wrap_int(70)])):
    for i in nums[::2]:
        if i % wrap_int(2) == wrap_int(1):
            tot -= i
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- x -11) -29) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 40))
)
### output for cvc5
sat
(
(define-fun x () Int (- 40))
)

Found solution -40
Yes! Solved for puzzle  OddEvenSum:4

Solving puzzle 277/774: LongEarlySum:0
sat_func def sat(tot: int, k=5, nums=[1252, 125273523, 0, 42, 100, 214532, 2, 0, 11, 14]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
modified_func def sat(tot: int, k=wrap_int(5), nums=wrap_list([wrap_int(1252), wrap_int(125273523), wrap_int(0), wrap_int(42), wrap_int(100), wrap_int(214532), wrap_int(2), wrap_int(0), wrap_int(11), wrap_int(14)])):
    for n in nums[:k]:
        if sym_len(sym_str(abs(n))) > wrap_int(2):
            tot -= n
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- x 1252) 125273523) 100) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    125274875)
)
### output for cvc5
sat
(
(define-fun x () Int 125274875)
)

Found solution 125274875
Yes! Solved for puzzle  LongEarlySum:0

Solving puzzle 278/774: LongEarlySum:1
sat_func def sat(tot: int, k=5, nums=[-7157016423, 2782843150, 7219126112, -6508908448, -2700793649]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
modified_func def sat(tot: int, k=wrap_int(5), nums=wrap_list([-wrap_int(7157016423), wrap_int(2782843150), wrap_int(7219126112), -wrap_int(6508908448), -wrap_int(2700793649)])):
    for n in nums[:k]:
        if sym_len(sym_str(abs(n))) > wrap_int(2):
            tot -= n
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- (- x -7157016423) 2782843150) 7219126112) -6508908448) -2700793649) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 6364749258))
)
### output for cvc5
sat
(
(define-fun x () Int (- 6364749258))
)

Found solution -6364749258
Yes! Solved for puzzle  LongEarlySum:1

Solving puzzle 279/774: LongEarlySum:2
sat_func def sat(tot: int, k=9, nums=[-5897482060, -6124803429, 460595384, -4038677051, 4034899461, 4374130613, -107107411]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
modified_func def sat(tot: int, k=wrap_int(9), nums=wrap_list([-wrap_int(5897482060), -wrap_int(6124803429), wrap_int(460595384), -wrap_int(4038677051), wrap_int(4034899461), wrap_int(4374130613), -wrap_int(107107411)])):
    for n in nums[:k]:
        if sym_len(sym_str(abs(n))) > wrap_int(2):
            tot -= n
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- (- (- (- x -5897482060) -6124803429) 460595384) -4038677051) 4034899461) 4374130613) -107107411) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 7298444493))
)
### output for cvc5
sat
(
(define-fun x () Int (- 7298444493))
)

Found solution -7298444493
Yes! Solved for puzzle  LongEarlySum:2

Solving puzzle 280/774: LongEarlySum:3
sat_func def sat(tot: int, k=9, nums=[-8188839170, -4196027936, 7189346049, -3904396164, -6197615761, -1925353242, 4455917604, -60399777, 2265288077, -5809369361, -1403148167, 4937241577, 6147738064, 2911928645, -3466247912]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
modified_func def sat(tot: int, k=wrap_int(9), nums=wrap_list([-wrap_int(8188839170), -wrap_int(4196027936), wrap_int(7189346049), -wrap_int(3904396164), -wrap_int(6197615761), -wrap_int(1925353242), wrap_int(4455917604), -wrap_int(60399777), wrap_int(2265288077), -wrap_int(5809369361), -wrap_int(1403148167), wrap_int(4937241577), wrap_int(6147738064), wrap_int(2911928645), -wrap_int(3466247912)])):
    for n in nums[:k]:
        if sym_len(sym_str(abs(n))) > wrap_int(2):
            tot -= n
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- (- (- (- (- (- x -8188839170) -4196027936) 7189346049) -3904396164) -6197615761) -1925353242) 4455917604) -60399777) 2265288077) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 10562080320))
)
### output for cvc5
sat
(
(define-fun x () Int (- 10562080320))
)

Found solution -10562080320
Yes! Solved for puzzle  LongEarlySum:3

Solving puzzle 281/774: LongEarlySum:4
sat_func def sat(tot: int, k=7, nums=[9205334525, 5459823374, -7169802732, 9865454706, -7321060937, 6045166493, 15149444, 1118638089, -4595115991, -3388779539]):
    for n in nums[:k]:
        if len(str(abs(n))) > 2:
            tot -= n
    return tot == 0
modified_func def sat(tot: int, k=wrap_int(7), nums=wrap_list([wrap_int(9205334525), wrap_int(5459823374), -wrap_int(7169802732), wrap_int(9865454706), -wrap_int(7321060937), wrap_int(6045166493), wrap_int(15149444), wrap_int(1118638089), -wrap_int(4595115991), -wrap_int(3388779539)])):
    for n in nums[:k]:
        if sym_len(sym_str(abs(n))) > wrap_int(2):
            tot -= n
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- (- (- (- (- (- (- x 9205334525) 5459823374) -7169802732) 9865454706) -7321060937) 6045166493) 15149444) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    16100064873)
)
### output for cvc5
sat
(
(define-fun x () Int 16100064873)
)

Found solution 16100064873
Yes! Solved for puzzle  LongEarlySum:4

Solving puzzle 282/774: DateDiff:0
sat_func def sat(s: str, target=-2075):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
modified_func def sat(s: str, target=-wrap_int(2075)):
    _assert(all(sym_generator((sym_in(c, wrap_str('0123457689-')) for c in s))).__and__((s[wrap_int(2)] == s[wrap_int(5)]).__and__(s[wrap_int(5)] == wrap_str('-'))))
    m, d, y = [sym_int(n) for n in s.split(wrap_str('-'))]
    _assert(sym_in(m, sym_range(1, 13)))
    _assert(sym_in(d, sym_range(1, 32)))
    if sym_in(m, wrap_list([wrap_int(4), wrap_int(6), wrap_int(9), wrap_int(11)])):
        _assert(d <= wrap_int(30))
    if m == wrap_int(2):
        _assert(d <= wrap_int(29))
    return m - d - y == target
Exception -- for puzzle DateDiff:0 not enough values to unpack (expected 3, got 1)

Solving puzzle 283/774: DateDiff:1
sat_func def sat(s: str, target=11):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
modified_func def sat(s: str, target=wrap_int(11)):
    _assert(all(sym_generator((sym_in(c, wrap_str('0123457689-')) for c in s))).__and__((s[wrap_int(2)] == s[wrap_int(5)]).__and__(s[wrap_int(5)] == wrap_str('-'))))
    m, d, y = [sym_int(n) for n in s.split(wrap_str('-'))]
    _assert(sym_in(m, sym_range(1, 13)))
    _assert(sym_in(d, sym_range(1, 32)))
    if sym_in(m, wrap_list([wrap_int(4), wrap_int(6), wrap_int(9), wrap_int(11)])):
        _assert(d <= wrap_int(30))
    if m == wrap_int(2):
        _assert(d <= wrap_int(29))
    return m - d - y == target
Exception -- for puzzle DateDiff:1 not enough values to unpack (expected 3, got 1)

Solving puzzle 284/774: DateDiff:2
sat_func def sat(s: str, target=-30):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
modified_func def sat(s: str, target=-wrap_int(30)):
    _assert(all(sym_generator((sym_in(c, wrap_str('0123457689-')) for c in s))).__and__((s[wrap_int(2)] == s[wrap_int(5)]).__and__(s[wrap_int(5)] == wrap_str('-'))))
    m, d, y = [sym_int(n) for n in s.split(wrap_str('-'))]
    _assert(sym_in(m, sym_range(1, 13)))
    _assert(sym_in(d, sym_range(1, 32)))
    if sym_in(m, wrap_list([wrap_int(4), wrap_int(6), wrap_int(9), wrap_int(11)])):
        _assert(d <= wrap_int(30))
    if m == wrap_int(2):
        _assert(d <= wrap_int(29))
    return m - d - y == target
Exception -- for puzzle DateDiff:2 not enough values to unpack (expected 3, got 1)

Solving puzzle 285/774: DateDiff:3
sat_func def sat(s: str, target=-1999):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
modified_func def sat(s: str, target=-wrap_int(1999)):
    _assert(all(sym_generator((sym_in(c, wrap_str('0123457689-')) for c in s))).__and__((s[wrap_int(2)] == s[wrap_int(5)]).__and__(s[wrap_int(5)] == wrap_str('-'))))
    m, d, y = [sym_int(n) for n in s.split(wrap_str('-'))]
    _assert(sym_in(m, sym_range(1, 13)))
    _assert(sym_in(d, sym_range(1, 32)))
    if sym_in(m, wrap_list([wrap_int(4), wrap_int(6), wrap_int(9), wrap_int(11)])):
        _assert(d <= wrap_int(30))
    if m == wrap_int(2):
        _assert(d <= wrap_int(29))
    return m - d - y == target
Exception -- for puzzle DateDiff:3 not enough values to unpack (expected 3, got 1)

Solving puzzle 286/774: DateDiff:4
sat_func def sat(s: str, target=-10029):
    assert all(c in "0123457689-" for c in s) and s[2] == s[5] == "-"
    m, d, y = [int(n) for n in s.split("-")]
    assert m in range(1, 13)
    assert d in range(1, 32)
    if m in [4, 6, 9, 11]:
        assert d <= 30
    if m == 2:
        assert d <= 29
    return m - d - y == target
modified_func def sat(s: str, target=-wrap_int(10029)):
    _assert(all(sym_generator((sym_in(c, wrap_str('0123457689-')) for c in s))).__and__((s[wrap_int(2)] == s[wrap_int(5)]).__and__(s[wrap_int(5)] == wrap_str('-'))))
    m, d, y = [sym_int(n) for n in s.split(wrap_str('-'))]
    _assert(sym_in(m, sym_range(1, 13)))
    _assert(sym_in(d, sym_range(1, 32)))
    if sym_in(m, wrap_list([wrap_int(4), wrap_int(6), wrap_int(9), wrap_int(11)])):
        _assert(d <= wrap_int(30))
    if m == wrap_int(2):
        _assert(d <= wrap_int(29))
    return m - d - y == target
Exception -- for puzzle DateDiff:4 not enough values to unpack (expected 3, got 1)

Solving puzzle 287/774: ProductSigns:0
sat_func def sat(n: int, arr=[1, 7, -20052, 14, -3, -11, 1025235, 14]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
modified_func def sat(n: int, arr=wrap_list([wrap_int(1), wrap_int(7), -wrap_int(20052), wrap_int(14), -wrap_int(3), -wrap_int(11), wrap_int(1025235), wrap_int(14)])):
    tot = wrap_int(0)
    for i in arr:
        if tot >= wrap_int(0):
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < wrap_int(0):
            tot = -tot
        elif i == wrap_int(0):
            tot = wrap_int(0)
            break
    return n == tot
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x -1045337))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1045337))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1045337))
)

Found solution -1045337
Yes! Solved for puzzle  ProductSigns:0

Solving puzzle 288/774: ProductSigns:1
sat_func def sat(n: int, arr=[13, 38, 57, 6, -79, 85, -96, 60, 45, 37, 66]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
modified_func def sat(n: int, arr=wrap_list([wrap_int(13), wrap_int(38), wrap_int(57), wrap_int(6), -wrap_int(79), wrap_int(85), -wrap_int(96), wrap_int(60), wrap_int(45), wrap_int(37), wrap_int(66)])):
    tot = wrap_int(0)
    for i in arr:
        if tot >= wrap_int(0):
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < wrap_int(0):
            tot = -tot
        elif i == wrap_int(0):
            tot = wrap_int(0)
            break
    return n == tot
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 582))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    582)
)
### output for cvc5
sat
(
(define-fun x () Int 582)
)

Found solution 582
Yes! Solved for puzzle  ProductSigns:1

Solving puzzle 289/774: ProductSigns:2
sat_func def sat(n: int, arr=[-58, -49, -56, 75, 52, -54, -95]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
modified_func def sat(n: int, arr=wrap_list([-wrap_int(58), -wrap_int(49), -wrap_int(56), wrap_int(75), wrap_int(52), -wrap_int(54), -wrap_int(95)])):
    tot = wrap_int(0)
    for i in arr:
        if tot >= wrap_int(0):
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < wrap_int(0):
            tot = -tot
        elif i == wrap_int(0):
            tot = wrap_int(0)
            break
    return n == tot
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x -439))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 439))
)
### output for cvc5
sat
(
(define-fun x () Int (- 439))
)

Found solution -439
Yes! Solved for puzzle  ProductSigns:2

Solving puzzle 290/774: ProductSigns:3
sat_func def sat(n: int, arr=[-41, 67, -27, -41, 16, 1, 66, -91, 4, 36, 10, -95, 7, 54, -97, -87]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
modified_func def sat(n: int, arr=wrap_list([-wrap_int(41), wrap_int(67), -wrap_int(27), -wrap_int(41), wrap_int(16), wrap_int(1), wrap_int(66), -wrap_int(91), wrap_int(4), wrap_int(36), wrap_int(10), -wrap_int(95), wrap_int(7), wrap_int(54), -wrap_int(97), -wrap_int(87)])):
    tot = wrap_int(0)
    for i in arr:
        if tot >= wrap_int(0):
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < wrap_int(0):
            tot = -tot
        elif i == wrap_int(0):
            tot = wrap_int(0)
            break
    return n == tot
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x -740))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 740))
)
### output for cvc5
sat
(
(define-fun x () Int (- 740))
)

Found solution -740
Yes! Solved for puzzle  ProductSigns:3

Solving puzzle 291/774: ProductSigns:4
sat_func def sat(n: int, arr=[-62, 46, -83, -14]):
    tot = 0

    for i in arr:
        if tot >= 0:
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < 0:
            tot = -tot
        elif i == 0:
            tot = 0
            break

    return n == tot
modified_func def sat(n: int, arr=wrap_list([-wrap_int(62), wrap_int(46), -wrap_int(83), -wrap_int(14)])):
    tot = wrap_int(0)
    for i in arr:
        if tot >= wrap_int(0):
            tot += abs(i)
        else:
            tot -= abs(i)
        if i < wrap_int(0):
            tot = -tot
        elif i == wrap_int(0):
            tot = wrap_int(0)
            break
    return n == tot
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x -205))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 205))
)
### output for cvc5
sat
(
(define-fun x () Int (- 205))
)

Found solution -205
Yes! Solved for puzzle  ProductSigns:4

Solving puzzle 292/774: OddProduct:0
sat_func def sat(prod: int, n=14235764939971075543215213):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
modified_func def sat(prod: int, n=wrap_int(14235764939971075543215213)):
    for c in sym_str(n):
        i = sym_int(c)
        if i % wrap_int(2) == wrap_int(1):
            _assert(prod % i == wrap_int(0))
            prod //= i
    return prod == any(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(n))))
Timed out for puzzle OddProduct:0

Solving puzzle 293/774: OddProduct:1
sat_func def sat(prod: int, n=8502):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
modified_func def sat(prod: int, n=wrap_int(8502)):
    for c in sym_str(n):
        i = sym_int(c)
        if i % wrap_int(2) == wrap_int(1):
            _assert(prod % i == wrap_int(0))
            prod //= i
    return prod == any(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(n))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (mod x 5) 0))
(assert (= (div x 5) (ite (not (= (ite (not (= (ite false 0 1) 0)) (ite false 0 1) 0) 0)) (ite (not (= (ite false 0 1) 0)) (ite false 0 1) 0) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    5)
)
### output for cvc5
sat
(
(define-fun x () Int 5)
)

Found solution 5
Yes! Solved for puzzle  OddProduct:1

Solving puzzle 294/774: OddProduct:2
sat_func def sat(prod: int, n=95973):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
modified_func def sat(prod: int, n=wrap_int(95973)):
    for c in sym_str(n):
        i = sym_int(c)
        if i % wrap_int(2) == wrap_int(1):
            _assert(prod % i == wrap_int(0))
            prod //= i
    return prod == any(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(n))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (mod x 9) 0))
(assert (= (mod (div x 9) 5) 0))
(assert (= (mod (div (div x 9) 5) 9) 0))
(assert (= (mod (div (div (div x 9) 5) 9) 7) 0))
(assert (= (mod (div (div (div (div x 9) 5) 9) 7) 3) 0))
(assert (= (div (div (div (div (div x 9) 5) 9) 7) 3) (ite (not (= (ite (not (= (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 0)) (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 1) 0)) (ite (not (= (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 0)) (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 1) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8505)
)
### output for cvc5
sat
(
(define-fun x () Int 8505)
)

Found solution 8505
Yes! Solved for puzzle  OddProduct:2

Solving puzzle 295/774: OddProduct:3
sat_func def sat(prod: int, n=0):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
modified_func def sat(prod: int, n=wrap_int(0)):
    for c in sym_str(n):
        i = sym_int(c)
        if i % wrap_int(2) == wrap_int(1):
            _assert(prod % i == wrap_int(0))
            prod //= i
    return prod == any(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(n))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  OddProduct:3

Solving puzzle 296/774: OddProduct:4
sat_func def sat(prod: int, n=331901673137376013):

    for c in str(n):
        i = int(c)
        if i % 2 == 1:
            assert prod % i == 0
            prod //= i
    return prod == any(int(c) % 2 for c in str(n))
modified_func def sat(prod: int, n=wrap_int(331901673137376013)):
    for c in sym_str(n):
        i = sym_int(c)
        if i % wrap_int(2) == wrap_int(1):
            _assert(prod % i == wrap_int(0))
            prod //= i
    return prod == any(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(n))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (mod x 3) 0))
(assert (= (mod (div x 3) 3) 0))
(assert (= (mod (div (div x 3) 3) 1) 0))
(assert (= (mod (div (div (div x 3) 3) 1) 9) 0))
(assert (= (mod (div (div (div (div x 3) 3) 1) 9) 1) 0))
(assert (= (mod (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 0))
(assert (= (mod (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 0))
(assert (= (mod (div (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 1) 0))
(assert (= (mod (div (div (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 1) 3) 0))
(assert (= (mod (div (div (div (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 1) 3) 7) 0))
(assert (= (mod (div (div (div (div (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 1) 3) 7) 3) 0))
(assert (= (mod (div (div (div (div (div (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 1) 3) 7) 3) 7) 0))
(assert (= (mod (div (div (div (div (div (div (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 1) 3) 7) 3) 7) 1) 0))
(assert (= (mod (div (div (div (div (div (div (div (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 1) 3) 7) 3) 7) 1) 3) 0))
(assert (= (div (div (div (div (div (div (div (div (div (div (div (div (div (div x 3) 3) 1) 9) 1) 7) 3) 1) 3) 7) 3) 7) 1) 3) (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 0)) (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 1) 0)) (ite (not (= (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 0)) (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 1) 0) 0)) (ite (not (= (ite (not (= (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 0)) (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 1) 0)) (ite (not (= (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 0)) (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 1) 0) 1) 0)) (ite (not (= (ite (not (= (ite (not (= (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 0)) (ite (not (= (ite true 1 1) 0)) (ite true 1 1) 1) 1) 0)) (ite (not (= (ite (not (=...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2250423)
)
### output for cvc5
sat
(
(define-fun x () Int 2250423)
)

Found solution 2250423
Yes! Solved for puzzle  OddProduct:4

Solving puzzle 297/774: ValidBracketSubsequence:0
sat_func def sat(valid: str, s="]]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[["):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
modified_func def sat(valid: str, s=wrap_str(']]]]]]]]]]]]]]]]][][][][]]]]]]]]]]][[[][[][[[[[][][][]][[[[[[[[[[[[[[[[[[')):
    _assert(sym_in(valid, s))
    depths = wrap_list([wrap_int(0)])
    for c in valid:
        if c == wrap_str('['):
            depths.append(depths[-wrap_int(1)] + wrap_int(1))
        elif c == wrap_str(']'):
            depths.append(depths[-wrap_int(1)] - wrap_int(1))
    return (depths[-wrap_int(1)] == wrap_int(0)).__and__(min(depths) == wrap_int(0)).__and__(max(depths) > wrap_int(1))
Exception -- for puzzle ValidBracketSubsequence:0 'SymbolicList' object has no attribute 'append'

Solving puzzle 298/774: ValidBracketSubsequence:1
sat_func def sat(valid: str, s="[[[[][][][][][][]][[]][]][[[][]][[]]"):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
modified_func def sat(valid: str, s=wrap_str('[[[[][][][][][][]][[]][]][[[][]][[]]')):
    _assert(sym_in(valid, s))
    depths = wrap_list([wrap_int(0)])
    for c in valid:
        if c == wrap_str('['):
            depths.append(depths[-wrap_int(1)] + wrap_int(1))
        elif c == wrap_str(']'):
            depths.append(depths[-wrap_int(1)] - wrap_int(1))
    return (depths[-wrap_int(1)] == wrap_int(0)).__and__(min(depths) == wrap_int(0)).__and__(max(depths) > wrap_int(1))
Exception -- for puzzle ValidBracketSubsequence:1 'SymbolicList' object has no attribute 'append'

Solving puzzle 299/774: ValidBracketSubsequence:2
sat_func def sat(valid: str, s="]][[]][[][[[[][]]][[][[[]["):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
modified_func def sat(valid: str, s=wrap_str(']][[]][[][[[[][]]][[][[[][')):
    _assert(sym_in(valid, s))
    depths = wrap_list([wrap_int(0)])
    for c in valid:
        if c == wrap_str('['):
            depths.append(depths[-wrap_int(1)] + wrap_int(1))
        elif c == wrap_str(']'):
            depths.append(depths[-wrap_int(1)] - wrap_int(1))
    return (depths[-wrap_int(1)] == wrap_int(0)).__and__(min(depths) == wrap_int(0)).__and__(max(depths) > wrap_int(1))
Exception -- for puzzle ValidBracketSubsequence:2 'SymbolicList' object has no attribute 'append'

Solving puzzle 300/774: ValidBracketSubsequence:3
sat_func def sat(valid: str, s="][]]][]][[[][][][][][][][]][[]][[]]][["):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
modified_func def sat(valid: str, s=wrap_str('][]]][]][[[][][][][][][][]][[]][[]]][[')):
    _assert(sym_in(valid, s))
    depths = wrap_list([wrap_int(0)])
    for c in valid:
        if c == wrap_str('['):
            depths.append(depths[-wrap_int(1)] + wrap_int(1))
        elif c == wrap_str(']'):
            depths.append(depths[-wrap_int(1)] - wrap_int(1))
    return (depths[-wrap_int(1)] == wrap_int(0)).__and__(min(depths) == wrap_int(0)).__and__(max(depths) > wrap_int(1))
Exception -- for puzzle ValidBracketSubsequence:3 'SymbolicList' object has no attribute 'append'

Solving puzzle 301/774: ValidBracketSubsequence:4
sat_func def sat(valid: str, s="[[[][][[[[[[]][[]][[[][][][][][][][][]]["):
    assert valid in s
    depths = [0]
    for c in valid:
        if c == "[":
            depths.append(depths[-1] + 1)
        elif c == "]":
            depths.append(depths[-1] - 1)
    return depths[-1] == 0 and min(depths) == 0 and max(depths) > 1
modified_func def sat(valid: str, s=wrap_str('[[[][][[[[[[]][[]][[[][][][][][][][][]][')):
    _assert(sym_in(valid, s))
    depths = wrap_list([wrap_int(0)])
    for c in valid:
        if c == wrap_str('['):
            depths.append(depths[-wrap_int(1)] + wrap_int(1))
        elif c == wrap_str(']'):
            depths.append(depths[-wrap_int(1)] - wrap_int(1))
    return (depths[-wrap_int(1)] == wrap_int(0)).__and__(min(depths) == wrap_int(0)).__and__(max(depths) > wrap_int(1))
Exception -- for puzzle ValidBracketSubsequence:4 'SymbolicList' object has no attribute 'append'

Solving puzzle 302/774: LargestStringNum:0
sat_func def sat(x: float, str_nums=['1,3', '-11', '17.5', '-11', '2', '2.2', '2,2', '4', '-18,18', '99.09']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
modified_func def sat(x: float, str_nums=wrap_list([wrap_str('1,3'), wrap_str('-11'), wrap_str('17.5'), wrap_str('-11'), wrap_str('2'), wrap_str('2.2'), wrap_str('2,2'), wrap_str('4'), wrap_str('-18,18'), wrap_str('99.09')])):
    found = False
    for s in str_nums:
        y = sym_float(s.replace(wrap_str(','), wrap_str('.')))
        _assert(y <= x)
        if y == x:
            found = True
    return found
### smt2
(set-logic ALL)

(define-fun str.to.float ((s String)) Real
  (let ((dot_pos (str.indexof s "." 0)))
    (ite (= dot_pos (- 1))
      ; No decimal point - convert whole string as integer
      (to_real (str.to_int s))
      ; Has decimal point - handle integer and decimal parts
      (let ((int_part (str.substr s 0 dot_pos))
            (dec_part (str.substr s (+ dot_pos 1) (- (str.len s) (+ dot_pos 1)))))
        (+ (to_real (str.to_int int_part))
           (/ (to_real (str.to_int dec_part))
              (^ 10.0 (- (str.len s) (+ dot_pos 1)))))))))

(declare-const x Real)
(assert (<= (str.to.float "1.3") x))
(assert (=> (= (str.to.float "1.3") x) (<= (str.to.float "-11") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x)) (<= (str.to.float "17.5") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x) (= (str.to.float "17.5") x)) (<= (str.to.float "-11") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x) (= (str.to.float "17.5") x) (= (str.to.float "-11") x)) (<= (str.to.float "2") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x) (= (str.to.float "17.5") x) (= (str.to.float "-11") x) (= (str.to.float "2") x)) (<= (str.to.float "2.2") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x) (= (str.to.float "17.5") x) (= (str.to.float "-11") x) (= (str.to.float "2") x) (= (str.to.float "2.2") x)) (<= (str.to.float "2.2") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x) (= (str.to.float "17.5") x) (= (str.to.float "-11") x) (= (str.to.float "2") x) (= (str.to.float "2.2") x) (= (str.to.float "2.2") x)) (<= (str.to.float "4") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x) (= (str.to.float "17.5") x) (= (str.to.float "-11") x) (= (str.to.float "2") x) (= (str.to.float "2.2") x) (= (str.to.float "2.2") x) (= (str.to.float "4") x)) (<= (str.to.float "-18.18") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x) (= (str.to.float "17.5") x) (= (str.to.float "-11") x) (= (str.to.float "2") x) (= (str.to.float "2.2") x) (= (str.to.float "2.2") x) (= (str.to.float "4") x) (= (str.to.float "-18.18") x)) (<= (str.to.float "99.09") x)))
(assert (=> (and (= (str.to.float "1.3") x) (= (str.to.float "-11") x) (= (str.to.float "17.5") x) (= (str.to.float "-11") x) (= (str.to.float "2") x) (= (str.to.float "2.2") x) (= (str.to.float "2.2") x) (= (str.to.float "4") x) (= (str.to.float "-18.18") x) (= (str.to.float "99.09") x)) true))
(assert (<= (str.to.float "1.3") x))
(assert (=> (not (= (str.to.float "1.3") x)) (<= (str.to.float "-11") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x))) (<= (str.to.float "17.5") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "17.5") x))) (<= (str.to.float "-11") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "17.5") x)) (not (= (str.to.float "-11") x))) (<= (str.to.float "2") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "17.5") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "2") x))) (<= (str.to.float "2.2") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "17.5") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "2") x)) (not (= (str.to.float "2.2") x))) (<= (str.to.float "2.2") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "17.5") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "2") x)) (not (= (str.to.float "2.2") x)) (not (= (str.to.float "2.2") x))) (<= (str.to.float "4") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "17.5") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "2") x)) (not (= (str.to.float "2.2") x)) (not (= (str.to.float "2.2") x)) (not (= (str.to.float "4") x))) (<= (str.to.float "-18.18") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "17.5") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "2") x)) (not (= (str.to.float "2.2") x)) (not (= (str.to.float "2.2") x)) (not (= (str.to.float "4") x)) (not (= (str.to.float "-18.18") x))) (<= (str.to.float "99.09") x)))
(assert (=> (and (not (= (str.to.float "1.3") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "17.5") x)) (not (= (str.to.float "-11") x)) (not (= (str.to.float "2") x)) (not (= (str.to.float "2.2") x)) (not (= (str.to.float "2.2") x)) (not (= (str.to.float "4") x)) (not (= (str.to.float "-18.18") x)) (not (= (str.to.float "99.09") x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 35.0 2.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:13.52: expecting same arithmetic types to POW")

Found solution 17.5
Exception in checking result: 
WARNING: Solution verification failed for puzzle LargestStringNum:0
Too many constants for extrapolation

Solving puzzle 303/774: LargestStringNum:1
sat_func def sat(x: float, str_nums=['31.39683666368859', '73,72440474051831', '72.34060469647804', '73']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
modified_func def sat(x: float, str_nums=wrap_list([wrap_str('31.39683666368859'), wrap_str('73,72440474051831'), wrap_str('72.34060469647804'), wrap_str('73')])):
    found = False
    for s in str_nums:
        y = sym_float(s.replace(wrap_str(','), wrap_str('.')))
        _assert(y <= x)
        if y == x:
            found = True
    return found
### smt2
(set-logic ALL)

(define-fun str.to.float ((s String)) Real
  (let ((dot_pos (str.indexof s "." 0)))
    (ite (= dot_pos (- 1))
      ; No decimal point - convert whole string as integer
      (to_real (str.to_int s))
      ; Has decimal point - handle integer and decimal parts
      (let ((int_part (str.substr s 0 dot_pos))
            (dec_part (str.substr s (+ dot_pos 1) (- (str.len s) (+ dot_pos 1)))))
        (+ (to_real (str.to_int int_part))
           (/ (to_real (str.to_int dec_part))
              (^ 10.0 (- (str.len s) (+ dot_pos 1)))))))))

(declare-const x Real)
(assert (<= (str.to.float "31.39683666368859") x))
(assert (=> (= (str.to.float "31.39683666368859") x) (<= (str.to.float "73.72440474051831") x)))
(assert (=> (and (= (str.to.float "31.39683666368859") x) (= (str.to.float "73.72440474051831") x)) (<= (str.to.float "72.34060469647804") x)))
(assert (=> (and (= (str.to.float "31.39683666368859") x) (= (str.to.float "73.72440474051831") x) (= (str.to.float "72.34060469647804") x)) (<= (str.to.float "73") x)))
(assert (=> (and (= (str.to.float "31.39683666368859") x) (= (str.to.float "73.72440474051831") x) (= (str.to.float "72.34060469647804") x) (= (str.to.float "73") x)) true))
(assert (<= (str.to.float "31.39683666368859") x))
(assert (=> (not (= (str.to.float "31.39683666368859") x)) (<= (str.to.float "73.72440474051831") x)))
(assert (=> (and (not (= (str.to.float "31.39683666368859") x)) (not (= (str.to.float "73.72440474051831") x))) (<= (str.to.float "72.34060469647804") x)))
(assert (=> (and (not (= (str.to.float "31.39683666368859") x)) (not (= (str.to.float "73.72440474051831") x)) (not (= (str.to.float "72.34060469647804") x))) (<= (str.to.float "73") x)))
(assert (=> (and (not (= (str.to.float "31.39683666368859") x)) (not (= (str.to.float "73.72440474051831") x)) (not (= (str.to.float "72.34060469647804") x)) (not (= (str.to.float "73") x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 7372440474051831.0 100000000000000.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:13.52: expecting same arithmetic types to POW")

Found solution 73.72440474051831
Yes! Solved for puzzle  LargestStringNum:1

Solving puzzle 304/774: LargestStringNum:2
sat_func def sat(x: float, str_nums=['-6', '68', '-100', '42,449764091997196', '-29,24317717823544', '-41.15991554949425', '93.91903086808122', '-40', '95,64713000645497', '10.987133348617888', '-12', '-30', '-67.5420580170809', '58', '66,77819624303987', '-37.8232752327492', '8', '-99', '98']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
modified_func def sat(x: float, str_nums=wrap_list([wrap_str('-6'), wrap_str('68'), wrap_str('-100'), wrap_str('42,449764091997196'), wrap_str('-29,24317717823544'), wrap_str('-41.15991554949425'), wrap_str('93.91903086808122'), wrap_str('-40'), wrap_str('95,64713000645497'), wrap_str('10.987133348617888'), wrap_str('-12'), wrap_str('-30'), wrap_str('-67.5420580170809'), wrap_str('58'), wrap_str('66,77819624303987'), wrap_str('-37.8232752327492'), wrap_str('8'), wrap_str('-99'), wrap_str('98')])):
    found = False
    for s in str_nums:
        y = sym_float(s.replace(wrap_str(','), wrap_str('.')))
        _assert(y <= x)
        if y == x:
            found = True
    return found
### smt2
(set-logic ALL)

(define-fun str.to.float ((s String)) Real
  (let ((dot_pos (str.indexof s "." 0)))
    (ite (= dot_pos (- 1))
      ; No decimal point - convert whole string as integer
      (to_real (str.to_int s))
      ; Has decimal point - handle integer and decimal parts
      (let ((int_part (str.substr s 0 dot_pos))
            (dec_part (str.substr s (+ dot_pos 1) (- (str.len s) (+ dot_pos 1)))))
        (+ (to_real (str.to_int int_part))
           (/ (to_real (str.to_int dec_part))
              (^ 10.0 (- (str.len s) (+ dot_pos 1)))))))))

(declare-const x Real)
(assert (<= (str.to.float "-6") x))
(assert (=> (= (str.to.float "-6") x) (<= (str.to.float "68") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x)) (<= (str.to.float "-100") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x)) (<= (str.to.float "42.449764091997196") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x)) (<= (str.to.float "-29.24317717823544") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x)) (<= (str.to.float "-41.15991554949425") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x)) (<= (str.to.float "93.91903086808122") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x)) (<= (str.to.float "-40") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x)) (<= (str.to.float "95.64713000645497") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x)) (<= (str.to.float "10.987133348617888") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x)) (<= (str.to.float "-12") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x)) (<= (str.to.float "-30") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x) (= (str.to.float "-30") x)) (<= (str.to.float "-67.5420580170809") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x) (= (str.to.float "-30") x) (= (str.to.float "-67.5420580170809") x)) (<= (str.to.float "58") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x) (= (str.to.float "-30") x) (= (str.to.float "-67.5420580170809") x) (= (str.to.float "58") x)) (<= (str.to.float "66.77819624303987") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x) (= (str.to.float "-30") x) (= (str.to.float "-67.5420580170809") x) (= (str.to.float "58") x) (= (str.to.float "66.77819624303987") x)) (<= (str.to.float "-37.8232752327492") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x) (= (str.to.float "-30") x) (= (str.to.float "-67.5420580170809") x) (= (str.to.float "58") x) (= (str.to.float "66.77819624303987") x) (= (str.to.float "-37.8232752327492") x)) (<= (str.to.float "8") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x) (= (str.to.float "-30") x) (= (str.to.float "-67.5420580170809") x) (= (str.to.float "58") x) (= (str.to.float "66.77819624303987") x) (= (str.to.float "-37.8232752327492") x) (= (str.to.float "8") x)) (<= (str.to.float "-99") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x) (= (str.to.float "-30") x) (= (str.to.float "-67.5420580170809") x) (= (str.to.float "58") x) (= (str.to.float "66.77819624303987") x) (= (str.to.float "-37.8232752327492") x) (= (str.to.float "8") x) (= (str.to.float "-99") x)) (<= (str.to.float "98") x)))
(assert (=> (and (= (str.to.float "-6") x) (= (str.to.float "68") x) (= (str.to.float "-100") x) (= (str.to.float "42.449764091997196") x) (= (str.to.float "-29.24317717823544") x) (= (str.to.float "-41.15991554949425") x) (= (str.to.float "93.91903086808122") x) (= (str.to.float "-40") x) (= (str.to.float "95.64713000645497") x) (= (str.to.float "10.987133348617888") x) (= (str.to.float "-12") x) (= (str.to.float "-30") x) (= (str.to.float "-67.5420580170809") x) (= (str.to.float "58") x) (= (str.to.float "66.77819624303987") x) (= (str.to.float "-37.8232752327492") x) (= (str.to.float "8") x) (= (str.to.float "-99") x) (= (str.to.float "98") x)) true))
(assert (<= (str.to.float "-6") x))
(assert (=> (not (= (str.to.float "-6") x)) (<= (str.to.float "68") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x))) (<= (str.to.float "-100") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x))) (<= (str.to.float "42.449764091997196") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x))) (<= (str.to.float "-29.24317717823544") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x))) (<= (str.to.float "-41.15991554949425") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x))) (<= (str.to.float "93.91903086808122") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x))) (<= (str.to.float "-40") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x))) (<= (str.to.float "95.64713000645497") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x))) (<= (str.to.float "10.987133348617888") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x))) (<= (str.to.float "-12") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x))) (<= (str.to.float "-30") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x)) (not (= (str.to.float "-30") x))) (<= (str.to.float "-67.5420580170809") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x)) (not (= (str.to.float "-30") x)) (not (= (str.to.float "-67.5420580170809") x))) (<= (str.to.float "58") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x)) (not (= (str.to.float "-30") x)) (not (= (str.to.float "-67.5420580170809") x)) (not (= (str.to.float "58") x))) (<= (str.to.float "66.77819624303987") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x)) (not (= (str.to.float "-30") x)) (not (= (str.to.float "-67.5420580170809") x)) (not (= (str.to.float "58") x)) (not (= (str.to.float "66.77819624303987") x))) (<= (str.to.float "-37.8232752327492") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x)) (not (= (str.to.float "-30") x)) (not (= (str.to.float "-67.5420580170809") x)) (not (= (str.to.float "58") x)) (not (= (str.to.float "66.77819624303987") x)) (not (= (str.to.float "-37.8232752327492") x))) (<= (str.to.float "8") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x)) (not (= (str.to.float "-30") x)) (not (= (str.to.float "-67.5420580170809") x)) (not (= (str.to.float "58") x)) (not (= (str.to.float "66.77819624303987") x)) (not (= (str.to.float "-37.8232752327492") x)) (not (= (str.to.float "8") x))) (<= (str.to.float "-99") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x)) (not (= (str.to.float "-30") x)) (not (= (str.to.float "-67.5420580170809") x)) (not (= (str.to.float "58") x)) (not (= (str.to.float "66.77819624303987") x)) (not (= (str.to.float "-37.8232752327492") x)) (not (= (str.to.float "8") x)) (not (= (str.to.float "-99") x))) (<= (str.to.float "98") x)))
(assert (=> (and (not (= (str.to.float "-6") x)) (not (= (str.to.float "68") x)) (not (= (str.to.float "-100") x)) (not (= (str.to.float "42.449764091997196") x)) (not (= (str.to.float "-29.24317717823544") x)) (not (= (str.to.float "-41.15991554949425") x)) (not (= (str.to.float "93.91903086808122") x)) (not (= (str.to.float "-40") x)) (not (= (str.to.float "95.64713000645497") x)) (not (= (str.to.float "10.987133348617888") x)) (not (= (str.to.float "-12") x)) (not (= (str.to.float "-30") x)) (not (= (str.to.float "-67.5420580170809") x)) (not (= (str.to.float "58") x)) (not (= (str.to.float "66.77819624303987") x)) (not (= (str.to.float "-37.8232752327492") x)) (not (= (str.to.float "8") x)) (not (= (str.to.float "-99") x)) (not (= (str.to.float "98") x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 9564713000645497.0 100000000000000.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:13.52: expecting same arithmetic types to POW")

Found solution 95.64713000645496
Exception in checking result: 
WARNING: Solution verification failed for puzzle LargestStringNum:2
Too many constants for extrapolation

Solving puzzle 305/774: LargestStringNum:3
sat_func def sat(x: float, str_nums=['-13', '-9,405268331489253', '86,60853263788738', '1.6303719756540573', '25,638544353710756']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
modified_func def sat(x: float, str_nums=wrap_list([wrap_str('-13'), wrap_str('-9,405268331489253'), wrap_str('86,60853263788738'), wrap_str('1.6303719756540573'), wrap_str('25,638544353710756')])):
    found = False
    for s in str_nums:
        y = sym_float(s.replace(wrap_str(','), wrap_str('.')))
        _assert(y <= x)
        if y == x:
            found = True
    return found
### smt2
(set-logic ALL)

(define-fun str.to.float ((s String)) Real
  (let ((dot_pos (str.indexof s "." 0)))
    (ite (= dot_pos (- 1))
      ; No decimal point - convert whole string as integer
      (to_real (str.to_int s))
      ; Has decimal point - handle integer and decimal parts
      (let ((int_part (str.substr s 0 dot_pos))
            (dec_part (str.substr s (+ dot_pos 1) (- (str.len s) (+ dot_pos 1)))))
        (+ (to_real (str.to_int int_part))
           (/ (to_real (str.to_int dec_part))
              (^ 10.0 (- (str.len s) (+ dot_pos 1)))))))))

(declare-const x Real)
(assert (<= (str.to.float "-13") x))
(assert (=> (= (str.to.float "-13") x) (<= (str.to.float "-9.405268331489253") x)))
(assert (=> (and (= (str.to.float "-13") x) (= (str.to.float "-9.405268331489253") x)) (<= (str.to.float "86.60853263788738") x)))
(assert (=> (and (= (str.to.float "-13") x) (= (str.to.float "-9.405268331489253") x) (= (str.to.float "86.60853263788738") x)) (<= (str.to.float "1.6303719756540573") x)))
(assert (=> (and (= (str.to.float "-13") x) (= (str.to.float "-9.405268331489253") x) (= (str.to.float "86.60853263788738") x) (= (str.to.float "1.6303719756540573") x)) (<= (str.to.float "25.638544353710756") x)))
(assert (=> (and (= (str.to.float "-13") x) (= (str.to.float "-9.405268331489253") x) (= (str.to.float "86.60853263788738") x) (= (str.to.float "1.6303719756540573") x) (= (str.to.float "25.638544353710756") x)) true))
(assert (<= (str.to.float "-13") x))
(assert (=> (not (= (str.to.float "-13") x)) (<= (str.to.float "-9.405268331489253") x)))
(assert (=> (and (not (= (str.to.float "-13") x)) (not (= (str.to.float "-9.405268331489253") x))) (<= (str.to.float "86.60853263788738") x)))
(assert (=> (and (not (= (str.to.float "-13") x)) (not (= (str.to.float "-9.405268331489253") x)) (not (= (str.to.float "86.60853263788738") x))) (<= (str.to.float "1.6303719756540573") x)))
(assert (=> (and (not (= (str.to.float "-13") x)) (not (= (str.to.float "-9.405268331489253") x)) (not (= (str.to.float "86.60853263788738") x)) (not (= (str.to.float "1.6303719756540573") x))) (<= (str.to.float "25.638544353710756") x)))
(assert (=> (and (not (= (str.to.float "-13") x)) (not (= (str.to.float "-9.405268331489253") x)) (not (= (str.to.float "86.60853263788738") x)) (not (= (str.to.float "1.6303719756540573") x)) (not (= (str.to.float "25.638544353710756") x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 4330426631894369.0 50000000000000.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:13.52: expecting same arithmetic types to POW")

Found solution 86.60853263788738
Yes! Solved for puzzle  LargestStringNum:3

Solving puzzle 306/774: LargestStringNum:4
sat_func def sat(x: float, str_nums=['-100', '43', '12,380225941003388', '-10', '55', '40,34567619114577', '45', '-26,348841728512014', '-79.01130149535118', '48', '57', '-87', '24,13286574459906', '8', '57.12265333169756', '19,864244993734175', '24', '-82', '22']):
    found = False
    for s in str_nums:
        y = float(s.replace(",", "."))
        assert y <= x
        if y == x:
            found = True
    return found
modified_func def sat(x: float, str_nums=wrap_list([wrap_str('-100'), wrap_str('43'), wrap_str('12,380225941003388'), wrap_str('-10'), wrap_str('55'), wrap_str('40,34567619114577'), wrap_str('45'), wrap_str('-26,348841728512014'), wrap_str('-79.01130149535118'), wrap_str('48'), wrap_str('57'), wrap_str('-87'), wrap_str('24,13286574459906'), wrap_str('8'), wrap_str('57.12265333169756'), wrap_str('19,864244993734175'), wrap_str('24'), wrap_str('-82'), wrap_str('22')])):
    found = False
    for s in str_nums:
        y = sym_float(s.replace(wrap_str(','), wrap_str('.')))
        _assert(y <= x)
        if y == x:
            found = True
    return found
### smt2
(set-logic ALL)

(define-fun str.to.float ((s String)) Real
  (let ((dot_pos (str.indexof s "." 0)))
    (ite (= dot_pos (- 1))
      ; No decimal point - convert whole string as integer
      (to_real (str.to_int s))
      ; Has decimal point - handle integer and decimal parts
      (let ((int_part (str.substr s 0 dot_pos))
            (dec_part (str.substr s (+ dot_pos 1) (- (str.len s) (+ dot_pos 1)))))
        (+ (to_real (str.to_int int_part))
           (/ (to_real (str.to_int dec_part))
              (^ 10.0 (- (str.len s) (+ dot_pos 1)))))))))

(declare-const x Real)
(assert (<= (str.to.float "-100") x))
(assert (=> (= (str.to.float "-100") x) (<= (str.to.float "43") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x)) (<= (str.to.float "12.380225941003388") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x)) (<= (str.to.float "-10") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x)) (<= (str.to.float "55") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x)) (<= (str.to.float "40.34567619114577") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x)) (<= (str.to.float "45") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x)) (<= (str.to.float "-26.348841728512014") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x)) (<= (str.to.float "-79.01130149535118") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x)) (<= (str.to.float "48") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x)) (<= (str.to.float "57") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x)) (<= (str.to.float "-87") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x) (= (str.to.float "-87") x)) (<= (str.to.float "24.13286574459906") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x) (= (str.to.float "-87") x) (= (str.to.float "24.13286574459906") x)) (<= (str.to.float "8") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x) (= (str.to.float "-87") x) (= (str.to.float "24.13286574459906") x) (= (str.to.float "8") x)) (<= (str.to.float "57.12265333169756") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x) (= (str.to.float "-87") x) (= (str.to.float "24.13286574459906") x) (= (str.to.float "8") x) (= (str.to.float "57.12265333169756") x)) (<= (str.to.float "19.864244993734175") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x) (= (str.to.float "-87") x) (= (str.to.float "24.13286574459906") x) (= (str.to.float "8") x) (= (str.to.float "57.12265333169756") x) (= (str.to.float "19.864244993734175") x)) (<= (str.to.float "24") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x) (= (str.to.float "-87") x) (= (str.to.float "24.13286574459906") x) (= (str.to.float "8") x) (= (str.to.float "57.12265333169756") x) (= (str.to.float "19.864244993734175") x) (= (str.to.float "24") x)) (<= (str.to.float "-82") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x) (= (str.to.float "-87") x) (= (str.to.float "24.13286574459906") x) (= (str.to.float "8") x) (= (str.to.float "57.12265333169756") x) (= (str.to.float "19.864244993734175") x) (= (str.to.float "24") x) (= (str.to.float "-82") x)) (<= (str.to.float "22") x)))
(assert (=> (and (= (str.to.float "-100") x) (= (str.to.float "43") x) (= (str.to.float "12.380225941003388") x) (= (str.to.float "-10") x) (= (str.to.float "55") x) (= (str.to.float "40.34567619114577") x) (= (str.to.float "45") x) (= (str.to.float "-26.348841728512014") x) (= (str.to.float "-79.01130149535118") x) (= (str.to.float "48") x) (= (str.to.float "57") x) (= (str.to.float "-87") x) (= (str.to.float "24.13286574459906") x) (= (str.to.float "8") x) (= (str.to.float "57.12265333169756") x) (= (str.to.float "19.864244993734175") x) (= (str.to.float "24") x) (= (str.to.float "-82") x) (= (str.to.float "22") x)) true))
(assert (<= (str.to.float "-100") x))
(assert (=> (not (= (str.to.float "-100") x)) (<= (str.to.float "43") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x))) (<= (str.to.float "12.380225941003388") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x))) (<= (str.to.float "-10") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x))) (<= (str.to.float "55") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x))) (<= (str.to.float "40.34567619114577") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x))) (<= (str.to.float "45") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x))) (<= (str.to.float "-26.348841728512014") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x))) (<= (str.to.float "-79.01130149535118") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x))) (<= (str.to.float "48") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x))) (<= (str.to.float "57") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x))) (<= (str.to.float "-87") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x)) (not (= (str.to.float "-87") x))) (<= (str.to.float "24.13286574459906") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x)) (not (= (str.to.float "-87") x)) (not (= (str.to.float "24.13286574459906") x))) (<= (str.to.float "8") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x)) (not (= (str.to.float "-87") x)) (not (= (str.to.float "24.13286574459906") x)) (not (= (str.to.float "8") x))) (<= (str.to.float "57.12265333169756") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x)) (not (= (str.to.float "-87") x)) (not (= (str.to.float "24.13286574459906") x)) (not (= (str.to.float "8") x)) (not (= (str.to.float "57.12265333169756") x))) (<= (str.to.float "19.864244993734175") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x)) (not (= (str.to.float "-87") x)) (not (= (str.to.float "24.13286574459906") x)) (not (= (str.to.float "8") x)) (not (= (str.to.float "57.12265333169756") x)) (not (= (str.to.float "19.864244993734175") x))) (<= (str.to.float "24") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x)) (not (= (str.to.float "-87") x)) (not (= (str.to.float "24.13286574459906") x)) (not (= (str.to.float "8") x)) (not (= (str.to.float "57.12265333169756") x)) (not (= (str.to.float "19.864244993734175") x)) (not (= (str.to.float "24") x))) (<= (str.to.float "-82") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x)) (not (= (str.to.float "-87") x)) (not (= (str.to.float "24.13286574459906") x)) (not (= (str.to.float "8") x)) (not (= (str.to.float "57.12265333169756") x)) (not (= (str.to.float "19.864244993734175") x)) (not (= (str.to.float "24") x)) (not (= (str.to.float "-82") x))) (<= (str.to.float "22") x)))
(assert (=> (and (not (= (str.to.float "-100") x)) (not (= (str.to.float "43") x)) (not (= (str.to.float "12.380225941003388") x)) (not (= (str.to.float "-10") x)) (not (= (str.to.float "55") x)) (not (= (str.to.float "40.34567619114577") x)) (not (= (str.to.float "45") x)) (not (= (str.to.float "-26.348841728512014") x)) (not (= (str.to.float "-79.01130149535118") x)) (not (= (str.to.float "48") x)) (not (= (str.to.float "57") x)) (not (= (str.to.float "-87") x)) (not (= (str.to.float "24.13286574459906") x)) (not (= (str.to.float "8") x)) (not (= (str.to.float "57.12265333169756") x)) (not (= (str.to.float "19.864244993734175") x)) (not (= (str.to.float "24") x)) (not (= (str.to.float "-82") x)) (not (= (str.to.float "22") x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 1428066333292439.0 25000000000000.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:13.52: expecting same arithmetic types to POW")

Found solution 57.12265333169756
Yes! Solved for puzzle  LargestStringNum:4

Solving puzzle 307/774: ExpandSpaces:0
sat_func def sat(orig: str, target="-Hello,_world!__This_is-so-easy!-"):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
modified_func def sat(orig: str, target=wrap_str('-Hello,_world!__This_is-so-easy!-')):
    _assert((wrap_str('_') not in orig).__and__(wrap_str('-') not in orig))
    new = wrap_str('')
    space_count = wrap_int(0)
    for c in orig:
        if c == wrap_str(' '):
            space_count += wrap_int(1)
        else:
            new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
            new += c
            space_count = wrap_int(0)
    new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
    return new == target
Exception -- for puzzle ExpandSpaces:0 found bad constraint False of type <class 'bool'>

Solving puzzle 308/774: ExpandSpaces:1
sat_func def sat(orig: str, target="H-d"):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
modified_func def sat(orig: str, target=wrap_str('H-d')):
    _assert((wrap_str('_') not in orig).__and__(wrap_str('-') not in orig))
    new = wrap_str('')
    space_count = wrap_int(0)
    for c in orig:
        if c == wrap_str(' '):
            space_count += wrap_int(1)
        else:
            new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
            new += c
            space_count = wrap_int(0)
    new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
    return new == target
Exception -- for puzzle ExpandSpaces:1 found bad constraint False of type <class 'bool'>

Solving puzzle 309/774: ExpandSpaces:2
sat_func def sat(orig: str, target=""):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
modified_func def sat(orig: str, target=wrap_str('')):
    _assert((wrap_str('_') not in orig).__and__(wrap_str('-') not in orig))
    new = wrap_str('')
    space_count = wrap_int(0)
    for c in orig:
        if c == wrap_str(' '):
            space_count += wrap_int(1)
        else:
            new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
            new += c
            space_count = wrap_int(0)
    new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
    return new == target
Exception -- for puzzle ExpandSpaces:2 found bad constraint False of type <class 'bool'>

Solving puzzle 310/774: ExpandSpaces:3
sat_func def sat(orig: str, target="H@zoxyquygupaxofirefavuvubadigwQ"):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
modified_func def sat(orig: str, target=wrap_str('H@zoxyquygupaxofirefavuvubadigwQ')):
    _assert((wrap_str('_') not in orig).__and__(wrap_str('-') not in orig))
    new = wrap_str('')
    space_count = wrap_int(0)
    for c in orig:
        if c == wrap_str(' '):
            space_count += wrap_int(1)
        else:
            new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
            new += c
            space_count = wrap_int(0)
    new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
    return new == target
Exception -- for puzzle ExpandSpaces:3 found bad constraint False of type <class 'bool'>

Solving puzzle 311/774: ExpandSpaces:4
sat_func def sat(orig: str, target="-O!6quag"):
    assert "_" not in orig and "-" not in orig
    new = ""
    space_count = 0
    for c in orig:
        if c == " ":
            space_count += 1
        else:
            new += ("-" if space_count > 2 else "_" * space_count)
            new += c
            space_count = 0
    new += ("-" if space_count > 2 else "_" * space_count)
    return new == target
modified_func def sat(orig: str, target=wrap_str('-O!6quag')):
    _assert((wrap_str('_') not in orig).__and__(wrap_str('-') not in orig))
    new = wrap_str('')
    space_count = wrap_int(0)
    for c in orig:
        if c == wrap_str(' '):
            space_count += wrap_int(1)
        else:
            new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
            new += c
            space_count = wrap_int(0)
    new += wrap_str('-') if space_count > wrap_int(2) else wrap_str('_') * space_count
    return new == target
Exception -- for puzzle ExpandSpaces:4 found bad constraint False of type <class 'bool'>

Solving puzzle 312/774: PrimeWords:0
sat_func def sat(primes: str, s="This is a test of whether you would want to do such strange puzzles"):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
modified_func def sat(primes: str, s=wrap_str('This is a test of whether you would want to do such strange puzzles')):

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    prime_words = primes.split()
    i = wrap_int(0)
    for word in s.split():
        if is_prime(sym_len(word)):
            _assert(prime_words[i] == word)
            i += wrap_int(1)
    return i == sym_len(prime_words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and true (not (= (mod 4 i_0) 0))) (= (list.get.string (str.split x " ") 0) "This")))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0)))) (= (list.get.string (str.split x " ") 1) "is")))))))
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0)))) (= (list.get.string (str.split x " ") 2) "a")))))))))
(assert (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0))) (and true (not (= (mod 4 i_3) 0)))) (= (list.get.string (str.split x " ") 3) "test")))))))))))
(assert (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0))) (and true (not (= (mod 4 i_3) 0))) (and true (not (= (mod 2 i_4) 0)))) (= (list.get.string (str.split x " ") 4) "of")))))))))))))
(assert (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0))) (and true (not (= (mod 4 i_3) 0))) (and true (not (= (mod 2 i_4) 0))) (and true (not (= (mod 7 i_5) 0)))) (= (list.get.string (str.split x " ") 5) "whether")))))))))))))))
(assert (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0))) (and true (not (= (mod 4 i_3) 0))) (and true (not (= (mod 2 i_4) 0))) (and true (not (= (mod 7 i_5) 0))) (and true (not (= (mod 3 i_6) 0)))) (= (list.get.string (str.split x " ") 6) "you")))))))))))))))))
(assert (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0))) (and true (not (= (mod 4 i_3) 0))) (and true (not (= (mod 2 i_4) 0))) (and true (not (= (mod 7 i_5) 0))) (and true (not (= (mod 3 i_6) 0))) (and true (not (= (mod 5 i_7) 0)))) (= (list.get.string (str.split x " ") 7) "would")))))))))))))))))))
(assert (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0))) (and true (not (= (mod 4 i_3) 0))) (and true (not (= (mod 2 i_4) 0))) (and true (not (= (mod 7 i_5) 0))) (and true (not (= (mod 3 i_6) 0))) (and true (not (= (mod 5 i_7) 0))) (and true (not (= (mod 4 i_8) 0)))) ...
(assert (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0))) (and true (not (= (mod 4 i_3) 0))) (and true (not (= (mod 2 i_4) 0))) (and true (not (= (mod 7 i_5) 0))) (and true (not (= (mod 3 i_6) 0)...
(assert (forall ((i_10 Int)) (=> (and (>= i_10 2) (< i_10 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= (mod 1 i_2) 0))) (and true (not (= (mod 4 i_3) 0))) (and true (not (= (mod 2 ...
(assert (forall ((i_11 Int)) (=> (and (>= i_11 2) (< i_11 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_10 Int)) (=> (and (>= i_10 2) (< i_10 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (not (= (mod 4 i_0) 0))) (and true (not (= (mod 2 i_1) 0))) (and false (not (= ...
(assert (forall ((i_12 Int)) (=> (and (>= i_12 2) (< i_12 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_11 Int)) (=> (and (>= i_11 2) (< i_11 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_10 Int)) (=> (and (>= i_10 2) (< i_10 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 4 0.5)) 1))) (=> (and (and true (n...
(assert (forall ((i_13 Int)) (=> (and (>= i_13 2) (< i_13 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_12 Int)) (=> (and (>= i_12 2) (< i_12 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_11 Int)) (=> (and (>= i_11 2) (< i_11 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_10 Int)) (=> (and (>= i_10 2) (< i_10 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)...
(assert (forall ((i_13 Int)) (=> (and (>= i_13 2) (< i_13 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_12 Int)) (=> (and (>= i_12 2) (< i_12 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_11 Int)) (=> (and (>= i_11 2) (< i_11 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_10 Int)) (=> (and (>= i_10 2) (< i_10 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_0 Int)...
(assert (forall ((i_27 Int)) (=> (and (>= i_27 2) (< i_27 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_26 Int)) (=> (and (>= i_26 2) (< i_26 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_25 Int)) (=> (and (>= i_25 2) (< i_25 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_24 Int)) (=> (and (>= i_24 2) (< i_24 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_23 Int)) (=> (and (>= i_23 2) (< i_23 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_22 Int)) (=> (and (>= i_22 2) (< i_22 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_21 Int)) (=> (and (>= i_21 2) (< i_21 (+ (to_int (^ 5 0.5)) 1))) (forall ((i_20 Int)) (=> (and (>= i_20 2) (< i_20 (+ (to_int (^ 3 0.5)) 1))) (forall ((i_19 Int)) (=> (and (>= i_19 2) (< i_19 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_18 Int)) (=> (and (>= i_18 2) (< i_18 (+ (to_int (^ 2 0.5)) 1))) (forall ((i_17 Int)) (=> (and (>= i_17 2) (< i_17 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_16 Int)) (=> (and (>= i_16 2) (< i_16 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_15 Int)) (=> (and (>= i_15 2) (< i_15 (+ (to_int (^ 2 0....
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
(error "Parse Error: tmp.smt2:136.75: expecting same arithmetic types to POW")

Found solution 
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle PrimeWords:0
Too many constants for extrapolation

Solving puzzle 313/774: PrimeWords:1
sat_func def sat(primes: str, s="t quiquitutohetextyvod thacycotextilequa thavow rygo q xythejixojubuz jufutozozat cabuthymuchyji"):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
modified_func def sat(primes: str, s=wrap_str('t quiquitutohetextyvod thacycotextilequa thavow rygo q xythejixojubuz jufutozozat cabuthymuchyji')):

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    prime_words = primes.split()
    i = wrap_int(0)
    for word in s.split():
        if is_prime(sym_len(word)):
            _assert(prime_words[i] == word)
            i += wrap_int(1)
    return i == sym_len(prime_words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and false (not (= (mod 1 i_0) 0))) (= (list.get.string (str.split x " ") 0) "t")))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0)))) (= (list.get.string (str.split x " ") 1) "quiquitutohetextyvod")))))))
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0))) (and true (not (= (mod 17 i_2) 0)))) (= (list.get.string (str.split x " ") 2) "thacycotextilequa")))))))))
(assert (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0))) (and true (not (= (mod 17 i_2) 0))) (and true (not (= (mod 6 i_3) 0)))) (= (list.get.string (str.split x " ") 3) "thavow")))))))))))
(assert (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0))) (and true (not (= (mod 17 i_2) 0))) (and true (not (= (mod 6 i_3) 0))) (and true (not (= (mod 4 i_4) 0)))) (= (list.get.string (str.split x " ") 4) "rygo")))))))))))))
(assert (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0))) (and true (not (= (mod 17 i_2) 0))) (and true (not (= (mod 6 i_3) 0))) (and true (not (= (mod 4 i_4) 0))) (and false (not (= (mod 1 i_5) 0)))) (= (list.get.string (str.split x " ") 5) "q")))))))))))))))
(assert (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0))) (and true (not (= (mod 17 i_2) 0))) (and true (not (= (mod 6 i_3) 0))) (and true (not (= (mod 4 i_4) 0))) (and false (not (= (mod 1 i_5) 0))) (and true (not (= (mod 14 i_6) 0)))) (= (list.get.string (str.split x " ") 6) "xythejixojubuz")))))))))))))))))
(assert (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0))) (and true (not (= (mod 17 i_2) 0))) (and true (not (= (mod 6 i_3) 0))) (and true (not (= (mod 4 i_4) 0))) (and false (not (= (mod 1 i_5) 0))) (and true (not (= (mod 14 i_6) 0))) (and true (not (= (mod 11 i_7) 0)))) (= (list.get.string (str.split x " ") 7) "jufutozozat")))))))))))))))))))
(assert (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0))) (and true (not (= (mod 17 i_2) 0))) (and true (not (= (mod 6 i_3) 0))) (and true (not (= (mod 4 i_4) 0))) (and false (not (= (mod 1 i_5) 0))) (and true (not (= (mod 14 i_6) 0))) (and true (not (= (mod 11 i_7) 0))) (and true (not (= (mod 14 ...
(assert (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 1 0.5)) 1))) (=> (and (and false (not (= (mod 1 i_0) 0))) (and true (not (= (mod 20 i_1) 0))) (and true (not (= (mod 17 i_2) 0))) (and true (not (= (mod 6 i_3) 0))) (and true (not (= (mod 4 i_4) 0))) (and false (not (= (mod 1 i_5) 0))) (and true (not (= (mod 14 i_6) 0))) (and true (not (= (mod 11 i_7) 0))) (and true (not (= (mod 14 ...
(assert (forall ((i_17 Int)) (=> (and (>= i_17 2) (< i_17 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_16 Int)) (=> (and (>= i_16 2) (< i_16 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_15 Int)) (=> (and (>= i_15 2) (< i_15 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_14 Int)) (=> (and (>= i_14 2) (< i_14 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_13 Int)) (=> (and (>= i_13 2) (< i_13 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_12 Int)) (=> (and (>= i_12 2) (< i_12 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_11 Int)) (=> (and (>= i_11 2) (< i_11 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_10 Int)) (=> (and (>= i_10 2) (< i_10 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 14 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
(error "Parse Error: tmp.smt2:136.75: expecting same arithmetic types to POW")

Found solution 
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle PrimeWords:1
Too many constants for extrapolation

Solving puzzle 314/774: PrimeWords:2
sat_func def sat(primes: str, s="caquovovich keguqu tatextuhok jajabyv kibatextuchisimoz xibe sotext s helalewipixemujiwixa"):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
modified_func def sat(primes: str, s=wrap_str('caquovovich keguqu tatextuhok jajabyv kibatextuchisimoz xibe sotext s helalewipixemujiwixa')):

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    prime_words = primes.split()
    i = wrap_int(0)
    for word in s.split():
        if is_prime(sym_len(word)):
            _assert(prime_words[i] == word)
            i += wrap_int(1)
    return i == sym_len(prime_words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and true (not (= (mod 11 i_0) 0))) (= (list.get.string (str.split x " ") 0) "caquovovich")))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0)))) (= (list.get.string (str.split x " ") 1) "keguqu")))))))
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0))) (and true (not (= (mod 10 i_2) 0)))) (= (list.get.string (str.split x " ") 2) "tatextuhok")))))))))
(assert (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0))) (and true (not (= (mod 10 i_2) 0))) (and true (not (= (mod 7 i_3) 0)))) (= (list.get.string (str.split x " ") 3) "jajabyv")))))))))))
(assert (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0))) (and true (not (= (mod 10 i_2) 0))) (and true (not (= (mod 7 i_3) 0))) (and true (not (= (mod 17 i_4) 0)))) (= (list.get.string (str.split x " ") 4) "kibatextuchisimoz")))))))))))))
(assert (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0))) (and true (not (= (mod 10 i_2) 0))) (and true (not (= (mod 7 i_3) 0))) (and true (not (= (mod 17 i_4) 0))) (and true (not (= (mod 4 i_5) 0)))) (= (list.get.string (str.split x " ") 5) "xibe")))))))))))))))
(assert (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0))) (and true (not (= (mod 10 i_2) 0))) (and true (not (= (mod 7 i_3) 0))) (and true (not (= (mod 17 i_4) 0))) (and true (not (= (mod 4 i_5) 0))) (and true (not (= (mod 6 i_6) 0)))) (= (list.get.string (str.split x " ") 6) "sotext")))))))))))))))))
(assert (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0))) (and true (not (= (mod 10 i_2) 0))) (and true (not (= (mod 7 i_3) 0))) (and true (not (= (mod 17 i_4) 0))) (and true (not (= (mod 4 i_5) 0))) (and true (not (= (mod 6 i_6) 0))) (and false (not (= (mod 1 i_7) 0)))) (= (list.get.string (str.split x " ") 7) "s")))))))))))))))))))
(assert (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0))) (and true (not (= (mod 10 i_2) 0))) (and true (not (= (mod 7 i_3) 0))) (and true (not (= (mod 17 i_4) 0))) (and true (not (= (mod 4 i_5) 0))) (and true (not (= (mod 6 i_6) 0))) (and false (not (= (mod 1 i_7) 0))) (and true (not (= (mod 20 i_8...
(assert (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 11 0.5)) 1))) (=> (and (and true (not (= (mod 11 i_0) 0))) (and true (not (= (mod 6 i_1) 0))) (and true (not (= (mod 10 i_2) 0))) (and true (not (= (mod 7 i_3) 0))) (and true (not (= (mod 17 i_4) 0))) (and true (not (= (mod 4 i_5) 0))) (and true (not (= (mod 6 i_6) 0))) (and false (not (= (mod 1 i_7) 0))) (and true (not (= (mod 20 i_8...
(assert (forall ((i_17 Int)) (=> (and (>= i_17 2) (< i_17 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_16 Int)) (=> (and (>= i_16 2) (< i_16 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_15 Int)) (=> (and (>= i_15 2) (< i_15 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_14 Int)) (=> (and (>= i_14 2) (< i_14 (+ (to_int (^ 4 0.5)) 1))) (forall ((i_13 Int)) (=> (and (>= i_13 2) (< i_13 (+ (to_int (^ 17 0.5)) 1))) (forall ((i_12 Int)) (=> (and (>= i_12 2) (< i_12 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_11 Int)) (=> (and (>= i_11 2) (< i_11 (+ (to_int (^ 10 0.5)) 1))) (forall ((i_10 Int)) (=> (and (>= i_10 2) (< i_10 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 4 0.5)) 1))) (...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 148 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:136.76: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeWords:2
Too many constants for extrapolation

Solving puzzle 315/774: PrimeWords:3
sat_func def sat(primes: str, s=""):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
modified_func def sat(primes: str, s=wrap_str('')):

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    prime_words = primes.split()
    i = wrap_int(0)
    for word in s.split():
        if is_prime(sym_len(word)):
            _assert(prime_words[i] == word)
            i += wrap_int(1)
    return i == sym_len(prime_words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (= 0 (list.length.string (str.split x " "))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle PrimeWords:3
Too many constants for extrapolation

Solving puzzle 316/774: PrimeWords:4
sat_func def sat(primes: str, s="sidathochocek qualodu thugolo wywyfykyxyhewyjapeke matofamep n wemahu pesethimine"):

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    prime_words = primes.split()
    i = 0
    for word in s.split():
        if is_prime(len(word)):
            assert prime_words[i] == word
            i += 1

    return i == len(prime_words)
modified_func def sat(primes: str, s=wrap_str('sidathochocek qualodu thugolo wywyfykyxyhewyjapeke matofamep n wemahu pesethimine')):

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    prime_words = primes.split()
    i = wrap_int(0)
    for word in s.split():
        if is_prime(sym_len(word)):
            _assert(prime_words[i] == word)
            i += wrap_int(1)
    return i == sym_len(prime_words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and true (not (= (mod 13 i_0) 0))) (= (list.get.string (str.split x " ") 0) "sidathochocek")))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and (and true (not (= (mod 13 i_0) 0))) (and true (not (= (mod 7 i_1) 0)))) (= (list.get.string (str.split x " ") 1) "qualodu")))))))
(assert (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and (and true (not (= (mod 13 i_0) 0))) (and true (not (= (mod 7 i_1) 0))) (and true (not (= (mod 7 i_2) 0)))) (= (list.get.string (str.split x " ") 2) "thugolo")))))))))
(assert (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and (and true (not (= (mod 13 i_0) 0))) (and true (not (= (mod 7 i_1) 0))) (and true (not (= (mod 7 i_2) 0))) (and true (not (= (mod 20 i_3) 0)))) (= (list.get.string (str.split x " ") 3) "wywyfykyxyhewyjapeke")))))))))))
(assert (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 9 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and (and true (not (= (mod 13 i_0) 0))) (and true (not (= (mod 7 i_1) 0))) (and true (not (= (mod 7 i_2) 0))) (and true (not (= (mod 20 i_3) 0))) (and true (not (= (mod 9 i_4) 0)))) (= (list.get.string (str.split x " ") 4) "matofamep")))))))))))))
(assert (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 9 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and (and true (not (= (mod 13 i_0) 0))) (and true (not (= (mod 7 i_1) 0))) (and true (not (= (mod 7 i_2) 0))) (and true (not (= (mod 20 i_3) 0))) (and true (not (= (mod 9 i_4) 0))) (and false (not (= (mod 1 i_5) 0)))) (= (list.get.string (str.split x " ") 5) "n")))))))))))))))
(assert (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 9 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and (and true (not (= (mod 13 i_0) 0))) (and true (not (= (mod 7 i_1) 0))) (and true (not (= (mod 7 i_2) 0))) (and true (not (= (mod 20 i_3) 0))) (and true (not (= (mod 9 i_4) 0))) (and false (not (= (mod 1 i_5) 0))) (and true (not (= (mod 6 i_6) 0)))) (= (list.get.string (str.split x " ") 6) "wemahu")))))))))))))))))
(assert (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 9 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and (and true (not (= (mod 13 i_0) 0))) (and true (not (= (mod 7 i_1) 0))) (and true (not (= (mod 7 i_2) 0))) (and true (not (= (mod 20 i_3) 0))) (and true (not (= (mod 9 i_4) 0))) (and false (not (= (mod 1 i_5) 0))) (and true (not (= (mod 6 i_6) 0))) (and true (not (= (mod 11 i_7) 0)))) (= (list.get.string (str.split x " ") 7) "pesethimine")))))))))))))))))))
(assert (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 9 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_2 Int)) (=> (and (>= i_2 2) (< i_2 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_1 Int)) (=> (and (>= i_1 2) (< i_1 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_0 Int)) (=> (and (>= i_0 2) (< i_0 (+ (to_int (^ 13 0.5)) 1))) (=> (and (and true (not (= (mod 13 i_0) 0))) (and true (not (= (mod 7 i_1) 0))) (and true (not (= (mod 7 i_2) 0))) (and true (not (= (mod 20 i_3) 0))) (and true (not (= (mod 9 i_4) 0))) (and false (not (= (mod 1 i_5) 0))) (and true (not (= (mod 6 i_6) 0))) (and true (not (= (mod 11 i_7) 0)))) (= 8 (list.length.string (str.split x " ")))))))))))))))))))))
(assert (forall ((i_15 Int)) (=> (and (>= i_15 2) (< i_15 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_14 Int)) (=> (and (>= i_14 2) (< i_14 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_13 Int)) (=> (and (>= i_13 2) (< i_13 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_12 Int)) (=> (and (>= i_12 2) (< i_12 (+ (to_int (^ 9 0.5)) 1))) (forall ((i_11 Int)) (=> (and (>= i_11 2) (< i_11 (+ (to_int (^ 20 0.5)) 1))) (forall ((i_10 Int)) (=> (and (>= i_10 2) (< i_10 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_9 Int)) (=> (and (>= i_9 2) (< i_9 (+ (to_int (^ 7 0.5)) 1))) (forall ((i_8 Int)) (=> (and (>= i_8 2) (< i_8 (+ (to_int (^ 13 0.5)) 1))) (forall ((i_7 Int)) (=> (and (>= i_7 2) (< i_7 (+ (to_int (^ 11 0.5)) 1))) (forall ((i_6 Int)) (=> (and (>= i_6 2) (< i_6 (+ (to_int (^ 6 0.5)) 1))) (forall ((i_5 Int)) (=> (and (>= i_5 2) (< i_5 (+ (to_int (^ 1 0.5)) 1))) (forall ((i_4 Int)) (=> (and (>= i_4 2) (< i_4 (+ (to_int (^ 9 0.5)) 1))) (forall ((i_3 Int)) (=> (and (>= i_3 2) (< i_3 (+ (to_int (^ 20 0.5)) 1))) (forall...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unknown
(error "line 147 column 10: model is not available")
### output for cvc5
(error "Parse Error: tmp.smt2:136.76: expecting same arithmetic types to POW")

Could not find any solution for puzzle PrimeWords:4
Too many constants for extrapolation

Solving puzzle 317/774: SimplifyProductFraction:0
sat_func def sat(z: str, x="-8142432/763083", y="66/-13474", max_len=18):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
modified_func def sat(z: str, x=wrap_str('-8142432/763083'), y=wrap_str('66/-13474'), max_len=wrap_int(18)):
    wrap_list([wrap_list([a, b]), wrap_list([c, d]), wrap_list([u, v])]) = [[sym_int(n) for n in s.split(wrap_str('/'))] for s in wrap_list([x, y, z])]
    return (a * c * v == b * d * u).__and__(sym_len(z) <= max_len)
Exception -- for puzzle SimplifyProductFraction:0 cannot assign to function call here. Maybe you meant '==' instead of '='? (<string>, line 2)

Solving puzzle 318/774: SimplifyProductFraction:1
sat_func def sat(z: str, x="0/47460", y="357/8389715", max_len=3):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
modified_func def sat(z: str, x=wrap_str('0/47460'), y=wrap_str('357/8389715'), max_len=wrap_int(3)):
    wrap_list([wrap_list([a, b]), wrap_list([c, d]), wrap_list([u, v])]) = [[sym_int(n) for n in s.split(wrap_str('/'))] for s in wrap_list([x, y, z])]
    return (a * c * v == b * d * u).__and__(sym_len(z) <= max_len)
Exception -- for puzzle SimplifyProductFraction:1 cannot assign to function call here. Maybe you meant '==' instead of '='? (<string>, line 2)

Solving puzzle 319/774: SimplifyProductFraction:2
sat_func def sat(z: str, x="-20/-54383610", y="7865/34", max_len=13):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
modified_func def sat(z: str, x=wrap_str('-20/-54383610'), y=wrap_str('7865/34'), max_len=wrap_int(13)):
    wrap_list([wrap_list([a, b]), wrap_list([c, d]), wrap_list([u, v])]) = [[sym_int(n) for n in s.split(wrap_str('/'))] for s in wrap_list([x, y, z])]
    return (a * c * v == b * d * u).__and__(sym_len(z) <= max_len)
Exception -- for puzzle SimplifyProductFraction:2 cannot assign to function call here. Maybe you meant '==' instead of '='? (<string>, line 2)

Solving puzzle 320/774: SimplifyProductFraction:3
sat_func def sat(z: str, x="0/2", y="79/45361", max_len=3):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
modified_func def sat(z: str, x=wrap_str('0/2'), y=wrap_str('79/45361'), max_len=wrap_int(3)):
    wrap_list([wrap_list([a, b]), wrap_list([c, d]), wrap_list([u, v])]) = [[sym_int(n) for n in s.split(wrap_str('/'))] for s in wrap_list([x, y, z])]
    return (a * c * v == b * d * u).__and__(sym_len(z) <= max_len)
Exception -- for puzzle SimplifyProductFraction:3 cannot assign to function call here. Maybe you meant '==' instead of '='? (<string>, line 2)

Solving puzzle 321/774: SimplifyProductFraction:4
sat_func def sat(z: str, x="1316/-4820197", y="0/28968", max_len=3):
    [[a, b], [c, d], [u, v]] = [[int(n) for n in s.split("/")] for s in [x, y, z]]
    return a * c * v == b * d * u and len(z) <= max_len
modified_func def sat(z: str, x=wrap_str('1316/-4820197'), y=wrap_str('0/28968'), max_len=wrap_int(3)):
    wrap_list([wrap_list([a, b]), wrap_list([c, d]), wrap_list([u, v])]) = [[sym_int(n) for n in s.split(wrap_str('/'))] for s in wrap_list([x, y, z])]
    return (a * c * v == b * d * u).__and__(sym_len(z) <= max_len)
Exception -- for puzzle SimplifyProductFraction:4 cannot assign to function call here. Maybe you meant '==' instead of '='? (<string>, line 2)

Solving puzzle 322/774: EvenSqure:0
sat_func def sat(tot: int, xs=[123.0, 872322.0, 542.2, -127.5, 18214.0, 3732.4, 12832.4, 23523800.0]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
modified_func def sat(tot: int, xs=wrap_list([123.0, 872322.0, 542.2, -127.5, 18214.0, 3732.4, 12832.4, 23523800.0])):
    for x in xs:
        if x.is_integer().__and__(x > wrap_int(0)).__and__(x % wrap_int(2) == wrap_int(0)):
            tot -= sym_int(x) ** wrap_int(2)
    return tot == wrap_int(0)
Exception -- for puzzle EvenSqure:0 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 323/774: EvenSqure:1
sat_func def sat(tot: int, xs=[]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
modified_func def sat(tot: int, xs=wrap_list([])):
    for x in xs:
        if x.is_integer().__and__(x > wrap_int(0)).__and__(x % wrap_int(2) == wrap_int(0)):
            tot -= sym_int(x) ** wrap_int(2)
    return tot == wrap_int(0)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  EvenSqure:1

Solving puzzle 324/774: EvenSqure:2
sat_func def sat(tot: int, xs=[274797.0, 8635.410691353316, 53805.0, -51907.0, -24430.861351406824, 190577.0, 237978.0, 133989.0]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
modified_func def sat(tot: int, xs=wrap_list([274797.0, 8635.410691353316, 53805.0, -51907.0, -24430.861351406824, 190577.0, 237978.0, 133989.0])):
    for x in xs:
        if x.is_integer().__and__(x > wrap_int(0)).__and__(x % wrap_int(2) == wrap_int(0)):
            tot -= sym_int(x) ** wrap_int(2)
    return tot == wrap_int(0)
Exception -- for puzzle EvenSqure:2 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 325/774: EvenSqure:3
sat_func def sat(tot: int, xs=[205685.0, 6849.8060301064015, 68569.0, 33659.85121811424, 71796.0, 183470.0, 236644.22522117657, -11658.772326982376, 155284.34795372086]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
modified_func def sat(tot: int, xs=wrap_list([205685.0, 6849.8060301064015, 68569.0, 33659.85121811424, 71796.0, 183470.0, 236644.22522117657, -11658.772326982376, 155284.34795372086])):
    for x in xs:
        if x.is_integer().__and__(x > wrap_int(0)).__and__(x % wrap_int(2) == wrap_int(0)):
            tot -= sym_int(x) ** wrap_int(2)
    return tot == wrap_int(0)
Exception -- for puzzle EvenSqure:3 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 326/774: EvenSqure:4
sat_func def sat(tot: int, xs=[58607.93384068141, 26960.422714894165, 220926.0, 32993.16403323761, 36258.0, 164898.58842568452, -22047.528018042995, 283472.0, -14768.0]):
    for x in xs:
        if x.is_integer() and x > 0 and x % 2 == 0:
            tot -= int(x) ** 2

    return tot == 0
modified_func def sat(tot: int, xs=wrap_list([58607.93384068141, 26960.422714894165, 220926.0, 32993.16403323761, 36258.0, 164898.58842568452, -22047.528018042995, 283472.0, -14768.0])):
    for x in xs:
        if x.is_integer().__and__(x > wrap_int(0)).__and__(x % wrap_int(2) == wrap_int(0)):
            tot -= sym_int(x) ** wrap_int(2)
    return tot == wrap_int(0)
Exception -- for puzzle EvenSqure:4 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 327/774: StrongestExtension:0
sat_func def sat(s: str, class_name="TestClass", extensions=['extEnd', 'LOL', 'SuPeRbLy', 'v9ACLQWTEW', 'PickMe', 'AI']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
modified_func def sat(s: str, class_name=wrap_str('TestClass'), extensions=wrap_list([wrap_str('extEnd'), wrap_str('LOL'), wrap_str('SuPeRbLy'), wrap_str('v9ACLQWTEW'), wrap_str('PickMe'), wrap_str('AI')])):
    _assert(s.startswith(class_name + '.'))
    ext = s[sym_len(class_name) + 1:]

    def case_delta(x: str):
        tot = wrap_int(0)
        for c in x:
            if c.isupper():
                tot += wrap_int(1)
            elif c.islower():
                tot -= wrap_int(1)
        return tot
    return sym_in(ext, extensions).__and__(case_delta(ext) == max([case_delta(x) for x in extensions]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun is-upper-char ((c String)) Bool
  (and (>= (str.to_code c) 65) (<= (str.to_code c) 90))
)

(define-fun-rec isupper ((s String)) Bool
  (ite (= s "")
       true
       (and (is-upper-char (str.at s 0))
            (isupper (str.substr s 1 (- (str.len s) 1))))
  )
)


(define-fun is-lower-char ((c String)) Bool
  (and (>= (str.to_code c) (str.to_code "a")) (<= (str.to_code c) (str.to_code "z")))
)

(define-fun-rec islower ((s String)) Bool
  (ite (= s "")
       true
       (and (is-lower-char (str.at s 0))
            (islower (str.substr s 1 (- (str.len s) 1))))
  )
)

(declare-const x String)
(assert (str.prefixof (str.++ "TestClass" ".") x))
(assert (forall ((str_pos_44 Int)) (=> (and (>= str_pos_44 0) (< str_pos_44 (str.len (python.str.substr x 10 (str.len x))))) (=> (isupper (python.str.at (python.str.substr x 10 (str.len x)) str_pos_44)) (and (or (= (python.str.substr x 10 (str.len x)) "extEnd") (= (python.str.substr x 10 (str.len x)) "LOL") (= (python.str.substr x 10 (str.len x)) "SuPeRbLy") (= (python.str.substr x 10 (str.len x)) "v9ACLQWTEW") (= (python.str.substr x 10 (str.len x)) "PickMe") (= (python.str.substr x 10 (str.len x)) "AI")) false)))))
(assert (forall ((str_pos_44 Int)) (=> (and (>= str_pos_44 0) (< str_pos_44 (str.len (python.str.substr x 10 (str.len x))))) (str.prefixof (str.++ "TestClass" ".") x))))
(assert (forall ((str_pos_45 Int)) (=> (and (>= str_pos_45 0) (< str_pos_45 (str.len (python.str.substr x 10 (str.len x))))) (forall ((str_pos_44 Int)) (=> (and (>= str_pos_44 0) (< str_pos_44 (str.len (python.str.substr x 10 (str.len x))))) (=> (and (not (isupper (python.str.at (python.str.substr x 10 (str.len x)) str_pos_45))) (not (islower (python.str.at (python.str.substr x 10 (str.len x)) str_pos_45)))) (and (or (= (python.str.substr x 10 (str.len x)) "extEnd") (= (python.str.substr x 10 (str.len x)) "LOL") (= (python.str.substr x 10 (str.len x)) "SuPeRbLy") (= (python.str.substr x 10 (str.len x)) "v9ACLQWTEW") (= (python.str.substr x 10 (str.len x)) "PickMe") (= (python.str.substr x 10 (str.len x)) "AI")) false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "TestClass.")
)
### output for cvc5
unknown
(
(define-fun x () String "TestClass.a")
)

Found solution TestClass.
WARNING: Solution verification failed for puzzle StrongestExtension:0
Too many constants for extrapolation

Solving puzzle 328/774: StrongestExtension:1
sat_func def sat(s: str, class_name="Lyhithywuwotu", extensions=['moRUTExterefI', 'vItHu', 'xIWygaly', 'zONITh', 'ChinELAbiFOfywUcU', 'sywyfIFuTagAX', 'CIcECHiriQUuXuxuh', 'JUFeSA']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
modified_func def sat(s: str, class_name=wrap_str('Lyhithywuwotu'), extensions=wrap_list([wrap_str('moRUTExterefI'), wrap_str('vItHu'), wrap_str('xIWygaly'), wrap_str('zONITh'), wrap_str('ChinELAbiFOfywUcU'), wrap_str('sywyfIFuTagAX'), wrap_str('CIcECHiriQUuXuxuh'), wrap_str('JUFeSA')])):
    _assert(s.startswith(class_name + '.'))
    ext = s[sym_len(class_name) + 1:]

    def case_delta(x: str):
        tot = wrap_int(0)
        for c in x:
            if c.isupper():
                tot += wrap_int(1)
            elif c.islower():
                tot -= wrap_int(1)
        return tot
    return sym_in(ext, extensions).__and__(case_delta(ext) == max([case_delta(x) for x in extensions]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun is-upper-char ((c String)) Bool
  (and (>= (str.to_code c) 65) (<= (str.to_code c) 90))
)

(define-fun-rec isupper ((s String)) Bool
  (ite (= s "")
       true
       (and (is-upper-char (str.at s 0))
            (isupper (str.substr s 1 (- (str.len s) 1))))
  )
)


(define-fun is-lower-char ((c String)) Bool
  (and (>= (str.to_code c) (str.to_code "a")) (<= (str.to_code c) (str.to_code "z")))
)

(define-fun-rec islower ((s String)) Bool
  (ite (= s "")
       true
       (and (is-lower-char (str.at s 0))
            (islower (str.substr s 1 (- (str.len s) 1))))
  )
)

(declare-const x String)
(assert (str.prefixof (str.++ "Lyhithywuwotu" ".") x))
(assert (forall ((str_pos_46 Int)) (=> (and (>= str_pos_46 0) (< str_pos_46 (str.len (python.str.substr x 14 (str.len x))))) (=> (isupper (python.str.at (python.str.substr x 14 (str.len x)) str_pos_46)) (and (or (= (python.str.substr x 14 (str.len x)) "moRUTExterefI") (= (python.str.substr x 14 (str.len x)) "vItHu") (= (python.str.substr x 14 (str.len x)) "xIWygaly") (= (python.str.substr x 14 (str.len x)) "zONITh") (= (python.str.substr x 14 (str.len x)) "ChinELAbiFOfywUcU") (= (python.str.substr x 14 (str.len x)) "sywyfIFuTagAX") (= (python.str.substr x 14 (str.len x)) "CIcECHiriQUuXuxuh") (= (python.str.substr x 14 (str.len x)) "JUFeSA")) false)))))
(assert (forall ((str_pos_46 Int)) (=> (and (>= str_pos_46 0) (< str_pos_46 (str.len (python.str.substr x 14 (str.len x))))) (str.prefixof (str.++ "Lyhithywuwotu" ".") x))))
(assert (forall ((str_pos_47 Int)) (=> (and (>= str_pos_47 0) (< str_pos_47 (str.len (python.str.substr x 14 (str.len x))))) (forall ((str_pos_46 Int)) (=> (and (>= str_pos_46 0) (< str_pos_46 (str.len (python.str.substr x 14 (str.len x))))) (=> (and (not (isupper (python.str.at (python.str.substr x 14 (str.len x)) str_pos_47))) (not (islower (python.str.at (python.str.substr x 14 (str.len x)) str_pos_47)))) (and (or (= (python.str.substr x 14 (str.len x)) "moRUTExterefI") (= (python.str.substr x 14 (str.len x)) "vItHu") (= (python.str.substr x 14 (str.len x)) "xIWygaly") (= (python.str.substr x 14 (str.len x)) "zONITh") (= (python.str.substr x 14 (str.len x)) "ChinELAbiFOfywUcU") (= (python.str.substr x 14 (str.len x)) "sywyfIFuTagAX") (= (python.str.substr x 14 (str.len x)) "CIcECHiriQUuXuxuh") (= (python.str.substr x 14 (str.len x)) "JUFeSA")) false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "Lyhithywuwotu.")
)
### output for cvc5
unknown
(
(define-fun x () String "Lyhithywuwotu.a")
)

Found solution Lyhithywuwotu.
WARNING: Solution verification failed for puzzle StrongestExtension:1
Too many constants for extrapolation

Solving puzzle 329/774: StrongestExtension:2
sat_func def sat(s: str, class_name="Textafarole", extensions=['bEzETExTutheQuYCetH', 'FUFetEpaPafawIxegIbI', 'fUxuXYfOmutYM', 'HYCygiNY', 'FUnaVYcHity', 'th', 'dULUDyQui', 'rAvUJUlAchUHAsOBese', 'tefO', 'vy']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
modified_func def sat(s: str, class_name=wrap_str('Textafarole'), extensions=wrap_list([wrap_str('bEzETExTutheQuYCetH'), wrap_str('FUFetEpaPafawIxegIbI'), wrap_str('fUxuXYfOmutYM'), wrap_str('HYCygiNY'), wrap_str('FUnaVYcHity'), wrap_str('th'), wrap_str('dULUDyQui'), wrap_str('rAvUJUlAchUHAsOBese'), wrap_str('tefO'), wrap_str('vy')])):
    _assert(s.startswith(class_name + '.'))
    ext = s[sym_len(class_name) + 1:]

    def case_delta(x: str):
        tot = wrap_int(0)
        for c in x:
            if c.isupper():
                tot += wrap_int(1)
            elif c.islower():
                tot -= wrap_int(1)
        return tot
    return sym_in(ext, extensions).__and__(case_delta(ext) == max([case_delta(x) for x in extensions]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun is-upper-char ((c String)) Bool
  (and (>= (str.to_code c) 65) (<= (str.to_code c) 90))
)

(define-fun-rec isupper ((s String)) Bool
  (ite (= s "")
       true
       (and (is-upper-char (str.at s 0))
            (isupper (str.substr s 1 (- (str.len s) 1))))
  )
)


(define-fun is-lower-char ((c String)) Bool
  (and (>= (str.to_code c) (str.to_code "a")) (<= (str.to_code c) (str.to_code "z")))
)

(define-fun-rec islower ((s String)) Bool
  (ite (= s "")
       true
       (and (is-lower-char (str.at s 0))
            (islower (str.substr s 1 (- (str.len s) 1))))
  )
)

(declare-const x String)
(assert (str.prefixof (str.++ "Textafarole" ".") x))
(assert (forall ((str_pos_48 Int)) (=> (and (>= str_pos_48 0) (< str_pos_48 (str.len (python.str.substr x 12 (str.len x))))) (=> (isupper (python.str.at (python.str.substr x 12 (str.len x)) str_pos_48)) (and (or (= (python.str.substr x 12 (str.len x)) "bEzETExTutheQuYCetH") (= (python.str.substr x 12 (str.len x)) "FUFetEpaPafawIxegIbI") (= (python.str.substr x 12 (str.len x)) "fUxuXYfOmutYM") (= (python.str.substr x 12 (str.len x)) "HYCygiNY") (= (python.str.substr x 12 (str.len x)) "FUnaVYcHity") (= (python.str.substr x 12 (str.len x)) "th") (= (python.str.substr x 12 (str.len x)) "dULUDyQui") (= (python.str.substr x 12 (str.len x)) "rAvUJUlAchUHAsOBese") (= (python.str.substr x 12 (str.len x)) "tefO") (= (python.str.substr x 12 (str.len x)) "vy")) false)))))
(assert (forall ((str_pos_48 Int)) (=> (and (>= str_pos_48 0) (< str_pos_48 (str.len (python.str.substr x 12 (str.len x))))) (str.prefixof (str.++ "Textafarole" ".") x))))
(assert (forall ((str_pos_49 Int)) (=> (and (>= str_pos_49 0) (< str_pos_49 (str.len (python.str.substr x 12 (str.len x))))) (forall ((str_pos_48 Int)) (=> (and (>= str_pos_48 0) (< str_pos_48 (str.len (python.str.substr x 12 (str.len x))))) (=> (and (not (isupper (python.str.at (python.str.substr x 12 (str.len x)) str_pos_49))) (not (islower (python.str.at (python.str.substr x 12 (str.len x)) str_pos_49)))) (and (or (= (python.str.substr x 12 (str.len x)) "bEzETExTutheQuYCetH") (= (python.str.substr x 12 (str.len x)) "FUFetEpaPafawIxegIbI") (= (python.str.substr x 12 (str.len x)) "fUxuXYfOmutYM") (= (python.str.substr x 12 (str.len x)) "HYCygiNY") (= (python.str.substr x 12 (str.len x)) "FUnaVYcHity") (= (python.str.substr x 12 (str.len x)) "th") (= (python.str.substr x 12 (str.len x)) "dULUDyQui") (= (python.str.substr x 12 (str.len x)) "rAvUJUlAchUHAsOBese") (= (python.str.substr x 12 (str.len x)) "tefO") (= (python.str.substr x 12 (str.len x)) "vy")) false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "Textafarole.")
)
### output for cvc5
unknown
(
(define-fun x () String "Textafarole.a")
)

Found solution Textafarole.
WARNING: Solution verification failed for puzzle StrongestExtension:2
Too many constants for extrapolation

Solving puzzle 330/774: StrongestExtension:3
sat_func def sat(s: str, class_name="Gudes", extensions=['CHOXeHeTAsUxyTe', 'QuEtHeTe', 'NOtEX', 'sehYJyFecIte', 'RySyJIFADEXETYBopUL', 'taMEcYW']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
modified_func def sat(s: str, class_name=wrap_str('Gudes'), extensions=wrap_list([wrap_str('CHOXeHeTAsUxyTe'), wrap_str('QuEtHeTe'), wrap_str('NOtEX'), wrap_str('sehYJyFecIte'), wrap_str('RySyJIFADEXETYBopUL'), wrap_str('taMEcYW')])):
    _assert(s.startswith(class_name + '.'))
    ext = s[sym_len(class_name) + 1:]

    def case_delta(x: str):
        tot = wrap_int(0)
        for c in x:
            if c.isupper():
                tot += wrap_int(1)
            elif c.islower():
                tot -= wrap_int(1)
        return tot
    return sym_in(ext, extensions).__and__(case_delta(ext) == max([case_delta(x) for x in extensions]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun is-upper-char ((c String)) Bool
  (and (>= (str.to_code c) 65) (<= (str.to_code c) 90))
)

(define-fun-rec isupper ((s String)) Bool
  (ite (= s "")
       true
       (and (is-upper-char (str.at s 0))
            (isupper (str.substr s 1 (- (str.len s) 1))))
  )
)


(define-fun is-lower-char ((c String)) Bool
  (and (>= (str.to_code c) (str.to_code "a")) (<= (str.to_code c) (str.to_code "z")))
)

(define-fun-rec islower ((s String)) Bool
  (ite (= s "")
       true
       (and (is-lower-char (str.at s 0))
            (islower (str.substr s 1 (- (str.len s) 1))))
  )
)

(declare-const x String)
(assert (str.prefixof (str.++ "Gudes" ".") x))
(assert (forall ((str_pos_50 Int)) (=> (and (>= str_pos_50 0) (< str_pos_50 (str.len (python.str.substr x 6 (str.len x))))) (=> (isupper (python.str.at (python.str.substr x 6 (str.len x)) str_pos_50)) (and (or (= (python.str.substr x 6 (str.len x)) "CHOXeHeTAsUxyTe") (= (python.str.substr x 6 (str.len x)) "QuEtHeTe") (= (python.str.substr x 6 (str.len x)) "NOtEX") (= (python.str.substr x 6 (str.len x)) "sehYJyFecIte") (= (python.str.substr x 6 (str.len x)) "RySyJIFADEXETYBopUL") (= (python.str.substr x 6 (str.len x)) "taMEcYW")) false)))))
(assert (forall ((str_pos_50 Int)) (=> (and (>= str_pos_50 0) (< str_pos_50 (str.len (python.str.substr x 6 (str.len x))))) (str.prefixof (str.++ "Gudes" ".") x))))
(assert (forall ((str_pos_51 Int)) (=> (and (>= str_pos_51 0) (< str_pos_51 (str.len (python.str.substr x 6 (str.len x))))) (forall ((str_pos_50 Int)) (=> (and (>= str_pos_50 0) (< str_pos_50 (str.len (python.str.substr x 6 (str.len x))))) (=> (and (not (isupper (python.str.at (python.str.substr x 6 (str.len x)) str_pos_51))) (not (islower (python.str.at (python.str.substr x 6 (str.len x)) str_pos_51)))) (and (or (= (python.str.substr x 6 (str.len x)) "CHOXeHeTAsUxyTe") (= (python.str.substr x 6 (str.len x)) "QuEtHeTe") (= (python.str.substr x 6 (str.len x)) "NOtEX") (= (python.str.substr x 6 (str.len x)) "sehYJyFecIte") (= (python.str.substr x 6 (str.len x)) "RySyJIFADEXETYBopUL") (= (python.str.substr x 6 (str.len x)) "taMEcYW")) false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "Gudes.")
)
### output for cvc5
unknown
(
(define-fun x () String "Gudes.a")
)

Found solution Gudes.
WARNING: Solution verification failed for puzzle StrongestExtension:3
Too many constants for extrapolation

Solving puzzle 331/774: StrongestExtension:4
sat_func def sat(s: str, class_name="Ruxomyw", extensions=['PUfam', 'H', 'PEVYtHAxe', 'cInyTex', 'PoJApESOch', 'teXTidaQuigUPOtho', 'TEXteSYSyWEQuy', 'C', 'ZEFutexTImyjUHi', 'CIcybAMeT', 'XIWAvaDoBe']):
    assert s.startswith(class_name + ".")
    ext = s[len(class_name) + 1:]

    def case_delta(x: str):
        tot = 0
        for c in x:
            if c.isupper():
                tot += 1
            elif c.islower():
                tot -= 1
        return tot

    return ext in extensions and case_delta(ext) == max([case_delta(x) for x in extensions])
modified_func def sat(s: str, class_name=wrap_str('Ruxomyw'), extensions=wrap_list([wrap_str('PUfam'), wrap_str('H'), wrap_str('PEVYtHAxe'), wrap_str('cInyTex'), wrap_str('PoJApESOch'), wrap_str('teXTidaQuigUPOtho'), wrap_str('TEXteSYSyWEQuy'), wrap_str('C'), wrap_str('ZEFutexTImyjUHi'), wrap_str('CIcybAMeT'), wrap_str('XIWAvaDoBe')])):
    _assert(s.startswith(class_name + '.'))
    ext = s[sym_len(class_name) + 1:]

    def case_delta(x: str):
        tot = wrap_int(0)
        for c in x:
            if c.isupper():
                tot += wrap_int(1)
            elif c.islower():
                tot -= wrap_int(1)
        return tot
    return sym_in(ext, extensions).__and__(case_delta(ext) == max([case_delta(x) for x in extensions]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun is-upper-char ((c String)) Bool
  (and (>= (str.to_code c) 65) (<= (str.to_code c) 90))
)

(define-fun-rec isupper ((s String)) Bool
  (ite (= s "")
       true
       (and (is-upper-char (str.at s 0))
            (isupper (str.substr s 1 (- (str.len s) 1))))
  )
)


(define-fun is-lower-char ((c String)) Bool
  (and (>= (str.to_code c) (str.to_code "a")) (<= (str.to_code c) (str.to_code "z")))
)

(define-fun-rec islower ((s String)) Bool
  (ite (= s "")
       true
       (and (is-lower-char (str.at s 0))
            (islower (str.substr s 1 (- (str.len s) 1))))
  )
)

(declare-const x String)
(assert (str.prefixof (str.++ "Ruxomyw" ".") x))
(assert (forall ((str_pos_52 Int)) (=> (and (>= str_pos_52 0) (< str_pos_52 (str.len (python.str.substr x 8 (str.len x))))) (=> (isupper (python.str.at (python.str.substr x 8 (str.len x)) str_pos_52)) (and (or (= (python.str.substr x 8 (str.len x)) "PUfam") (= (python.str.substr x 8 (str.len x)) "H") (= (python.str.substr x 8 (str.len x)) "PEVYtHAxe") (= (python.str.substr x 8 (str.len x)) "cInyTex") (= (python.str.substr x 8 (str.len x)) "PoJApESOch") (= (python.str.substr x 8 (str.len x)) "teXTidaQuigUPOtho") (= (python.str.substr x 8 (str.len x)) "TEXteSYSyWEQuy") (= (python.str.substr x 8 (str.len x)) "C") (= (python.str.substr x 8 (str.len x)) "ZEFutexTImyjUHi") (= (python.str.substr x 8 (str.len x)) "CIcybAMeT") (= (python.str.substr x 8 (str.len x)) "XIWAvaDoBe")) false)))))
(assert (forall ((str_pos_52 Int)) (=> (and (>= str_pos_52 0) (< str_pos_52 (str.len (python.str.substr x 8 (str.len x))))) (str.prefixof (str.++ "Ruxomyw" ".") x))))
(assert (forall ((str_pos_53 Int)) (=> (and (>= str_pos_53 0) (< str_pos_53 (str.len (python.str.substr x 8 (str.len x))))) (forall ((str_pos_52 Int)) (=> (and (>= str_pos_52 0) (< str_pos_52 (str.len (python.str.substr x 8 (str.len x))))) (=> (and (not (isupper (python.str.at (python.str.substr x 8 (str.len x)) str_pos_53))) (not (islower (python.str.at (python.str.substr x 8 (str.len x)) str_pos_53)))) (and (or (= (python.str.substr x 8 (str.len x)) "PUfam") (= (python.str.substr x 8 (str.len x)) "H") (= (python.str.substr x 8 (str.len x)) "PEVYtHAxe") (= (python.str.substr x 8 (str.len x)) "cInyTex") (= (python.str.substr x 8 (str.len x)) "PoJApESOch") (= (python.str.substr x 8 (str.len x)) "teXTidaQuigUPOtho") (= (python.str.substr x 8 (str.len x)) "TEXteSYSyWEQuy") (= (python.str.substr x 8 (str.len x)) "C") (= (python.str.substr x 8 (str.len x)) "ZEFutexTImyjUHi") (= (python.str.substr x 8 (str.len x)) "CIcybAMeT") (= (python.str.substr x 8 (str.len x)) "XIWAvaDoBe")) false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "Ruxomyw.")
)
### output for cvc5
unknown
(
(define-fun x () String "Ruxomyw.a")
)

Found solution Ruxomyw.
WARNING: Solution verification failed for puzzle StrongestExtension:4
Too many constants for extrapolation

Solving puzzle 332/774: RotateString:0
sat_func def sat(r: str, s="light star", t="I love to look at the starlight!"):
    return r in t and len(r) == len(s) and r in s + s
modified_func def sat(r: str, s=wrap_str('light star'), t=wrap_str('I love to look at the starlight!')):
    return sym_in(r, t).__and__(sym_len(r) == sym_len(s)).__and__(sym_in(r, s + s))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (str.contains "I love to look at the starlight!" x) (= (str.len x) 10)) (str.contains (str.++ "light star" "light star") x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    " starlight")
)
### output for cvc5
sat
(
(define-fun x () String " starlight")
)

Found solution  starlight
Yes! Solved for puzzle  RotateString:0

Solving puzzle 333/774: RotateString:1
sat_func def sat(r: str, s="fuz tox banu dukukyjosuthihono", t="sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt"):
    return r in t and len(r) == len(s) and r in s + s
modified_func def sat(r: str, s=wrap_str('fuz tox banu dukukyjosuthihono'), t=wrap_str('sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt')):
    return sym_in(r, t).__and__(sym_len(r) == sym_len(s)).__and__(sym_in(r, s + s))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (str.contains "sikysefylacywitijuz thosowehiv kiviwas girezol betext lepumarasithihonofuz tox banu dukukyjosutog kuquinecakyt" x) (= (str.len x) 30)) (str.contains (str.++ "fuz tox banu dukukyjosuthihono" "fuz tox banu dukukyjosuthihono") x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "thihonofuz tox banu dukukyjosu")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution thihonofuz tox banu dukukyjosu
Yes! Solved for puzzle  RotateString:1

Solving puzzle 334/774: RotateString:2
sat_func def sat(r: str, s="vyquaquabuwuktus tyryrezywovimu sopikalo ", t="zugu benuzyca cafoca gawy sycapoxitus tyryrezywovimu sopikalo vyquaquabuwuko citextytextythakidu basikyched"):
    return r in t and len(r) == len(s) and r in s + s
modified_func def sat(r: str, s=wrap_str('vyquaquabuwuktus tyryrezywovimu sopikalo '), t=wrap_str('zugu benuzyca cafoca gawy sycapoxitus tyryrezywovimu sopikalo vyquaquabuwuko citextytextythakidu basikyched')):
    return sym_in(r, t).__and__(sym_len(r) == sym_len(s)).__and__(sym_in(r, s + s))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (str.contains "zugu benuzyca cafoca gawy sycapoxitus tyryrezywovimu sopikalo vyquaquabuwuko citextytextythakidu basikyched" x) (= (str.len x) 41)) (str.contains (str.++ "vyquaquabuwuktus tyryrezywovimu sopikalo " "vyquaquabuwuktus tyryrezywovimu sopikalo ") x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "tus tyryrezywovimu sopikalo vyquaquabuwuk")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution tus tyryrezywovimu sopikalo vyquaquabuwuk
Yes! Solved for puzzle  RotateString:2

Solving puzzle 335/774: RotateString:3
sat_func def sat(r: str, s="udynybu cequelynxebalu w guh", t="zigoxesychujocefete nyquuquu wubupi quidoxebalu w guhudynybu cequelynuquumythaku xet syquaxatext lizevachuciconolove"):
    return r in t and len(r) == len(s) and r in s + s
modified_func def sat(r: str, s=wrap_str('udynybu cequelynxebalu w guh'), t=wrap_str('zigoxesychujocefete nyquuquu wubupi quidoxebalu w guhudynybu cequelynuquumythaku xet syquaxatext lizevachuciconolove')):
    return sym_in(r, t).__and__(sym_len(r) == sym_len(s)).__and__(sym_in(r, s + s))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (str.contains "zigoxesychujocefete nyquuquu wubupi quidoxebalu w guhudynybu cequelynuquumythaku xet syquaxatext lizevachuciconolove" x) (= (str.len x) 28)) (str.contains (str.++ "udynybu cequelynxebalu w guh" "udynybu cequelynxebalu w guh") x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "xebalu w guhudynybu cequelyn")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution xebalu w guhudynybu cequelyn
Yes! Solved for puzzle  RotateString:3

Solving puzzle 336/774: RotateString:4
sat_func def sat(r: str, s="fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe", t="fuch mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kotextu hothakatozate thyzet"):
    return r in t and len(r) == len(s) and r in s + s
modified_func def sat(r: str, s=wrap_str('fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe'), t=wrap_str('fuch mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kotextu hothakatozate thyzet')):
    return sym_in(r, t).__and__(sym_len(r) == sym_len(s)).__and__(sym_in(r, s + s))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (str.contains "fuch mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kotextu hothakatozate thyzet" x) (= (str.len x) 65)) (str.contains (str.++ "fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe" "fecajajeh b tythanenifewed quomekucybimudegicyj zos depogip kmowe") x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip k")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution mowefecajajeh b tythanenifewed quomekucybimudegicyj zos depogip k
Yes! Solved for puzzle  RotateString:4

Solving puzzle 337/774: EvenOddDigits:0
sat_func def sat(n: int, evens=17, odds=3):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(17), odds=wrap_int(3)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_54 Int)) (=> (and (>= str_pos_54 0) (< str_pos_54 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_54)) 0))))
(assert (forall ((str_pos_54 Int)) (=> (and (>= str_pos_54 0) (< str_pos_54 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_54) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_55 Int)) (=> (and (>= str_pos_55 0) (< str_pos_55 (str.len (str.from_int x)))) (forall ((str_pos_54 Int)) (=> (and (>= str_pos_54 0) (< str_pos_54 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_55)) 0))))))
(assert (forall ((str_pos_55 Int)) (=> (and (>= str_pos_55 0) (< str_pos_55 (str.len (str.from_int x)))) (forall ((str_pos_54 Int)) (=> (and (>= str_pos_54 0) (< str_pos_54 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_55) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:0
Too many constants for extrapolation

Solving puzzle 338/774: EvenOddDigits:1
sat_func def sat(n: int, evens=117, odds=56):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(117), odds=wrap_int(56)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_56 Int)) (=> (and (>= str_pos_56 0) (< str_pos_56 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_56)) 0))))
(assert (forall ((str_pos_56 Int)) (=> (and (>= str_pos_56 0) (< str_pos_56 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_56) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_57 Int)) (=> (and (>= str_pos_57 0) (< str_pos_57 (str.len (str.from_int x)))) (forall ((str_pos_56 Int)) (=> (and (>= str_pos_56 0) (< str_pos_56 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_57)) 0))))))
(assert (forall ((str_pos_57 Int)) (=> (and (>= str_pos_57 0) (< str_pos_57 (str.len (str.from_int x)))) (forall ((str_pos_56 Int)) (=> (and (>= str_pos_56 0) (< str_pos_56 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_57) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:1
One large constant for extrapolation
Solving simpler variation replaced 117 with 3
sat_func def sat(n: int, evens=3, odds=56):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(3), odds=wrap_int(56)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_58 Int)) (=> (and (>= str_pos_58 0) (< str_pos_58 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_58)) 0))))
(assert (forall ((str_pos_58 Int)) (=> (and (>= str_pos_58 0) (< str_pos_58 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_58) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_59 Int)) (=> (and (>= str_pos_59 0) (< str_pos_59 (str.len (str.from_int x)))) (forall ((str_pos_58 Int)) (=> (and (>= str_pos_58 0) (< str_pos_58 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_59)) 0))))))
(assert (forall ((str_pos_59 Int)) (=> (and (>= str_pos_59 0) (< str_pos_59 (str.len (str.from_int x)))) (forall ((str_pos_58 Int)) (=> (and (>= str_pos_58 0) (< str_pos_58 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_59) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:1

Solving puzzle 339/774: EvenOddDigits:2
sat_func def sat(n: int, evens=114, odds=119):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(114), odds=wrap_int(119)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_60 Int)) (=> (and (>= str_pos_60 0) (< str_pos_60 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_60)) 0))))
(assert (forall ((str_pos_60 Int)) (=> (and (>= str_pos_60 0) (< str_pos_60 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_60) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_61 Int)) (=> (and (>= str_pos_61 0) (< str_pos_61 (str.len (str.from_int x)))) (forall ((str_pos_60 Int)) (=> (and (>= str_pos_60 0) (< str_pos_60 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_61)) 0))))))
(assert (forall ((str_pos_61 Int)) (=> (and (>= str_pos_61 0) (< str_pos_61 (str.len (str.from_int x)))) (forall ((str_pos_60 Int)) (=> (and (>= str_pos_60 0) (< str_pos_60 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_61) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:2
Two large constants for extrapolation
Solving simpler variation replaced 114 with 3 and 119 with 5
sat_func def sat(n: int, evens=3, odds=5):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(3), odds=wrap_int(5)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_62 Int)) (=> (and (>= str_pos_62 0) (< str_pos_62 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_62)) 0))))
(assert (forall ((str_pos_62 Int)) (=> (and (>= str_pos_62 0) (< str_pos_62 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_62) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_63 Int)) (=> (and (>= str_pos_63 0) (< str_pos_63 (str.len (str.from_int x)))) (forall ((str_pos_62 Int)) (=> (and (>= str_pos_62 0) (< str_pos_62 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_63)) 0))))))
(assert (forall ((str_pos_63 Int)) (=> (and (>= str_pos_63 0) (< str_pos_63 (str.len (str.from_int x)))) (forall ((str_pos_62 Int)) (=> (and (>= str_pos_62 0) (< str_pos_62 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_63) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:2

Solving puzzle 340/774: EvenOddDigits:3
sat_func def sat(n: int, evens=133, odds=33):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(133), odds=wrap_int(33)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_64 Int)) (=> (and (>= str_pos_64 0) (< str_pos_64 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_64)) 0))))
(assert (forall ((str_pos_64 Int)) (=> (and (>= str_pos_64 0) (< str_pos_64 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_64) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_65 Int)) (=> (and (>= str_pos_65 0) (< str_pos_65 (str.len (str.from_int x)))) (forall ((str_pos_64 Int)) (=> (and (>= str_pos_64 0) (< str_pos_64 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_65)) 0))))))
(assert (forall ((str_pos_65 Int)) (=> (and (>= str_pos_65 0) (< str_pos_65 (str.len (str.from_int x)))) (forall ((str_pos_64 Int)) (=> (and (>= str_pos_64 0) (< str_pos_64 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_65) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:3
One large constant for extrapolation
Solving simpler variation replaced 133 with 3
sat_func def sat(n: int, evens=3, odds=33):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(3), odds=wrap_int(33)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_66 Int)) (=> (and (>= str_pos_66 0) (< str_pos_66 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_66)) 0))))
(assert (forall ((str_pos_66 Int)) (=> (and (>= str_pos_66 0) (< str_pos_66 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_66) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_67 Int)) (=> (and (>= str_pos_67 0) (< str_pos_67 (str.len (str.from_int x)))) (forall ((str_pos_66 Int)) (=> (and (>= str_pos_66 0) (< str_pos_66 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_67)) 0))))))
(assert (forall ((str_pos_67 Int)) (=> (and (>= str_pos_67 0) (< str_pos_67 (str.len (str.from_int x)))) (forall ((str_pos_66 Int)) (=> (and (>= str_pos_66 0) (< str_pos_66 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_67) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:3

Solving puzzle 341/774: EvenOddDigits:4
sat_func def sat(n: int, evens=8, odds=114):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(8), odds=wrap_int(114)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_68 Int)) (=> (and (>= str_pos_68 0) (< str_pos_68 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_68)) 0))))
(assert (forall ((str_pos_68 Int)) (=> (and (>= str_pos_68 0) (< str_pos_68 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_68) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_69 Int)) (=> (and (>= str_pos_69 0) (< str_pos_69 (str.len (str.from_int x)))) (forall ((str_pos_68 Int)) (=> (and (>= str_pos_68 0) (< str_pos_68 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_69)) 0))))))
(assert (forall ((str_pos_69 Int)) (=> (and (>= str_pos_69 0) (< str_pos_69 (str.len (str.from_int x)))) (forall ((str_pos_68 Int)) (=> (and (>= str_pos_68 0) (< str_pos_68 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_69) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:4
One large constant for extrapolation
Solving simpler variation replaced 114 with 3
sat_func def sat(n: int, evens=8, odds=3):
    for c in str(n):
        if int(c) % 2 == 0:
            evens -= 1
        else:
            odds -= 1
    return evens == 0 and odds == 0
modified_func def sat(n: int, evens=wrap_int(8), odds=wrap_int(3)):
    for c in sym_str(n):
        if sym_int(c) % wrap_int(2) == wrap_int(0):
            evens -= wrap_int(1)
        else:
            odds -= wrap_int(1)
    return (evens == wrap_int(0)).__and__(odds == wrap_int(0))
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_70 Int)) (=> (and (>= str_pos_70 0) (< str_pos_70 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_70)) 0))))
(assert (forall ((str_pos_70 Int)) (=> (and (>= str_pos_70 0) (< str_pos_70 (str.len (str.from_int x)))) (=> (= (mod (python.int (python.str.at (str.from_int x) str_pos_70) 10) 2) 0) (and false false)))))
(assert (forall ((str_pos_71 Int)) (=> (and (>= str_pos_71 0) (< str_pos_71 (str.len (str.from_int x)))) (forall ((str_pos_70 Int)) (=> (and (>= str_pos_70 0) (< str_pos_70 (str.len (str.from_int x)))) (> (str.len (python.str.at (str.from_int x) str_pos_71)) 0))))))
(assert (forall ((str_pos_71 Int)) (=> (and (>= str_pos_71 0) (< str_pos_71 (str.len (str.from_int x)))) (forall ((str_pos_70 Int)) (=> (and (>= str_pos_70 0) (< str_pos_70 (str.len (str.from_int x)))) (=> (not (= (mod (python.int (python.str.at (str.from_int x) str_pos_71) 10) 2) 0)) (and false false)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 1))
)

Found solution -2
Exception in checking result: invalid literal for int() with base 10: '-'
WARNING: Solution verification failed for puzzle EvenOddDigits:4

Solving puzzle 342/774: RomanNumerals:0
sat_func def sat(roman: str, n=2414):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
modified_func def sat(roman: str, n=wrap_int(2414)):
    key = {wrap_int(1000): wrap_str('m'), wrap_int(900): wrap_str('cm'), wrap_int(500): wrap_str('d'), wrap_int(400): wrap_str('cd'), wrap_int(100): wrap_str('c'), wrap_int(90): wrap_str('xc'), wrap_int(50): wrap_str('l'), wrap_int(40): wrap_str('xl'), wrap_int(10): wrap_str('x'), wrap_int(9): wrap_str('ix'), wrap_int(5): wrap_str('v'), wrap_int(4): wrap_str('iv'), wrap_int(1): wrap_str('i')}
    m = wrap_int(0)
    for base in wrap_list([wrap_int(1000), wrap_int(100), wrap_int(10), wrap_int(1)]):
        for mul in wrap_list([wrap_int(9), wrap_int(4), wrap_int(5), wrap_int(1), wrap_int(1), wrap_int(1)]):
            val = base * mul
            if sym_in(val, key).__and__(roman.startswith(key[val])):
                m += val
                roman = roman[sym_len(key[val]):]
                if (mul == wrap_int(9)).__or__(mul == wrap_int(4)):
                    break
    return m == n
Exception -- for puzzle RomanNumerals:0 'dict' object has no attribute 'contains'

Solving puzzle 343/774: RomanNumerals:1
sat_func def sat(roman: str, n=2058):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
modified_func def sat(roman: str, n=wrap_int(2058)):
    key = {wrap_int(1000): wrap_str('m'), wrap_int(900): wrap_str('cm'), wrap_int(500): wrap_str('d'), wrap_int(400): wrap_str('cd'), wrap_int(100): wrap_str('c'), wrap_int(90): wrap_str('xc'), wrap_int(50): wrap_str('l'), wrap_int(40): wrap_str('xl'), wrap_int(10): wrap_str('x'), wrap_int(9): wrap_str('ix'), wrap_int(5): wrap_str('v'), wrap_int(4): wrap_str('iv'), wrap_int(1): wrap_str('i')}
    m = wrap_int(0)
    for base in wrap_list([wrap_int(1000), wrap_int(100), wrap_int(10), wrap_int(1)]):
        for mul in wrap_list([wrap_int(9), wrap_int(4), wrap_int(5), wrap_int(1), wrap_int(1), wrap_int(1)]):
            val = base * mul
            if sym_in(val, key).__and__(roman.startswith(key[val])):
                m += val
                roman = roman[sym_len(key[val]):]
                if (mul == wrap_int(9)).__or__(mul == wrap_int(4)):
                    break
    return m == n
Exception -- for puzzle RomanNumerals:1 'dict' object has no attribute 'contains'

Solving puzzle 344/774: RomanNumerals:2
sat_func def sat(roman: str, n=1467):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
modified_func def sat(roman: str, n=wrap_int(1467)):
    key = {wrap_int(1000): wrap_str('m'), wrap_int(900): wrap_str('cm'), wrap_int(500): wrap_str('d'), wrap_int(400): wrap_str('cd'), wrap_int(100): wrap_str('c'), wrap_int(90): wrap_str('xc'), wrap_int(50): wrap_str('l'), wrap_int(40): wrap_str('xl'), wrap_int(10): wrap_str('x'), wrap_int(9): wrap_str('ix'), wrap_int(5): wrap_str('v'), wrap_int(4): wrap_str('iv'), wrap_int(1): wrap_str('i')}
    m = wrap_int(0)
    for base in wrap_list([wrap_int(1000), wrap_int(100), wrap_int(10), wrap_int(1)]):
        for mul in wrap_list([wrap_int(9), wrap_int(4), wrap_int(5), wrap_int(1), wrap_int(1), wrap_int(1)]):
            val = base * mul
            if sym_in(val, key).__and__(roman.startswith(key[val])):
                m += val
                roman = roman[sym_len(key[val]):]
                if (mul == wrap_int(9)).__or__(mul == wrap_int(4)):
                    break
    return m == n
Exception -- for puzzle RomanNumerals:2 'dict' object has no attribute 'contains'

Solving puzzle 345/774: RomanNumerals:3
sat_func def sat(roman: str, n=1533):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
modified_func def sat(roman: str, n=wrap_int(1533)):
    key = {wrap_int(1000): wrap_str('m'), wrap_int(900): wrap_str('cm'), wrap_int(500): wrap_str('d'), wrap_int(400): wrap_str('cd'), wrap_int(100): wrap_str('c'), wrap_int(90): wrap_str('xc'), wrap_int(50): wrap_str('l'), wrap_int(40): wrap_str('xl'), wrap_int(10): wrap_str('x'), wrap_int(9): wrap_str('ix'), wrap_int(5): wrap_str('v'), wrap_int(4): wrap_str('iv'), wrap_int(1): wrap_str('i')}
    m = wrap_int(0)
    for base in wrap_list([wrap_int(1000), wrap_int(100), wrap_int(10), wrap_int(1)]):
        for mul in wrap_list([wrap_int(9), wrap_int(4), wrap_int(5), wrap_int(1), wrap_int(1), wrap_int(1)]):
            val = base * mul
            if sym_in(val, key).__and__(roman.startswith(key[val])):
                m += val
                roman = roman[sym_len(key[val]):]
                if (mul == wrap_int(9)).__or__(mul == wrap_int(4)):
                    break
    return m == n
Exception -- for puzzle RomanNumerals:3 'dict' object has no attribute 'contains'

Solving puzzle 346/774: RomanNumerals:4
sat_func def sat(roman: str, n=114):
    key = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',
           100: 'c', 90: 'xc', 50: 'l', 40: 'xl',
           10: 'x', 9: 'ix', 5: 'v', 4: 'iv',
           1: 'i'}
    m = 0
    for base in [1000, 100, 10, 1]:
        for mul in [9, 4, 5, 1, 1, 1]:  # up to three 1's, move on after 9 or 4
            val = base * mul
            if val in key and roman.startswith(key[val]):
                m += val
                roman = roman[len(key[val]):]
                if mul == 9 or mul == 4:  # 9 or 4 can't be followed by anything else
                    break
    return m == n
modified_func def sat(roman: str, n=wrap_int(114)):
    key = {wrap_int(1000): wrap_str('m'), wrap_int(900): wrap_str('cm'), wrap_int(500): wrap_str('d'), wrap_int(400): wrap_str('cd'), wrap_int(100): wrap_str('c'), wrap_int(90): wrap_str('xc'), wrap_int(50): wrap_str('l'), wrap_int(40): wrap_str('xl'), wrap_int(10): wrap_str('x'), wrap_int(9): wrap_str('ix'), wrap_int(5): wrap_str('v'), wrap_int(4): wrap_str('iv'), wrap_int(1): wrap_str('i')}
    m = wrap_int(0)
    for base in wrap_list([wrap_int(1000), wrap_int(100), wrap_int(10), wrap_int(1)]):
        for mul in wrap_list([wrap_int(9), wrap_int(4), wrap_int(5), wrap_int(1), wrap_int(1), wrap_int(1)]):
            val = base * mul
            if sym_in(val, key).__and__(roman.startswith(key[val])):
                m += val
                roman = roman[sym_len(key[val]):]
                if (mul == wrap_int(9)).__or__(mul == wrap_int(4)):
                    break
    return m == n
Exception -- for puzzle RomanNumerals:4 'dict' object has no attribute 'contains'

Solving puzzle 347/774: MostUnique:0
sat_func def sat(s: str, pool=['cat', 'catatatatctsa', 'abcdefhijklmnop', '124259239185125', '', 'foo', 'unique']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
modified_func def sat(s: str, pool=wrap_list([wrap_str('cat'), wrap_str('catatatatctsa'), wrap_str('abcdefhijklmnop'), wrap_str('124259239185125'), wrap_str(''), wrap_str('foo'), wrap_str('unique')])):
    _assert(sym_in(s, pool))
    n = sym_len(set(s))
    for p in pool:
        _assert(sym_len(set(p)) <= n)
    return True
Exception -- for puzzle MostUnique:0 Symbolic hash not yet implemented

Solving puzzle 348/774: MostUnique:1
sat_func def sat(s: str, pool=['sibiloguhujuquenam', 'nyzidikedutexti', 'zatextuquyvakijahixa', 'textujig', 'cewynyrimatex', 'textusaxinypuhyheza']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
modified_func def sat(s: str, pool=wrap_list([wrap_str('sibiloguhujuquenam'), wrap_str('nyzidikedutexti'), wrap_str('zatextuquyvakijahixa'), wrap_str('textujig'), wrap_str('cewynyrimatex'), wrap_str('textusaxinypuhyheza')])):
    _assert(sym_in(s, pool))
    n = sym_len(set(s))
    for p in pool:
        _assert(sym_len(set(p)) <= n)
    return True
Exception -- for puzzle MostUnique:1 Symbolic hash not yet implemented

Solving puzzle 349/774: MostUnique:2
sat_func def sat(s: str, pool=['gylapasugatextysar', 'zapy', 'hycokelet']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
modified_func def sat(s: str, pool=wrap_list([wrap_str('gylapasugatextysar'), wrap_str('zapy'), wrap_str('hycokelet')])):
    _assert(sym_in(s, pool))
    n = sym_len(set(s))
    for p in pool:
        _assert(sym_len(set(p)) <= n)
    return True
Exception -- for puzzle MostUnique:2 Symbolic hash not yet implemented

Solving puzzle 350/774: MostUnique:3
sat_func def sat(s: str, pool=['te', '', 'badypikyxucudil', 'fuhibatextixyburekan', 'chole']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
modified_func def sat(s: str, pool=wrap_list([wrap_str('te'), wrap_str(''), wrap_str('badypikyxucudil'), wrap_str('fuhibatextixyburekan'), wrap_str('chole')])):
    _assert(sym_in(s, pool))
    n = sym_len(set(s))
    for p in pool:
        _assert(sym_len(set(p)) <= n)
    return True
Exception -- for puzzle MostUnique:3 Symbolic hash not yet implemented

Solving puzzle 351/774: MostUnique:4
sat_func def sat(s: str, pool=['th', 's', 'bulonu', 'r']):
    assert s in pool
    n = len(set(s))
    for p in pool:
        assert len(set(p)) <= n
    return True
modified_func def sat(s: str, pool=wrap_list([wrap_str('th'), wrap_str('s'), wrap_str('bulonu'), wrap_str('r')])):
    _assert(sym_in(s, pool))
    n = sym_len(set(s))
    for p in pool:
        _assert(sym_len(set(p)) <= n)
    return True
Exception -- for puzzle MostUnique:4 Symbolic hash not yet implemented

Solving puzzle 352/774: Abbreviate:0
sat_func def sat(s: str, word="antidisestablishmentarianism", max_len=10):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
modified_func def sat(s: str, word=wrap_str('antidisestablishmentarianism'), max_len=wrap_int(10)):
    if sym_len(word) <= max_len:
        return word == s
    return (sym_int(s[1:-1]) == sym_len(word[1:-1])).__and__(word[wrap_int(0)] == s[wrap_int(0)]).__and__(word[-wrap_int(1)] == s[-wrap_int(1)])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (=> (<= 28 10) (= "antidisestablishmentarianism" x)))
(assert (=> (not (<= 28 10)) (> (str.len (python.str.substr x 1 -1)) 0)))
(assert (=> (not (<= 28 10)) (and (and (= (python.int (python.str.substr x 1 -1) 10) 26) (= (str.substr "antidisestablishmentarianism" 0 (- 1 0)) (python.str.at x 0))) (= (str.substr "antidisestablishmentarianism" -1 (- 0 -1)) (python.str.at x -1)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 39 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Abbreviate:0
Too many constants for extrapolation

Solving puzzle 353/774: Abbreviate:1
sat_func def sat(s: str, word="pawuzorythalirinasubyg", max_len=12):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
modified_func def sat(s: str, word=wrap_str('pawuzorythalirinasubyg'), max_len=wrap_int(12)):
    if sym_len(word) <= max_len:
        return word == s
    return (sym_int(s[1:-1]) == sym_len(word[1:-1])).__and__(word[wrap_int(0)] == s[wrap_int(0)]).__and__(word[-wrap_int(1)] == s[-wrap_int(1)])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (=> (<= 22 12) (= "pawuzorythalirinasubyg" x)))
(assert (=> (not (<= 22 12)) (> (str.len (python.str.substr x 1 -1)) 0)))
(assert (=> (not (<= 22 12)) (and (and (= (python.int (python.str.substr x 1 -1) 10) 20) (= (str.substr "pawuzorythalirinasubyg" 0 (- 1 0)) (python.str.at x 0))) (= (str.substr "pawuzorythalirinasubyg" -1 (- 0 -1)) (python.str.at x -1)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 39 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Abbreviate:1
Too many constants for extrapolation

Solving puzzle 354/774: Abbreviate:2
sat_func def sat(s: str, word="jomodosigezyfulach", max_len=5):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
modified_func def sat(s: str, word=wrap_str('jomodosigezyfulach'), max_len=wrap_int(5)):
    if sym_len(word) <= max_len:
        return word == s
    return (sym_int(s[1:-1]) == sym_len(word[1:-1])).__and__(word[wrap_int(0)] == s[wrap_int(0)]).__and__(word[-wrap_int(1)] == s[-wrap_int(1)])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (=> (<= 18 5) (= "jomodosigezyfulach" x)))
(assert (=> (not (<= 18 5)) (> (str.len (python.str.substr x 1 -1)) 0)))
(assert (=> (not (<= 18 5)) (and (and (= (python.int (python.str.substr x 1 -1) 10) 16) (= (str.substr "jomodosigezyfulach" 0 (- 1 0)) (python.str.at x 0))) (= (str.substr "jomodosigezyfulach" -1 (- 0 -1)) (python.str.at x -1)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 39 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Abbreviate:2
Too many constants for extrapolation

Solving puzzle 355/774: Abbreviate:3
sat_func def sat(s: str, word="bybakichop", max_len=12):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
modified_func def sat(s: str, word=wrap_str('bybakichop'), max_len=wrap_int(12)):
    if sym_len(word) <= max_len:
        return word == s
    return (sym_int(s[1:-1]) == sym_len(word[1:-1])).__and__(word[wrap_int(0)] == s[wrap_int(0)]).__and__(word[-wrap_int(1)] == s[-wrap_int(1)])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (=> (<= 10 12) (= "bybakichop" x)))
(assert (=> (not (<= 10 12)) (> (str.len (python.str.substr x 1 -1)) 0)))
(assert (=> (not (<= 10 12)) (and (and (= (python.int (python.str.substr x 1 -1) 10) 8) (= (str.substr "bybakichop" 0 (- 1 0)) (python.str.at x 0))) (= (str.substr "bybakichop" -1 (- 0 -1)) (python.str.at x -1)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bybakichop")
)
### output for cvc5
sat
(
(define-fun x () String "bybakichop")
)

Found solution bybakichop
Yes! Solved for puzzle  Abbreviate:3

Solving puzzle 356/774: Abbreviate:4
sat_func def sat(s: str, word="wywaxizodetextonigijalate", max_len=5):
    if len(word) <= max_len:
        return word == s
    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]
modified_func def sat(s: str, word=wrap_str('wywaxizodetextonigijalate'), max_len=wrap_int(5)):
    if sym_len(word) <= max_len:
        return word == s
    return (sym_int(s[1:-1]) == sym_len(word[1:-1])).__and__(word[wrap_int(0)] == s[wrap_int(0)]).__and__(word[-wrap_int(1)] == s[-wrap_int(1)])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x String)
(assert (=> (<= 25 5) (= "wywaxizodetextonigijalate" x)))
(assert (=> (not (<= 25 5)) (> (str.len (python.str.substr x 1 -1)) 0)))
(assert (=> (not (<= 25 5)) (and (and (= (python.int (python.str.substr x 1 -1) 10) 23) (= (str.substr "wywaxizodetextonigijalate" 0 (- 1 0)) (python.str.at x 0))) (= (str.substr "wywaxizodetextonigijalate" -1 (- 0 -1)) (python.str.at x -1)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 39 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Abbreviate:4
Too many constants for extrapolation

Solving puzzle 357/774: DecreasingCountComparison:0
sat_func def sat(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
modified_func def sat(n: int, scores=wrap_list([wrap_int(100), wrap_int(95), wrap_int(80), wrap_int(70), wrap_int(65), wrap_int(9), wrap_int(9), wrap_int(9), wrap_int(4), wrap_int(2), wrap_int(1)]), k=wrap_int(6)):
    _assert(all(sym_generator((scores[i] >= scores[i + wrap_int(1)] for i in sym_range(sym_len(scores) - 1)))), wrap_str('Hint: scores are non-decreasing'))
    return all(sym_generator(((s >= scores[k]).__and__(s > wrap_int(0)) for s in scores[:n]))).__and__(all(sym_generator(((s < scores[k]).__or__(s <= wrap_int(0)) for s in scores[n:]))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true))
(assert (and (and (and (and (and (and (and (and (and (and (and (and true true) (and true true)) (and true true)) (and true true)) (and true true)) (and true true)) (and true true)) (and true true)) (and false true)) (and false true)) (and false true)) (and (and (and (and (and (and (and (and (and (and (or false (<= 100 0)) (or false (<= 95 0))) (or false (<= 80 0))) (or false (<= 70 0))) (or false (<= 65 0))) (or false (<= 9 0))) (or false (<= 9 0))) (or false (<= 9 0))) (or true (<= 4 0))) (or true (<= 2 0))) (or true (<= 1 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 6 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle DecreasingCountComparison:0
One large constant for extrapolation
Solving simpler variation replaced 100 with 3
sat_func def sat(n: int, scores=[3, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
modified_func def sat(n: int, scores=wrap_list([wrap_int(3), wrap_int(95), wrap_int(80), wrap_int(70), wrap_int(65), wrap_int(9), wrap_int(9), wrap_int(9), wrap_int(4), wrap_int(2), wrap_int(1)]), k=wrap_int(6)):
    _assert(all(sym_generator((scores[i] >= scores[i + wrap_int(1)] for i in sym_range(sym_len(scores) - 1)))), wrap_str('Hint: scores are non-decreasing'))
    return all(sym_generator(((s >= scores[k]).__and__(s > wrap_int(0)) for s in scores[:n]))).__and__(all(sym_generator(((s < scores[k]).__or__(s <= wrap_int(0)) for s in scores[n:]))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (and (and (and (and false true) true) true) true) true) true) true) true) true))
(assert (and (and (and (and (and (and (and (and (and (and (and (and false true) (and true true)) (and true true)) (and true true)) (and true true)) (and true true)) (and true true)) (and true true)) (and false true)) (and false true)) (and false true)) (and (and (and (and (and (and (and (and (and (and (or true (<= 3 0)) (or false (<= 95 0))) (or false (<= 80 0))) (or false (<= 70 0))) (or false (<= 65 0))) (or false (<= 9 0))) (or false (<= 9 0))) (or false (<= 9 0))) (or true (<= 4 0))) (or true (<= 2 0))) (or true (<= 1 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 6 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle DecreasingCountComparison:0

Solving puzzle 358/774: DecreasingCountComparison:1
sat_func def sat(n: int, scores=[32, 32, 31, 30, 25, 25, 21, 20, 17, 17, 16, 15, 15, 14, 11, 2, 0], k=4):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
modified_func def sat(n: int, scores=wrap_list([wrap_int(32), wrap_int(32), wrap_int(31), wrap_int(30), wrap_int(25), wrap_int(25), wrap_int(21), wrap_int(20), wrap_int(17), wrap_int(17), wrap_int(16), wrap_int(15), wrap_int(15), wrap_int(14), wrap_int(11), wrap_int(2), wrap_int(0)]), k=wrap_int(4)):
    _assert(all(sym_generator((scores[i] >= scores[i + wrap_int(1)] for i in sym_range(sym_len(scores) - 1)))), wrap_str('Hint: scores are non-decreasing'))
    return all(sym_generator(((s >= scores[k]).__and__(s > wrap_int(0)) for s in scores[:n]))).__and__(all(sym_generator(((s < scores[k]).__or__(s <= wrap_int(0)) for s in scores[n:]))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true) true) true) true) true) true) true))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and true true) (and true true)) (and true true)) (and true true)) (and true true)) (and true true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false false)) (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (or false (<= 32 0)) (or false (<= 32 0))) (or false (<= 31 0))) (or false (<= 30 0))) (or false (<= 25 0))) (or false (<= 25 0))) (or true (<= 21 0))) (or true (<= 20 0))) (or true (<= 17 0))) (or true (<= 17 0))) (or true (<= 16 0))) (or true (<= 15 0))) (or true (<= 15 0))) (or true (<= 14 0))) (or true (<= 11 0))) (or true (<= 2 0))) (or true (<= 0 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 6 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle DecreasingCountComparison:1
Too many constants for extrapolation

Solving puzzle 359/774: DecreasingCountComparison:2
sat_func def sat(n: int, scores=[44, 42, 41, 41, 40, 40, 39, 38, 38, 38, 37, 33, 32, 31, 31, 31, 30, 29, 28, 26, 25, 24, 24, 23, 23, 22, 20, 20, 20, 18, 17, 17, 16, 16, 12, 9, 9, 7, 6, 5, 4, 2], k=1):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
modified_func def sat(n: int, scores=wrap_list([wrap_int(44), wrap_int(42), wrap_int(41), wrap_int(41), wrap_int(40), wrap_int(40), wrap_int(39), wrap_int(38), wrap_int(38), wrap_int(38), wrap_int(37), wrap_int(33), wrap_int(32), wrap_int(31), wrap_int(31), wrap_int(31), wrap_int(30), wrap_int(29), wrap_int(28), wrap_int(26), wrap_int(25), wrap_int(24), wrap_int(24), wrap_int(23), wrap_int(23), wrap_int(22), wrap_int(20), wrap_int(20), wrap_int(20), wrap_int(18), wrap_int(17), wrap_int(17), wrap_int(16), wrap_int(16), wrap_int(12), wrap_int(9), wrap_int(9), wrap_int(7), wrap_int(6), wrap_int(5), wrap_int(4), wrap_int(2)]), k=wrap_int(1)):
    _assert(all(sym_generator((scores[i] >= scores[i + wrap_int(1)] for i in sym_range(sym_len(scores) - 1)))), wrap_str('Hint: scores are non-decreasing'))
    return all(sym_generator(((s >= scores[k]).__and__(s > wrap_int(0)) for s in scores[:n]))).__and__(all(sym_generator(((s < scores[k]).__or__(s <= wrap_int(0)) for s in scores[n:]))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true) true))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and true true) (and true true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and (and (and (and (and (and...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 6 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle DecreasingCountComparison:2
Too many constants for extrapolation

Solving puzzle 360/774: DecreasingCountComparison:3
sat_func def sat(n: int, scores=[36, 27, 24, 19, 15, 15, 8, 8, 5], k=4):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
modified_func def sat(n: int, scores=wrap_list([wrap_int(36), wrap_int(27), wrap_int(24), wrap_int(19), wrap_int(15), wrap_int(15), wrap_int(8), wrap_int(8), wrap_int(5)]), k=wrap_int(4)):
    _assert(all(sym_generator((scores[i] >= scores[i + wrap_int(1)] for i in sym_range(sym_len(scores) - 1)))), wrap_str('Hint: scores are non-decreasing'))
    return all(sym_generator(((s >= scores[k]).__and__(s > wrap_int(0)) for s in scores[:n]))).__and__(all(sym_generator(((s < scores[k]).__or__(s <= wrap_int(0)) for s in scores[n:]))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (and (and true true) true) true) true) true) true) true))
(assert (and (and (and (and (and (and (and (and (and (and true true) (and true true)) (and true true)) (and true true)) (and true true)) (and true true)) (and false true)) (and false true)) (and false true)) (and (and (and (and (and (and (and (and (or false (<= 36 0)) (or false (<= 27 0))) (or false (<= 24 0))) (or false (<= 19 0))) (or false (<= 15 0))) (or false (<= 15 0))) (or true (<= 8 0))) (or true (<= 8 0))) (or true (<= 5 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 6 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle DecreasingCountComparison:3
Too many constants for extrapolation

Solving puzzle 361/774: DecreasingCountComparison:4
sat_func def sat(n: int, scores=[20, 19, 17, 13, 12, 11, 10, 6], k=2):
    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), "Hint: scores are non-decreasing"
    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])
modified_func def sat(n: int, scores=wrap_list([wrap_int(20), wrap_int(19), wrap_int(17), wrap_int(13), wrap_int(12), wrap_int(11), wrap_int(10), wrap_int(6)]), k=wrap_int(2)):
    _assert(all(sym_generator((scores[i] >= scores[i + wrap_int(1)] for i in sym_range(sym_len(scores) - 1)))), wrap_str('Hint: scores are non-decreasing'))
    return all(sym_generator(((s >= scores[k]).__and__(s > wrap_int(0)) for s in scores[:n]))).__and__(all(sym_generator(((s < scores[k]).__or__(s <= wrap_int(0)) for s in scores[n:]))))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (and true true) true) true) true) true) true))
(assert (and (and (and (and (and (and (and (and (and true true) (and true true)) (and true true)) (and false true)) (and false true)) (and false true)) (and false true)) (and false true)) (and (and (and (and (and (and (and (or false (<= 20 0)) (or false (<= 19 0))) (or false (<= 17 0))) (or true (<= 13 0))) (or true (<= 12 0))) (or true (<= 11 0))) (or true (<= 10 0))) (or true (<= 6 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 6 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle DecreasingCountComparison:4
Too many constants for extrapolation

Solving puzzle 362/774: VowelDrop:0
sat_func def sat(t: str, s="Problems"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
modified_func def sat(t: str, s=wrap_str('Problems')):
    i = wrap_int(0)
    for c in s.lower():
        if sym_in(c, wrap_str('aeiouy')):
            continue
        _assert(t[i] == wrap_str('.'), wrap_str('expecting `.` at position ') + sym_str(i))
        i += wrap_int(1)
        _assert(t[i] == c, wrap_str('expecting `') + sym_str(c) + wrap_str('`'))
        i += wrap_int(1)
    return i == sym_len(t)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "."))
(assert (= (python.str.at x 1) "p"))
(assert (= (python.str.at x 2) "."))
(assert (= (python.str.at x 3) "r"))
(assert (= (python.str.at x 4) "."))
(assert (= (python.str.at x 5) "b"))
(assert (= (python.str.at x 6) "."))
(assert (= (python.str.at x 7) "l"))
(assert (= (python.str.at x 8) "."))
(assert (= (python.str.at x 9) "m"))
(assert (= (python.str.at x 10) "."))
(assert (= (python.str.at x 11) "s"))
(assert (= 12 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    ".p.r.b.l.m.s")
)
### output for cvc5
sat
(
(define-fun x () String ".p.r.b.l.m.s")
)

Found solution .p.r.b.l.m.s
Yes! Solved for puzzle  VowelDrop:0

Solving puzzle 363/774: VowelDrop:1
sat_func def sat(t: str, s="VahOjaquAlYMEcubidePYwApawAtonE"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
modified_func def sat(t: str, s=wrap_str('VahOjaquAlYMEcubidePYwApawAtonE')):
    i = wrap_int(0)
    for c in s.lower():
        if sym_in(c, wrap_str('aeiouy')):
            continue
        _assert(t[i] == wrap_str('.'), wrap_str('expecting `.` at position ') + sym_str(i))
        i += wrap_int(1)
        _assert(t[i] == c, wrap_str('expecting `') + sym_str(c) + wrap_str('`'))
        i += wrap_int(1)
    return i == sym_len(t)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "."))
(assert (= (python.str.at x 1) "v"))
(assert (= (python.str.at x 2) "."))
(assert (= (python.str.at x 3) "h"))
(assert (= (python.str.at x 4) "."))
(assert (= (python.str.at x 5) "j"))
(assert (= (python.str.at x 6) "."))
(assert (= (python.str.at x 7) "q"))
(assert (= (python.str.at x 8) "."))
(assert (= (python.str.at x 9) "l"))
(assert (= (python.str.at x 10) "."))
(assert (= (python.str.at x 11) "m"))
(assert (= (python.str.at x 12) "."))
(assert (= (python.str.at x 13) "c"))
(assert (= (python.str.at x 14) "."))
(assert (= (python.str.at x 15) "b"))
(assert (= (python.str.at x 16) "."))
(assert (= (python.str.at x 17) "d"))
(assert (= (python.str.at x 18) "."))
(assert (= (python.str.at x 19) "p"))
(assert (= (python.str.at x 20) "."))
(assert (= (python.str.at x 21) "w"))
(assert (= (python.str.at x 22) "."))
(assert (= (python.str.at x 23) "p"))
(assert (= (python.str.at x 24) "."))
(assert (= (python.str.at x 25) "w"))
(assert (= (python.str.at x 26) "."))
(assert (= (python.str.at x 27) "t"))
(assert (= (python.str.at x 28) "."))
(assert (= (python.str.at x 29) "n"))
(assert (= 30 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    ".v.h.j.q.l.m.c.b.d.p.w.p.w.t.n")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution .v.h.j.q.l.m.c.b.d.p.w.p.w.t.n
Yes! Solved for puzzle  VowelDrop:1

Solving puzzle 364/774: VowelDrop:2
sat_func def sat(t: str, s="kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
modified_func def sat(t: str, s=wrap_str('kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL')):
    i = wrap_int(0)
    for c in s.lower():
        if sym_in(c, wrap_str('aeiouy')):
            continue
        _assert(t[i] == wrap_str('.'), wrap_str('expecting `.` at position ') + sym_str(i))
        i += wrap_int(1)
        _assert(t[i] == c, wrap_str('expecting `') + sym_str(c) + wrap_str('`'))
        i += wrap_int(1)
    return i == sym_len(t)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "."))
(assert (= (python.str.at x 1) "k"))
(assert (= (python.str.at x 2) "."))
(assert (= (python.str.at x 3) "g"))
(assert (= (python.str.at x 4) "."))
(assert (= (python.str.at x 5) "h"))
(assert (= (python.str.at x 6) "."))
(assert (= (python.str.at x 7) "d"))
(assert (= (python.str.at x 8) "."))
(assert (= (python.str.at x 9) "h"))
(assert (= (python.str.at x 10) "."))
(assert (= (python.str.at x 11) "k"))
(assert (= (python.str.at x 12) "."))
(assert (= (python.str.at x 13) "n"))
(assert (= (python.str.at x 14) "."))
(assert (= (python.str.at x 15) "j"))
(assert (= (python.str.at x 16) "."))
(assert (= (python.str.at x 17) "b"))
(assert (= (python.str.at x 18) "."))
(assert (= (python.str.at x 19) "z"))
(assert (= (python.str.at x 20) "."))
(assert (= (python.str.at x 21) "k"))
(assert (= (python.str.at x 22) "."))
(assert (= (python.str.at x 23) "m"))
(assert (= (python.str.at x 24) "."))
(assert (= (python.str.at x 25) "d"))
(assert (= (python.str.at x 26) "."))
(assert (= (python.str.at x 27) "t"))
(assert (= (python.str.at x 28) "."))
(assert (= (python.str.at x 29) "d"))
(assert (= (python.str.at x 30) "."))
(assert (= (python.str.at x 31) "z"))
(assert (= (python.str.at x 32) "."))
(assert (= (python.str.at x 33) "z"))
(assert (= (python.str.at x 34) "."))
(assert (= (python.str.at x 35) "v"))
(assert (= (python.str.at x 36) "."))
(assert (= (python.str.at x 37) "l"))
(assert (= 38 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    ".k.g.h.d.h.k.n.j.b.z.k.m.d.t.d.z.z.v.l")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution .k.g.h.d.h.k.n.j.b.z.k.m.d.t.d.z.z.v.l
Yes! Solved for puzzle  VowelDrop:2

Solving puzzle 365/774: VowelDrop:3
sat_func def sat(t: str, s="NOxADaNIMiReZoTeXtODUtHulyTHETextojoLeQuaNutEXtE"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
modified_func def sat(t: str, s=wrap_str('NOxADaNIMiReZoTeXtODUtHulyTHETextojoLeQuaNutEXtE')):
    i = wrap_int(0)
    for c in s.lower():
        if sym_in(c, wrap_str('aeiouy')):
            continue
        _assert(t[i] == wrap_str('.'), wrap_str('expecting `.` at position ') + sym_str(i))
        i += wrap_int(1)
        _assert(t[i] == c, wrap_str('expecting `') + sym_str(c) + wrap_str('`'))
        i += wrap_int(1)
    return i == sym_len(t)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "."))
(assert (= (python.str.at x 1) "n"))
(assert (= (python.str.at x 2) "."))
(assert (= (python.str.at x 3) "x"))
(assert (= (python.str.at x 4) "."))
(assert (= (python.str.at x 5) "d"))
(assert (= (python.str.at x 6) "."))
(assert (= (python.str.at x 7) "n"))
(assert (= (python.str.at x 8) "."))
(assert (= (python.str.at x 9) "m"))
(assert (= (python.str.at x 10) "."))
(assert (= (python.str.at x 11) "r"))
(assert (= (python.str.at x 12) "."))
(assert (= (python.str.at x 13) "z"))
(assert (= (python.str.at x 14) "."))
(assert (= (python.str.at x 15) "t"))
(assert (= (python.str.at x 16) "."))
(assert (= (python.str.at x 17) "x"))
(assert (= (python.str.at x 18) "."))
(assert (= (python.str.at x 19) "t"))
(assert (= (python.str.at x 20) "."))
(assert (= (python.str.at x 21) "d"))
(assert (= (python.str.at x 22) "."))
(assert (= (python.str.at x 23) "t"))
(assert (= (python.str.at x 24) "."))
(assert (= (python.str.at x 25) "h"))
(assert (= (python.str.at x 26) "."))
(assert (= (python.str.at x 27) "l"))
(assert (= (python.str.at x 28) "."))
(assert (= (python.str.at x 29) "t"))
(assert (= (python.str.at x 30) "."))
(assert (= (python.str.at x 31) "h"))
(assert (= (python.str.at x 32) "."))
(assert (= (python.str.at x 33) "t"))
(assert (= (python.str.at x 34) "."))
(assert (= (python.str.at x 35) "x"))
(assert (= (python.str.at x 36) "."))
(assert (= (python.str.at x 37) "t"))
(assert (= (python.str.at x 38) "."))
(assert (= (python.str.at x 39) "j"))
(assert (= (python.str.at x 40) "."))
(assert (= (python.str.at x 41) "l"))
(assert (= (python.str.at x 42) "."))
(assert (= (python.str.at x 43) "q"))
(assert (= (python.str.at x 44) "."))
(assert (= (python.str.at x 45) "n"))
(assert (= (python.str.at x 46) "."))
(assert (= (python.str.at x 47) "t"))
(assert (= (python.str.at x 48) "."))
(assert (= (python.str.at x 49) "x"))
(assert (= (python.str.at x 50) "."))
(assert (= (python.str.at x 51) "t"))
(assert (= 52 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    ".n.x.d.n.m.r.z.t.x.t.d.t.h.l.t.h.t.x.t.j.l.q.n.t.x.t")
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution .n.x.d.n.m.r.z.t.x.t.d.t.h.l.t.h.t.x.t.j.l.q.n.t.x.t
Yes! Solved for puzzle  VowelDrop:3

Solving puzzle 366/774: VowelDrop:4
sat_func def sat(t: str, s="MEkUWonymYNAQUypEcIv"):
    i = 0
    for c in s.lower():
        if c in "aeiouy":
            continue
        assert t[i] == ".", f"expecting `.` at position {i}"
        i += 1
        assert t[i] == c, f"expecting `{c}`"
        i += 1
    return i == len(t)
modified_func def sat(t: str, s=wrap_str('MEkUWonymYNAQUypEcIv')):
    i = wrap_int(0)
    for c in s.lower():
        if sym_in(c, wrap_str('aeiouy')):
            continue
        _assert(t[i] == wrap_str('.'), wrap_str('expecting `.` at position ') + sym_str(i))
        i += wrap_int(1)
        _assert(t[i] == c, wrap_str('expecting `') + sym_str(c) + wrap_str('`'))
        i += wrap_int(1)
    return i == sym_len(t)
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (= (python.str.at x 0) "."))
(assert (= (python.str.at x 1) "m"))
(assert (= (python.str.at x 2) "."))
(assert (= (python.str.at x 3) "k"))
(assert (= (python.str.at x 4) "."))
(assert (= (python.str.at x 5) "w"))
(assert (= (python.str.at x 6) "."))
(assert (= (python.str.at x 7) "n"))
(assert (= (python.str.at x 8) "."))
(assert (= (python.str.at x 9) "m"))
(assert (= (python.str.at x 10) "."))
(assert (= (python.str.at x 11) "n"))
(assert (= (python.str.at x 12) "."))
(assert (= (python.str.at x 13) "q"))
(assert (= (python.str.at x 14) "."))
(assert (= (python.str.at x 15) "p"))
(assert (= (python.str.at x 16) "."))
(assert (= (python.str.at x 17) "c"))
(assert (= (python.str.at x 18) "."))
(assert (= (python.str.at x 19) "v"))
(assert (= 20 (str.len x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    ".m.k.w.n.m.n.q.p.c.v")
)
### output for cvc5
sat
(
(define-fun x () String ".m.k.w.n.m.n.q.p.c.v")
)

Found solution .m.k.w.n.m.n.q.p.c.v
Yes! Solved for puzzle  VowelDrop:4

Solving puzzle 367/774: IncDec:0
sat_func def sat(n: int, ops=['x++', '--x', '--x'], target=19143212):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
modified_func def sat(n: int, ops=wrap_list([wrap_str('x++'), wrap_str('--x'), wrap_str('--x')]), target=wrap_int(19143212)):
    for op in ops:
        if sym_in(op, wrap_list([wrap_str('++x'), wrap_str('x++')])):
            n += wrap_int(1)
        else:
            _assert(sym_in(op, wrap_list([wrap_str('--x'), wrap_str('x--')])))
            n -= wrap_int(1)
    return n == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert true)
(assert (= (- (- (+ x 1) 1) 1) 19143212))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    19143213)
)
### output for cvc5
sat
(
(define-fun x () Int 19143213)
)

Found solution 19143213
Yes! Solved for puzzle  IncDec:0

Solving puzzle 368/774: IncDec:1
sat_func def sat(n: int, ops=['x++', '++x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x++', '--x', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x++', 'x++', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x++', '--x', '++x', 'x--', 'x--', 'x--', 'x++', 'x--', '--x', 'x++', '++x', '--x', '--x', 'x++', '++x', 'x--', 'x++', 'x--', '++x', 'x--', 'x--', '--x', 'x++', '--x', 'x--', '++x', '--x', '--x', 'x--', 'x--', 'x++', 'x--', 'x--', '--x', '++x', 'x--', '--x', 'x++', 'x--', 'x++', '++x', '++x', 'x++', '--x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x++', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '++x', 'x++', 'x++', '++x', '++x', '++x', '--x', '--x', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x++', 'x++', 'x++', '--x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', '--x', 'x--', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', '++x', '--x', '--x', '++x', '--x', '++x', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x', 'x--', '--x', '++x', '++x', '--x', 'x++', '++x', 'x++', 'x--', 'x--', '++x', '++x', 'x++', '++x', 'x--', '--x', 'x++', '--x', 'x++', '--x', 'x++', 'x++', 'x--', 'x--', 'x--', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x--', '--x', 'x++', '++x', 'x++', 'x++', '++x', 'x++', '++x', '++x', '++x', '--x', 'x--', 'x--', '--x', '--x', '++x', '++x', '--x', '++x', '--x', 'x--', 'x--', '--x', '--x', '--x', '--x', '--x', 'x++', '++x', 'x++', 'x++', '--x', 'x--', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x++', '++x', '++x', 'x--', '++x', 'x--', '--x', 'x++', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', '--x', '--x', '++x', '++x', 'x--', '++x', '--x', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x--'], target=88808):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
modified_func def sat(n: int, ops=wrap_list([wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--')]), target=wrap_int(88808)):
    for op in ops:
        if sym_in(op, wrap_list([wrap_str('++x'), wrap_str('x++')])):
            n += wrap_int(1)
        else:
            _assert(sym_in(op, wrap_list([wrap_str('--x'), wrap_str('x--')])))
            n -= wrap_int(1)
    return n == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert (= (- (- (- (- (+ (- (- (- (+ (- (+ (+ (- (- (- (- (+ (+ (+ (- (- (- (+ (+ (- (+ (+ (- (- (+ (- (+ (+ (+ (- (- (+ (+ (- (+ (- (- (- (- (- (+ (- (- (+ (- (+ (- (- (- (+ (+ (+ (+ (- (- (- (- (- (- (- (- (+ (- (+ (+ (- (- (- (- (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (- (- (- (- (+ (- (+ (+ (- (- (- (+ (+ (- (+ (- (+ (- (- (+ (+ (+ (+ (- (- (+ (+ (+ (- (+ (+ (- (- (+ (+ (+ (- (+ (+ (+ (- (- (- (+ (+ (+ (+ (+ (- (+ (- (- (+ (+ (+ (- (- (+ (+ (+ (- (- (+ (- (+ (+ (+ (+ (+ (- (+ (+ (+ (- (+ (+ (- (+ (- (- (+ (- (- (- (+ (- (- (+ (+ (+ (+ (+ (+ (- (+ (+ (- (+ (+ (- (+ (- (+ (- (- (- (- (- (+ (- (+ (+ (- (- (- (+ (- (- (+ (- (+ (+ (+ (+ (- (+ (- (- (+ (- (- (- (+ (- (- (- (- (+ (- (- (+ (- (- (- (+ (- (+ (- (+ (+ (- (- (+ (+ (- (- (+ (- (- (- (+ (- (+ (- (- (+ (+ (- (+ (+ (+ (+ (- (- (- (- (+ (- (+ (+ (+ (- (+ (+ (- (- (+ (+ (- (- (- (- (+ (+ (+ (+ x 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) ...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    88812)
)
### output for cvc5
sat
(
(define-fun x () Int 88812)
)

Found solution 88812
Yes! Solved for puzzle  IncDec:1

Solving puzzle 369/774: IncDec:2
sat_func def sat(n: int, ops=['x--', 'x--', '++x', '--x', '--x', 'x--', '--x', '++x', 'x++', 'x++', 'x--', 'x++', '++x', '--x', '++x', '--x', 'x++', 'x++', '++x', 'x++', '--x', '--x', '--x', 'x++', '--x', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x++', '++x', '--x', '--x', '++x', '--x', '--x', 'x++', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '++x', 'x++', 'x++', 'x++', '--x', 'x--', 'x++', '++x', 'x--', '++x', '++x', 'x--', '++x', '++x', 'x--', '--x', '++x', '--x', '++x', 'x++', '++x', 'x++', 'x++', 'x++', 'x--', '++x', '--x', '--x', 'x++', '--x', '++x', '--x', '++x', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', 'x++', 'x++', '--x', '--x', 'x--', '++x', 'x++', '++x', 'x++', 'x--', 'x--', '--x', '++x', 'x++', '--x', 'x--', 'x--', '--x', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '++x', 'x++', 'x++', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', 'x++', '--x', 'x--', '--x', 'x++', '++x', '--x', 'x--', 'x--', '++x', '++x', '--x', 'x++', '++x', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', 'x--', '++x', '++x', 'x++', '--x', '++x', 'x--', '--x', 'x--', '++x', 'x--', 'x--', '++x', '++x', 'x++', 'x--', '++x', 'x++', 'x++', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x--', 'x++', '++x', 'x--', 'x--', 'x--', '++x', '--x', '++x', 'x--', '--x', '++x', 'x--', '++x', 'x--', 'x--', '++x', '--x', '--x', '++x', '--x', 'x++', 'x--', '++x', 'x--', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '--x', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', 'x--', '++x', '--x', 'x++', 'x++', '--x', 'x--', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x--', 'x++', '++x', 'x--', 'x++', '--x', '++x', '++x', '++x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x--', '--x', 'x--', 'x++', '--x', 'x++', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', '++x', 'x--', '--x', 'x++', '++x', '++x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', '--x', '++x', '--x', 'x++', 'x++', 'x++', 'x--', 'x++', '++x', 'x--', 'x--', '--x', '++x', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '++x', '--x', '--x', 'x--', '++x', 'x--', 'x++', '--x', 'x++', '++x', 'x++', '++x', '++x', '--x', 'x++', '--x', 'x--', '++x', '++x', '--x', 'x--', '++x', '++x', 'x--', '--x', 'x--', '--x', 'x++', 'x--', '++x', 'x--', '++x', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x--', 'x++', 'x++', '--x', 'x--', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '++x', 'x--', 'x++', '++x', 'x--', 'x--', 'x++', 'x++', '++x', '++x', '++x', '++x', '++x', '++x', 'x++', 'x++', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', '++x', '--x', '--x', 'x--', 'x--', '--x', 'x++', '++x', '--x', 'x++', '--x', '--x', 'x++', '++x', 'x--', 'x--', 'x--', '--x', '++x', '--x', 'x--', 'x--', 'x++', '++x', '--x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '--x', '--x', 'x--', '++x', '++x', '++x', '++x', '++x', 'x++', '--x', '++x', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x--', '++x', '++x', 'x++', 'x--', 'x--', '++x', '--x', '--x', '--x', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', '--x', '--x', '++x', '++x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x++', '++x', '++x', 'x--', '--x', '--x', '++x', 'x++', '--x', 'x--', 'x--', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '++x', 'x--', 'x++', 'x++', 'x++', '--x', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x++', 'x++', 'x--', '--x', 'x++', 'x--', 'x++', 'x++', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', 'x++', 'x++', 'x--', '--x', '--x', 'x--', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', 'x++', 'x--', '++x', 'x++', '--x', 'x--', 'x--', 'x--', '++x', '++x', '--x', 'x--', 'x++', 'x--', 'x++', 'x--', '--x', '++x', '++x', '++x', 'x++', '--x', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', 'x++', '++x', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x++', 'x++', 'x--', '++x', '--x', '--x', '--x', 'x++', '++x', '--x', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', '++x', '--x', 'x--', 'x--', 'x--', '--x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', '++x', '--x', '--x', '--x', 'x--', '--x', '++x', '--x', 'x--', '++x', 'x++', 'x++', '--x', 'x--', 'x++', '++x', '++x', '++x', 'x--', 'x--', 'x++', '--x', 'x++', 'x--', '++x', '--x', 'x--', 'x--', 'x++', 'x--', '++x', '++x', 'x--', '++x', 'x--', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', 'x--', 'x--', 'x++', 'x++', '++x', 'x++', 'x++', 'x++', 'x++', '++x', 'x--', 'x++', 'x--', 'x--', 'x++', '--x', 'x++', '++x', 'x--', '++x', 'x--', 'x++', '++x', 'x++', 'x++', '++x', '++x', '--x', '--x', '--x', '--x', '--x', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '--x', 'x--', '--x', '++x', 'x--', 'x--', '--x', '--x', 'x++', 'x--', '--x', 'x--', '--x', '--x', 'x++', '++x', '++x', '--x', 'x--', '++x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '--x', '++x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '--x', '++x', '--x', 'x--', '++x', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x--', '--x', 'x++', '++x', '++x', 'x++', '++x', 'x++', '--x', 'x--', 'x--', '++x', 'x--', '--x', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', '++x', 'x--', '++x', '++x', 'x++', 'x++', 'x--', 'x--', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x--', '--x', '--x', '--x', 'x--', 'x--', '++x', '--x', 'x--', 'x++', 'x--', '++x', 'x--', '--x', '++x', '--x', 'x--', 'x++', 'x++', '--x', '--x', 'x++'], target=28110):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
modified_func def sat(n: int, ops=wrap_list([wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++')]), target=wrap_int(28110)):
    for op in ops:
        if sym_in(op, wrap_list([wrap_str('++x'), wrap_str('x++')])):
            n += wrap_int(1)
        else:
            _assert(sym_in(op, wrap_list([wrap_str('--x'), wrap_str('x--')])))
            n -= wrap_int(1)
    return n == target
Exception -- for puzzle IncDec:2 maximum recursion depth exceeded

Solving puzzle 370/774: IncDec:3
sat_func def sat(n: int, ops=['--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++'], target=82823):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
modified_func def sat(n: int, ops=wrap_list([wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('x--'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('++x'), wrap_str('--x'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--'), wrap_str('++x'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('x++'), wrap_str('++x'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x--'), wrap_str('x--'), wrap_str('++x'), wrap_str('++x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('x++'), wrap_str('--x'), wrap_str('++x'), wrap_str('x++'), wrap_str('--x'), wrap_str('--x'), wrap_str('x--'), wrap_str('--x'), wrap_str('x++')]), target=wrap_int(82823)):
    for op in ops:
        if sym_in(op, wrap_list([wrap_str('++x'), wrap_str('x++')])):
            n += wrap_int(1)
        else:
            _assert(sym_in(op, wrap_list([wrap_str('--x'), wrap_str('x--')])))
            n -= wrap_int(1)
    return n == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert true)
(assert (= (+ (- (- (- (- (+ (+ (- (+ (+ (- (+ (+ (+ (+ (+ (- (- (+ (- (- (+ (+ (- (- (- (- (- (- (- (+ (+ (- (+ (+ (+ (- (+ (- (- (+ (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (- (+ (- (- (+ (+ (+ (+ (- (- (- (+ (- (- (+ (- (+ (+ (- (- (+ (- (- (- (+ (- (- (+ (+ (+ (- (+ (+ (+ (- (- (+ (- (- (- (+ (+ (- (- (+ (- (+ (- (- (- (- (+ (- (+ (+ (+ (+ (+ (- (+ (+ (+ (- (+ (+ (+ (+ (- (- (+ (+ (- (- (- (+ (+ (- (- (- (+ (- (+ (+ (- (+ (+ (+ (- (- (+ (- (+ (+ (+ (+ (+ (- (- (+ (- (- (+ (- (- (+ (+ (- (- (- (+ (+ (+ (- (+ (- (- (- (- (- (- (- (+ (+ (- (+ (- (- (- (- (- (+ (- (- (- (+ (+ (+ (- (- (+ (- (- (- (+ (- (- (- (+ (+ (+ (+ (+ (+ (- (+ (- (- (+ (+ (- (+ (- (- (- (+ (- (- (- (+ (- (- (+ (- (+ (- (+ (- (- (- (+ (- (- (- (- (- (+ (- (- (+ (+ (- (- (- (+ (+ (+ (- (+ (+ (- (+ (- (- (- (+ (- (+ (+ (+ (- (- (+ (+ (- (- (+ (+ (- (- (+ (+ (+ (+ (- (- (+ (- (+ (+ (+ (+ (+ (- (- (+ (+ (+ (+ (+ (- (- (- (+ (- (+ (+ (- (- (+ (+ (+ (+ (- (- (+ (+ (+ (- (+ (- (- (- (+ (+ (- (+ (+ (- (+ (- (- (- (+ (+ (- (+ (- (-...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    82833)
)
### output for cvc5
sat
(
(define-fun x () Int 82833)
)

Found solution 82833
Yes! Solved for puzzle  IncDec:3

Solving puzzle 371/774: IncDec:4
sat_func def sat(n: int, ops=['x--', 'x++', '++x', '--x', 'x++', '--x', 'x--'], target=61813):
    for op in ops:
        if op in ["++x", "x++"]:
            n += 1
        else:
            assert op in ["--x", "x--"]
            n -= 1
    return n == target
modified_func def sat(n: int, ops=wrap_list([wrap_str('x--'), wrap_str('x++'), wrap_str('++x'), wrap_str('--x'), wrap_str('x++'), wrap_str('--x'), wrap_str('x--')]), target=wrap_int(61813)):
    for op in ops:
        if sym_in(op, wrap_list([wrap_str('++x'), wrap_str('x++')])):
            n += wrap_int(1)
        else:
            _assert(sym_in(op, wrap_list([wrap_str('--x'), wrap_str('x--')])))
            n -= wrap_int(1)
    return n == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert true)
(assert true)
(assert true)
(assert (= (- (- (+ (- (+ (+ (- x 1) 1) 1) 1) 1) 1) 1) 61813))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    61814)
)
### output for cvc5
sat
(
(define-fun x () Int 61814)
)

Found solution 61814
Yes! Solved for puzzle  IncDec:4

Solving puzzle 372/774: CompareInAnyCase:0
sat_func def sat(n: int, s="aaAab", t="aAaaB"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
modified_func def sat(n: int, s=wrap_str('aaAab'), t=wrap_str('aAaaB')):
    if n == wrap_int(0):
        return s.lower() == t.lower()
    if n == wrap_int(1):
        return s.lower() > t.lower()
    if n == -wrap_int(1):
        return s.lower() < t.lower()
    return False
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x 0) true))
(assert (=> (and (not (= x 0)) (not (= x 1)) (not (= x -1))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1))
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution -1
WARNING: Solution verification failed for puzzle CompareInAnyCase:0
Too many constants for extrapolation

Solving puzzle 373/774: CompareInAnyCase:1
sat_func def sat(n: int, s="JyNuTexTETiGAVIC", t="JynUTEXTetigAViC"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
modified_func def sat(n: int, s=wrap_str('JyNuTexTETiGAVIC'), t=wrap_str('JynUTEXTetigAViC')):
    if n == wrap_int(0):
        return s.lower() == t.lower()
    if n == wrap_int(1):
        return s.lower() > t.lower()
    if n == -wrap_int(1):
        return s.lower() < t.lower()
    return False
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x 0) true))
(assert (=> (and (not (= x 0)) (not (= x 1)) (not (= x -1))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1))
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution -1
WARNING: Solution verification failed for puzzle CompareInAnyCase:1
Too many constants for extrapolation

Solving puzzle 374/774: CompareInAnyCase:2
sat_func def sat(n: int, s="tExTYtOHahekomArof", t="TExTYTohaHeKomryGUSeteXTUrYgir"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
modified_func def sat(n: int, s=wrap_str('tExTYtOHahekomArof'), t=wrap_str('TExTYTohaHeKomryGUSeteXTUrYgir')):
    if n == wrap_int(0):
        return s.lower() == t.lower()
    if n == wrap_int(1):
        return s.lower() > t.lower()
    if n == -wrap_int(1):
        return s.lower() < t.lower()
    return False
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x 0) false))
(assert (=> (and (not (= x 0)) (not (= x 1)) (not (= x -1))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1))
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution -1
Yes! Solved for puzzle  CompareInAnyCase:2

Solving puzzle 375/774: CompareInAnyCase:3
sat_func def sat(n: int, s="RObAQuYK", t="robaQUYKkuLY"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
modified_func def sat(n: int, s=wrap_str('RObAQuYK'), t=wrap_str('robaQUYKkuLY')):
    if n == wrap_int(0):
        return s.lower() == t.lower()
    if n == wrap_int(1):
        return s.lower() > t.lower()
    if n == -wrap_int(1):
        return s.lower() < t.lower()
    return False
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x 0) false))
(assert (=> (and (not (= x 0)) (not (= x 1)) (not (= x -1))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1))
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution -1
Yes! Solved for puzzle  CompareInAnyCase:3

Solving puzzle 376/774: CompareInAnyCase:4
sat_func def sat(n: int, s="DUTeX", t="dutdE"):
    if n == 0:
        return s.lower() == t.lower()
    if n == 1:
        return s.lower() > t.lower()
    if n == -1:
        return s.lower() < t.lower()
    return False
modified_func def sat(n: int, s=wrap_str('DUTeX'), t=wrap_str('dutdE')):
    if n == wrap_int(0):
        return s.lower() == t.lower()
    if n == wrap_int(1):
        return s.lower() > t.lower()
    if n == -wrap_int(1):
        return s.lower() < t.lower()
    return False
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (= x 0) false))
(assert (=> (and (not (= x 0)) (not (= x 1)) (not (= x -1))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1))
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution -1
WARNING: Solution verification failed for puzzle CompareInAnyCase:4
Too many constants for extrapolation

Solving puzzle 377/774: SlidingOne:0
sat_func def sat(s: str, matrix=[[0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):
    matrix = [m[:] for m in matrix]  # copy
    for c in s:
        if c in "01234":
            i = "01234".index(c)
            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]
        if c in "abcde":
            j = "abcde".index(c)
            for row in matrix:
                row[j], row[j + 1] = row[j + 1], row[j]

    return len(s) <= max_moves and matrix[2][2] == 1
modified_func def sat(s: str, matrix=wrap_list([wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)])]), max_moves=wrap_int(3)):
    matrix = [m[:] for m in matrix]
    for c in s:
        if sym_in(c, wrap_str('01234')):
            i = wrap_str('01234').index(c)
            matrix[i], matrix[i + wrap_int(1)] = (matrix[i + wrap_int(1)], matrix[i])
        if sym_in(c, wrap_str('abcde')):
            j = wrap_str('abcde').index(c)
            for row in matrix:
                row[j], row[j + wrap_int(1)] = (row[j + wrap_int(1)], row[j])
    return (sym_len(s) <= max_moves).__and__(matrix[wrap_int(2)][wrap_int(2)] == wrap_int(1))
Exception -- for puzzle SlidingOne:0 Cannot convert symbolic integer to index

Solving puzzle 378/774: SlidingOne:1
sat_func def sat(s: str, matrix=[[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=4):
    matrix = [m[:] for m in matrix]  # copy
    for c in s:
        if c in "01234":
            i = "01234".index(c)
            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]
        if c in "abcde":
            j = "abcde".index(c)
            for row in matrix:
                row[j], row[j + 1] = row[j + 1], row[j]

    return len(s) <= max_moves and matrix[2][2] == 1
modified_func def sat(s: str, matrix=wrap_list([wrap_list([wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)])]), max_moves=wrap_int(4)):
    matrix = [m[:] for m in matrix]
    for c in s:
        if sym_in(c, wrap_str('01234')):
            i = wrap_str('01234').index(c)
            matrix[i], matrix[i + wrap_int(1)] = (matrix[i + wrap_int(1)], matrix[i])
        if sym_in(c, wrap_str('abcde')):
            j = wrap_str('abcde').index(c)
            for row in matrix:
                row[j], row[j + wrap_int(1)] = (row[j + wrap_int(1)], row[j])
    return (sym_len(s) <= max_moves).__and__(matrix[wrap_int(2)][wrap_int(2)] == wrap_int(1))
Exception -- for puzzle SlidingOne:1 Cannot convert symbolic integer to index

Solving puzzle 379/774: SlidingOne:2
sat_func def sat(s: str, matrix=[[0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=3):
    matrix = [m[:] for m in matrix]  # copy
    for c in s:
        if c in "01234":
            i = "01234".index(c)
            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]
        if c in "abcde":
            j = "abcde".index(c)
            for row in matrix:
                row[j], row[j + 1] = row[j + 1], row[j]

    return len(s) <= max_moves and matrix[2][2] == 1
modified_func def sat(s: str, matrix=wrap_list([wrap_list([wrap_int(0), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)])]), max_moves=wrap_int(3)):
    matrix = [m[:] for m in matrix]
    for c in s:
        if sym_in(c, wrap_str('01234')):
            i = wrap_str('01234').index(c)
            matrix[i], matrix[i + wrap_int(1)] = (matrix[i + wrap_int(1)], matrix[i])
        if sym_in(c, wrap_str('abcde')):
            j = wrap_str('abcde').index(c)
            for row in matrix:
                row[j], row[j + wrap_int(1)] = (row[j + wrap_int(1)], row[j])
    return (sym_len(s) <= max_moves).__and__(matrix[wrap_int(2)][wrap_int(2)] == wrap_int(1))
Exception -- for puzzle SlidingOne:2 Cannot convert symbolic integer to index

Solving puzzle 380/774: SlidingOne:3
sat_func def sat(s: str, matrix=[[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], max_moves=2):
    matrix = [m[:] for m in matrix]  # copy
    for c in s:
        if c in "01234":
            i = "01234".index(c)
            matrix[i], matrix[i + 1] = matrix[i + 1], matrix[i]
        if c in "abcde":
            j = "abcde".index(c)
            for row in matrix:
                row[j], row[j + 1] = row[j + 1], row[j]

    return len(s) <= max_moves and matrix[2][2] == 1
modified_func def sat(s: str, matrix=wrap_list([wrap_list([wrap_int(0), wrap_int(0), wrap_int(1), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)])]), max_moves=wrap_int(2)):
    matrix = [m[:] for m in matrix]
    for c in s:
        if sym_in(c, wrap_str('01234')):
            i = wrap_str('01234').index(c)
            matrix[i], matrix[i + wrap_int(1)] = (matrix[i + wrap_int(1)], matrix[i])
        if sym_in(c, wrap_str('abcde')):
            j = wrap_str('abcde').index(c)
            for row in matrix:
                row[j], row[j + wrap_int(1)] = (row[j + wrap_int(1)], row[j])
    return (sym_len(s) <= max_moves).__and__(matrix[wrap_int(2)][wrap_int(2)] == wrap_int(1))
Exception -- for puzzle SlidingOne:3 Cannot convert symbolic integer to index

Solving puzzle 381/774: SortPlusPlus:0
sat_func def sat(s: str, inp="1+1+3+1+3+2+2+1+3+1+2"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
modified_func def sat(s: str, inp=wrap_str('1+1+3+1+3+2+2+1+3+1+2')):
    return all(sym_generator((s.count(c) == inp.count(c) for c in inp + s))).__and__(all(sym_generator((s[i - wrap_int(2)] <= s[i] for i in sym_range(2, sym_len(s), 2)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(declare-const k_1 Int)
(assert (forall ((str_pos_81 Int)) (=> (and (>= str_pos_81 0) (< str_pos_81 (str.len (str.++ "1+1+3+1+3+2+2+1+3+1+2" x)))) (>= (str.count x (python.str.at (str.++ "1+1+3+1+3+2+2+1+3+1+2" x) str_pos_81)) 0))))
(assert (forall ((str_pos_81 Int)) (=> (and (>= str_pos_81 0) (< str_pos_81 (str.len (str.++ "1+1+3+1+3+2+2+1+3+1+2" x)))) (>= (str.count "1+1+3+1+3+2+2+1+3+1+2" (python.str.at (str.++ "1+1+3+1+3+2+2+1+3+1+2" x) str_pos_81)) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 2) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 2 (* k_1 2)))) (< k_1 (div (- (str.len x) 2) 2))) (forall ((str_pos_81 Int)) (=> (and (>= str_pos_81 0) (< str_pos_81 (str.len (str.++ "1+1+3+1+3+2+2+1+3+1+2" x)))) (and (= (str.count x (python.str.at (str.++ "1+1+3+1+3+2+2+1+3+1+2" x) str_pos_81)) (str.count "1+1+3+1+3+2+2+1+3+1+2" (python.str.at (str.++ "1+1+3+1+3+2+2+1+3+1+2" x) str_pos_81))) (or (str.< (python.str.at x (- i_0 2)) (python.str.at x i_0)) (= (python.str.at x (- i_0 2)) (python.str.at x i_0)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!0!")
  (define-fun k_1 () Int
    (- 1))
)
### output for cvc5
unknown
(
(define-fun x () String "1+1+3+1+3+2+2+1+3+1+2")
(define-fun k_1 () Int 10)
)

Found solution !0!
WARNING: Solution verification failed for puzzle SortPlusPlus:0
Too many constants for extrapolation

Solving puzzle 382/774: SortPlusPlus:1
sat_func def sat(s: str, inp="2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
modified_func def sat(s: str, inp=wrap_str('2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2')):
    return all(sym_generator((s.count(c) == inp.count(c) for c in inp + s))).__and__(all(sym_generator((s[i - wrap_int(2)] <= s[i] for i in sym_range(2, sym_len(s), 2)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(declare-const k_1 Int)
(assert (forall ((str_pos_82 Int)) (=> (and (>= str_pos_82 0) (< str_pos_82 (str.len (str.++ "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" x)))) (>= (str.count x (python.str.at (str.++ "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" x) str_pos_82)) 0))))
(assert (forall ((str_pos_82 Int)) (=> (and (>= str_pos_82 0) (< str_pos_82 (str.len (str.++ "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" x)))) (>= (str.count "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" (python.str.at (str.++ "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" x) str_pos_82)) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 2) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 2 (* k_1 2)))) (< k_1 (div (- (str.len x) 2) 2))) (forall ((str_pos_82 Int)) (=> (and (>= str_pos_82 0) (< str_pos_82 (str.len (str.++ "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" x)))) (and (= (str.count x (python.str.at (str.++ "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" x) str_pos_82)) (str.count "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" (python.str.at (str.++ "2+3+1+2+2+2+1+1+1+3+2+3+3+3+2+3+1+3+3+2+1+2+3+1+2+1+3+2+3+1+1+2+2+3+1+2+2+1+3+2+3+2+3+2+2" x) str_pos_82))) (or (str.< (python.str.at x (- i_0 2)) (python.str.at x i_0)) (= (python.str.at x (- i_0 2)) (python.str.at x i_0)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!0!")
  (define-fun k_1 () Int
    (- 1))
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution !0!
WARNING: Solution verification failed for puzzle SortPlusPlus:1
Too many constants for extrapolation

Solving puzzle 383/774: SortPlusPlus:2
sat_func def sat(s: str, inp="3+2+2"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
modified_func def sat(s: str, inp=wrap_str('3+2+2')):
    return all(sym_generator((s.count(c) == inp.count(c) for c in inp + s))).__and__(all(sym_generator((s[i - wrap_int(2)] <= s[i] for i in sym_range(2, sym_len(s), 2)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(declare-const k_1 Int)
(assert (forall ((str_pos_83 Int)) (=> (and (>= str_pos_83 0) (< str_pos_83 (str.len (str.++ "3+2+2" x)))) (>= (str.count x (python.str.at (str.++ "3+2+2" x) str_pos_83)) 0))))
(assert (forall ((str_pos_83 Int)) (=> (and (>= str_pos_83 0) (< str_pos_83 (str.len (str.++ "3+2+2" x)))) (>= (str.count "3+2+2" (python.str.at (str.++ "3+2+2" x) str_pos_83)) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 2) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 2 (* k_1 2)))) (< k_1 (div (- (str.len x) 2) 2))) (forall ((str_pos_83 Int)) (=> (and (>= str_pos_83 0) (< str_pos_83 (str.len (str.++ "3+2+2" x)))) (and (= (str.count x (python.str.at (str.++ "3+2+2" x) str_pos_83)) (str.count "3+2+2" (python.str.at (str.++ "3+2+2" x) str_pos_83))) (or (str.< (python.str.at x (- i_0 2)) (python.str.at x i_0)) (= (python.str.at x (- i_0 2)) (python.str.at x i_0)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!0!")
  (define-fun k_1 () Int
    (- 1))
)
### output for cvc5
unknown
(
(define-fun x () String "3+2+2")
(define-fun k_1 () Int 2)
)

Found solution !0!
WARNING: Solution verification failed for puzzle SortPlusPlus:2
Too many constants for extrapolation

Solving puzzle 384/774: SortPlusPlus:3
sat_func def sat(s: str, inp="3+2+1+1+3+3+2+2+2+3+2+3+3+1+1"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
modified_func def sat(s: str, inp=wrap_str('3+2+1+1+3+3+2+2+2+3+2+3+3+1+1')):
    return all(sym_generator((s.count(c) == inp.count(c) for c in inp + s))).__and__(all(sym_generator((s[i - wrap_int(2)] <= s[i] for i in sym_range(2, sym_len(s), 2)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(declare-const k_1 Int)
(assert (forall ((str_pos_84 Int)) (=> (and (>= str_pos_84 0) (< str_pos_84 (str.len (str.++ "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" x)))) (>= (str.count x (python.str.at (str.++ "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" x) str_pos_84)) 0))))
(assert (forall ((str_pos_84 Int)) (=> (and (>= str_pos_84 0) (< str_pos_84 (str.len (str.++ "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" x)))) (>= (str.count "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" (python.str.at (str.++ "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" x) str_pos_84)) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 2) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 2 (* k_1 2)))) (< k_1 (div (- (str.len x) 2) 2))) (forall ((str_pos_84 Int)) (=> (and (>= str_pos_84 0) (< str_pos_84 (str.len (str.++ "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" x)))) (and (= (str.count x (python.str.at (str.++ "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" x) str_pos_84)) (str.count "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" (python.str.at (str.++ "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1" x) str_pos_84))) (or (str.< (python.str.at x (- i_0 2)) (python.str.at x i_0)) (= (python.str.at x (- i_0 2)) (python.str.at x i_0)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!0!")
  (define-fun k_1 () Int
    (- 1))
)
### output for cvc5
unknown
(
(define-fun x () String "3+2+1+1+3+3+2+2+2+3+2+3+3+1+1")
(define-fun k_1 () Int 14)
)

Found solution !0!
WARNING: Solution verification failed for puzzle SortPlusPlus:3
Too many constants for extrapolation

Solving puzzle 385/774: SortPlusPlus:4
sat_func def sat(s: str, inp="2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1"):
    return all(s.count(c) == inp.count(c) for c in inp + s) and all(s[i - 2] <= s[i] for i in range(2, len(s), 2))
modified_func def sat(s: str, inp=wrap_str('2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1')):
    return all(sym_generator((s.count(c) == inp.count(c) for c in inp + s))).__and__(all(sym_generator((s[i - wrap_int(2)] <= s[i] for i in sym_range(2, sym_len(s), 2)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(declare-const k_1 Int)
(assert (forall ((str_pos_85 Int)) (=> (and (>= str_pos_85 0) (< str_pos_85 (str.len (str.++ "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" x)))) (>= (str.count x (python.str.at (str.++ "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" x) str_pos_85)) 0))))
(assert (forall ((str_pos_85 Int)) (=> (and (>= str_pos_85 0) (< str_pos_85 (str.len (str.++ "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" x)))) (>= (str.count "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" (python.str.at (str.++ "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" x) str_pos_85)) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 2) (< i_0 (str.len x))) (>= k_1 0)) (= i_0 (+ 2 (* k_1 2)))) (< k_1 (div (- (str.len x) 2) 2))) (forall ((str_pos_85 Int)) (=> (and (>= str_pos_85 0) (< str_pos_85 (str.len (str.++ "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" x)))) (and (= (str.count x (python.str.at (str.++ "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" x) str_pos_85)) (str.count "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" (python.str.at (str.++ "2+2+2+1+1+1+2+1+3+3+3+3+2+2+2+1+2+3+3+1+3+2+3+2+3+2+2+3+2+3+1+2+1+3+3+2+3+1+1+3+3+1" x) str_pos_85))) (or (str.< (python.str.at x (- i_0 2)) (python.str.at x i_0)) (= (python.str.at x (- i_0 2)) (python.str.at x i_0)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!0!")
  (define-fun k_1 () Int
    (- 1))
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution !0!
WARNING: Solution verification failed for puzzle SortPlusPlus:4
Too many constants for extrapolation

Solving puzzle 386/774: CapitalizeFirstLetter:0
sat_func def sat(s: str, word="konjac"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
modified_func def sat(s: str, word=wrap_str('konjac')):
    for i in sym_range(sym_len(word)):
        if i == wrap_int(0):
            if s[i] != word[i].upper():
                return False
        elif s[i] != word[i]:
            return False
    return True
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (=> (not (= (python.str.at x 0) "K")) false))
(assert (=> (and (not (not (= (python.str.at x 0) "K"))) (not (not (= (python.str.at x 1) "o"))) (not (not (= (python.str.at x 2) "n"))) (not (not (= (python.str.at x 3) "j"))) (not (not (= (python.str.at x 4) "a"))) (not (not (= (python.str.at x 5) "c")))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "K")
)
### output for cvc5
sat
(
(define-fun x () String "K")
)

Found solution K
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle CapitalizeFirstLetter:0
Too many constants for extrapolation

Solving puzzle 387/774: CapitalizeFirstLetter:1
sat_func def sat(s: str, word="nojapoxe"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
modified_func def sat(s: str, word=wrap_str('nojapoxe')):
    for i in sym_range(sym_len(word)):
        if i == wrap_int(0):
            if s[i] != word[i].upper():
                return False
        elif s[i] != word[i]:
            return False
    return True
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (=> (not (= (python.str.at x 0) "N")) false))
(assert (=> (and (not (not (= (python.str.at x 0) "N"))) (not (not (= (python.str.at x 1) "o"))) (not (not (= (python.str.at x 2) "j"))) (not (not (= (python.str.at x 3) "a"))) (not (not (= (python.str.at x 4) "p"))) (not (not (= (python.str.at x 5) "o"))) (not (not (= (python.str.at x 6) "x"))) (not (not (= (python.str.at x 7) "e")))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "N")
)
### output for cvc5
sat
(
(define-fun x () String "N")
)

Found solution N
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle CapitalizeFirstLetter:1
Too many constants for extrapolation

Solving puzzle 388/774: CapitalizeFirstLetter:2
sat_func def sat(s: str, word="silon"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
modified_func def sat(s: str, word=wrap_str('silon')):
    for i in sym_range(sym_len(word)):
        if i == wrap_int(0):
            if s[i] != word[i].upper():
                return False
        elif s[i] != word[i]:
            return False
    return True
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (=> (not (= (python.str.at x 0) "S")) false))
(assert (=> (and (not (not (= (python.str.at x 0) "S"))) (not (not (= (python.str.at x 1) "i"))) (not (not (= (python.str.at x 2) "l"))) (not (not (= (python.str.at x 3) "o"))) (not (not (= (python.str.at x 4) "n")))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "S")
)
### output for cvc5
sat
(
(define-fun x () String "S")
)

Found solution S
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle CapitalizeFirstLetter:2
Too many constants for extrapolation

Solving puzzle 389/774: CapitalizeFirstLetter:3
sat_func def sat(s: str, word="fekovo"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
modified_func def sat(s: str, word=wrap_str('fekovo')):
    for i in sym_range(sym_len(word)):
        if i == wrap_int(0):
            if s[i] != word[i].upper():
                return False
        elif s[i] != word[i]:
            return False
    return True
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (=> (not (= (python.str.at x 0) "F")) false))
(assert (=> (and (not (not (= (python.str.at x 0) "F"))) (not (not (= (python.str.at x 1) "e"))) (not (not (= (python.str.at x 2) "k"))) (not (not (= (python.str.at x 3) "o"))) (not (not (= (python.str.at x 4) "v"))) (not (not (= (python.str.at x 5) "o")))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "F")
)
### output for cvc5
sat
(
(define-fun x () String "F")
)

Found solution F
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle CapitalizeFirstLetter:3
Too many constants for extrapolation

Solving puzzle 390/774: CapitalizeFirstLetter:4
sat_func def sat(s: str, word="mo"):
    for i in range(len(word)):
        if i == 0:
            if s[i] != word[i].upper():
                return False
        else:
            if s[i] != word[i]:
                return False
    return True
modified_func def sat(s: str, word=wrap_str('mo')):
    for i in sym_range(sym_len(word)):
        if i == wrap_int(0):
            if s[i] != word[i].upper():
                return False
        elif s[i] != word[i]:
            return False
    return True
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (=> (not (= (python.str.at x 0) "M")) false))
(assert (=> (and (not (not (= (python.str.at x 0) "M"))) (not (not (= (python.str.at x 1) "o")))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "M")
)
### output for cvc5
sat
(
(define-fun x () String "M")
)

Found solution M
Exception in checking result: string index out of range
WARNING: Solution verification failed for puzzle CapitalizeFirstLetter:4
Too many constants for extrapolation

Solving puzzle 391/774: LongestSubsetString:0
sat_func def sat(t: str, s="abbbcabbac", target=7):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
modified_func def sat(t: str, s=wrap_str('abbbcabbac'), target=wrap_int(7)):
    i = wrap_int(0)
    for c in t:
        while c != s[i]:
            i += wrap_int(1)
        i += wrap_int(1)
    return (sym_len(t) >= target).__and__(all(sym_generator((t[i] != t[i + wrap_int(1)] for i in sym_range(sym_len(t) - 1)))))
Timed out for puzzle LongestSubsetString:0

Solving puzzle 392/774: LongestSubsetString:1
sat_func def sat(t: str, s="cbbbbbcbbbbbbbaccacacaacbbcaaacbbaacbabacabccbbbcaacbbacaabcabbaacbbaa", target=43):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
modified_func def sat(t: str, s=wrap_str('cbbbbbcbbbbbbbaccacacaacbbcaaacbbaacbabacabccbbbcaacbbacaabcabbaacbbaa'), target=wrap_int(43)):
    i = wrap_int(0)
    for c in t:
        while c != s[i]:
            i += wrap_int(1)
        i += wrap_int(1)
    return (sym_len(t) >= target).__and__(all(sym_generator((t[i] != t[i + wrap_int(1)] for i in sym_range(sym_len(t) - 1)))))
Timed out for puzzle LongestSubsetString:1

Solving puzzle 393/774: LongestSubsetString:2
sat_func def sat(t: str, s="bcb", target=3):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
modified_func def sat(t: str, s=wrap_str('bcb'), target=wrap_int(3)):
    i = wrap_int(0)
    for c in t:
        while c != s[i]:
            i += wrap_int(1)
        i += wrap_int(1)
    return (sym_len(t) >= target).__and__(all(sym_generator((t[i] != t[i + wrap_int(1)] for i in sym_range(sym_len(t) - 1)))))
Timed out for puzzle LongestSubsetString:2

Solving puzzle 394/774: LongestSubsetString:3
sat_func def sat(t: str, s="c", target=1):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
modified_func def sat(t: str, s=wrap_str('c'), target=wrap_int(1)):
    i = wrap_int(0)
    for c in t:
        while c != s[i]:
            i += wrap_int(1)
        i += wrap_int(1)
    return (sym_len(t) >= target).__and__(all(sym_generator((t[i] != t[i + wrap_int(1)] for i in sym_range(sym_len(t) - 1)))))
Timed out for puzzle LongestSubsetString:3

Solving puzzle 395/774: LongestSubsetString:4
sat_func def sat(t: str, s="bcbcabba", target=7):
    i = 0
    for c in t:
        while c != s[i]:
            i += 1
        i += 1
    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))
modified_func def sat(t: str, s=wrap_str('bcbcabba'), target=wrap_int(7)):
    i = wrap_int(0)
    for c in t:
        while c != s[i]:
            i += wrap_int(1)
        i += wrap_int(1)
    return (sym_len(t) >= target).__and__(all(sym_generator((t[i] != t[i + wrap_int(1)] for i in sym_range(sym_len(t) - 1)))))
Timed out for puzzle LongestSubsetString:4

Solving puzzle 396/774: FindHomogeneousSubstring:0
sat_func def sat(n: int, s="0000101111111000010", k=5):
    return s[n:n + k] == s[n] * k
modified_func def sat(n: int, s=wrap_str('0000101111111000010'), k=wrap_int(5)):
    return s[n:n + k] == s[n] * k
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str.substr "0000101111111000010" x (- (+ x 5) x)) (str_multiply (str.substr "0000101111111000010" x (- (+ x 1) x)) 5)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    6)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 6
Yes! Solved for puzzle  FindHomogeneousSubstring:0

Solving puzzle 397/774: FindHomogeneousSubstring:1
sat_func def sat(n: int, s="000000", k=4):
    return s[n:n + k] == s[n] * k
modified_func def sat(n: int, s=wrap_str('000000'), k=wrap_int(4)):
    return s[n:n + k] == s[n] * k
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str.substr "000000" x (- (+ x 4) x)) (str_multiply (str.substr "000000" x (- (+ x 1) x)) 4)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 0
Yes! Solved for puzzle  FindHomogeneousSubstring:1

Solving puzzle 398/774: FindHomogeneousSubstring:2
sat_func def sat(n: int, s="001100000000000000000000101010100111101110000100", k=18):
    return s[n:n + k] == s[n] * k
modified_func def sat(n: int, s=wrap_str('001100000000000000000000101010100111101110000100'), k=wrap_int(18)):
    return s[n:n + k] == s[n] * k
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str.substr "001100000000000000000000101010100111101110000100" x (- (+ x 18) x)) (str_multiply (str.substr "001100000000000000000000101010100111101110000100" x (- (+ x 1) x)) 18)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    4)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 4
Yes! Solved for puzzle  FindHomogeneousSubstring:2

Solving puzzle 399/774: FindHomogeneousSubstring:3
sat_func def sat(n: int, s="10100111100110001010011110100111010110010000101101110100010", k=3):
    return s[n:n + k] == s[n] * k
modified_func def sat(n: int, s=wrap_str('10100111100110001010011110100111010110010000101101110100010'), k=wrap_int(3)):
    return s[n:n + k] == s[n] * k
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str.substr "10100111100110001010011110100111010110010000101101110100010" x (- (+ x 3) x)) (str_multiply (str.substr "10100111100110001010011110100111010110010000101101110100010" x (- (+ x 1) x)) 3)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    54)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 54
Yes! Solved for puzzle  FindHomogeneousSubstring:3

Solving puzzle 400/774: FindHomogeneousSubstring:4
sat_func def sat(n: int, s="010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101", k=18):
    return s[n:n + k] == s[n] * k
modified_func def sat(n: int, s=wrap_str('010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101'), k=wrap_int(18)):
    return s[n:n + k] == s[n] * k
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str.substr "010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101" x (- (+ x 18) x)) (str_multiply (str.substr "010110011110100000001010010010001101001110110001111011000000000000000000000011101010111000111011001100111101101" x (- (+ x 1) x)) 18)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    58)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 58
Yes! Solved for puzzle  FindHomogeneousSubstring:4

Solving puzzle 401/774: TotalDifference:0
sat_func def sat(n: int, a=17, b=100, c=20):
    return n + a == sum([b * i for i in range(c)])
modified_func def sat(n: int, a=wrap_int(17), b=wrap_int(100), c=wrap_int(20)):
    return n + a == sym_sum([b * i for i in sym_range(c)])
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x 17) 19000))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    18983)
)
### output for cvc5
sat
(
(define-fun x () Int 18983)
)

Found solution 18983
Yes! Solved for puzzle  TotalDifference:0

Solving puzzle 402/774: TotalDifference:1
sat_func def sat(n: int, a=62, b=92, c=24):
    return n + a == sum([b * i for i in range(c)])
modified_func def sat(n: int, a=wrap_int(62), b=wrap_int(92), c=wrap_int(24)):
    return n + a == sym_sum([b * i for i in sym_range(c)])
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x 62) 25392))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    25330)
)
### output for cvc5
sat
(
(define-fun x () Int 25330)
)

Found solution 25330
Yes! Solved for puzzle  TotalDifference:1

Solving puzzle 403/774: TotalDifference:2
sat_func def sat(n: int, a=14, b=50, c=47):
    return n + a == sum([b * i for i in range(c)])
modified_func def sat(n: int, a=wrap_int(14), b=wrap_int(50), c=wrap_int(47)):
    return n + a == sym_sum([b * i for i in sym_range(c)])
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x 14) 54050))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    54036)
)
### output for cvc5
sat
(
(define-fun x () Int 54036)
)

Found solution 54036
Yes! Solved for puzzle  TotalDifference:2

Solving puzzle 404/774: TotalDifference:3
sat_func def sat(n: int, a=62, b=63, c=13):
    return n + a == sum([b * i for i in range(c)])
modified_func def sat(n: int, a=wrap_int(62), b=wrap_int(63), c=wrap_int(13)):
    return n + a == sym_sum([b * i for i in sym_range(c)])
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x 62) 4914))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    4852)
)
### output for cvc5
sat
(
(define-fun x () Int 4852)
)

Found solution 4852
Yes! Solved for puzzle  TotalDifference:3

Solving puzzle 405/774: TotalDifference:4
sat_func def sat(n: int, a=5, b=31, c=37):
    return n + a == sum([b * i for i in range(c)])
modified_func def sat(n: int, a=wrap_int(5), b=wrap_int(31), c=wrap_int(37)):
    return n + a == sym_sum([b * i for i in sym_range(c)])
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x 5) 20646))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    20641)
)
### output for cvc5
sat
(
(define-fun x () Int 20641)
)

Found solution 20641
Yes! Solved for puzzle  TotalDifference:4

Solving puzzle 406/774: TripleDouble:0
sat_func def sat(n: int, v=17, w=100):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(17), w=wrap_int(100)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 17 100))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:0
One large constant for extrapolation
Solving simpler variation replaced 100 with 3
sat_func def sat(n: int, v=17, w=3):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(17), w=wrap_int(3)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 17 3))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) true)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0

Solving puzzle 407/774: TripleDouble:1
sat_func def sat(n: int, v=75129500, w=979292947):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(75129500), w=wrap_int(979292947)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 75129500 979292947))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:1
Two large constants for extrapolation
Solving simpler variation replaced 75129500 with 3 and 979292947 with 5
sat_func def sat(n: int, v=3, w=5):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(3), w=wrap_int(5)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 3 5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:1

Solving puzzle 408/774: TripleDouble:2
sat_func def sat(n: int, v=609909721, w=872375011):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(609909721), w=wrap_int(872375011)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 609909721 872375011))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) true)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:2
Two large constants for extrapolation
Solving simpler variation replaced 609909721 with 3 and 872375011 with 5
sat_func def sat(n: int, v=3, w=5):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(3), w=wrap_int(5)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 3 5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:2

Solving puzzle 409/774: TripleDouble:3
sat_func def sat(n: int, v=313946483, w=806690290):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(313946483), w=wrap_int(806690290)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 313946483 806690290))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:3
Two large constants for extrapolation
Solving simpler variation replaced 313946483 with 3 and 806690290 with 5
sat_func def sat(n: int, v=3, w=5):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(3), w=wrap_int(5)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 3 5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:3

Solving puzzle 410/774: TripleDouble:4
sat_func def sat(n: int, v=54888266, w=670740803):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(54888266), w=wrap_int(670740803)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 54888266 670740803))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:4
Two large constants for extrapolation
Solving simpler variation replaced 54888266 with 3 and 670740803 with 5
sat_func def sat(n: int, v=3, w=5):
    for i in range(n):
        assert v <= w
        v *= 3
        w *= 2
    return v > w
modified_func def sat(n: int, v=wrap_int(3), w=wrap_int(5)):
    for i in sym_range(n):
        _assert(v <= w)
        v *= wrap_int(3)
        w *= wrap_int(2)
    return v > w
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= 3 5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) false)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle TripleDouble:4

Solving puzzle 411/774: RepeatDec:0
sat_func def sat(res: int, m=1234578987654321, n=4):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
modified_func def sat(res: int, m=wrap_int(1234578987654321), n=wrap_int(4)):
    for i in sym_range(n):
        m = m - wrap_int(1) if m % wrap_int(10) else m // wrap_int(10)
    return res == m
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 1234578987654317))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1234578987654317)
)
### output for cvc5
sat
(
(define-fun x () Int 1234578987654317)
)

Found solution 1234578987654317
WARNING: Solution verification failed for puzzle RepeatDec:0
One large constant for extrapolation
Solving simpler variation replaced 1234578987654321 with 3
sat_func def sat(res: int, m=3, n=4):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
modified_func def sat(res: int, m=wrap_int(3), n=wrap_int(4)):
    for i in sym_range(n):
        m = m - wrap_int(1) if m % wrap_int(10) else m // wrap_int(10)
    return res == m
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x -1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1))
)

Found solution -1
WARNING: Solution verification failed for puzzle RepeatDec:0

Solving puzzle 412/774: RepeatDec:1
sat_func def sat(res: int, m=52891398375817839454, n=3):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
modified_func def sat(res: int, m=wrap_int(52891398375817839454), n=wrap_int(3)):
    for i in sym_range(n):
        m = m - wrap_int(1) if m % wrap_int(10) else m // wrap_int(10)
    return res == m
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 52891398375817839451))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    52891398375817839451)
)
### output for cvc5
sat
(
(define-fun x () Int 52891398375817839451)
)

Found solution 52891398375817839451
Yes! Solved for puzzle  RepeatDec:1

Solving puzzle 413/774: RepeatDec:2
sat_func def sat(res: int, m=22262059435814874058, n=6):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
modified_func def sat(res: int, m=wrap_int(22262059435814874058), n=wrap_int(6)):
    for i in sym_range(n):
        m = m - wrap_int(1) if m % wrap_int(10) else m // wrap_int(10)
    return res == m
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 22262059435814874052))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    22262059435814874052)
)
### output for cvc5
sat
(
(define-fun x () Int 22262059435814874052)
)

Found solution 22262059435814874052
Yes! Solved for puzzle  RepeatDec:2

Solving puzzle 414/774: RepeatDec:3
sat_func def sat(res: int, m=23602903522227899062, n=2):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
modified_func def sat(res: int, m=wrap_int(23602903522227899062), n=wrap_int(2)):
    for i in sym_range(n):
        m = m - wrap_int(1) if m % wrap_int(10) else m // wrap_int(10)
    return res == m
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 23602903522227899060))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    23602903522227899060)
)
### output for cvc5
sat
(
(define-fun x () Int 23602903522227899060)
)

Found solution 23602903522227899060
Yes! Solved for puzzle  RepeatDec:3

Solving puzzle 415/774: RepeatDec:4
sat_func def sat(res: int, m=27368816582234104063, n=4):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
modified_func def sat(res: int, m=wrap_int(27368816582234104063), n=wrap_int(4)):
    for i in sym_range(n):
        m = m - wrap_int(1) if m % wrap_int(10) else m // wrap_int(10)
    return res == m
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 27368816582234104059))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    27368816582234104059)
)
### output for cvc5
sat
(
(define-fun x () Int 27368816582234104059)
)

Found solution 27368816582234104059
WARNING: Solution verification failed for puzzle RepeatDec:4
One large constant for extrapolation
Solving simpler variation replaced 27368816582234104063 with 3
sat_func def sat(res: int, m=3, n=4):
    for i in range(n):
        m = (m - 1 if m % 10 else m // 10)
    return res == m
modified_func def sat(res: int, m=wrap_int(3), n=wrap_int(4)):
    for i in sym_range(n):
        m = m - wrap_int(1) if m % wrap_int(10) else m // wrap_int(10)
    return res == m
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x -1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1))
)

Found solution -1
WARNING: Solution verification failed for puzzle RepeatDec:4

Solving puzzle 416/774: MaxDelta:0
sat_func def sat(n: int, pairs=[[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
modified_func def sat(n: int, pairs=wrap_list([wrap_list([wrap_int(3), wrap_int(0)]), wrap_list([wrap_int(17), wrap_int(1)]), wrap_list([wrap_int(9254359), wrap_int(19)]), wrap_list([wrap_int(123), wrap_int(9254359)]), wrap_list([wrap_int(0), wrap_int(123)])])):
    _assert(sym_sum(sym_generator((p - m for p, m in pairs))) == wrap_int(0), wrap_str('oo'))
    tot = wrap_int(0)
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        _assert(tot <= n)
        if tot == n:
            success = True
    return success
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert (<= 3 x))
(assert (=> (= 3 x) (<= 19 x)))
(assert (=> (and (= 3 x) (= 19 x)) (<= 9254359 x)))
(assert (=> (and (= 3 x) (= 19 x) (= 9254359 x)) (<= 123 x)))
(assert (=> (and (= 3 x) (= 19 x) (= 9254359 x) (= 123 x)) (<= 0 x)))
(assert (=> (and (= 3 x) (= 19 x) (= 9254359 x) (= 123 x) (= 0 x)) true))
(assert true)
(assert (<= 3 x))
(assert (=> (not (= 3 x)) (<= 19 x)))
(assert (=> (and (not (= 3 x)) (not (= 19 x))) (<= 9254359 x)))
(assert (=> (and (not (= 3 x)) (not (= 19 x)) (not (= 9254359 x))) (<= 123 x)))
(assert (=> (and (not (= 3 x)) (not (= 19 x)) (not (= 9254359 x)) (not (= 123 x))) (<= 0 x)))
(assert (=> (and (not (= 3 x)) (not (= 19 x)) (not (= 9254359 x)) (not (= 123 x)) (not (= 0 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    19)
)
### output for cvc5
sat
(
(define-fun x () Int 19)
)

Found solution 19
Exception in checking result: 
WARNING: Solution verification failed for puzzle MaxDelta:0
Two large constants for extrapolation
Solving simpler variation replaced 123 with 3 and 9254359 with 5
sat_func def sat(n: int, pairs=[[3, 0], [17, 1], [5, 19], [3, 5], [0, 3]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
modified_func def sat(n: int, pairs=wrap_list([wrap_list([wrap_int(3), wrap_int(0)]), wrap_list([wrap_int(17), wrap_int(1)]), wrap_list([wrap_int(5), wrap_int(19)]), wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(0), wrap_int(3)])])):
    _assert(sym_sum(sym_generator((p - m for p, m in pairs))) == wrap_int(0), wrap_str('oo'))
    tot = wrap_int(0)
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        _assert(tot <= n)
        if tot == n:
            success = True
    return success
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert (<= 3 x))
(assert (=> (= 3 x) (<= 19 x)))
(assert (=> (and (= 3 x) (= 19 x)) (<= 5 x)))
(assert (=> (and (= 3 x) (= 19 x) (= 5 x)) (<= 3 x)))
(assert (=> (and (= 3 x) (= 19 x) (= 5 x) (= 3 x)) (<= 0 x)))
(assert (=> (and (= 3 x) (= 19 x) (= 5 x) (= 3 x) (= 0 x)) true))
(assert true)
(assert (<= 3 x))
(assert (=> (not (= 3 x)) (<= 19 x)))
(assert (=> (and (not (= 3 x)) (not (= 19 x))) (<= 5 x)))
(assert (=> (and (not (= 3 x)) (not (= 19 x)) (not (= 5 x))) (<= 3 x)))
(assert (=> (and (not (= 3 x)) (not (= 19 x)) (not (= 5 x)) (not (= 3 x))) (<= 0 x)))
(assert (=> (and (not (= 3 x)) (not (= 19 x)) (not (= 5 x)) (not (= 3 x)) (not (= 0 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    19)
)
### output for cvc5
sat
(
(define-fun x () Int 19)
)

Found solution 19

Solving puzzle 417/774: MaxDelta:1
sat_func def sat(n: int, pairs=[[735272, 0], [959403, 509925], [627622, 420078], [26718, 90062], [175999, 98715], [428400, 1098754], [958640, 543606], [983032, 181754], [143406, 1301552], [183299, 437141], [133206, 199853], [679951, 366700], [383704, 737787], [476200, 226078], [923093, 81263], [574756, 679331], [766050, 5511], [214260, 445680], [434074, 747765], [769774, 209386], [512796, 2095723], [0, 612991]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
modified_func def sat(n: int, pairs=wrap_list([wrap_list([wrap_int(735272), wrap_int(0)]), wrap_list([wrap_int(959403), wrap_int(509925)]), wrap_list([wrap_int(627622), wrap_int(420078)]), wrap_list([wrap_int(26718), wrap_int(90062)]), wrap_list([wrap_int(175999), wrap_int(98715)]), wrap_list([wrap_int(428400), wrap_int(1098754)]), wrap_list([wrap_int(958640), wrap_int(543606)]), wrap_list([wrap_int(983032), wrap_int(181754)]), wrap_list([wrap_int(143406), wrap_int(1301552)]), wrap_list([wrap_int(183299), wrap_int(437141)]), wrap_list([wrap_int(133206), wrap_int(199853)]), wrap_list([wrap_int(679951), wrap_int(366700)]), wrap_list([wrap_int(383704), wrap_int(737787)]), wrap_list([wrap_int(476200), wrap_int(226078)]), wrap_list([wrap_int(923093), wrap_int(81263)]), wrap_list([wrap_int(574756), wrap_int(679331)]), wrap_list([wrap_int(766050), wrap_int(5511)]), wrap_list([wrap_int(214260), wrap_int(445680)]), wrap_list([wrap_int(434074), wrap_int(747765)]), wrap_list([wrap_int(769774), wrap_int(209386)]), wrap_list([wrap_int(512796), wrap_int(2095723)]), wrap_list([wrap_int(0), wrap_int(612991)])])):
    _assert(sym_sum(sym_generator((p - m for p, m in pairs))) == wrap_int(0), wrap_str('oo'))
    tot = wrap_int(0)
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        _assert(tot <= n)
        if tot == n:
            success = True
    return success
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert (<= 735272 x))
(assert (=> (= 735272 x) (<= 1184750 x)))
(assert (=> (and (= 735272 x) (= 1184750 x)) (<= 1392294 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x)) (<= 1328950 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x)) (<= 1406234 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x)) (<= 735880 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x)) (<= 1150914 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x)) (<= 1952192 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x)) (<= 794046 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x)) (<= 540204 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x)) (<= 473557 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x)) (<= 786808 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x)) (<= 432725 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x)) (<= 682847 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x)) (<= 1524677 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x) (= 1524677 x)) (<= 1420102 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x) (= 1524677 x) (= 1420102 x)) (<= 2180641 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x) (= 1524677 x) (= 1420102 x) (= 2180641 x)) (<= 1949221 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x) (= 1524677 x) (= 1420102 x) (= 2180641 x) (= 1949221 x)) (<= 1635530 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x) (= 1524677 x) (= 1420102 x) (= 2180641 x) (= 1949221 x) (= 1635530 x)) (<= 2195918 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x) (= 1524677 x) (= 1420102 x) (= 2180641 x) (= 1949221 x) (= 1635530 x) (= 2195918 x)) (<= 612991 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x) (= 1524677 x) (= 1420102 x) (= 2180641 x) (= 1949221 x) (= 1635530 x) (= 2195918 x) (= 612991 x)) (<= 0 x)))
(assert (=> (and (= 735272 x) (= 1184750 x) (= 1392294 x) (= 1328950 x) (= 1406234 x) (= 735880 x) (= 1150914 x) (= 1952192 x) (= 794046 x) (= 540204 x) (= 473557 x) (= 786808 x) (= 432725 x) (= 682847 x) (= 1524677 x) (= 1420102 x) (= 2180641 x) (= 1949221 x) (= 1635530 x) (= 2195918 x) (= 612991 x) (= 0 x)) true))
(assert true)
(assert (<= 735272 x))
(assert (=> (not (= 735272 x)) (<= 1184750 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x))) (<= 1392294 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x))) (<= 1328950 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x))) (<= 1406234 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x))) (<= 735880 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x))) (<= 1150914 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x))) (<= 1952192 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x))) (<= 794046 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x))) (<= 540204 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x))) (<= 473557 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x))) (<= 786808 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x))) (<= 432725 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x))) (<= 682847 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x))) (<= 1524677 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x)) (not (= 1524677 x))) (<= 1420102 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x)) (not (= 1524677 x)) (not (= 1420102 x))) (<= 2180641 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x)) (not (= 1524677 x)) (not (= 1420102 x)) (not (= 2180641 x))) (<= 1949221 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x)) (not (= 1524677 x)) (not (= 1420102 x)) (not (= 2180641 x)) (not (= 1949221 x))) (<= 1635530 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x)) (not (= 1524677 x)) (not (= 1420102 x)) (not (= 2180641 x)) (not (= 1949221 x)) (not (= 1635530 x))) (<= 2195918 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x)) (not (= 1524677 x)) (not (= 1420102 x)) (not (= 2180641 x)) (not (= 1949221 x)) (not (= 1635530 x)) (not (= 2195918 x))) (<= 612991 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x)) (not (= 1524677 x)) (not (= 1420102 x)) (not (= 2180641 x)) (not (= 1949221 x)) (not (= 1635530 x)) (not (= 2195918 x)) (not (= 612991 x))) (<= 0 x)))
(assert (=> (and (not (= 735272 x)) (not (= 1184750 x)) (not (= 1392294 x)) (not (= 1328950 x)) (not (= 1406234 x)) (not (= 735880 x)) (not (= 1150914 x)) (not (= 1952192 x)) (not (= 794046 x)) (not (= 540204 x)) (not (= 473557 x)) (not (= 786808 x)) (not (= 432725 x)) (not (= 682847 x)) (not (= 1524677 x)) (not (= 1420102 x)) (not (= 2180641 x)) (not (= 1949221 x)) (not (= 1635530 x)) (not (= 2195918 x)) (not (= 612991 x)) (not (= 0 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1184750)
)
### output for cvc5
sat
(
(define-fun x () Int 1184750)
)

Found solution 1184750
Exception in checking result: 
WARNING: Solution verification failed for puzzle MaxDelta:1
Too many constants for extrapolation

Solving puzzle 418/774: MaxDelta:2
sat_func def sat(n: int, pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
modified_func def sat(n: int, pairs=wrap_list([wrap_list([wrap_int(266519), wrap_int(0)]), wrap_list([wrap_int(548032), wrap_int(32788)]), wrap_list([wrap_int(612482), wrap_int(632311)]), wrap_list([wrap_int(465240), wrap_int(376403)]), wrap_list([wrap_int(123288), wrap_int(475698)]), wrap_list([wrap_int(962873), wrap_int(439482)]), wrap_list([wrap_int(193531), wrap_int(258475)]), wrap_list([wrap_int(747616), wrap_int(319130)]), wrap_list([wrap_int(592192), wrap_int(824307)]), wrap_list([wrap_int(508933), wrap_int(296745)]), wrap_list([wrap_int(411467), wrap_int(566648)]), wrap_list([wrap_int(905981), wrap_int(19854)]), wrap_list([wrap_int(805465), wrap_int(657818)]), wrap_list([wrap_int(802088), wrap_int(325540)]), wrap_list([wrap_int(127441), wrap_int(1703553)]), wrap_list([wrap_int(19150), wrap_int(964316)]), wrap_list([wrap_int(0), wrap_int(199230)])])):
    _assert(sym_sum(sym_generator((p - m for p, m in pairs))) == wrap_int(0), wrap_str('oo'))
    tot = wrap_int(0)
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        _assert(tot <= n)
        if tot == n:
            success = True
    return success
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert (<= 266519 x))
(assert (=> (= 266519 x) (<= 781763 x)))
(assert (=> (and (= 266519 x) (= 781763 x)) (<= 761934 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x)) (<= 850771 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x)) (<= 498361 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x)) (<= 1021752 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x)) (<= 956808 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x)) (<= 1385294 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x)) (<= 1153179 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x)) (<= 1365367 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x) (= 1365367 x)) (<= 1210186 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x) (= 1365367 x) (= 1210186 x)) (<= 2096313 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x) (= 1365367 x) (= 1210186 x) (= 2096313 x)) (<= 2243960 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x) (= 1365367 x) (= 1210186 x) (= 2096313 x) (= 2243960 x)) (<= 2720508 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x) (= 1365367 x) (= 1210186 x) (= 2096313 x) (= 2243960 x) (= 2720508 x)) (<= 1144396 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x) (= 1365367 x) (= 1210186 x) (= 2096313 x) (= 2243960 x) (= 2720508 x) (= 1144396 x)) (<= 199230 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x) (= 1365367 x) (= 1210186 x) (= 2096313 x) (= 2243960 x) (= 2720508 x) (= 1144396 x) (= 199230 x)) (<= 0 x)))
(assert (=> (and (= 266519 x) (= 781763 x) (= 761934 x) (= 850771 x) (= 498361 x) (= 1021752 x) (= 956808 x) (= 1385294 x) (= 1153179 x) (= 1365367 x) (= 1210186 x) (= 2096313 x) (= 2243960 x) (= 2720508 x) (= 1144396 x) (= 199230 x) (= 0 x)) true))
(assert true)
(assert (<= 266519 x))
(assert (=> (not (= 266519 x)) (<= 781763 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x))) (<= 761934 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x))) (<= 850771 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x))) (<= 498361 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x))) (<= 1021752 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x))) (<= 956808 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x))) (<= 1385294 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x))) (<= 1153179 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x))) (<= 1365367 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x)) (not (= 1365367 x))) (<= 1210186 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x)) (not (= 1365367 x)) (not (= 1210186 x))) (<= 2096313 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x)) (not (= 1365367 x)) (not (= 1210186 x)) (not (= 2096313 x))) (<= 2243960 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x)) (not (= 1365367 x)) (not (= 1210186 x)) (not (= 2096313 x)) (not (= 2243960 x))) (<= 2720508 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x)) (not (= 1365367 x)) (not (= 1210186 x)) (not (= 2096313 x)) (not (= 2243960 x)) (not (= 2720508 x))) (<= 1144396 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x)) (not (= 1365367 x)) (not (= 1210186 x)) (not (= 2096313 x)) (not (= 2243960 x)) (not (= 2720508 x)) (not (= 1144396 x))) (<= 199230 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x)) (not (= 1365367 x)) (not (= 1210186 x)) (not (= 2096313 x)) (not (= 2243960 x)) (not (= 2720508 x)) (not (= 1144396 x)) (not (= 199230 x))) (<= 0 x)))
(assert (=> (and (not (= 266519 x)) (not (= 781763 x)) (not (= 761934 x)) (not (= 850771 x)) (not (= 498361 x)) (not (= 1021752 x)) (not (= 956808 x)) (not (= 1385294 x)) (not (= 1153179 x)) (not (= 1365367 x)) (not (= 1210186 x)) (not (= 2096313 x)) (not (= 2243960 x)) (not (= 2720508 x)) (not (= 1144396 x)) (not (= 199230 x)) (not (= 0 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2720508)
)
### output for cvc5
sat
(
(define-fun x () Int 781763)
)

Found solution 2720508
Yes! Solved for puzzle  MaxDelta:2

Solving puzzle 419/774: MaxDelta:3
sat_func def sat(n: int, pairs=[[0, 0]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
modified_func def sat(n: int, pairs=wrap_list([wrap_list([wrap_int(0), wrap_int(0)])])):
    _assert(sym_sum(sym_generator((p - m for p, m in pairs))) == wrap_int(0), wrap_str('oo'))
    tot = wrap_int(0)
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        _assert(tot <= n)
        if tot == n:
            success = True
    return success
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert (<= 0 x))
(assert (=> (= 0 x) true))
(assert true)
(assert (<= 0 x))
(assert (=> (not (= 0 x)) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  MaxDelta:3

Solving puzzle 420/774: MaxDelta:4
sat_func def sat(n: int, pairs=[[459604, 0], [364611, 68505], [562652, 512251], [668655, 471975], [464486, 626280], [138684, 177065], [163296, 68630], [188271, 104677], [367839, 338137], [73022, 362103], [464143, 484458], [214935, 189299], [643725, 283515], [908210, 541732], [710201, 234839], [854230, 34479], [3288, 675724], [846637, 396244], [0, 2526576]]):
    assert sum(p - m for p, m in pairs) == 0, "oo"
    tot = 0
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        assert tot <= n
        if tot == n:
            success = True
    return success
modified_func def sat(n: int, pairs=wrap_list([wrap_list([wrap_int(459604), wrap_int(0)]), wrap_list([wrap_int(364611), wrap_int(68505)]), wrap_list([wrap_int(562652), wrap_int(512251)]), wrap_list([wrap_int(668655), wrap_int(471975)]), wrap_list([wrap_int(464486), wrap_int(626280)]), wrap_list([wrap_int(138684), wrap_int(177065)]), wrap_list([wrap_int(163296), wrap_int(68630)]), wrap_list([wrap_int(188271), wrap_int(104677)]), wrap_list([wrap_int(367839), wrap_int(338137)]), wrap_list([wrap_int(73022), wrap_int(362103)]), wrap_list([wrap_int(464143), wrap_int(484458)]), wrap_list([wrap_int(214935), wrap_int(189299)]), wrap_list([wrap_int(643725), wrap_int(283515)]), wrap_list([wrap_int(908210), wrap_int(541732)]), wrap_list([wrap_int(710201), wrap_int(234839)]), wrap_list([wrap_int(854230), wrap_int(34479)]), wrap_list([wrap_int(3288), wrap_int(675724)]), wrap_list([wrap_int(846637), wrap_int(396244)]), wrap_list([wrap_int(0), wrap_int(2526576)])])):
    _assert(sym_sum(sym_generator((p - m for p, m in pairs))) == wrap_int(0), wrap_str('oo'))
    tot = wrap_int(0)
    success = False
    for p, m in pairs:
        tot -= m
        tot += p
        _assert(tot <= n)
        if tot == n:
            success = True
    return success
### smt2
(set-logic ALL)
(declare-const x Int)
(assert true)
(assert (<= 459604 x))
(assert (=> (= 459604 x) (<= 755710 x)))
(assert (=> (and (= 459604 x) (= 755710 x)) (<= 806111 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x)) (<= 1002791 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x)) (<= 840997 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x)) (<= 802616 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x)) (<= 897282 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x)) (<= 980876 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x)) (<= 1010578 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x)) (<= 721497 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x)) (<= 701182 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x)) (<= 726818 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x) (= 726818 x)) (<= 1087028 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x) (= 726818 x) (= 1087028 x)) (<= 1453506 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x) (= 726818 x) (= 1087028 x) (= 1453506 x)) (<= 1928868 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x) (= 726818 x) (= 1087028 x) (= 1453506 x) (= 1928868 x)) (<= 2748619 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x) (= 726818 x) (= 1087028 x) (= 1453506 x) (= 1928868 x) (= 2748619 x)) (<= 2076183 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x) (= 726818 x) (= 1087028 x) (= 1453506 x) (= 1928868 x) (= 2748619 x) (= 2076183 x)) (<= 2526576 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x) (= 726818 x) (= 1087028 x) (= 1453506 x) (= 1928868 x) (= 2748619 x) (= 2076183 x) (= 2526576 x)) (<= 0 x)))
(assert (=> (and (= 459604 x) (= 755710 x) (= 806111 x) (= 1002791 x) (= 840997 x) (= 802616 x) (= 897282 x) (= 980876 x) (= 1010578 x) (= 721497 x) (= 701182 x) (= 726818 x) (= 1087028 x) (= 1453506 x) (= 1928868 x) (= 2748619 x) (= 2076183 x) (= 2526576 x) (= 0 x)) true))
(assert true)
(assert (<= 459604 x))
(assert (=> (not (= 459604 x)) (<= 755710 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x))) (<= 806111 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x))) (<= 1002791 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x))) (<= 840997 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x))) (<= 802616 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x))) (<= 897282 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x))) (<= 980876 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x))) (<= 1010578 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x))) (<= 721497 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x))) (<= 701182 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x))) (<= 726818 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x)) (not (= 726818 x))) (<= 1087028 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x)) (not (= 726818 x)) (not (= 1087028 x))) (<= 1453506 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x)) (not (= 726818 x)) (not (= 1087028 x)) (not (= 1453506 x))) (<= 1928868 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x)) (not (= 726818 x)) (not (= 1087028 x)) (not (= 1453506 x)) (not (= 1928868 x))) (<= 2748619 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x)) (not (= 726818 x)) (not (= 1087028 x)) (not (= 1453506 x)) (not (= 1928868 x)) (not (= 2748619 x))) (<= 2076183 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x)) (not (= 726818 x)) (not (= 1087028 x)) (not (= 1453506 x)) (not (= 1928868 x)) (not (= 2748619 x)) (not (= 2076183 x))) (<= 2526576 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x)) (not (= 726818 x)) (not (= 1087028 x)) (not (= 1453506 x)) (not (= 1928868 x)) (not (= 2748619 x)) (not (= 2076183 x)) (not (= 2526576 x))) (<= 0 x)))
(assert (=> (and (not (= 459604 x)) (not (= 755710 x)) (not (= 806111 x)) (not (= 1002791 x)) (not (= 840997 x)) (not (= 802616 x)) (not (= 897282 x)) (not (= 980876 x)) (not (= 1010578 x)) (not (= 721497 x)) (not (= 701182 x)) (not (= 726818 x)) (not (= 1087028 x)) (not (= 1453506 x)) (not (= 1928868 x)) (not (= 2748619 x)) (not (= 2076183 x)) (not (= 2526576 x)) (not (= 0 x))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1010578)
)
### output for cvc5
sat
(
(define-fun x () Int 755710)
)

Found solution 1010578
Exception in checking result: 
WARNING: Solution verification failed for puzzle MaxDelta:4
Too many constants for extrapolation

Solving puzzle 421/774: CommonCase:0
sat_func def sat(s_case: str, s="CanYouTellIfItHASmoreCAPITALS"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
modified_func def sat(s_case: str, s=wrap_str('CanYouTellIfItHASmoreCAPITALS')):
    caps = wrap_int(0)
    for c in s:
        if c != c.lower():
            caps += wrap_int(1)
    return s_case == (s.upper() if caps > sym_len(s) // wrap_int(2) else s.lower())
### smt2
(set-logic ALL)
(declare-const x String)
(assert (=> (> 16 (div 29 2)) (= x "CANYOUTELLIFITHASMORECAPITALS")))
(assert (=> (not (> 16 (div 29 2))) (= x "canyoutellifithasmorecapitals")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "CANYOUTELLIFITHASMORECAPITALS")
)
### output for cvc5
sat
(
(define-fun x () String "CANYOUTELLIFITHASMORECAPITALS")
)

Found solution CANYOUTELLIFITHASMORECAPITALS
Yes! Solved for puzzle  CommonCase:0

Solving puzzle 422/774: CommonCase:1
sat_func def sat(s_case: str, s="ThUcynICHiHIc"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
modified_func def sat(s_case: str, s=wrap_str('ThUcynICHiHIc')):
    caps = wrap_int(0)
    for c in s:
        if c != c.lower():
            caps += wrap_int(1)
    return s_case == (s.upper() if caps > sym_len(s) // wrap_int(2) else s.lower())
### smt2
(set-logic ALL)
(declare-const x String)
(assert (=> (> 7 (div 13 2)) (= x "THUCYNICHIHIC")))
(assert (=> (not (> 7 (div 13 2))) (= x "thucynichihic")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "THUCYNICHIHIC")
)
### output for cvc5
sat
(
(define-fun x () String "THUCYNICHIHIC")
)

Found solution THUCYNICHIHIC
Yes! Solved for puzzle  CommonCase:1

Solving puzzle 423/774: CommonCase:2
sat_func def sat(s_case: str, s="riziP"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
modified_func def sat(s_case: str, s=wrap_str('riziP')):
    caps = wrap_int(0)
    for c in s:
        if c != c.lower():
            caps += wrap_int(1)
    return s_case == (s.upper() if caps > sym_len(s) // wrap_int(2) else s.lower())
### smt2
(set-logic ALL)
(declare-const x String)
(assert (=> (> 1 (div 5 2)) (= x "RIZIP")))
(assert (=> (not (> 1 (div 5 2))) (= x "rizip")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "rizip")
)
### output for cvc5
sat
(
(define-fun x () String "rizip")
)

Found solution rizip
Yes! Solved for puzzle  CommonCase:2

Solving puzzle 424/774: CommonCase:3
sat_func def sat(s_case: str, s="KANExAjoHiBotipomyVOkATuMY"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
modified_func def sat(s_case: str, s=wrap_str('KANExAjoHiBotipomyVOkATuMY')):
    caps = wrap_int(0)
    for c in s:
        if c != c.lower():
            caps += wrap_int(1)
    return s_case == (s.upper() if caps > sym_len(s) // wrap_int(2) else s.lower())
### smt2
(set-logic ALL)
(declare-const x String)
(assert (=> (> 13 (div 26 2)) (= x "KANEXAJOHIBOTIPOMYVOKATUMY")))
(assert (=> (not (> 13 (div 26 2))) (= x "kanexajohibotipomyvokatumy")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "kanexajohibotipomyvokatumy")
)
### output for cvc5
sat
(
(define-fun x () String "kanexajohibotipomyvokatumy")
)

Found solution kanexajohibotipomyvokatumy
Yes! Solved for puzzle  CommonCase:3

Solving puzzle 425/774: CommonCase:4
sat_func def sat(s_case: str, s="rAC"):
    caps = 0
    for c in s:
        if c != c.lower():
            caps += 1
    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())
modified_func def sat(s_case: str, s=wrap_str('rAC')):
    caps = wrap_int(0)
    for c in s:
        if c != c.lower():
            caps += wrap_int(1)
    return s_case == (s.upper() if caps > sym_len(s) // wrap_int(2) else s.lower())
### smt2
(set-logic ALL)
(declare-const x String)
(assert (=> (> 2 (div 3 2)) (= x "RAC")))
(assert (=> (not (> 2 (div 3 2))) (= x "rac")))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "RAC")
)
### output for cvc5
sat
(
(define-fun x () String "RAC")
)

Found solution RAC
Yes! Solved for puzzle  CommonCase:4

Solving puzzle 426/774: Factor47:0
sat_func def sat(d: int, n=6002685529):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(6002685529)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_91 Int)) (=> (and (>= str_pos_91 0) (< str_pos_91 (str.len (str.from_int x)))) (and (= (mod 6002685529 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_91))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 6002685530))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:0
One large constant for extrapolation
Solving simpler variation replaced 6002685529 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_92 Int)) (=> (and (>= str_pos_92 0) (< str_pos_92 (str.len (str.from_int x)))) (and (= (mod 3 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_92))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 4))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:0

Solving puzzle 427/774: Factor47:1
sat_func def sat(d: int, n=16):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(16)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_93 Int)) (=> (and (>= str_pos_93 0) (< str_pos_93 (str.len (str.from_int x)))) (and (= (mod 16 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_93))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 17))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:1
Too many constants for extrapolation

Solving puzzle 428/774: Factor47:2
sat_func def sat(d: int, n=433459952851983617609247):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(433459952851983617609247)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_94 Int)) (=> (and (>= str_pos_94 0) (< str_pos_94 (str.len (str.from_int x)))) (and (= (mod 433459952851983617609247 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_94))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 433459952851983617609248))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:2
One large constant for extrapolation
Solving simpler variation replaced 433459952851983617609247 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_95 Int)) (=> (and (>= str_pos_95 0) (< str_pos_95 (str.len (str.from_int x)))) (and (= (mod 3 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_95))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 4))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:2

Solving puzzle 429/774: Factor47:3
sat_func def sat(d: int, n=738195924589532712188415):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(738195924589532712188415)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_96 Int)) (=> (and (>= str_pos_96 0) (< str_pos_96 (str.len (str.from_int x)))) (and (= (mod 738195924589532712188415 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_96))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 738195924589532712188416))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:3
One large constant for extrapolation
Solving simpler variation replaced 738195924589532712188415 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_97 Int)) (=> (and (>= str_pos_97 0) (< str_pos_97 (str.len (str.from_int x)))) (and (= (mod 3 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_97))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 4))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:3

Solving puzzle 430/774: Factor47:4
sat_func def sat(d: int, n=323190690645573746957862):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(323190690645573746957862)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_98 Int)) (=> (and (>= str_pos_98 0) (< str_pos_98 (str.len (str.from_int x)))) (and (= (mod 323190690645573746957862 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_98))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 323190690645573746957863))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:4
One large constant for extrapolation
Solving simpler variation replaced 323190690645573746957862 with 3
sat_func def sat(d: int, n=3):
    return n % d == 0 and all(i in "47" for i in str(d))
modified_func def sat(d: int, n=wrap_int(3)):
    return (n % d == wrap_int(0)).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(d)))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x Int)
(assert (forall ((str_pos_99 Int)) (=> (and (>= str_pos_99 0) (< str_pos_99 (str.len (str.from_int x)))) (and (= (mod 3 x) 0) (str.contains "47" (python.str.at (str.from_int x) str_pos_99))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
)
### output for cvc5
unknown
(
(define-fun x () Int (- 4))
)

Found solution -2
WARNING: Solution verification failed for puzzle Factor47:4

Solving puzzle 431/774: Count47:0
sat_func def sat(d: int, n=123456789):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(123456789)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_100 Int)) (=> (and (>= str_pos_100 0) (< str_pos_100 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 123456789) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_100))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:0
One large constant for extrapolation
Solving simpler variation replaced 123456789 with 3
sat_func def sat(d: int, n=3):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(3)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_101 Int)) (=> (and (>= str_pos_101 0) (< str_pos_101 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 3) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_101))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:0

Solving puzzle 432/774: Count47:1
sat_func def sat(d: int, n=659104579100082212):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(659104579100082212)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_102 Int)) (=> (and (>= str_pos_102 0) (< str_pos_102 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 659104579100082212) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_102))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:1
One large constant for extrapolation
Solving simpler variation replaced 659104579100082212 with 3
sat_func def sat(d: int, n=3):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(3)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_103 Int)) (=> (and (>= str_pos_103 0) (< str_pos_103 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 3) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_103))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:1

Solving puzzle 433/774: Count47:2
sat_func def sat(d: int, n=476988101965):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(476988101965)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_104 Int)) (=> (and (>= str_pos_104 0) (< str_pos_104 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 476988101965) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_104))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:2
One large constant for extrapolation
Solving simpler variation replaced 476988101965 with 3
sat_func def sat(d: int, n=3):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(3)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_105 Int)) (=> (and (>= str_pos_105 0) (< str_pos_105 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 3) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_105))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:2

Solving puzzle 434/774: Count47:3
sat_func def sat(d: int, n=3169877099077541094754):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(3169877099077541094754)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_106 Int)) (=> (and (>= str_pos_106 0) (< str_pos_106 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 3169877099077541094754) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_106))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:3
One large constant for extrapolation
Solving simpler variation replaced 3169877099077541094754 with 3
sat_func def sat(d: int, n=3):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(3)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_107 Int)) (=> (and (>= str_pos_107 0) (< str_pos_107 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 3) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_107))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:3

Solving puzzle 435/774: Count47:4
sat_func def sat(d: int, n=707):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(707)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_108 Int)) (=> (and (>= str_pos_108 0) (< str_pos_108 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 707) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_108))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () Int 7777)
)

Could not find any solution for puzzle Count47:4
One large constant for extrapolation
Solving simpler variation replaced 707 with 3
sat_func def sat(d: int, n=3):
    return d > n and all(i in "47" for i in str(str(d).count("4") + str(d).count("7")))
modified_func def sat(d: int, n=wrap_int(3)):
    return (d > n).__and__(all(sym_generator((sym_in(i, wrap_str('47')) for i in sym_str(sym_str(d).count('4') + sym_str(d).count('7'))))))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x Int)
(assert (>= (str.count (str.from_int x) "4") 0))
(assert (>= (str.count (str.from_int x) "7") 0))
(assert (forall ((str_pos_109 Int)) (=> (and (>= str_pos_109 0) (< str_pos_109 (str.len (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7")))))) (and (> x 3) (str.contains "47" (python.str.at (str.from_int (+ (str.count (str.from_int x) "4") (str.count (str.from_int x) "7"))) str_pos_109))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Count47:4

Solving puzzle 436/774: MaybeReversed:0
sat_func def sat(s: str, target="reverse me", reverse=True):
    return (s[::-1] == target) == reverse
modified_func def sat(s: str, target=wrap_str('reverse me'), reverse=True):
    return (s[::-1] == target) == reverse
Exception -- for puzzle MaybeReversed:0 found bad constraint False of type <class 'bool'>

Solving puzzle 437/774: MaybeReversed:1
sat_func def sat(s: str, target="thubonyna", reverse=True):
    return (s[::-1] == target) == reverse
modified_func def sat(s: str, target=wrap_str('thubonyna'), reverse=True):
    return (s[::-1] == target) == reverse
Exception -- for puzzle MaybeReversed:1 found bad constraint False of type <class 'bool'>

Solving puzzle 438/774: MaybeReversed:2
sat_func def sat(s: str, target="nivosypetextyzavalag", reverse=False):
    return (s[::-1] == target) == reverse
modified_func def sat(s: str, target=wrap_str('nivosypetextyzavalag'), reverse=False):
    return (s[::-1] == target) == reverse
Exception -- for puzzle MaybeReversed:2 found bad constraint False of type <class 'bool'>

Solving puzzle 439/774: MaybeReversed:3
sat_func def sat(s: str, target="l", reverse=False):
    return (s[::-1] == target) == reverse
modified_func def sat(s: str, target=wrap_str('l'), reverse=False):
    return (s[::-1] == target) == reverse
Exception -- for puzzle MaybeReversed:3 found bad constraint False of type <class 'bool'>

Solving puzzle 440/774: MaybeReversed:4
sat_func def sat(s: str, target="rechawewivetextovy", reverse=True):
    return (s[::-1] == target) == reverse
modified_func def sat(s: str, target=wrap_str('rechawewivetextovy'), reverse=True):
    return (s[::-1] == target) == reverse
Exception -- for puzzle MaybeReversed:4 found bad constraint False of type <class 'bool'>

Solving puzzle 441/774: Dada:0
sat_func def sat(s: str, a=5129, d=17):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(5129), d=wrap_int(17)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 5129) (= (str.count x "d") 17)) (= (str.len x) 5146)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Dada:0
One large constant for extrapolation
Solving simpler variation replaced 5129 with 3
sat_func def sat(s: str, a=3, d=17):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(3), d=wrap_int(17)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 3) (= (str.count x "d") 17)) (= (str.len x) 20)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Dada:0

Solving puzzle 442/774: Dada:1
sat_func def sat(s: str, a=5798, d=1873):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(5798), d=wrap_int(1873)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 5798) (= (str.count x "d") 1873)) (= (str.len x) 7671)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Dada:1
Two large constants for extrapolation
Solving simpler variation replaced 1873 with 3 and 5798 with 5
sat_func def sat(s: str, a=5, d=3):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(5), d=wrap_int(3)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 5) (= (str.count x "d") 3)) (= (str.len x) 8)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "adaadaad")
)
### output for cvc5
sat
(
(define-fun x () String "aaaddaad")
)

Found solution adaadaad

Solving puzzle 443/774: Dada:2
sat_func def sat(s: str, a=2645, d=1270):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(2645), d=wrap_int(1270)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 2645) (= (str.count x "d") 1270)) (= (str.len x) 3915)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Dada:2
Two large constants for extrapolation
Solving simpler variation replaced 1270 with 3 and 2645 with 5
sat_func def sat(s: str, a=5, d=3):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(5), d=wrap_int(3)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 5) (= (str.count x "d") 3)) (= (str.len x) 8)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "adaadaad")
)
### output for cvc5
sat
(
(define-fun x () String "aaaddaad")
)

Found solution adaadaad

Solving puzzle 444/774: Dada:3
sat_func def sat(s: str, a=2996, d=6808):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(2996), d=wrap_int(6808)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 2996) (= (str.count x "d") 6808)) (= (str.len x) 9804)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Dada:3
Two large constants for extrapolation
Solving simpler variation replaced 2996 with 3 and 6808 with 5
sat_func def sat(s: str, a=3, d=5):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(3), d=wrap_int(5)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 3) (= (str.count x "d") 5)) (= (str.len x) 8)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "aaaddddd")
)

Found solution aaaddddd

Solving puzzle 445/774: Dada:4
sat_func def sat(s: str, a=4763, d=8408):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(4763), d=wrap_int(8408)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 4763) (= (str.count x "d") 8408)) (= (str.len x) 13171)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Dada:4
Two large constants for extrapolation
Solving simpler variation replaced 4763 with 3 and 8408 with 5
sat_func def sat(s: str, a=3, d=5):
    return s.count("a") == a and s.count("d") == d and len(s) == a + d
modified_func def sat(s: str, a=wrap_int(3), d=wrap_int(5)):
    return (s.count('a') == a).__and__(s.count('d') == d).__and__(sym_len(s) == a + d)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "d") 0))
(assert (and (and (= (str.count x "a") 3) (= (str.count x "d") 5)) (= (str.len x) 8)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "aaaddddd")
)

Found solution aaaddddd

Solving puzzle 446/774: EasySum:0
sat_func def sat(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):
    return tot == sum(1 if i < thresh else 2 for i in nums)
modified_func def sat(tot: int, nums=wrap_list([wrap_int(2), wrap_int(8), wrap_int(25), wrap_int(18), wrap_int(99), wrap_int(11), wrap_int(17), wrap_int(16)]), thresh=wrap_int(17)):
    return tot == sym_sum(sym_generator((wrap_int(1) if i < thresh else wrap_int(2) for i in nums)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 12))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    12)
)
### output for cvc5
sat
(
(define-fun x () Int 12)
)

Found solution 12
Yes! Solved for puzzle  EasySum:0

Solving puzzle 447/774: EasySum:1
sat_func def sat(tot: int, nums=[60, 63, 11], thresh=99):
    return tot == sum(1 if i < thresh else 2 for i in nums)
modified_func def sat(tot: int, nums=wrap_list([wrap_int(60), wrap_int(63), wrap_int(11)]), thresh=wrap_int(99)):
    return tot == sym_sum(sym_generator((wrap_int(1) if i < thresh else wrap_int(2) for i in nums)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3)
)
### output for cvc5
sat
(
(define-fun x () Int 3)
)

Found solution 3
Yes! Solved for puzzle  EasySum:1

Solving puzzle 448/774: EasySum:2
sat_func def sat(tot: int, nums=[32, 24, 19, 88, 6, 33, 13], thresh=33):
    return tot == sum(1 if i < thresh else 2 for i in nums)
modified_func def sat(tot: int, nums=wrap_list([wrap_int(32), wrap_int(24), wrap_int(19), wrap_int(88), wrap_int(6), wrap_int(33), wrap_int(13)]), thresh=wrap_int(33)):
    return tot == sym_sum(sym_generator((wrap_int(1) if i < thresh else wrap_int(2) for i in nums)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 9))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    9)
)
### output for cvc5
sat
(
(define-fun x () Int 9)
)

Found solution 9
Yes! Solved for puzzle  EasySum:2

Solving puzzle 449/774: EasySum:3
sat_func def sat(tot: int, nums=[60, 72, 32, 29, 90, 9, 39, 67, 31, 71, 68, 72, 28, 85, 75, 60, 42, 66, 4, 71, 57, 45, 88, 20, 66, 97, 33, 43, 48], thresh=30):
    return tot == sum(1 if i < thresh else 2 for i in nums)
modified_func def sat(tot: int, nums=wrap_list([wrap_int(60), wrap_int(72), wrap_int(32), wrap_int(29), wrap_int(90), wrap_int(9), wrap_int(39), wrap_int(67), wrap_int(31), wrap_int(71), wrap_int(68), wrap_int(72), wrap_int(28), wrap_int(85), wrap_int(75), wrap_int(60), wrap_int(42), wrap_int(66), wrap_int(4), wrap_int(71), wrap_int(57), wrap_int(45), wrap_int(88), wrap_int(20), wrap_int(66), wrap_int(97), wrap_int(33), wrap_int(43), wrap_int(48)]), thresh=wrap_int(30)):
    return tot == sym_sum(sym_generator((wrap_int(1) if i < thresh else wrap_int(2) for i in nums)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 53))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    53)
)
### output for cvc5
sat
(
(define-fun x () Int 53)
)

Found solution 53
Yes! Solved for puzzle  EasySum:3

Solving puzzle 450/774: EasySum:4
sat_func def sat(tot: int, nums=[61, 98, 33, 32, 4, 99, 91, 63, 76, 83, 52, 0, 19, 49, 85, 5, 54, 71, 41, 93, 54, 78, 92], thresh=91):
    return tot == sum(1 if i < thresh else 2 for i in nums)
modified_func def sat(tot: int, nums=wrap_list([wrap_int(61), wrap_int(98), wrap_int(33), wrap_int(32), wrap_int(4), wrap_int(99), wrap_int(91), wrap_int(63), wrap_int(76), wrap_int(83), wrap_int(52), wrap_int(0), wrap_int(19), wrap_int(49), wrap_int(85), wrap_int(5), wrap_int(54), wrap_int(71), wrap_int(41), wrap_int(93), wrap_int(54), wrap_int(78), wrap_int(92)]), thresh=wrap_int(91)):
    return tot == sym_sum(sym_generator((wrap_int(1) if i < thresh else wrap_int(2) for i in nums)))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= x 28))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    28)
)
### output for cvc5
sat
(
(define-fun x () Int 28)
)

Found solution 28
Yes! Solved for puzzle  EasySum:4

Solving puzzle 451/774: GimmeChars:0
sat_func def sat(s: str, chars=['o', 'h', 'e', 'l', ' ', 'w', '!', 'r', 'd']):
    for c in chars:
        if c not in s:
            return False
    return True
modified_func def sat(s: str, chars=wrap_list([wrap_str('o'), wrap_str('h'), wrap_str('e'), wrap_str('l'), wrap_str(' '), wrap_str('w'), wrap_str('!'), wrap_str('r'), wrap_str('d')])):
    for c in chars:
        if c not in s:
            return False
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle GimmeChars:0
Too many constants for extrapolation

Solving puzzle 452/774: GimmeChars:1
sat_func def sat(s: str, chars=['1', 'j', '3', 'Q', 'e']):
    for c in chars:
        if c not in s:
            return False
    return True
modified_func def sat(s: str, chars=wrap_list([wrap_str('1'), wrap_str('j'), wrap_str('3'), wrap_str('Q'), wrap_str('e')])):
    for c in chars:
        if c not in s:
            return False
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle GimmeChars:1
Too many constants for extrapolation

Solving puzzle 453/774: GimmeChars:2
sat_func def sat(s: str, chars=['[', '/', 'g']):
    for c in chars:
        if c not in s:
            return False
    return True
modified_func def sat(s: str, chars=wrap_list([wrap_str('['), wrap_str('/'), wrap_str('g')])):
    for c in chars:
        if c not in s:
            return False
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle GimmeChars:2
Too many constants for extrapolation

Solving puzzle 454/774: GimmeChars:3
sat_func def sat(s: str, chars=[' ', 'e', '%', '1', 'f']):
    for c in chars:
        if c not in s:
            return False
    return True
modified_func def sat(s: str, chars=wrap_list([wrap_str(' '), wrap_str('e'), wrap_str('%'), wrap_str('1'), wrap_str('f')])):
    for c in chars:
        if c not in s:
            return False
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle GimmeChars:3
Too many constants for extrapolation

Solving puzzle 455/774: GimmeChars:4
sat_func def sat(s: str, chars=['W', '@', 'S']):
    for c in chars:
        if c not in s:
            return False
    return True
modified_func def sat(s: str, chars=wrap_list([wrap_str('W'), wrap_str('@'), wrap_str('S')])):
    for c in chars:
        if c not in s:
            return False
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)
(declare-const x String)
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle GimmeChars:4
Too many constants for extrapolation

Solving puzzle 456/774: FivePowers:0
sat_func def sat(s: str, n=7012):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
modified_func def sat(s: str, n=wrap_int(7012)):
    return sym_int(sym_str(wrap_int(5) ** n)[:-2] + s) == wrap_int(5) ** n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len (str.++ "169515547674460088" x)) 0))
(assert (= (python.int (str.++ "169515547674460088" x) 10) 16951554767446008832))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "32")
)
### output for cvc5
sat
(
(define-fun x () String "32")
)

Found solution 32
Exception in checking result: Exceeds the limit (4300 digits) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit
WARNING: Solution verification failed for puzzle FivePowers:0
One large constant for extrapolation
Solving simpler variation replaced 7012 with 3
sat_func def sat(s: str, n=3):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
modified_func def sat(s: str, n=wrap_int(3)):
    return sym_int(sym_str(wrap_int(5) ** n)[:-2] + s) == wrap_int(5) ** n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len (str.++ "2" x)) 0))
(assert (= (python.int (str.++ "2" x) 10) 243))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "43")
)
### output for cvc5
sat
(
(define-fun x () String "43")
)

Found solution 43
WARNING: Solution verification failed for puzzle FivePowers:0

Solving puzzle 457/774: FivePowers:1
sat_func def sat(s: str, n=0):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
modified_func def sat(s: str, n=wrap_int(0)):
    return sym_int(sym_str(wrap_int(5) ** n)[:-2] + s) == wrap_int(5) ** n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len (str.++ "" x)) 0))
(assert (= (python.int (str.++ "" x) 10) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "0")
)
### output for cvc5
sat
(
(define-fun x () String "0")
)

Found solution 0
WARNING: Solution verification failed for puzzle FivePowers:1
Too many constants for extrapolation

Solving puzzle 458/774: FivePowers:2
sat_func def sat(s: str, n=1):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
modified_func def sat(s: str, n=wrap_int(1)):
    return sym_int(sym_str(wrap_int(5) ** n)[:-2] + s) == wrap_int(5) ** n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len (str.++ "" x)) 0))
(assert (= (python.int (str.++ "" x) 10) 1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "1")
)
### output for cvc5
sat
(
(define-fun x () String "1")
)

Found solution 1
WARNING: Solution verification failed for puzzle FivePowers:2
Too many constants for extrapolation

Solving puzzle 459/774: FivePowers:3
sat_func def sat(s: str, n=2):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
modified_func def sat(s: str, n=wrap_int(2)):
    return sym_int(sym_str(wrap_int(5) ** n)[:-2] + s) == wrap_int(5) ** n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len (str.++ "" x)) 0))
(assert (= (python.int (str.++ "" x) 10) 32))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "32")
)
### output for cvc5
sat
(
(define-fun x () String "32")
)

Found solution 32
WARNING: Solution verification failed for puzzle FivePowers:3
Too many constants for extrapolation

Solving puzzle 460/774: FivePowers:4
sat_func def sat(s: str, n=3):
    return int(str(5 ** n)[:-2] + s) == 5 ** n
modified_func def sat(s: str, n=wrap_int(3)):
    return sym_int(sym_str(wrap_int(5) ** n)[:-2] + s) == wrap_int(5) ** n
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))

(declare-const x String)
(assert (> (str.len (str.++ "2" x)) 0))
(assert (= (python.int (str.++ "2" x) 10) 243))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "43")
)
### output for cvc5
sat
(
(define-fun x () String "43")
)

Found solution 43
WARNING: Solution verification failed for puzzle FivePowers:4
Too many constants for extrapolation

Solving puzzle 461/774: InvertPermutation:0
sat_func def sat(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="hello are you there?"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
modified_func def sat(s: str, perm=wrap_str('qwertyuiopasdfghjklzxcvbnm'), target=wrap_str('hello are you there?')):
    return wrap_str('').join(sym_generator((perm[(perm.index(c) + wrap_int(1)) % sym_len(perm)] if sym_in(c, perm) else c for c in s))) == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_110 Int)) (=> (and (>= str_pos_110 0) (< str_pos_110 (str.len x))) (=> (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_110)) (= (python.join (cons (str.substr "qwertyuiopasdfghjklzxcvbnm" (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_110) 0) 1) 26) (- (+ (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_110) 0) 1) 26) 1) (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_110) 0) 1) 26))) (as nil (List String))) "") "hello are you there?")))))
(assert (forall ((str_pos_111 Int)) (=> (and (>= str_pos_111 0) (< str_pos_111 (str.len x))) (forall ((str_pos_110 Int)) (=> (and (>= str_pos_110 0) (< str_pos_110 (str.len x))) (=> (not (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_111))) (= (python.join (cons (python.str.at x str_pos_111) (as nil (List String))) "") "hello are you there?")))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "")
)

Could not find any solution for puzzle InvertPermutation:0
Too many constants for extrapolation

Solving puzzle 462/774: InvertPermutation:1
sat_func def sat(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="xapypakygatextifyth divufyjacof cecuchuquypo sulechukijocharapad hych mugemi re binivot"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
modified_func def sat(s: str, perm=wrap_str('qwertyuiopasdfghjklzxcvbnm'), target=wrap_str('xapypakygatextifyth divufyjacof cecuchuquypo sulechukijocharapad hych mugemi re binivot')):
    return wrap_str('').join(sym_generator((perm[(perm.index(c) + wrap_int(1)) % sym_len(perm)] if sym_in(c, perm) else c for c in s))) == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x String)
(assert (forall ((str_pos_112 Int)) (=> (and (>= str_pos_112 0) (< str_pos_112 (str.len x))) (=> (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_112)) (= (python.join (cons (str.substr "qwertyuiopasdfghjklzxcvbnm" (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_112) 0) 1) 26) (- (+ (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_112) 0) 1) 26) 1) (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_112) 0) 1) 26))) (as nil (List String))) "") "xapypakygatextifyth divufyjacof cecuchuquypo sulechukijocharapad hych mugemi re binivot")))))
(assert (forall ((str_pos_113 Int)) (=> (and (>= str_pos_113 0) (< str_pos_113 (str.len x))) (forall ((str_pos_112 Int)) (=> (and (>= str_pos_112 0) (< str_pos_112 (str.len x))) (=> (not (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_113))) (= (python.join (cons (python.str.at x str_pos_113) (as nil (List String))) "") "xapypakygatextifyth divufyjacof cecuchuquypo sulechukijocharapad hych mugemi re binivot")))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "")
)

Could not find any solution for puzzle InvertPermutation:1
Too many constants for extrapolation

Solving puzzle 463/774: InvertPermutation:2
sat_func def sat(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="mujychenyzo"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
modified_func def sat(s: str, perm=wrap_str('qwertyuiopasdfghjklzxcvbnm'), target=wrap_str('mujychenyzo')):
    return wrap_str('').join(sym_generator((perm[(perm.index(c) + wrap_int(1)) % sym_len(perm)] if sym_in(c, perm) else c for c in s))) == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_114 Int)) (=> (and (>= str_pos_114 0) (< str_pos_114 (str.len x))) (=> (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_114)) (= (python.join (cons (str.substr "qwertyuiopasdfghjklzxcvbnm" (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_114) 0) 1) 26) (- (+ (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_114) 0) 1) 26) 1) (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_114) 0) 1) 26))) (as nil (List String))) "") "mujychenyzo")))))
(assert (forall ((str_pos_115 Int)) (=> (and (>= str_pos_115 0) (< str_pos_115 (str.len x))) (forall ((str_pos_114 Int)) (=> (and (>= str_pos_114 0) (< str_pos_114 (str.len x))) (=> (not (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_115))) (= (python.join (cons (python.str.at x str_pos_115) (as nil (List String))) "") "mujychenyzo")))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "")
)

Could not find any solution for puzzle InvertPermutation:2
Too many constants for extrapolation

Solving puzzle 464/774: InvertPermutation:3
sat_func def sat(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="quethoruchyrugyz wemywuconuthisiquu kachogechehuz pulybyri quuby thatextak tychuzymuxuzazylyk neruzesithipecytoqu"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
modified_func def sat(s: str, perm=wrap_str('qwertyuiopasdfghjklzxcvbnm'), target=wrap_str('quethoruchyrugyz wemywuconuthisiquu kachogechehuz pulybyri quuby thatextak tychuzymuxuzazylyk neruzesithipecytoqu')):
    return wrap_str('').join(sym_generator((perm[(perm.index(c) + wrap_int(1)) % sym_len(perm)] if sym_in(c, perm) else c for c in s))) == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_116 Int)) (=> (and (>= str_pos_116 0) (< str_pos_116 (str.len x))) (=> (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_116)) (= (python.join (cons (str.substr "qwertyuiopasdfghjklzxcvbnm" (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_116) 0) 1) 26) (- (+ (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_116) 0) 1) 26) 1) (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_116) 0) 1) 26))) (as nil (List String))) "") "quethoruchyrugyz wemywuconuthisiquu kachogechehuz pulybyri quuby thatextak tychuzymuxuzazylyk neruzesithipecytoqu")))))
(assert (forall ((str_pos_117 Int)) (=> (and (>= str_pos_117 0) (< str_pos_117 (str.len x))) (forall ((str_pos_116 Int)) (=> (and (>= str_pos_116 0) (< str_pos_116 (str.len x))) (=> (not (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_117))) (= (python.join (cons (python.str.at x str_pos_117) (as nil (List String))) "") "quethoruchyrugyz wemywuconuthisiquu kachogechehuz pulybyri quuby thatextak tychuzymuxuzazylyk neruzesithipecytoqu")))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "")
)

Could not find any solution for puzzle InvertPermutation:3
Too many constants for extrapolation

Solving puzzle 465/774: InvertPermutation:4
sat_func def sat(s: str, perm="qwertyuiopasdfghjklzxcvbnm", target="thyjytex cequolichitextotho bymoxokepy jyvumywefoc"):
    return "".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target
modified_func def sat(s: str, perm=wrap_str('qwertyuiopasdfghjklzxcvbnm'), target=wrap_str('thyjytex cequolichitextotho bymoxokepy jyvumywefoc')):
    return wrap_str('').join(sym_generator((perm[(perm.index(c) + wrap_int(1)) % sym_len(perm)] if sym_in(c, perm) else c for c in s))) == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_118 Int)) (=> (and (>= str_pos_118 0) (< str_pos_118 (str.len x))) (=> (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_118)) (= (python.join (cons (str.substr "qwertyuiopasdfghjklzxcvbnm" (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_118) 0) 1) 26) (- (+ (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_118) 0) 1) 26) 1) (mod (+ (str.indexof "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_118) 0) 1) 26))) (as nil (List String))) "") "thyjytex cequolichitextotho bymoxokepy jyvumywefoc")))))
(assert (forall ((str_pos_119 Int)) (=> (and (>= str_pos_119 0) (< str_pos_119 (str.len x))) (forall ((str_pos_118 Int)) (=> (and (>= str_pos_118 0) (< str_pos_118 (str.len x))) (=> (not (str.contains "qwertyuiopasdfghjklzxcvbnm" (python.str.at x str_pos_119))) (= (python.join (cons (python.str.at x str_pos_119) (as nil (List String))) "") "thyjytex cequolichitextotho bymoxokepy jyvumywefoc")))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "")
)

Could not find any solution for puzzle InvertPermutation:4
Too many constants for extrapolation

Solving puzzle 466/774: MinConsecutiveSum:0
sat_func def sat(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
modified_func def sat(start: int, k=wrap_int(3), upper=wrap_int(6), seq=wrap_list([wrap_int(17), wrap_int(1), wrap_int(2), wrap_int(65), wrap_int(18), wrap_int(91), -wrap_int(30), wrap_int(100), wrap_int(3), wrap_int(1), wrap_int(2)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) <= upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 11 3))) (<= 270 6)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MinConsecutiveSum:0
One large constant for extrapolation
Solving simpler variation replaced 100 with 3
sat_func def sat(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 3, 3, 1, 2]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
modified_func def sat(start: int, k=wrap_int(3), upper=wrap_int(6), seq=wrap_list([wrap_int(17), wrap_int(1), wrap_int(2), wrap_int(65), wrap_int(18), wrap_int(91), -wrap_int(30), wrap_int(3), wrap_int(3), wrap_int(1), wrap_int(2)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) <= upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 11 3))) (<= 173 6)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MinConsecutiveSum:0

Solving puzzle 467/774: MinConsecutiveSum:1
sat_func def sat(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
modified_func def sat(start: int, k=wrap_int(2), upper=-wrap_int(172), seq=wrap_list([wrap_int(79), wrap_int(18), -wrap_int(98), -wrap_int(13), wrap_int(88), -wrap_int(93), -wrap_int(77), -wrap_int(95), wrap_int(40), -wrap_int(3), -wrap_int(22)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) <= upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 11 2))) (<= -176 -172)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle MinConsecutiveSum:1
One large constant for extrapolation
Solving simpler variation replaced 172 with 3
sat_func def sat(start: int, k=2, upper=-3, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
modified_func def sat(start: int, k=wrap_int(2), upper=-wrap_int(3), seq=wrap_list([wrap_int(79), wrap_int(18), -wrap_int(98), -wrap_int(13), wrap_int(88), -wrap_int(93), -wrap_int(77), -wrap_int(95), wrap_int(40), -wrap_int(3), -wrap_int(22)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) <= upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 11 2))) (<= -176 -3)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle MinConsecutiveSum:1

Solving puzzle 468/774: MinConsecutiveSum:2
sat_func def sat(start: int, k=3, upper=-238, seq=[34, -9, -41, -62, -99, -58, -81, 66, -51, 90, -8, -56, -80, -66, -50, -74, -4, -47, 63, -86, 66, 72, 38, -3, 9, 92, 25, -77, 86, -24, -23, 9, 10, 36, -82, -48, -74, -1, -80, 55, -2, -86, 95, -52, -14, -87]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
modified_func def sat(start: int, k=wrap_int(3), upper=-wrap_int(238), seq=wrap_list([wrap_int(34), -wrap_int(9), -wrap_int(41), -wrap_int(62), -wrap_int(99), -wrap_int(58), -wrap_int(81), wrap_int(66), -wrap_int(51), wrap_int(90), -wrap_int(8), -wrap_int(56), -wrap_int(80), -wrap_int(66), -wrap_int(50), -wrap_int(74), -wrap_int(4), -wrap_int(47), wrap_int(63), -wrap_int(86), wrap_int(66), wrap_int(72), wrap_int(38), -wrap_int(3), wrap_int(9), wrap_int(92), wrap_int(25), -wrap_int(77), wrap_int(86), -wrap_int(24), -wrap_int(23), wrap_int(9), wrap_int(10), wrap_int(36), -wrap_int(82), -wrap_int(48), -wrap_int(74), -wrap_int(1), -wrap_int(80), wrap_int(55), -wrap_int(2), -wrap_int(86), wrap_int(95), -wrap_int(52), -wrap_int(14), -wrap_int(87)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) <= upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 46 3))) (<= -679 -238)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle MinConsecutiveSum:2
One large constant for extrapolation
Solving simpler variation replaced 238 with 3
sat_func def sat(start: int, k=3, upper=-3, seq=[34, -9, -41, -62, -99, -58, -81, 66, -51, 90, -8, -56, -80, -66, -50, -74, -4, -47, 63, -86, 66, 72, 38, -3, 9, 92, 25, -77, 86, -24, -23, 9, 10, 36, -82, -48, -74, -1, -80, 55, -2, -86, 95, -52, -14, -87]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
modified_func def sat(start: int, k=wrap_int(3), upper=-wrap_int(3), seq=wrap_list([wrap_int(34), -wrap_int(9), -wrap_int(41), -wrap_int(62), -wrap_int(99), -wrap_int(58), -wrap_int(81), wrap_int(66), -wrap_int(51), wrap_int(90), -wrap_int(8), -wrap_int(56), -wrap_int(80), -wrap_int(66), -wrap_int(50), -wrap_int(74), -wrap_int(4), -wrap_int(47), wrap_int(63), -wrap_int(86), wrap_int(66), wrap_int(72), wrap_int(38), -wrap_int(3), wrap_int(9), wrap_int(92), wrap_int(25), -wrap_int(77), wrap_int(86), -wrap_int(24), -wrap_int(23), wrap_int(9), wrap_int(10), wrap_int(36), -wrap_int(82), -wrap_int(48), -wrap_int(74), -wrap_int(1), -wrap_int(80), wrap_int(55), -wrap_int(2), -wrap_int(86), wrap_int(95), -wrap_int(52), -wrap_int(14), -wrap_int(87)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) <= upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 46 3))) (<= -679 -3)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0

Solving puzzle 469/774: MinConsecutiveSum:3
sat_func def sat(start: int, k=8, upper=-75, seq=[17, -90, 61, -29, 57, 7, -45, -37, 1, 69]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
modified_func def sat(start: int, k=wrap_int(8), upper=-wrap_int(75), seq=wrap_list([wrap_int(17), -wrap_int(90), wrap_int(61), -wrap_int(29), wrap_int(57), wrap_int(7), -wrap_int(45), -wrap_int(37), wrap_int(1), wrap_int(69)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) <= upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 10 8))) (<= 11 -75)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MinConsecutiveSum:3
Too many constants for extrapolation

Solving puzzle 470/774: MinConsecutiveSum:4
sat_func def sat(start: int, k=8, upper=-4, seq=[-17, 55, 6, -2, -14, -19, 86, -4, -8, -49, 40, 82]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper
modified_func def sat(start: int, k=wrap_int(8), upper=-wrap_int(4), seq=wrap_list([-wrap_int(17), wrap_int(55), wrap_int(6), -wrap_int(2), -wrap_int(14), -wrap_int(19), wrap_int(86), -wrap_int(4), -wrap_int(8), -wrap_int(49), wrap_int(40), wrap_int(82)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) <= upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 12 8))) (<= 156 -4)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MinConsecutiveSum:4
Too many constants for extrapolation

Solving puzzle 471/774: MaxConsecutiveSum:0
sat_func def sat(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
modified_func def sat(start: int, k=wrap_int(3), lower=wrap_int(150), seq=wrap_list([wrap_int(3), wrap_int(1), wrap_int(2), wrap_int(65), wrap_int(18), wrap_int(91), -wrap_int(30), wrap_int(100), wrap_int(0), wrap_int(19), wrap_int(52)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) >= lower)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 11 3))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
WARNING: Solution verification failed for puzzle MaxConsecutiveSum:0
Two large constants for extrapolation
Solving simpler variation replaced 100 with 3 and 150 with 5
sat_func def sat(start: int, k=3, lower=5, seq=[3, 1, 2, 65, 18, 91, -30, 3, 0, 19, 52]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
modified_func def sat(start: int, k=wrap_int(3), lower=wrap_int(5), seq=wrap_list([wrap_int(3), wrap_int(1), wrap_int(2), wrap_int(65), wrap_int(18), wrap_int(91), -wrap_int(30), wrap_int(3), wrap_int(0), wrap_int(19), wrap_int(52)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) >= lower)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 11 3))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0

Solving puzzle 472/774: MaxConsecutiveSum:1
sat_func def sat(start: int, k=9, lower=-183, seq=[44, -94, 25, -63, -39, -71, -34, 84, -35]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
modified_func def sat(start: int, k=wrap_int(9), lower=-wrap_int(183), seq=wrap_list([wrap_int(44), -wrap_int(94), wrap_int(25), -wrap_int(63), -wrap_int(39), -wrap_int(71), -wrap_int(34), wrap_int(84), -wrap_int(35)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) >= lower)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 9 9))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  MaxConsecutiveSum:1

Solving puzzle 473/774: MaxConsecutiveSum:2
sat_func def sat(start: int, k=3, lower=86, seq=[19, 82, -24, -9, -92, 50, -89, -15, 45, 56, -64]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
modified_func def sat(start: int, k=wrap_int(3), lower=wrap_int(86), seq=wrap_list([wrap_int(19), wrap_int(82), -wrap_int(24), -wrap_int(9), -wrap_int(92), wrap_int(50), -wrap_int(89), -wrap_int(15), wrap_int(45), wrap_int(56), -wrap_int(64)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) >= lower)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 11 3))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MaxConsecutiveSum:2
Too many constants for extrapolation

Solving puzzle 474/774: MaxConsecutiveSum:3
sat_func def sat(start: int, k=1, lower=-36, seq=[-36]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
modified_func def sat(start: int, k=wrap_int(1), lower=-wrap_int(36), seq=wrap_list([-wrap_int(36)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) >= lower)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 1 1))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  MaxConsecutiveSum:3

Solving puzzle 475/774: MaxConsecutiveSum:4
sat_func def sat(start: int, k=1, lower=93, seq=[-61, -46, 89, 93, -13, 14, -95, -74, -92, -38, -93, 64, -78, 3, 92, -10, -4, 43, 72, 12, 3, -3, -15, -96, 72, -71, -30, 53, 17, -87, 49, 17, -69, 78, 6, -77, -99, 91, 13, 9, 81, -55, 75, 48, -65, 18, -83, 10, -12, 88, 60, -72, -7, -49, -56, -76, 82, 18, 77, 52, -92, -88, 39, 13, -16, 82, 4, 44, -19, 54, 6, 55, 77, -38, -30, -55, -16]):
    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower
modified_func def sat(start: int, k=wrap_int(1), lower=wrap_int(93), seq=wrap_list([-wrap_int(61), -wrap_int(46), wrap_int(89), wrap_int(93), -wrap_int(13), wrap_int(14), -wrap_int(95), -wrap_int(74), -wrap_int(92), -wrap_int(38), -wrap_int(93), wrap_int(64), -wrap_int(78), wrap_int(3), wrap_int(92), -wrap_int(10), -wrap_int(4), wrap_int(43), wrap_int(72), wrap_int(12), wrap_int(3), -wrap_int(3), -wrap_int(15), -wrap_int(96), wrap_int(72), -wrap_int(71), -wrap_int(30), wrap_int(53), wrap_int(17), -wrap_int(87), wrap_int(49), wrap_int(17), -wrap_int(69), wrap_int(78), wrap_int(6), -wrap_int(77), -wrap_int(99), wrap_int(91), wrap_int(13), wrap_int(9), wrap_int(81), -wrap_int(55), wrap_int(75), wrap_int(48), -wrap_int(65), wrap_int(18), -wrap_int(83), wrap_int(10), -wrap_int(12), wrap_int(88), wrap_int(60), -wrap_int(72), -wrap_int(7), -wrap_int(49), -wrap_int(56), -wrap_int(76), wrap_int(82), wrap_int(18), wrap_int(77), wrap_int(52), -wrap_int(92), -wrap_int(88), wrap_int(39), wrap_int(13), -wrap_int(16), wrap_int(82), wrap_int(4), wrap_int(44), -wrap_int(19), wrap_int(54), wrap_int(6), wrap_int(55), wrap_int(77), -wrap_int(38), -wrap_int(30), -wrap_int(55), -wrap_int(16)])):
    return (wrap_int(0) <= start).__and__(start <= sym_len(seq) - k).__and__(sym_sum(seq[start:start + k]) >= lower)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (<= 0 x) (<= x (- 77 1))) false))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MaxConsecutiveSum:4
Too many constants for extrapolation

Solving puzzle 476/774: MaxConsecutiveProduct:0
sat_func def sat(start: int, k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(3), lower=wrap_int(100000), seq=wrap_list([wrap_int(91), wrap_int(1), wrap_int(2), wrap_int(64), wrap_int(18), wrap_int(91), -wrap_int(30), wrap_int(100), wrap_int(3), wrap_int(65), wrap_int(18)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 3))) (< i_0 11))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 3))) (> i_0 -11))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 3))) (>= (* 1 (ite (or (= i_0 10) (= i_0 -1)) 18 (ite (or (= i_0 9) (= i_0 -2)) 65 (ite (or (= i_0 8) (= i_0 -3)) 3 (ite (or (= i_0 7) (= i_0 -4)) 100 (ite (or (= i_0 6) (= i_0 -5)) -30 (ite (or (= i_0 5) (= i_0 -6)) 91 (ite (or (= i_0 4) (= i_0 -7)) 18 (ite (or (= i_0 3) (= i_0 -8)) 64 (ite (or (= i_0 2) (= i_0 -9)) 2 (ite (or (= i_0 1) (= i_0 -10)) 1 91))))))))))) 100000))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 7 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MaxConsecutiveProduct:0
Two large constants for extrapolation
Solving simpler variation replaced 100 with 3 and 100000 with 5
sat_func def sat(start: int, k=3, lower=5, seq=[91, 1, 2, 64, 18, 91, -30, 3, 3, 65, 18]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(3), lower=wrap_int(5), seq=wrap_list([wrap_int(91), wrap_int(1), wrap_int(2), wrap_int(64), wrap_int(18), wrap_int(91), -wrap_int(30), wrap_int(3), wrap_int(3), wrap_int(65), wrap_int(18)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 3))) (< i_0 11))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 3))) (> i_0 -11))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 3))) (>= (* 1 (ite (or (= i_0 10) (= i_0 -1)) 18 (ite (or (= i_0 9) (= i_0 -2)) 65 (ite (or (= i_0 8) (= i_0 -3)) 3 (ite (or (= i_0 7) (= i_0 -4)) 3 (ite (or (= i_0 6) (= i_0 -5)) -30 (ite (or (= i_0 5) (= i_0 -6)) 91 (ite (or (= i_0 4) (= i_0 -7)) 18 (ite (or (= i_0 3) (= i_0 -8)) 64 (ite (or (= i_0 2) (= i_0 -9)) 2 (ite (or (= i_0 1) (= i_0 -10)) 1 91))))))))))) 5))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3)
)
### output for cvc5
sat
(
(define-fun x () Int 3)
)

Found solution 3

Solving puzzle 477/774: MaxConsecutiveProduct:1
sat_func def sat(start: int, k=8, lower=774420991987500, seq=[-50, -99, -99, -65, -69, -87, 90, 45]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(8), lower=wrap_int(774420991987500), seq=wrap_list([-wrap_int(50), -wrap_int(99), -wrap_int(99), -wrap_int(65), -wrap_int(69), -wrap_int(87), wrap_int(90), wrap_int(45)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 8))) (< i_0 8))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 8))) (> i_0 -8))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 8))) (>= (* 1 (ite (or (= i_0 7) (= i_0 -1)) 45 (ite (or (= i_0 6) (= i_0 -2)) 90 (ite (or (= i_0 5) (= i_0 -3)) -87 (ite (or (= i_0 4) (= i_0 -4)) -69 (ite (or (= i_0 3) (= i_0 -5)) -65 (ite (or (= i_0 2) (= i_0 -6)) -99 (ite (or (= i_0 1) (= i_0 -7)) -99 -50)))))))) 774420991987500))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 7 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MaxConsecutiveProduct:1
One large constant for extrapolation
Solving simpler variation replaced 774420991987500 with 3
sat_func def sat(start: int, k=8, lower=3, seq=[-50, -99, -99, -65, -69, -87, 90, 45]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(8), lower=wrap_int(3), seq=wrap_list([-wrap_int(50), -wrap_int(99), -wrap_int(99), -wrap_int(65), -wrap_int(69), -wrap_int(87), wrap_int(90), wrap_int(45)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 8))) (< i_0 8))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 8))) (> i_0 -8))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 8))) (>= (* 1 (ite (or (= i_0 7) (= i_0 -1)) 45 (ite (or (= i_0 6) (= i_0 -2)) 90 (ite (or (= i_0 5) (= i_0 -3)) -87 (ite (or (= i_0 4) (= i_0 -4)) -69 (ite (or (= i_0 3) (= i_0 -5)) -65 (ite (or (= i_0 2) (= i_0 -6)) -99 (ite (or (= i_0 1) (= i_0 -7)) -99 -50)))))))) 3))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 7 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MaxConsecutiveProduct:1

Solving puzzle 478/774: MaxConsecutiveProduct:2
sat_func def sat(start: int, k=6, lower=188917681120, seq=[73, -32, 30, 92, 73, 8, 31, 40, -59, -97, -16, -83, -86, 78, -91, -18, -31, 31, 37, 79, 63, 38, 14, 68, -73, 91, 71, 87, 54, -7, -74, -63, -57, -46, -78, -22, 71, 52, 32, -82, 71, 76, -28, 83, -65, -65, 70, -35, 83, -40, 69, 78, -81, 0, -69, -1, 0, 61, 92, 55, -89, 60, 74, 99, -53, -22, 50, 28, -60, 6, 27, -53, -77, 99, 1, -69, -67, 81, -89, 45, 59, -28, 24, -21, -65, -56, -89, -30, 58, 78, 73, 9, 81, -39, -99, 43, 32, 58, -56, -83, 82, 97, 70]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(6), lower=wrap_int(188917681120), seq=wrap_list([wrap_int(73), -wrap_int(32), wrap_int(30), wrap_int(92), wrap_int(73), wrap_int(8), wrap_int(31), wrap_int(40), -wrap_int(59), -wrap_int(97), -wrap_int(16), -wrap_int(83), -wrap_int(86), wrap_int(78), -wrap_int(91), -wrap_int(18), -wrap_int(31), wrap_int(31), wrap_int(37), wrap_int(79), wrap_int(63), wrap_int(38), wrap_int(14), wrap_int(68), -wrap_int(73), wrap_int(91), wrap_int(71), wrap_int(87), wrap_int(54), -wrap_int(7), -wrap_int(74), -wrap_int(63), -wrap_int(57), -wrap_int(46), -wrap_int(78), -wrap_int(22), wrap_int(71), wrap_int(52), wrap_int(32), -wrap_int(82), wrap_int(71), wrap_int(76), -wrap_int(28), wrap_int(83), -wrap_int(65), -wrap_int(65), wrap_int(70), -wrap_int(35), wrap_int(83), -wrap_int(40), wrap_int(69), wrap_int(78), -wrap_int(81), wrap_int(0), -wrap_int(69), -wrap_int(1), wrap_int(0), wrap_int(61), wrap_int(92), wrap_int(55), -wrap_int(89), wrap_int(60), wrap_int(74), wrap_int(99), -wrap_int(53), -wrap_int(22), wrap_int(50), wrap_int(28), -wrap_int(60), wrap_int(6), wrap_int(27), -wrap_int(53), -wrap_int(77), wrap_int(99), wrap_int(1), -wrap_int(69), -wrap_int(67), wrap_int(81), -wrap_int(89), wrap_int(45), wrap_int(59), -wrap_int(28), wrap_int(24), -wrap_int(21), -wrap_int(65), -wrap_int(56), -wrap_int(89), -wrap_int(30), wrap_int(58), wrap_int(78), wrap_int(73), wrap_int(9), wrap_int(81), -wrap_int(39), -wrap_int(99), wrap_int(43), wrap_int(32), wrap_int(58), -wrap_int(56), -wrap_int(83), wrap_int(82), wrap_int(97), wrap_int(70)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 6))) (< i_0 103))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 6))) (> i_0 -103))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 6))) (>= (* 1 (ite (or (= i_0 102) (= i_0 -1)) 70 (ite (or (= i_0 101) (= i_0 -2)) 97 (ite (or (= i_0 100) (= i_0 -3)) 82 (ite (or (= i_0 99) (= i_0 -4)) -83 (ite (or (= i_0 98) (= i_0 -5)) -56 (ite (or (= i_0 97) (= i_0 -6)) 58 (ite (or (= i_0 96) (= i_0 -7)) 32 (ite (or (= i_0 95) (= i_0 -8)) 43 (ite (or (= i_0 94) (= i_0 -9)) -99 (ite (or (= i_0 93) (= i_0 -10)) -39 (ite (or (= i_0 92) (= i_0 -11)) 81 (ite (or (= i_0 91) (= i_0 -12)) 9 (ite (or (= i_0 90) (= i_0 -13)) 73 (ite (or (= i_0 89) (= i_0 -14)) 78 (ite (or (= i_0 88) (= i_0 -15)) 58 (ite (or (= i_0 87) (= i_0 -16)) -30 (ite (or (= i_0 86) (= i_0 -17)) -89 (ite (or (= i_0 85) (= i_0 -18)) -56 (ite (or (= i_0 84) (= i_0 -19)) -65 (ite (or (= i_0 83) (= i_0 -20)) -21 (ite (or (= i_0 82) (= i_0 -21)) 24 (ite (or (= i_0 81) (= i_0 -22)) -28 (ite (or (= i_0 80) (= i_0 -23)) 59 (ite (or (= i_0 79) (= i_0 -24)) 45 (ite (or (= i_0 78) (= i_0 -25)) -89 (ite (or (= i_0 77) (=...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 7 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MaxConsecutiveProduct:2
One large constant for extrapolation
Solving simpler variation replaced 188917681120 with 3
sat_func def sat(start: int, k=6, lower=3, seq=[73, -32, 30, 92, 73, 8, 31, 40, -59, -97, -16, -83, -86, 78, -91, -18, -31, 31, 37, 79, 63, 38, 14, 68, -73, 91, 71, 87, 54, -7, -74, -63, -57, -46, -78, -22, 71, 52, 32, -82, 71, 76, -28, 83, -65, -65, 70, -35, 83, -40, 69, 78, -81, 0, -69, -1, 0, 61, 92, 55, -89, 60, 74, 99, -53, -22, 50, 28, -60, 6, 27, -53, -77, 99, 1, -69, -67, 81, -89, 45, 59, -28, 24, -21, -65, -56, -89, -30, 58, 78, 73, 9, 81, -39, -99, 43, 32, 58, -56, -83, 82, 97, 70]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(6), lower=wrap_int(3), seq=wrap_list([wrap_int(73), -wrap_int(32), wrap_int(30), wrap_int(92), wrap_int(73), wrap_int(8), wrap_int(31), wrap_int(40), -wrap_int(59), -wrap_int(97), -wrap_int(16), -wrap_int(83), -wrap_int(86), wrap_int(78), -wrap_int(91), -wrap_int(18), -wrap_int(31), wrap_int(31), wrap_int(37), wrap_int(79), wrap_int(63), wrap_int(38), wrap_int(14), wrap_int(68), -wrap_int(73), wrap_int(91), wrap_int(71), wrap_int(87), wrap_int(54), -wrap_int(7), -wrap_int(74), -wrap_int(63), -wrap_int(57), -wrap_int(46), -wrap_int(78), -wrap_int(22), wrap_int(71), wrap_int(52), wrap_int(32), -wrap_int(82), wrap_int(71), wrap_int(76), -wrap_int(28), wrap_int(83), -wrap_int(65), -wrap_int(65), wrap_int(70), -wrap_int(35), wrap_int(83), -wrap_int(40), wrap_int(69), wrap_int(78), -wrap_int(81), wrap_int(0), -wrap_int(69), -wrap_int(1), wrap_int(0), wrap_int(61), wrap_int(92), wrap_int(55), -wrap_int(89), wrap_int(60), wrap_int(74), wrap_int(99), -wrap_int(53), -wrap_int(22), wrap_int(50), wrap_int(28), -wrap_int(60), wrap_int(6), wrap_int(27), -wrap_int(53), -wrap_int(77), wrap_int(99), wrap_int(1), -wrap_int(69), -wrap_int(67), wrap_int(81), -wrap_int(89), wrap_int(45), wrap_int(59), -wrap_int(28), wrap_int(24), -wrap_int(21), -wrap_int(65), -wrap_int(56), -wrap_int(89), -wrap_int(30), wrap_int(58), wrap_int(78), wrap_int(73), wrap_int(9), wrap_int(81), -wrap_int(39), -wrap_int(99), wrap_int(43), wrap_int(32), wrap_int(58), -wrap_int(56), -wrap_int(83), wrap_int(82), wrap_int(97), wrap_int(70)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 6))) (< i_0 103))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 6))) (> i_0 -103))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 6))) (>= (* 1 (ite (or (= i_0 102) (= i_0 -1)) 70 (ite (or (= i_0 101) (= i_0 -2)) 97 (ite (or (= i_0 100) (= i_0 -3)) 82 (ite (or (= i_0 99) (= i_0 -4)) -83 (ite (or (= i_0 98) (= i_0 -5)) -56 (ite (or (= i_0 97) (= i_0 -6)) 58 (ite (or (= i_0 96) (= i_0 -7)) 32 (ite (or (= i_0 95) (= i_0 -8)) 43 (ite (or (= i_0 94) (= i_0 -9)) -99 (ite (or (= i_0 93) (= i_0 -10)) -39 (ite (or (= i_0 92) (= i_0 -11)) 81 (ite (or (= i_0 91) (= i_0 -12)) 9 (ite (or (= i_0 90) (= i_0 -13)) 73 (ite (or (= i_0 89) (= i_0 -14)) 78 (ite (or (= i_0 88) (= i_0 -15)) 58 (ite (or (= i_0 87) (= i_0 -16)) -30 (ite (or (= i_0 86) (= i_0 -17)) -89 (ite (or (= i_0 85) (= i_0 -18)) -56 (ite (or (= i_0 84) (= i_0 -19)) -65 (ite (or (= i_0 83) (= i_0 -20)) -21 (ite (or (= i_0 82) (= i_0 -21)) 24 (ite (or (= i_0 81) (= i_0 -22)) -28 (ite (or (= i_0 80) (= i_0 -23)) 59 (ite (or (= i_0 79) (= i_0 -24)) 45 (ite (or (= i_0 78) (= i_0 -25)) -89 (ite (or (= i_0 77) (=...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    18)
)
### output for cvc5
sat
(
(define-fun x () Int 18)
)

Found solution 18

Solving puzzle 479/774: MaxConsecutiveProduct:3
sat_func def sat(start: int, k=2, lower=5589, seq=[8, -66, 75, 74, 40, 14, -81, -69, 99, 27, -18]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(2), lower=wrap_int(5589), seq=wrap_list([wrap_int(8), -wrap_int(66), wrap_int(75), wrap_int(74), wrap_int(40), wrap_int(14), -wrap_int(81), -wrap_int(69), wrap_int(99), wrap_int(27), -wrap_int(18)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 2))) (< i_0 11))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 2))) (> i_0 -11))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 2))) (>= (* 1 (ite (or (= i_0 10) (= i_0 -1)) -18 (ite (or (= i_0 9) (= i_0 -2)) 27 (ite (or (= i_0 8) (= i_0 -3)) 99 (ite (or (= i_0 7) (= i_0 -4)) -69 (ite (or (= i_0 6) (= i_0 -5)) -81 (ite (or (= i_0 5) (= i_0 -6)) 14 (ite (or (= i_0 4) (= i_0 -7)) 40 (ite (or (= i_0 3) (= i_0 -8)) 74 (ite (or (= i_0 2) (= i_0 -9)) 75 (ite (or (= i_0 1) (= i_0 -10)) -66 8))))))))))) 5589))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 7 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle MaxConsecutiveProduct:3
One large constant for extrapolation
Solving simpler variation replaced 5589 with 3
sat_func def sat(start: int, k=2, lower=3, seq=[8, -66, 75, 74, 40, 14, -81, -69, 99, 27, -18]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(2), lower=wrap_int(3), seq=wrap_list([wrap_int(8), -wrap_int(66), wrap_int(75), wrap_int(74), wrap_int(40), wrap_int(14), -wrap_int(81), -wrap_int(69), wrap_int(99), wrap_int(27), -wrap_int(18)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 2))) (< i_0 11))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 2))) (> i_0 -11))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 2))) (>= (* 1 (ite (or (= i_0 10) (= i_0 -1)) -18 (ite (or (= i_0 9) (= i_0 -2)) 27 (ite (or (= i_0 8) (= i_0 -3)) 99 (ite (or (= i_0 7) (= i_0 -4)) -69 (ite (or (= i_0 6) (= i_0 -5)) -81 (ite (or (= i_0 5) (= i_0 -6)) 14 (ite (or (= i_0 4) (= i_0 -7)) 40 (ite (or (= i_0 3) (= i_0 -8)) 74 (ite (or (= i_0 2) (= i_0 -9)) 75 (ite (or (= i_0 1) (= i_0 -10)) -66 8))))))))))) 3))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8)
)
### output for cvc5
sat
(
(define-fun x () Int 8)
)

Found solution 8

Solving puzzle 480/774: MaxConsecutiveProduct:4
sat_func def sat(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):
    prod = 1
    for i in range(start, start + k):
        prod *= seq[i]
    return prod >= lower
modified_func def sat(start: int, k=wrap_int(10), lower=-wrap_int(8326797433194240), seq=wrap_list([wrap_int(49), -wrap_int(99), wrap_int(80), wrap_int(26), wrap_int(54), wrap_int(13), wrap_int(37), wrap_int(13), -wrap_int(52), -wrap_int(47)])):
    prod = wrap_int(1)
    for i in sym_range(start, start + k):
        prod *= seq[i]
    return prod >= lower
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 10))) (< i_0 10))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 10))) (> i_0 -10))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 x) (< i_0 (+ x 10))) (>= (* 1 (ite (or (= i_0 9) (= i_0 -1)) -47 (ite (or (= i_0 8) (= i_0 -2)) -52 (ite (or (= i_0 7) (= i_0 -3)) 13 (ite (or (= i_0 6) (= i_0 -4)) 37 (ite (or (= i_0 5) (= i_0 -5)) 13 (ite (or (= i_0 4) (= i_0 -6)) 54 (ite (or (= i_0 3) (= i_0 -7)) 26 (ite (or (= i_0 2) (= i_0 -8)) 80 (ite (or (= i_0 1) (= i_0 -9)) -99 49)))))))))) -8326797433194240))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  MaxConsecutiveProduct:4

Solving puzzle 481/774: QuadraticRoot:0
sat_func def sat(x: float, coeffs=[2.5, 1.3, -0.5]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([2.5, 1.3, -0.5])):
    a, b, c = coeffs
    return abs(a * x ** wrap_int(2) + b * x + c) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (* (^ x 2) 2.5) (* x 1.3)) -0.5) 0) (+ (+ (* (^ x 2) 2.5) (* x 1.3)) -0.5) (- (+ (+ (* (^ x 2) 2.5) (* x 1.3)) -0.5))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 146: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.36: expecting same arithmetic types to POW")

Could not find any solution for puzzle QuadraticRoot:0
Too many constants for extrapolation

Solving puzzle 482/774: QuadraticRoot:1
sat_func def sat(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([0.0685642998539026, -0.10446230957339113, -0.11141402891228723])):
    a, b, c = coeffs
    return abs(a * x ** wrap_int(2) + b * x + c) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (* (^ x 2) 0.0685642998539026) (* x -0.10446230957339113)) -0.11141402891228723) 0) (+ (+ (* (^ x 2) 0.0685642998539026) (* x -0.10446230957339113)) -0.11141402891228723) (- (+ (+ (* (^ x 2) 0.0685642998539026) (* x -0.10446230957339113)) -0.11141402891228723))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 290: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.36: expecting same arithmetic types to POW")

Could not find any solution for puzzle QuadraticRoot:1
Too many constants for extrapolation

Solving puzzle 483/774: QuadraticRoot:2
sat_func def sat(x: float, coeffs=[0.2622487694588566, 0.48521166316030495, -41.749384651642444]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([0.2622487694588566, 0.48521166316030495, -41.749384651642444])):
    a, b, c = coeffs
    return abs(a * x ** wrap_int(2) + b * x + c) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (* (^ x 2) 0.2622487694588566) (* x 0.48521166316030495)) -41.749384651642444) 0) (+ (+ (* (^ x 2) 0.2622487694588566) (* x 0.48521166316030495)) -41.749384651642444) (- (+ (+ (* (^ x 2) 0.2622487694588566) (* x 0.48521166316030495)) -41.749384651642444))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 284: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.36: expecting same arithmetic types to POW")

Could not find any solution for puzzle QuadraticRoot:2
Too many constants for extrapolation

Solving puzzle 484/774: QuadraticRoot:3
sat_func def sat(x: float, coeffs=[145.72190605632582, 0.027358325157428014, -5.149342624051854]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([145.72190605632582, 0.027358325157428014, -5.149342624051854])):
    a, b, c = coeffs
    return abs(a * x ** wrap_int(2) + b * x + c) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (* (^ x 2) 145.72190605632582) (* x 0.027358325157428014)) -5.149342624051854) 0) (+ (+ (* (^ x 2) 145.72190605632582) (* x 0.027358325157428014)) -5.149342624051854) (- (+ (+ (* (^ x 2) 145.72190605632582) (* x 0.027358325157428014)) -5.149342624051854))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 284: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.36: expecting same arithmetic types to POW")

Could not find any solution for puzzle QuadraticRoot:3
Too many constants for extrapolation

Solving puzzle 485/774: QuadraticRoot:4
sat_func def sat(x: float, coeffs=[1.1222556871110754, -0.007015312913509468, -309237.6867547677]):
    a, b, c = coeffs
    return abs(a * x ** 2 + b * x + c) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([1.1222556871110754, -0.007015312913509468, -309237.6867547677])):
    a, b, c = coeffs
    return abs(a * x ** wrap_int(2) + b * x + c) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (* (^ x 2) 1.1222556871110754) (* x -0.007015312913509468)) -309237.6867547677) 0) (+ (+ (* (^ x 2) 1.1222556871110754) (* x -0.007015312913509468)) -309237.6867547677) (- (+ (+ (* (^ x 2) 1.1222556871110754) (* x -0.007015312913509468)) -309237.6867547677))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 287: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.36: expecting same arithmetic types to POW")

Could not find any solution for puzzle QuadraticRoot:4
Too many constants for extrapolation

Solving puzzle 486/774: CubicRoot:0
sat_func def sat(x: float, coeffs=[2.0, 1.0, 0.0, 8.0]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([2.0, 1.0, 0.0, 8.0])):
    return abs(sym_sum(sym_generator((c * x ** (wrap_int(3) - i) for i, c in enumerate(coeffs))))) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (+ (+ (* (^ x 3) 2.0) 0) (* (^ x 2) 1.0)) (* (^ x 1) 0.0)) (* (^ x 0) 8.0)) 0) (+ (+ (+ (+ (* (^ x 3) 2.0) 0) (* (^ x 2) 1.0)) (* (^ x 1) 0.0)) (* (^ x 0) 8.0)) (- (+ (+ (+ (+ (* (^ x 3) 2.0) 0) (* (^ x 2) 1.0)) (* (^ x 1) 0.0)) (* (^ x 0) 8.0)))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 275: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle CubicRoot:0
Too many constants for extrapolation

Solving puzzle 487/774: CubicRoot:1
sat_func def sat(x: float, coeffs=[0.009597657937719273, -10.297175825569942, 0.15891220226280925, 10.530249049250433]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([0.009597657937719273, -10.297175825569942, 0.15891220226280925, 10.530249049250433])):
    return abs(sym_sum(sym_generator((c * x ** (wrap_int(3) - i) for i, c in enumerate(coeffs))))) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (+ (+ (* (^ x 3) 0.009597657937719273) 0) (* (^ x 2) -10.297175825569942)) (* (^ x 1) 0.15891220226280925)) (* (^ x 0) 10.530249049250433)) 0) (+ (+ (+ (+ (* (^ x 3) 0.009597657937719273) 0) (* (^ x 2) -10.297175825569942)) (* (^ x 1) 0.15891220226280925)) (* (^ x 0) 10.530249049250433)) (- (+ (+ (+ (+ (* (^ x 3) 0.009597657937719273) 0) (* (^ x 2) -10.297175825569942)) (* (^ x 1) 0.15891220226280925)) (* (^ x 0) 10.530249049250433)))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 467: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle CubicRoot:1
Too many constants for extrapolation

Solving puzzle 488/774: CubicRoot:2
sat_func def sat(x: float, coeffs=[-0.17749172356645268, -1.3894267878542186, 0.03752944532850555, 0.2624916128068381]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([-0.17749172356645268, -1.3894267878542186, 0.03752944532850555, 0.2624916128068381])):
    return abs(sym_sum(sym_generator((c * x ** (wrap_int(3) - i) for i, c in enumerate(coeffs))))) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (+ (+ (* (^ x 3) -0.17749172356645268) 0) (* (^ x 2) -1.3894267878542186)) (* (^ x 1) 0.03752944532850555)) (* (^ x 0) 0.2624916128068381)) 0) (+ (+ (+ (+ (* (^ x 3) -0.17749172356645268) 0) (* (^ x 2) -1.3894267878542186)) (* (^ x 1) 0.03752944532850555)) (* (^ x 0) 0.2624916128068381)) (- (+ (+ (+ (+ (* (^ x 3) -0.17749172356645268) 0) (* (^ x 2) -1.3894267878542186)) (* (^ x 1) 0.03752944532850555)) (* (^ x 0) 0.2624916128068381)))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 467: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle CubicRoot:2
Too many constants for extrapolation

Solving puzzle 489/774: CubicRoot:3
sat_func def sat(x: float, coeffs=[0.41725114111706524, 155.2589446092116, -0.10619077904258341, -0.024129284994425074]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([0.41725114111706524, 155.2589446092116, -0.10619077904258341, -0.024129284994425074])):
    return abs(sym_sum(sym_generator((c * x ** (wrap_int(3) - i) for i, c in enumerate(coeffs))))) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (+ (+ (* (^ x 3) 0.41725114111706524) 0) (* (^ x 2) 155.2589446092116)) (* (^ x 1) -0.10619077904258341)) (* (^ x 0) -0.024129284994425074)) 0) (+ (+ (+ (+ (* (^ x 3) 0.41725114111706524) 0) (* (^ x 2) 155.2589446092116)) (* (^ x 1) -0.10619077904258341)) (* (^ x 0) -0.024129284994425074)) (- (+ (+ (+ (+ (* (^ x 3) 0.41725114111706524) 0) (* (^ x 2) 155.2589446092116)) (* (^ x 1) -0.10619077904258341)) (* (^ x 0) -0.024129284994425074)))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 470: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle CubicRoot:3
Too many constants for extrapolation

Solving puzzle 490/774: CubicRoot:4
sat_func def sat(x: float, coeffs=[-2.3153234528266906, 11.247619504308075, -72.3705721705674, 53.97429005428236]):
    return abs(sum(c * x ** (3 - i) for i, c in enumerate(coeffs))) < 1e-6
modified_func def sat(x: float, coeffs=wrap_list([-2.3153234528266906, 11.247619504308075, -72.3705721705674, 53.97429005428236])):
    return abs(sym_sum(sym_generator((c * x ** (wrap_int(3) - i) for i, c in enumerate(coeffs))))) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (+ (+ (+ (+ (* (^ x 3) -2.3153234528266906) 0) (* (^ x 2) 11.247619504308075)) (* (^ x 1) -72.3705721705674)) (* (^ x 0) 53.97429005428236)) 0) (+ (+ (+ (+ (* (^ x 3) -2.3153234528266906) 0) (* (^ x 2) 11.247619504308075)) (* (^ x 1) -72.3705721705674)) (* (^ x 0) 53.97429005428236)) (- (+ (+ (+ (+ (* (^ x 3) -2.3153234528266906) 0) (* (^ x 2) 11.247619504308075)) (* (^ x 1) -72.3705721705674)) (* (^ x 0) 53.97429005428236)))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 452: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.42: expecting same arithmetic types to POW")

Could not find any solution for puzzle CubicRoot:4
Too many constants for extrapolation

Solving puzzle 491/774: SumOfDigits:0
sat_func def sat(x: str, s=679):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(679)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_120 Int)) (=> (and (>= str_pos_120 0) (< str_pos_120 (str.len x))) (> (str.len (python.str.at x str_pos_120)) 0))))
(assert (forall ((str_pos_120 Int)) (=> (and (>= str_pos_120 0) (< str_pos_120 (str.len x))) (= 679 (+ (python.int (python.str.at x str_pos_120) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:0
One large constant for extrapolation
Solving simpler variation replaced 679 with 3
sat_func def sat(x: str, s=3):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(3)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_121 Int)) (=> (and (>= str_pos_121 0) (< str_pos_121 (str.len x))) (> (str.len (python.str.at x str_pos_121)) 0))))
(assert (forall ((str_pos_121 Int)) (=> (and (>= str_pos_121 0) (< str_pos_121 (str.len x))) (= 3 (+ (python.int (python.str.at x str_pos_121) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:0

Solving puzzle 492/774: SumOfDigits:1
sat_func def sat(x: str, s=40427):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(40427)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_122 Int)) (=> (and (>= str_pos_122 0) (< str_pos_122 (str.len x))) (> (str.len (python.str.at x str_pos_122)) 0))))
(assert (forall ((str_pos_122 Int)) (=> (and (>= str_pos_122 0) (< str_pos_122 (str.len x))) (= 40427 (+ (python.int (python.str.at x str_pos_122) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:1
One large constant for extrapolation
Solving simpler variation replaced 40427 with 3
sat_func def sat(x: str, s=3):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(3)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_123 Int)) (=> (and (>= str_pos_123 0) (< str_pos_123 (str.len x))) (> (str.len (python.str.at x str_pos_123)) 0))))
(assert (forall ((str_pos_123 Int)) (=> (and (>= str_pos_123 0) (< str_pos_123 (str.len x))) (= 3 (+ (python.int (python.str.at x str_pos_123) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:1

Solving puzzle 493/774: SumOfDigits:2
sat_func def sat(x: str, s=8071):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(8071)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_124 Int)) (=> (and (>= str_pos_124 0) (< str_pos_124 (str.len x))) (> (str.len (python.str.at x str_pos_124)) 0))))
(assert (forall ((str_pos_124 Int)) (=> (and (>= str_pos_124 0) (< str_pos_124 (str.len x))) (= 8071 (+ (python.int (python.str.at x str_pos_124) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:2
One large constant for extrapolation
Solving simpler variation replaced 8071 with 3
sat_func def sat(x: str, s=3):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(3)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_125 Int)) (=> (and (>= str_pos_125 0) (< str_pos_125 (str.len x))) (> (str.len (python.str.at x str_pos_125)) 0))))
(assert (forall ((str_pos_125 Int)) (=> (and (>= str_pos_125 0) (< str_pos_125 (str.len x))) (= 3 (+ (python.int (python.str.at x str_pos_125) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:2

Solving puzzle 494/774: SumOfDigits:3
sat_func def sat(x: str, s=86120):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(86120)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_126 Int)) (=> (and (>= str_pos_126 0) (< str_pos_126 (str.len x))) (> (str.len (python.str.at x str_pos_126)) 0))))
(assert (forall ((str_pos_126 Int)) (=> (and (>= str_pos_126 0) (< str_pos_126 (str.len x))) (= 86120 (+ (python.int (python.str.at x str_pos_126) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:3
One large constant for extrapolation
Solving simpler variation replaced 86120 with 3
sat_func def sat(x: str, s=3):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(3)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_127 Int)) (=> (and (>= str_pos_127 0) (< str_pos_127 (str.len x))) (> (str.len (python.str.at x str_pos_127)) 0))))
(assert (forall ((str_pos_127 Int)) (=> (and (>= str_pos_127 0) (< str_pos_127 (str.len x))) (= 3 (+ (python.int (python.str.at x str_pos_127) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:3

Solving puzzle 495/774: SumOfDigits:4
sat_func def sat(x: str, s=26785):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(26785)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_128 Int)) (=> (and (>= str_pos_128 0) (< str_pos_128 (str.len x))) (> (str.len (python.str.at x str_pos_128)) 0))))
(assert (forall ((str_pos_128 Int)) (=> (and (>= str_pos_128 0) (< str_pos_128 (str.len x))) (= 26785 (+ (python.int (python.str.at x str_pos_128) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:4
One large constant for extrapolation
Solving simpler variation replaced 26785 with 3
sat_func def sat(x: str, s=3):
    return s == sum([int(d) for d in x])
modified_func def sat(x: str, s=wrap_int(3)):
    return s == sym_sum([sym_int(d) for d in x])
### smt2
(set-logic ALL)

(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (forall ((str_pos_129 Int)) (=> (and (>= str_pos_129 0) (< str_pos_129 (str.len x))) (> (str.len (python.str.at x str_pos_129)) 0))))
(assert (forall ((str_pos_129 Int)) (=> (and (>= str_pos_129 0) (< str_pos_129 (str.len x))) (= 3 (+ (python.int (python.str.at x str_pos_129) 10) 0)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
unknown
(
(define-fun x () String "")
)

Found solution 
WARNING: Solution verification failed for puzzle SumOfDigits:4

Solving puzzle 496/774: FloatWithDecimalValue:0
sat_func def sat(z: float, v=9, d=0.0001):
    return int(z * 1 / d % 10) == v
modified_func def sat(z: float, v=wrap_int(9), d=0.0001):
    return sym_int(z * wrap_int(1) / d % wrap_int(10)) == v
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (= (mod (/ (* x 1) 0.0001) 10) 9))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 19.0 10000.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.38: Expecting a integer term as the first argument in 'mod'")

Found solution 0.0019
Yes! Solved for puzzle  FloatWithDecimalValue:0

Solving puzzle 497/774: FloatWithDecimalValue:1
sat_func def sat(z: float, v=1, d=1e-17):
    return int(z * 1 / d % 10) == v
modified_func def sat(z: float, v=wrap_int(1), d=1e-17):
    return sym_int(z * wrap_int(1) / d % wrap_int(10)) == v
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (= (mod (/ (* x 1) 1e-17) 10) 1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 28: unknown constant e-17")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.29: Symbol 'e-17' not declared as a variable")

Could not find any solution for puzzle FloatWithDecimalValue:1
Too many constants for extrapolation

Solving puzzle 498/774: FloatWithDecimalValue:2
sat_func def sat(z: float, v=9, d=1e+83):
    return int(z * 1 / d % 10) == v
modified_func def sat(z: float, v=wrap_int(9), d=1e+83):
    return sym_int(z * wrap_int(1) / d % wrap_int(10)) == v
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (= (mod (/ (* x 1) 1e+83) 10) 9))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 28: unknown constant e+83")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.29: Symbol 'e+83' not declared as a variable")

Could not find any solution for puzzle FloatWithDecimalValue:2
Too many constants for extrapolation

Solving puzzle 499/774: FloatWithDecimalValue:3
sat_func def sat(z: float, v=5, d=1e-18):
    return int(z * 1 / d % 10) == v
modified_func def sat(z: float, v=wrap_int(5), d=1e-18):
    return sym_int(z * wrap_int(1) / d % wrap_int(10)) == v
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (= (mod (/ (* x 1) 1e-18) 10) 5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 28: unknown constant e-18")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.29: Symbol 'e-18' not declared as a variable")

Could not find any solution for puzzle FloatWithDecimalValue:3
Too many constants for extrapolation

Solving puzzle 500/774: FloatWithDecimalValue:4
sat_func def sat(z: float, v=5, d=1e+90):
    return int(z * 1 / d % 10) == v
modified_func def sat(z: float, v=wrap_int(5), d=1e+90):
    return sym_int(z * wrap_int(1) / d % wrap_int(10)) == v
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (= (mod (/ (* x 1) 1e+90) 10) 5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 28: unknown constant e+90")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.29: Symbol 'e+90' not declared as a variable")

Could not find any solution for puzzle FloatWithDecimalValue:4
Too many constants for extrapolation

Solving puzzle 501/774: IfProblem:0
sat_func def sat(x: int, a=324554, b=1345345):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
modified_func def sat(x: int, a=wrap_int(324554), b=wrap_int(1345345)):
    if a < wrap_int(50):
        return x + a == b
    else:
        return x - wrap_int(2) * a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x 649108) 1345345))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1994453)
)
### output for cvc5
sat
(
(define-fun x () Int 1994453)
)

Found solution 1994453
Yes! Solved for puzzle  IfProblem:0

Solving puzzle 502/774: IfProblem:1
sat_func def sat(x: int, a=51, b=40553793):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
modified_func def sat(x: int, a=wrap_int(51), b=wrap_int(40553793)):
    if a < wrap_int(50):
        return x + a == b
    else:
        return x - wrap_int(2) * a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x 102) 40553793))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    40553895)
)
### output for cvc5
sat
(
(define-fun x () Int 40553895)
)

Found solution 40553895
Yes! Solved for puzzle  IfProblem:1

Solving puzzle 503/774: IfProblem:2
sat_func def sat(x: int, a=50, b=72369383):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
modified_func def sat(x: int, a=wrap_int(50), b=wrap_int(72369383)):
    if a < wrap_int(50):
        return x + a == b
    else:
        return x - wrap_int(2) * a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x 100) 72369383))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    72369483)
)
### output for cvc5
sat
(
(define-fun x () Int 72369483)
)

Found solution 72369483
Yes! Solved for puzzle  IfProblem:2

Solving puzzle 504/774: IfProblem:3
sat_func def sat(x: int, a=90, b=42412534):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
modified_func def sat(x: int, a=wrap_int(90), b=wrap_int(42412534)):
    if a < wrap_int(50):
        return x + a == b
    else:
        return x - wrap_int(2) * a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x 180) 42412534))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    42412714)
)
### output for cvc5
sat
(
(define-fun x () Int 42412714)
)

Found solution 42412714
Yes! Solved for puzzle  IfProblem:3

Solving puzzle 505/774: IfProblem:4
sat_func def sat(x: int, a=62, b=-26538057):
    if a < 50:
        return x + a == b
    else:
        return x - 2 * a == b
modified_func def sat(x: int, a=wrap_int(62), b=-wrap_int(26538057)):
    if a < wrap_int(50):
        return x + a == b
    else:
        return x - wrap_int(2) * a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x 124) -26538057))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 26537933))
)
### output for cvc5
sat
(
(define-fun x () Int (- 26537933))
)

Found solution -26537933
Yes! Solved for puzzle  IfProblem:4

Solving puzzle 506/774: IfProblemWithAnd:0
sat_func def sat(x: int, a=9384594, b=1343663):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(9384594), b=wrap_int(1343663)):
    if (x > wrap_int(0)).__and__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (and (> x 0) true) (= (- x 9384594) 1343663)))
(assert (=> (not (and (> x 0) true)) (= (+ x 9384594) 1343663)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 8040931))
)
### output for cvc5
sat
(
(define-fun x () Int (- 8040931))
)

Found solution -8040931
Yes! Solved for puzzle  IfProblemWithAnd:0

Solving puzzle 507/774: IfProblemWithAnd:1
sat_func def sat(x: int, a=57, b=40522966):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(57), b=wrap_int(40522966)):
    if (x > wrap_int(0)).__and__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (and (> x 0) true) (= (- x 57) 40522966)))
(assert (=> (not (and (> x 0) true)) (= (+ x 57) 40522966)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    40523023)
)
### output for cvc5
sat
(
(define-fun x () Int 40523023)
)

Found solution 40523023
Yes! Solved for puzzle  IfProblemWithAnd:1

Solving puzzle 508/774: IfProblemWithAnd:2
sat_func def sat(x: int, a=29, b=71683001):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(29), b=wrap_int(71683001)):
    if (x > wrap_int(0)).__and__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (and (> x 0) false) (= (- x 29) 71683001)))
(assert (=> (not (and (> x 0) false)) (= (+ x 29) 71683001)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    71682972)
)
### output for cvc5
sat
(
(define-fun x () Int 71682972)
)

Found solution 71682972
Yes! Solved for puzzle  IfProblemWithAnd:2

Solving puzzle 509/774: IfProblemWithAnd:3
sat_func def sat(x: int, a=92, b=8820402):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(92), b=wrap_int(8820402)):
    if (x > wrap_int(0)).__and__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (and (> x 0) true) (= (- x 92) 8820402)))
(assert (=> (not (and (> x 0) true)) (= (+ x 92) 8820402)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8820494)
)
### output for cvc5
sat
(
(define-fun x () Int 8820494)
)

Found solution 8820494
Yes! Solved for puzzle  IfProblemWithAnd:3

Solving puzzle 510/774: IfProblemWithAnd:4
sat_func def sat(x: int, a=64, b=46712723):
    if x > 0 and a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(64), b=wrap_int(46712723)):
    if (x > wrap_int(0)).__and__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (and (> x 0) true) (= (- x 64) 46712723)))
(assert (=> (not (and (> x 0) true)) (= (+ x 64) 46712723)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    46712787)
)
### output for cvc5
sat
(
(define-fun x () Int 46712787)
)

Found solution 46712787
Yes! Solved for puzzle  IfProblemWithAnd:4

Solving puzzle 511/774: IfProblemWithOr:0
sat_func def sat(x: int, a=253532, b=1230200):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(253532), b=wrap_int(1230200)):
    if (x > wrap_int(0)).__or__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (or (> x 0) true) (= (- x 253532) 1230200)))
(assert (=> (not (or (> x 0) true)) (= (+ x 253532) 1230200)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1483732)
)
### output for cvc5
sat
(
(define-fun x () Int 1483732)
)

Found solution 1483732
Yes! Solved for puzzle  IfProblemWithOr:0

Solving puzzle 512/774: IfProblemWithOr:1
sat_func def sat(x: int, a=22, b=-84904666):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(22), b=-wrap_int(84904666)):
    if (x > wrap_int(0)).__or__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (or (> x 0) false) (= (- x 22) -84904666)))
(assert (=> (not (or (> x 0) false)) (= (+ x 22) -84904666)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 84904688))
)
### output for cvc5
sat
(
(define-fun x () Int (- 84904688))
)

Found solution -84904688
Yes! Solved for puzzle  IfProblemWithOr:1

Solving puzzle 513/774: IfProblemWithOr:2
sat_func def sat(x: int, a=10, b=74723522):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(10), b=wrap_int(74723522)):
    if (x > wrap_int(0)).__or__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (or (> x 0) false) (= (- x 10) 74723522)))
(assert (=> (not (or (> x 0) false)) (= (+ x 10) 74723522)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    74723532)
)
### output for cvc5
sat
(
(define-fun x () Int 74723532)
)

Found solution 74723532
Yes! Solved for puzzle  IfProblemWithOr:2

Solving puzzle 514/774: IfProblemWithOr:3
sat_func def sat(x: int, a=66, b=-39109407):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(66), b=-wrap_int(39109407)):
    if (x > wrap_int(0)).__or__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (or (> x 0) true) (= (- x 66) -39109407)))
(assert (=> (not (or (> x 0) true)) (= (+ x 66) -39109407)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 39109341))
)
### output for cvc5
sat
(
(define-fun x () Int (- 39109341))
)

Found solution -39109341
Yes! Solved for puzzle  IfProblemWithOr:3

Solving puzzle 515/774: IfProblemWithOr:4
sat_func def sat(x: int, a=24, b=18773099):
    if x > 0 or a > 50:
        return x - a == b
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(24), b=wrap_int(18773099)):
    if (x > wrap_int(0)).__or__(a > wrap_int(50)):
        return x - a == b
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (or (> x 0) false) (= (- x 24) 18773099)))
(assert (=> (not (or (> x 0) false)) (= (+ x 24) 18773099)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    18773123)
)
### output for cvc5
sat
(
(define-fun x () Int 18773123)
)

Found solution 18773123
Yes! Solved for puzzle  IfProblemWithOr:4

Solving puzzle 516/774: IfCases:0
sat_func def sat(x: int, a=4, b=54368639):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(4), b=wrap_int(54368639)):
    if a == wrap_int(1):
        return x % wrap_int(2) == wrap_int(0)
    elif a == -wrap_int(1):
        return x % wrap_int(2) == wrap_int(1)
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x 4) 54368639))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    54368635)
)
### output for cvc5
sat
(
(define-fun x () Int 54368635)
)

Found solution 54368635
Yes! Solved for puzzle  IfCases:0

Solving puzzle 517/774: IfCases:1
sat_func def sat(x: int, a=-4, b=-83354930):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
modified_func def sat(x: int, a=-wrap_int(4), b=-wrap_int(83354930)):
    if a == wrap_int(1):
        return x % wrap_int(2) == wrap_int(0)
    elif a == -wrap_int(1):
        return x % wrap_int(2) == wrap_int(1)
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x -4) -83354930))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 83354926))
)
### output for cvc5
sat
(
(define-fun x () Int (- 83354926))
)

Found solution -83354926
Yes! Solved for puzzle  IfCases:1

Solving puzzle 518/774: IfCases:2
sat_func def sat(x: int, a=-3, b=71965664):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
modified_func def sat(x: int, a=-wrap_int(3), b=wrap_int(71965664)):
    if a == wrap_int(1):
        return x % wrap_int(2) == wrap_int(0)
    elif a == -wrap_int(1):
        return x % wrap_int(2) == wrap_int(1)
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x -3) 71965664))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    71965667)
)
### output for cvc5
sat
(
(define-fun x () Int 71965667)
)

Found solution 71965667
Yes! Solved for puzzle  IfCases:2

Solving puzzle 519/774: IfCases:3
sat_func def sat(x: int, a=2, b=36068130):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
modified_func def sat(x: int, a=wrap_int(2), b=wrap_int(36068130)):
    if a == wrap_int(1):
        return x % wrap_int(2) == wrap_int(0)
    elif a == -wrap_int(1):
        return x % wrap_int(2) == wrap_int(1)
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x 2) 36068130))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    36068128)
)
### output for cvc5
sat
(
(define-fun x () Int 36068128)
)

Found solution 36068128
Yes! Solved for puzzle  IfCases:3

Solving puzzle 520/774: IfCases:4
sat_func def sat(x: int, a=-3, b=14385903):
    if a == 1:
        return x % 2 == 0
    elif a == -1:
        return x % 2 == 1
    else:
        return x + a == b
modified_func def sat(x: int, a=-wrap_int(3), b=wrap_int(14385903)):
    if a == wrap_int(1):
        return x % wrap_int(2) == wrap_int(0)
    elif a == -wrap_int(1):
        return x % wrap_int(2) == wrap_int(1)
    else:
        return x + a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ x -3) 14385903))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    14385906)
)
### output for cvc5
sat
(
(define-fun x () Int 14385906)
)

Found solution 14385906
Yes! Solved for puzzle  IfCases:4

Solving puzzle 521/774: ConcatStrings:0
sat_func def sat(x: str, s=['a', 'b', 'c', 'd', 'e', 'f'], n=4):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
modified_func def sat(x: str, s=wrap_list([wrap_str('a'), wrap_str('b'), wrap_str('c'), wrap_str('d'), wrap_str('e'), wrap_str('f')]), n=wrap_int(4)):
    return (sym_len(x) == n).__and__(all([x[i] == s[i] for i in sym_range(n)]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (and (= (str.len x) 4) (and (and (and (= (python.str.at x 0) "a") (= (python.str.at x 1) "b")) (= (python.str.at x 2) "c")) (= (python.str.at x 3) "d"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "abcd")
)
### output for cvc5
sat
(
(define-fun x () String "abcd")
)

Found solution abcd
Yes! Solved for puzzle  ConcatStrings:0

Solving puzzle 522/774: ConcatStrings:1
sat_func def sat(x: str, s=['I', '&', 'W', '&', 'p', 'c', '-', 'U', '(', ' ', 'A', '(', 'S', 'W', 'R', '#', 'm', 'v', '@', '8', '%', 'a', '.', 'K', 'O', '[', '[', '#', 'q', 'k', 'K'], n=16):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
modified_func def sat(x: str, s=wrap_list([wrap_str('I'), wrap_str('&'), wrap_str('W'), wrap_str('&'), wrap_str('p'), wrap_str('c'), wrap_str('-'), wrap_str('U'), wrap_str('('), wrap_str(' '), wrap_str('A'), wrap_str('('), wrap_str('S'), wrap_str('W'), wrap_str('R'), wrap_str('#'), wrap_str('m'), wrap_str('v'), wrap_str('@'), wrap_str('8'), wrap_str('%'), wrap_str('a'), wrap_str('.'), wrap_str('K'), wrap_str('O'), wrap_str('['), wrap_str('['), wrap_str('#'), wrap_str('q'), wrap_str('k'), wrap_str('K')]), n=wrap_int(16)):
    return (sym_len(x) == n).__and__(all([x[i] == s[i] for i in sym_range(n)]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (and (= (str.len x) 16) (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (python.str.at x 0) "I") (= (python.str.at x 1) "&")) (= (python.str.at x 2) "W")) (= (python.str.at x 3) "&")) (= (python.str.at x 4) "p")) (= (python.str.at x 5) "c")) (= (python.str.at x 6) "-")) (= (python.str.at x 7) "U")) (= (python.str.at x 8) "(")) (= (python.str.at x 9) " ")) (= (python.str.at x 10) "A")) (= (python.str.at x 11) "(")) (= (python.str.at x 12) "S")) (= (python.str.at x 13) "W")) (= (python.str.at x 14) "R")) (= (python.str.at x 15) "#"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "I&W&pc-U( A(SWR#")
)
### output for cvc5
sat
(
(define-fun x () String "I&W&pc-U( A(SWR#")
)

Found solution I&W&pc-U( A(SWR#
Yes! Solved for puzzle  ConcatStrings:1

Solving puzzle 523/774: ConcatStrings:2
sat_func def sat(x: str, s=['L', 'C', 'b', 'r', 't', 'V', 'R', '%', 'R', '8', 'V', '#', '<', '!', 'U', 'y', 'x'], n=13):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
modified_func def sat(x: str, s=wrap_list([wrap_str('L'), wrap_str('C'), wrap_str('b'), wrap_str('r'), wrap_str('t'), wrap_str('V'), wrap_str('R'), wrap_str('%'), wrap_str('R'), wrap_str('8'), wrap_str('V'), wrap_str('#'), wrap_str('<'), wrap_str('!'), wrap_str('U'), wrap_str('y'), wrap_str('x')]), n=wrap_int(13)):
    return (sym_len(x) == n).__and__(all([x[i] == s[i] for i in sym_range(n)]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (and (= (str.len x) 13) (and (and (and (and (and (and (and (and (and (and (and (and (= (python.str.at x 0) "L") (= (python.str.at x 1) "C")) (= (python.str.at x 2) "b")) (= (python.str.at x 3) "r")) (= (python.str.at x 4) "t")) (= (python.str.at x 5) "V")) (= (python.str.at x 6) "R")) (= (python.str.at x 7) "%")) (= (python.str.at x 8) "R")) (= (python.str.at x 9) "8")) (= (python.str.at x 10) "V")) (= (python.str.at x 11) "#")) (= (python.str.at x 12) "<"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "LCbrtVR%R8V#<")
)
### output for cvc5
sat
(
(define-fun x () String "LCbrtVR%R8V#<")
)

Found solution LCbrtVR%R8V#<
Yes! Solved for puzzle  ConcatStrings:2

Solving puzzle 524/774: ConcatStrings:3
sat_func def sat(x: str, s=['-', '&', ')', '&', 'c', 'l', '/', 'H', '1', 'j', 'z', 'o', 'E', '|', '8', '&', '0', '&', 'y', '!', 'r', 'H', 'S', 'P', '5'], n=8):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
modified_func def sat(x: str, s=wrap_list([wrap_str('-'), wrap_str('&'), wrap_str(')'), wrap_str('&'), wrap_str('c'), wrap_str('l'), wrap_str('/'), wrap_str('H'), wrap_str('1'), wrap_str('j'), wrap_str('z'), wrap_str('o'), wrap_str('E'), wrap_str('|'), wrap_str('8'), wrap_str('&'), wrap_str('0'), wrap_str('&'), wrap_str('y'), wrap_str('!'), wrap_str('r'), wrap_str('H'), wrap_str('S'), wrap_str('P'), wrap_str('5')]), n=wrap_int(8)):
    return (sym_len(x) == n).__and__(all([x[i] == s[i] for i in sym_range(n)]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (and (= (str.len x) 8) (and (and (and (and (and (and (and (= (python.str.at x 0) "-") (= (python.str.at x 1) "&")) (= (python.str.at x 2) ")")) (= (python.str.at x 3) "&")) (= (python.str.at x 4) "c")) (= (python.str.at x 5) "l")) (= (python.str.at x 6) "/")) (= (python.str.at x 7) "H"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "-&)&cl/H")
)
### output for cvc5
sat
(
(define-fun x () String "-&)&cl/H")
)

Found solution -&)&cl/H
Yes! Solved for puzzle  ConcatStrings:3

Solving puzzle 525/774: ConcatStrings:4
sat_func def sat(x: str, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n=16):
    return len(x) == n and all([x[i] == s[i] for i in range(n)])
modified_func def sat(x: str, s=wrap_list([wrap_str('0'), wrap_str('@'), wrap_str('R'), wrap_str('k'), wrap_str('$'), wrap_str('$'), wrap_str('t'), wrap_str('0'), wrap_str('3'), wrap_str('#'), wrap_str('!'), wrap_str('a'), wrap_str('w'), wrap_str('k'), wrap_str('q'), wrap_str('H'), wrap_str('-'), wrap_str('m')]), n=wrap_int(16)):
    return (sym_len(x) == n).__and__(all([x[i] == s[i] for i in sym_range(n)]))
### smt2
(set-logic ALL)

(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x String)
(assert (and (= (str.len x) 16) (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (python.str.at x 0) "0") (= (python.str.at x 1) "@")) (= (python.str.at x 2) "R")) (= (python.str.at x 3) "k")) (= (python.str.at x 4) "$")) (= (python.str.at x 5) "$")) (= (python.str.at x 6) "t")) (= (python.str.at x 7) "0")) (= (python.str.at x 8) "3")) (= (python.str.at x 9) "#")) (= (python.str.at x 10) "!")) (= (python.str.at x 11) "a")) (= (python.str.at x 12) "w")) (= (python.str.at x 13) "k")) (= (python.str.at x 14) "q")) (= (python.str.at x 15) "H"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "0@Rk$$t03#!awkqH")
)
### output for cvc5
sat
(
(define-fun x () String "0@Rk$$t03#!awkqH")
)

Found solution 0@Rk$$t03#!awkqH
Yes! Solved for puzzle  ConcatStrings:4

Solving puzzle 526/774: BasicStrCounts:0
sat_func def sat(s: str, s1="a", s2="b", count1=50, count2=30):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
modified_func def sat(s: str, s1=wrap_str('a'), s2=wrap_str('b'), count1=wrap_int(50), count2=wrap_int(30)):
    return (s.count(s1) == count1).__and__(s.count(s2) == count2).__and__(s[:10] == s[-10:])
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (>= (str.count x "b") 0))
(assert (and (and (= (str.count x "a") 50) (= (str.count x "b") 30)) (= (python.str.substr x 0 10) (python.str.substr x -10 (str.len x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle BasicStrCounts:0
Too many constants for extrapolation

Solving puzzle 527/774: BasicStrCounts:1
sat_func def sat(s: str, s1="t", s2="qu", count1=86, count2=83):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
modified_func def sat(s: str, s1=wrap_str('t'), s2=wrap_str('qu'), count1=wrap_int(86), count2=wrap_int(83)):
    return (s.count(s1) == count1).__and__(s.count(s2) == count2).__and__(s[:10] == s[-10:])
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "t") 0))
(assert (>= (str.count x "qu") 0))
(assert (and (and (= (str.count x "t") 86) (= (str.count x "qu") 83)) (= (python.str.substr x 0 10) (python.str.substr x -10 (str.len x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle BasicStrCounts:1
Too many constants for extrapolation

Solving puzzle 528/774: BasicStrCounts:2
sat_func def sat(s: str, s1="kuc", s2="qu", count1=63, count2=58):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
modified_func def sat(s: str, s1=wrap_str('kuc'), s2=wrap_str('qu'), count1=wrap_int(63), count2=wrap_int(58)):
    return (s.count(s1) == count1).__and__(s.count(s2) == count2).__and__(s[:10] == s[-10:])
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "kuc") 0))
(assert (>= (str.count x "qu") 0))
(assert (and (and (= (str.count x "kuc") 63) (= (str.count x "qu") 58)) (= (python.str.substr x 0 10) (python.str.substr x -10 (str.len x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle BasicStrCounts:2
Too many constants for extrapolation

Solving puzzle 529/774: BasicStrCounts:3
sat_func def sat(s: str, s1="te", s2="tex", count1=97, count2=53):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
modified_func def sat(s: str, s1=wrap_str('te'), s2=wrap_str('tex'), count1=wrap_int(97), count2=wrap_int(53)):
    return (s.count(s1) == count1).__and__(s.count(s2) == count2).__and__(s[:10] == s[-10:])
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "te") 0))
(assert (>= (str.count x "tex") 0))
(assert (and (and (= (str.count x "te") 97) (= (str.count x "tex") 53)) (= (python.str.substr x 0 10) (python.str.substr x -10 (str.len x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle BasicStrCounts:3
Too many constants for extrapolation

Solving puzzle 530/774: BasicStrCounts:4
sat_func def sat(s: str, s1="hot", s2="n", count1=48, count2=92):
    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]
modified_func def sat(s: str, s1=wrap_str('hot'), s2=wrap_str('n'), count1=wrap_int(48), count2=wrap_int(92)):
    return (s.count(s1) == count1).__and__(s.count(s2) == count2).__and__(s[:10] == s[-10:])
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "hot") 0))
(assert (>= (str.count x "n") 0))
(assert (and (and (= (str.count x "hot") 48) (= (str.count x "n") 92)) (= (python.str.substr x 0 10) (python.str.substr x -10 (str.len x)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle BasicStrCounts:4
Too many constants for extrapolation

Solving puzzle 531/774: ZipStr:0
sat_func def sat(s: str, substrings=['foo', 'bar', 'baz', 'oddball']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
modified_func def sat(s: str, substrings=wrap_list([wrap_str('foo'), wrap_str('bar'), wrap_str('baz'), wrap_str('oddball')])):
    return all(sym_generator((sym_in(sub, s[i::sym_len(substrings)]) for i, sub in enumerate(substrings))))
Exception -- for puzzle ZipStr:0 Slicing on symbolic strings not fully implemented.

Solving puzzle 532/774: ZipStr:1
sat_func def sat(s: str, substrings=['quifelota', 'chyhimyvemene', 'ge']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
modified_func def sat(s: str, substrings=wrap_list([wrap_str('quifelota'), wrap_str('chyhimyvemene'), wrap_str('ge')])):
    return all(sym_generator((sym_in(sub, s[i::sym_len(substrings)]) for i, sub in enumerate(substrings))))
Exception -- for puzzle ZipStr:1 Slicing on symbolic strings not fully implemented.

Solving puzzle 533/774: ZipStr:2
sat_func def sat(s: str, substrings=['kitytextiritex', 'cumathoxaz', 'rebute', 'rocor']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
modified_func def sat(s: str, substrings=wrap_list([wrap_str('kitytextiritex'), wrap_str('cumathoxaz'), wrap_str('rebute'), wrap_str('rocor')])):
    return all(sym_generator((sym_in(sub, s[i::sym_len(substrings)]) for i, sub in enumerate(substrings))))
Exception -- for puzzle ZipStr:2 Slicing on symbolic strings not fully implemented.

Solving puzzle 534/774: ZipStr:3
sat_func def sat(s: str, substrings=['te', 'wusyc']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
modified_func def sat(s: str, substrings=wrap_list([wrap_str('te'), wrap_str('wusyc')])):
    return all(sym_generator((sym_in(sub, s[i::sym_len(substrings)]) for i, sub in enumerate(substrings))))
Exception -- for puzzle ZipStr:3 Slicing on symbolic strings not fully implemented.

Solving puzzle 535/774: ZipStr:4
sat_func def sat(s: str, substrings=['cute', 'rysucajaxuno']):
    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))
modified_func def sat(s: str, substrings=wrap_list([wrap_str('cute'), wrap_str('rysucajaxuno')])):
    return all(sym_generator((sym_in(sub, s[i::sym_len(substrings)]) for i, sub in enumerate(substrings))))
Exception -- for puzzle ZipStr:4 Slicing on symbolic strings not fully implemented.

Solving puzzle 536/774: ReverseCat:0
sat_func def sat(s: str, substrings=['foo', 'bar', 'baz']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
modified_func def sat(s: str, substrings=wrap_list([wrap_str('foo'), wrap_str('bar'), wrap_str('baz')])):
    return all(sym_generator((sym_in(sub, s).__and__(sym_in(sub[::-1], s)) for sub in substrings)))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (and (str.contains x "foo") (str.contains x "oof")) (and (str.contains x "bar") (str.contains x "rab"))) (and (str.contains x "baz") (str.contains x "zab"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "oofbarabazabfoo")
)

Found solution oofbarabazabfoo
Yes! Solved for puzzle  ReverseCat:0

Solving puzzle 537/774: ReverseCat:1
sat_func def sat(s: str, substrings=['kepijilufuwisejyzat', 'lechogyvonaxegitex']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
modified_func def sat(s: str, substrings=wrap_list([wrap_str('kepijilufuwisejyzat'), wrap_str('lechogyvonaxegitex')])):
    return all(sym_generator((sym_in(sub, s).__and__(sym_in(sub[::-1], s)) for sub in substrings)))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (str.contains x "kepijilufuwisejyzat") (str.contains x "tazyjesiwufulijipek")) (and (str.contains x "lechogyvonaxegitex") (str.contains x "xetigexanovygohcel"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "tazyjesiwufulijipeklechogyvonaxegitexetigexanovygohcelkepijilufuwisejyzat")
)

Found solution tazyjesiwufulijipeklechogyvonaxegitexetigexanovygohcelkepijilufuwisejyzat
Yes! Solved for puzzle  ReverseCat:1

Solving puzzle 538/774: ReverseCat:2
sat_func def sat(s: str, substrings=['ripihuquyrenytu', 'quosafyji', 'chyguzocuzuqu', 'futhixequyb']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
modified_func def sat(s: str, substrings=wrap_list([wrap_str('ripihuquyrenytu'), wrap_str('quosafyji'), wrap_str('chyguzocuzuqu'), wrap_str('futhixequyb')])):
    return all(sym_generator((sym_in(sub, s).__and__(sym_in(sub[::-1], s)) for sub in substrings)))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (and (and (str.contains x "ripihuquyrenytu") (str.contains x "utyneryuquhipir")) (and (str.contains x "quosafyji") (str.contains x "ijyfasouq"))) (and (str.contains x "chyguzocuzuqu") (str.contains x "uquzucozugyhc"))) (and (str.contains x "futhixequyb") (str.contains x "byuqexihtuf"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "utyneryuquhipirquosafyjijyfasouqchyguzocuzuquzucozugyhcfuthixequybyuqexihtufripihuquyrenytu")
)

Found solution utyneryuquhipirquosafyjijyfasouqchyguzocuzuquzucozugyhcfuthixequybyuqexihtufripihuquyrenytu
Yes! Solved for puzzle  ReverseCat:2

Solving puzzle 539/774: ReverseCat:3
sat_func def sat(s: str, substrings=['thacovatukoliva', 'maquyfezisothizyp', 'ka', 'benegiquememif']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
modified_func def sat(s: str, substrings=wrap_list([wrap_str('thacovatukoliva'), wrap_str('maquyfezisothizyp'), wrap_str('ka'), wrap_str('benegiquememif')])):
    return all(sym_generator((sym_in(sub, s).__and__(sym_in(sub[::-1], s)) for sub in substrings)))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (and (and (str.contains x "thacovatukoliva") (str.contains x "avilokutavocaht")) (and (str.contains x "maquyfezisothizyp") (str.contains x "pyzihtosizefyuqam"))) (and (str.contains x "ka") (str.contains x "ak"))) (and (str.contains x "benegiquememif") (str.contains x "fimemeuqigeneb"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "avilokutavocahtmaquyfezisothizypyzihtosizefyuqamkakbenegiquememifimemeuqigenebthacovatukoliva")
)

Found solution avilokutavocahtmaquyfezisothizypyzihtosizefyuqamkakbenegiquememifimemeuqigenebthacovatukoliva
Yes! Solved for puzzle  ReverseCat:3

Solving puzzle 540/774: ReverseCat:4
sat_func def sat(s: str, substrings=['t', 'vochemachylit', 'vutextynydakelopi', 'fazapydomozamochug']):
    return all(sub in s and sub[::-1] in s for sub in substrings)
modified_func def sat(s: str, substrings=wrap_list([wrap_str('t'), wrap_str('vochemachylit'), wrap_str('vutextynydakelopi'), wrap_str('fazapydomozamochug')])):
    return all(sym_generator((sym_in(sub, s).__and__(sym_in(sub[::-1], s)) for sub in substrings)))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (and (and (str.contains x "t") (str.contains x "t")) (and (str.contains x "vochemachylit") (str.contains x "tilyhcamehcov"))) (and (str.contains x "vutextynydakelopi") (str.contains x "ipolekadynytxetuv"))) (and (str.contains x "fazapydomozamochug") (str.contains x "guhcomazomodypazaf"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "tilyhcamehcovutextynydakelopipolekadynytxetuvfazapydomozamochuguhcomazomodypazafvochemachylit")
)

Found solution tilyhcamehcovutextynydakelopipolekadynytxetuvfazapydomozamochuguhcomazomodypazafvochemachylit
Yes! Solved for puzzle  ReverseCat:4

Solving puzzle 541/774: PenultimateString:0
sat_func def sat(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):
    return s in strings and sum(t > s for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('cat'), wrap_str('dog'), wrap_str('bird'), wrap_str('fly'), wrap_str('moose')])):
    return sym_in(s, strings).__and__(sym_sum(sym_generator((t > s for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "cat") (= x "dog") (= x "bird") (= x "fly") (= x "moose")) (= (+ (+ (+ (+ (+ (ite (str.< x "cat") 1 0) 0) (ite (str.< x "dog") 1 0)) (ite (str.< x "bird") 1 0)) (ite (str.< x "fly") 1 0)) (ite (str.< x "moose") 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "fly")
)
### output for cvc5
sat
(
(define-fun x () String "fly")
)

Found solution fly
Yes! Solved for puzzle  PenultimateString:0

Solving puzzle 542/774: PenultimateString:1
sat_func def sat(s: str, strings=['ryzapychybykydege', 'mivowepe', 'sovywos', 'chanyrorybynid', 'vafechajufo', 'nokymocymoxac', 'jahejafuquoduk', 'gogy', 'bytothice', 'ruminuvixixutudigom']):
    return s in strings and sum(t > s for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('ryzapychybykydege'), wrap_str('mivowepe'), wrap_str('sovywos'), wrap_str('chanyrorybynid'), wrap_str('vafechajufo'), wrap_str('nokymocymoxac'), wrap_str('jahejafuquoduk'), wrap_str('gogy'), wrap_str('bytothice'), wrap_str('ruminuvixixutudigom')])):
    return sym_in(s, strings).__and__(sym_sum(sym_generator((t > s for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "ryzapychybykydege") (= x "mivowepe") (= x "sovywos") (= x "chanyrorybynid") (= x "vafechajufo") (= x "nokymocymoxac") (= x "jahejafuquoduk") (= x "gogy") (= x "bytothice") (= x "ruminuvixixutudigom")) (= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (str.< x "ryzapychybykydege") 1 0) 0) (ite (str.< x "mivowepe") 1 0)) (ite (str.< x "sovywos") 1 0)) (ite (str.< x "chanyrorybynid") 1 0)) (ite (str.< x "vafechajufo") 1 0)) (ite (str.< x "nokymocymoxac") 1 0)) (ite (str.< x "jahejafuquoduk") 1 0)) (ite (str.< x "gogy") 1 0)) (ite (str.< x "bytothice") 1 0)) (ite (str.< x "ruminuvixixutudigom") 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "sovywos")
)
### output for cvc5
sat
(
(define-fun x () String "sovywos")
)

Found solution sovywos
Yes! Solved for puzzle  PenultimateString:1

Solving puzzle 543/774: PenultimateString:2
sat_func def sat(s: str, strings=['mipelavychekecy', 'pythujutisoxofe', 'diliwagacivychinofiw', 'na', 'dobynaramithibolo', 'cugupyfytextofoxat', 'gyfokebo', 'bymitextitextizoc', 'rekimuk', 'bepumyxitubachek']):
    return s in strings and sum(t > s for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('mipelavychekecy'), wrap_str('pythujutisoxofe'), wrap_str('diliwagacivychinofiw'), wrap_str('na'), wrap_str('dobynaramithibolo'), wrap_str('cugupyfytextofoxat'), wrap_str('gyfokebo'), wrap_str('bymitextitextizoc'), wrap_str('rekimuk'), wrap_str('bepumyxitubachek')])):
    return sym_in(s, strings).__and__(sym_sum(sym_generator((t > s for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "mipelavychekecy") (= x "pythujutisoxofe") (= x "diliwagacivychinofiw") (= x "na") (= x "dobynaramithibolo") (= x "cugupyfytextofoxat") (= x "gyfokebo") (= x "bymitextitextizoc") (= x "rekimuk") (= x "bepumyxitubachek")) (= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (str.< x "mipelavychekecy") 1 0) 0) (ite (str.< x "pythujutisoxofe") 1 0)) (ite (str.< x "diliwagacivychinofiw") 1 0)) (ite (str.< x "na") 1 0)) (ite (str.< x "dobynaramithibolo") 1 0)) (ite (str.< x "cugupyfytextofoxat") 1 0)) (ite (str.< x "gyfokebo") 1 0)) (ite (str.< x "bymitextitextizoc") 1 0)) (ite (str.< x "rekimuk") 1 0)) (ite (str.< x "bepumyxitubachek") 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "pythujutisoxofe")
)

Found solution pythujutisoxofe
Yes! Solved for puzzle  PenultimateString:2

Solving puzzle 544/774: PenultimateString:3
sat_func def sat(s: str, strings=['hunuvarufefikaq', 'xejegu', 'minoc', 'puthyvyc', 'xyzeryberi', 'tyl', 'thyvojyvijazetonowa', 'jahygywuchitho', 'quuvuvigy', 'zuhechywituthexe']):
    return s in strings and sum(t > s for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('hunuvarufefikaq'), wrap_str('xejegu'), wrap_str('minoc'), wrap_str('puthyvyc'), wrap_str('xyzeryberi'), wrap_str('tyl'), wrap_str('thyvojyvijazetonowa'), wrap_str('jahygywuchitho'), wrap_str('quuvuvigy'), wrap_str('zuhechywituthexe')])):
    return sym_in(s, strings).__and__(sym_sum(sym_generator((t > s for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "hunuvarufefikaq") (= x "xejegu") (= x "minoc") (= x "puthyvyc") (= x "xyzeryberi") (= x "tyl") (= x "thyvojyvijazetonowa") (= x "jahygywuchitho") (= x "quuvuvigy") (= x "zuhechywituthexe")) (= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (str.< x "hunuvarufefikaq") 1 0) 0) (ite (str.< x "xejegu") 1 0)) (ite (str.< x "minoc") 1 0)) (ite (str.< x "puthyvyc") 1 0)) (ite (str.< x "xyzeryberi") 1 0)) (ite (str.< x "tyl") 1 0)) (ite (str.< x "thyvojyvijazetonowa") 1 0)) (ite (str.< x "jahygywuchitho") 1 0)) (ite (str.< x "quuvuvigy") 1 0)) (ite (str.< x "zuhechywituthexe") 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "xyzeryberi")
)

Found solution xyzeryberi
Yes! Solved for puzzle  PenultimateString:3

Solving puzzle 545/774: PenultimateString:4
sat_func def sat(s: str, strings=['wesolotelunyzecemexi', 'pociquuwygocysahef', 'lequusigipitexti', 'quojuxaq', 'fyt', 'm', 'bavalepynoza', 'zihath', 'lodomijibuxoju', 'xasuwytextochypuli']):
    return s in strings and sum(t > s for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('wesolotelunyzecemexi'), wrap_str('pociquuwygocysahef'), wrap_str('lequusigipitexti'), wrap_str('quojuxaq'), wrap_str('fyt'), wrap_str('m'), wrap_str('bavalepynoza'), wrap_str('zihath'), wrap_str('lodomijibuxoju'), wrap_str('xasuwytextochypuli')])):
    return sym_in(s, strings).__and__(sym_sum(sym_generator((t > s for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "wesolotelunyzecemexi") (= x "pociquuwygocysahef") (= x "lequusigipitexti") (= x "quojuxaq") (= x "fyt") (= x "m") (= x "bavalepynoza") (= x "zihath") (= x "lodomijibuxoju") (= x "xasuwytextochypuli")) (= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (str.< x "wesolotelunyzecemexi") 1 0) 0) (ite (str.< x "pociquuwygocysahef") 1 0)) (ite (str.< x "lequusigipitexti") 1 0)) (ite (str.< x "quojuxaq") 1 0)) (ite (str.< x "fyt") 1 0)) (ite (str.< x "m") 1 0)) (ite (str.< x "bavalepynoza") 1 0)) (ite (str.< x "zihath") 1 0)) (ite (str.< x "lodomijibuxoju") 1 0)) (ite (str.< x "xasuwytextochypuli") 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "xasuwytextochypuli")
)

Found solution xasuwytextochypuli
Yes! Solved for puzzle  PenultimateString:4

Solving puzzle 546/774: PenultimateRevString:0
sat_func def sat(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('cat'), wrap_str('dog'), wrap_str('bird'), wrap_str('fly'), wrap_str('moose')])):
    return sym_in(s[::-1], strings).__and__(sym_sum(sym_generator((t < s[::-1] for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (or (= (str.reverse x) "cat") (= (str.reverse x) "dog") (= (str.reverse x) "bird") (= (str.reverse x) "fly") (= (str.reverse x) "moose")) (= (+ (+ (+ (+ (+ (ite (str.< "cat" (str.reverse x)) 1 0) 0) (ite (str.< "dog" (str.reverse x)) 1 0)) (ite (str.< "bird" (str.reverse x)) 1 0)) (ite (str.< "fly" (str.reverse x)) 1 0)) (ite (str.< "moose" (str.reverse x)) 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "tac")
)
### output for cvc5
sat
(
(define-fun x () String "tac")
)

Found solution tac
Yes! Solved for puzzle  PenultimateRevString:0

Solving puzzle 547/774: PenultimateRevString:1
sat_func def sat(s: str, strings=['rawithelen', 'que', 'pikuf', 'koze', 'zehyquorofyxytextef', 'text', 'jezebox', 'zychopucebychokyz', 'pyzyxatevafugedix', 'buzogehabojyb']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('rawithelen'), wrap_str('que'), wrap_str('pikuf'), wrap_str('koze'), wrap_str('zehyquorofyxytextef'), wrap_str('text'), wrap_str('jezebox'), wrap_str('zychopucebychokyz'), wrap_str('pyzyxatevafugedix'), wrap_str('buzogehabojyb')])):
    return sym_in(s[::-1], strings).__and__(sym_sum(sym_generator((t < s[::-1] for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (or (= (str.reverse x) "rawithelen") (= (str.reverse x) "que") (= (str.reverse x) "pikuf") (= (str.reverse x) "koze") (= (str.reverse x) "zehyquorofyxytextef") (= (str.reverse x) "text") (= (str.reverse x) "jezebox") (= (str.reverse x) "zychopucebychokyz") (= (str.reverse x) "pyzyxatevafugedix") (= (str.reverse x) "buzogehabojyb")) (= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (str.< "rawithelen" (str.reverse x)) 1 0) 0) (ite (str.< "que" (str.reverse x)) 1 0)) (ite (str.< "pikuf" (str.reverse x)) 1 0)) (ite (str.< "koze" (str.reverse x)) 1 0)) (ite (str.< "zehyquorofyxytextef" (str.reverse x)) 1 0)) (ite (str.< "text" (str.reverse x)) 1 0)) (ite (str.< "jezebox" (str.reverse x)) 1 0)) (ite (str.< "zychopucebychokyz" (str.reverse x)) 1 0)) (ite (str.< "pyzyxatevafugedix" (str.reverse x)) 1 0)) (ite (str.< "buzogehabojyb" (str.reverse x)) 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "xobezej")
)

Found solution xobezej
Yes! Solved for puzzle  PenultimateRevString:1

Solving puzzle 548/774: PenultimateRevString:2
sat_func def sat(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('thythanaham'), wrap_str('quiroxebadivogis'), wrap_str('kyh'), wrap_str('xa'), wrap_str('gathytyjonymihahahy'), wrap_str('musyzisequyxyhenico'), wrap_str('poxizitizexokigewifi'), wrap_str('mife'), wrap_str('chyjuratexta'), wrap_str('gyrato')])):
    return sym_in(s[::-1], strings).__and__(sym_sum(sym_generator((t < s[::-1] for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (or (= (str.reverse x) "thythanaham") (= (str.reverse x) "quiroxebadivogis") (= (str.reverse x) "kyh") (= (str.reverse x) "xa") (= (str.reverse x) "gathytyjonymihahahy") (= (str.reverse x) "musyzisequyxyhenico") (= (str.reverse x) "poxizitizexokigewifi") (= (str.reverse x) "mife") (= (str.reverse x) "chyjuratexta") (= (str.reverse x) "gyrato")) (= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (str.< "thythanaham" (str.reverse x)) 1 0) 0) (ite (str.< "quiroxebadivogis" (str.reverse x)) 1 0)) (ite (str.< "kyh" (str.reverse x)) 1 0)) (ite (str.< "xa" (str.reverse x)) 1 0)) (ite (str.< "gathytyjonymihahahy" (str.reverse x)) 1 0)) (ite (str.< "musyzisequyxyhenico" (str.reverse x)) 1 0)) (ite (str.< "poxizitizexokigewifi" (str.reverse x)) 1 0)) (ite (str.< "mife" (str.reverse x)) 1 0)) (ite (str.< "chyjuratexta" (str.reverse x)) 1 0)) (ite (str.< "gyrato" (str.reverse x)) 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "yhahahimynojytyhtag")
)

Found solution yhahahimynojytyhtag
Yes! Solved for puzzle  PenultimateRevString:2

Solving puzzle 549/774: PenultimateRevString:3
sat_func def sat(s: str, strings=['habicynanikadifovac', 'bozehathyfoz', 'hud', 'textudunachuxarise', 'hewohahatazabab', 'lutumelimevabutha', 'wocher', 'wacifufixudizon', 'tazibedo', 'xytu']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('habicynanikadifovac'), wrap_str('bozehathyfoz'), wrap_str('hud'), wrap_str('textudunachuxarise'), wrap_str('hewohahatazabab'), wrap_str('lutumelimevabutha'), wrap_str('wocher'), wrap_str('wacifufixudizon'), wrap_str('tazibedo'), wrap_str('xytu')])):
    return sym_in(s[::-1], strings).__and__(sym_sum(sym_generator((t < s[::-1] for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (or (= (str.reverse x) "habicynanikadifovac") (= (str.reverse x) "bozehathyfoz") (= (str.reverse x) "hud") (= (str.reverse x) "textudunachuxarise") (= (str.reverse x) "hewohahatazabab") (= (str.reverse x) "lutumelimevabutha") (= (str.reverse x) "wocher") (= (str.reverse x) "wacifufixudizon") (= (str.reverse x) "tazibedo") (= (str.reverse x) "xytu")) (= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (str.< "habicynanikadifovac" (str.reverse x)) 1 0) 0) (ite (str.< "bozehathyfoz" (str.reverse x)) 1 0)) (ite (str.< "hud" (str.reverse x)) 1 0)) (ite (str.< "textudunachuxarise" (str.reverse x)) 1 0)) (ite (str.< "hewohahatazabab" (str.reverse x)) 1 0)) (ite (str.< "lutumelimevabutha" (str.reverse x)) 1 0)) (ite (str.< "wocher" (str.reverse x)) 1 0)) (ite (str.< "wacifufixudizon" (str.reverse x)) 1 0)) (ite (str.< "tazibedo" (str.reverse x)) 1 0)) (ite (str.< "xytu" (str.reverse x)) 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "cavofidakinanycibah")
)

Found solution cavofidakinanycibah
Yes! Solved for puzzle  PenultimateRevString:3

Solving puzzle 550/774: PenultimateRevString:4
sat_func def sat(s: str, strings=['vekykothumygochuth', 'xujatajazisiqu', 'vapyvymobymethotexto', 'tygope', 'g', 'ripalotextaj', 'tecehuthojodogucivaj', 'xyjulecometihesej', 'ribo', 'gutachowagexatoset']):
    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1
modified_func def sat(s: str, strings=wrap_list([wrap_str('vekykothumygochuth'), wrap_str('xujatajazisiqu'), wrap_str('vapyvymobymethotexto'), wrap_str('tygope'), wrap_str('g'), wrap_str('ripalotextaj'), wrap_str('tecehuthojodogucivaj'), wrap_str('xyjulecometihesej'), wrap_str('ribo'), wrap_str('gutachowagexatoset')])):
    return sym_in(s[::-1], strings).__and__(sym_sum(sym_generator((t < s[::-1] for t in strings))) == wrap_int(1))
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (and (or (= (str.reverse x) "vekykothumygochuth") (= (str.reverse x) "xujatajazisiqu") (= (str.reverse x) "vapyvymobymethotexto") (= (str.reverse x) "tygope") (= (str.reverse x) "g") (= (str.reverse x) "ripalotextaj") (= (str.reverse x) "tecehuthojodogucivaj") (= (str.reverse x) "xyjulecometihesej") (= (str.reverse x) "ribo") (= (str.reverse x) "gutachowagexatoset")) (= (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (str.< "vekykothumygochuth" (str.reverse x)) 1 0) 0) (ite (str.< "xujatajazisiqu" (str.reverse x)) 1 0)) (ite (str.< "vapyvymobymethotexto" (str.reverse x)) 1 0)) (ite (str.< "tygope" (str.reverse x)) 1 0)) (ite (str.< "g" (str.reverse x)) 1 0)) (ite (str.< "ripalotextaj" (str.reverse x)) 1 0)) (ite (str.< "tecehuthojodogucivaj" (str.reverse x)) 1 0)) (ite (str.< "xyjulecometihesej" (str.reverse x)) 1 0)) (ite (str.< "ribo" (str.reverse x)) 1 0)) (ite (str.< "gutachowagexatoset" (str.reverse x)) 1 0)) 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "tesotaxegawohcatug")
)

Found solution tesotaxegawohcatug
Yes! Solved for puzzle  PenultimateRevString:4

Solving puzzle 551/774: CenteredString:0
sat_func def sat(s: str, target="foobarbazwow", length=6):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
modified_func def sat(s: str, target=wrap_str('foobarbazwow'), length=wrap_int(6)):
    return target[(sym_len(target) - length) // 2:(sym_len(target) + length) // 2] == s
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.substr "foobarbazwow" (div 6 2) (- (div 18 2) (div 6 2))) x))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "barbaz")
)
### output for cvc5
sat
(
(define-fun x () String "barbaz")
)

Found solution barbaz
Yes! Solved for puzzle  CenteredString:0

Solving puzzle 552/774: CenteredString:1
sat_func def sat(s: str, target="rujus", length=1):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
modified_func def sat(s: str, target=wrap_str('rujus'), length=wrap_int(1)):
    return target[(sym_len(target) - length) // 2:(sym_len(target) + length) // 2] == s
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.substr "rujus" (div 4 2) (- (div 6 2) (div 4 2))) x))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "j")
)
### output for cvc5
sat
(
(define-fun x () String "j")
)

Found solution j
Yes! Solved for puzzle  CenteredString:1

Solving puzzle 553/774: CenteredString:2
sat_func def sat(s: str, target="bulu", length=4):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
modified_func def sat(s: str, target=wrap_str('bulu'), length=wrap_int(4)):
    return target[(sym_len(target) - length) // 2:(sym_len(target) + length) // 2] == s
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.substr "bulu" (div 0 2) (- (div 8 2) (div 0 2))) x))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "bulu")
)
### output for cvc5
sat
(
(define-fun x () String "bulu")
)

Found solution bulu
Yes! Solved for puzzle  CenteredString:2

Solving puzzle 554/774: CenteredString:3
sat_func def sat(s: str, target="defojuhujuwilumec", length=7):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
modified_func def sat(s: str, target=wrap_str('defojuhujuwilumec'), length=wrap_int(7)):
    return target[(sym_len(target) - length) // 2:(sym_len(target) + length) // 2] == s
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.substr "defojuhujuwilumec" (div 10 2) (- (div 24 2) (div 10 2))) x))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "uhujuwi")
)
### output for cvc5
sat
(
(define-fun x () String "uhujuwi")
)

Found solution uhujuwi
Yes! Solved for puzzle  CenteredString:3

Solving puzzle 555/774: CenteredString:4
sat_func def sat(s: str, target="tenuhije", length=6):
    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s
modified_func def sat(s: str, target=wrap_str('tenuhije'), length=wrap_int(6)):
    return target[(sym_len(target) - length) // 2:(sym_len(target) + length) // 2] == s
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.substr "tenuhije" (div 2 2) (- (div 14 2) (div 2 2))) x))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "enuhij")
)
### output for cvc5
sat
(
(define-fun x () String "enuhij")
)

Found solution enuhij
Yes! Solved for puzzle  CenteredString:4

Solving puzzle 556/774: SubstrCount:0
sat_func def sat(substring: str, string="moooboooofasd", count=2):
    return string.count(substring) == count
modified_func def sat(substring: str, string=wrap_str('moooboooofasd'), count=wrap_int(2)):
    return string.count(substring) == count
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count "moooboooofasd" x) 0))
(assert (= (str.count "moooboooofasd" x) 2))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "ooo")
)

Found solution ooo
Yes! Solved for puzzle  SubstrCount:0

Solving puzzle 557/774: SubstrCount:1
sat_func def sat(substring: str, string="nyvyfytibuquyquuchudemixyzychumanachozyquiquowutextyvomyzychyme", count=4):
    return string.count(substring) == count
modified_func def sat(substring: str, string=wrap_str('nyvyfytibuquyquuchudemixyzychumanachozyquiquowutextyvomyzychyme'), count=wrap_int(4)):
    return string.count(substring) == count
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count "nyvyfytibuquyquuchudemixyzychumanachozyquiquowutextyvomyzychyme" x) 0))
(assert (= (str.count "nyvyfytibuquyquuchudemixyzychumanachozyquiquowutextyvomyzychyme" x) 4))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SubstrCount:1
Too many constants for extrapolation

Solving puzzle 558/774: SubstrCount:2
sat_func def sat(substring: str, string="cokomoquiwythyluwamymothynihythenyfeteth", count=4):
    return string.count(substring) == count
modified_func def sat(substring: str, string=wrap_str('cokomoquiwythyluwamymothynihythenyfeteth'), count=wrap_int(4)):
    return string.count(substring) == count
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count "cokomoquiwythyluwamymothynihythenyfeteth" x) 0))
(assert (= (str.count "cokomoquiwythyluwamymothynihythenyfeteth" x) 4))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SubstrCount:2
Too many constants for extrapolation

Solving puzzle 559/774: SubstrCount:3
sat_func def sat(substring: str, string="cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf", count=3):
    return string.count(substring) == count
modified_func def sat(substring: str, string=wrap_str('cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf'), count=wrap_int(3)):
    return string.count(substring) == count
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count "cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf" x) 0))
(assert (= (str.count "cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf" x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SubstrCount:3
Too many constants for extrapolation

Solving puzzle 560/774: SubstrCount:4
sat_func def sat(substring: str, string="modacequytextytextilaleguthovamipehywaciripetext", count=3):
    return string.count(substring) == count
modified_func def sat(substring: str, string=wrap_str('modacequytextytextilaleguthovamipehywaciripetext'), count=wrap_int(3)):
    return string.count(substring) == count
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count "modacequytextytextilaleguthovamipehywaciripetext" x) 0))
(assert (= (str.count "modacequytextytextilaleguthovamipehywaciripetext" x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle SubstrCount:4
Too many constants for extrapolation

Solving puzzle 561/774: CompleteParens:0
sat_func def sat(t: str, s="))(Add)some))parens()to()(balance(()(()(me!)(((("):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
modified_func def sat(t: str, s=wrap_str('))(Add)some))parens()to()(balance(()(()(me!)((((')):
    for i in sym_range(sym_len(t) + 1):
        depth = t[:i].count('(') - t[:i].count(')')
        _assert(depth >= wrap_int(0))
    return (depth == wrap_int(0)).__and__(sym_in(s, t))
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) "(") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) ")") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (and (= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0) (str.contains x "))(Add)some))parens()to()(balance(()(()(me!)((((")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "))(Add)some))parens()to()(balance(()(()(me!)((((")
)

Could not find any solution for puzzle CompleteParens:0
Too many constants for extrapolation

Solving puzzle 562/774: CompleteParens:1
sat_func def sat(t: str, s="(po)(())kf((((cy()))((tex()())("):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
modified_func def sat(t: str, s=wrap_str('(po)(())kf((((cy()))((tex()())(')):
    for i in sym_range(sym_len(t) + 1):
        depth = t[:i].count('(') - t[:i].count(')')
        _assert(depth >= wrap_int(0))
    return (depth == wrap_int(0)).__and__(sym_in(s, t))
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) "(") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) ")") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (and (= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0) (str.contains x "(po)(())kf((((cy()))((tex()())(")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "(po)(())kf((((cy()))((tex()())(")
)

Could not find any solution for puzzle CompleteParens:1
Too many constants for extrapolation

Solving puzzle 563/774: CompleteParens:2
sat_func def sat(t: str, s="yf)()(()))hik()t((("):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
modified_func def sat(t: str, s=wrap_str('yf)()(()))hik()t(((')):
    for i in sym_range(sym_len(t) + 1):
        depth = t[:i].count('(') - t[:i].count(')')
        _assert(depth >= wrap_int(0))
    return (depth == wrap_int(0)).__and__(sym_in(s, t))
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) "(") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) ")") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (and (= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0) (str.contains x "yf)()(()))hik()t(((")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "yf)()(()))hik()t(((")
)

Could not find any solution for puzzle CompleteParens:2
Too many constants for extrapolation

Solving puzzle 564/774: CompleteParens:3
sat_func def sat(t: str, s=")((le(()()chu)())nol))((sic(((da)()ty((()te))xy(())))))k"):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
modified_func def sat(t: str, s=wrap_str(')((le(()()chu)())nol))((sic(((da)()ty((()te))xy(())))))k')):
    for i in sym_range(sym_len(t) + 1):
        depth = t[:i].count('(') - t[:i].count(')')
        _assert(depth >= wrap_int(0))
    return (depth == wrap_int(0)).__and__(sym_in(s, t))
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) "(") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) ")") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (and (= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0) (str.contains x ")((le(()()chu)())nol))((sic(((da)()ty((()te))xy(())))))k")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String ")((le(()()chu)())nol))((sic(((da)()ty((()te))xy(())))))k")
)

Could not find any solution for puzzle CompleteParens:3
Too many constants for extrapolation

Solving puzzle 565/774: CompleteParens:4
sat_func def sat(t: str, s="))())l"):
    for i in range(len(t) + 1):
        depth = t[:i].count("(") - t[:i].count(")")
        assert depth >= 0
    return depth == 0 and s in t
modified_func def sat(t: str, s=wrap_str('))())l')):
    for i in sym_range(sym_len(t) + 1):
        depth = t[:i].count('(') - t[:i].count(')')
        _assert(depth >= wrap_int(0))
    return (depth == wrap_int(0)).__and__(sym_in(s, t))
### smt2
(set-logic ALL)

(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) "(") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (str.count (python.str.substr x 0 i_0) ")") 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (>= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (+ (str.len x) 1))) (and (= (- (str.count (python.str.substr x 0 i_0) "(") (str.count (python.str.substr x 0 i_0) ")")) 0) (str.contains x "))())l")))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
unknown
(
(define-fun x () String "))())l")
)

Could not find any solution for puzzle CompleteParens:4
Too many constants for extrapolation

Solving puzzle 566/774: MatchingMarkers:0
sat_func def sat(cut_position: int, ring="yRrsmOkLCHSDJywpVDEDsjgCwSUmtvHMefxxPFdmBIpM", lower=5):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
modified_func def sat(cut_position: int, ring=wrap_str('yRrsmOkLCHSDJywpVDEDsjgCwSUmtvHMefxxPFdmBIpM'), lower=wrap_int(5)):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: wrap_int(0) for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= wrap_int(1) if matches[c] > wrap_int(0) else sym_len(line)
        else:
            matches[c.lower()] += wrap_int(1)
    return sym_sum(sym_generator((i == wrap_int(0) for i in matches.values()))) >= lower
Exception -- for puzzle MatchingMarkers:0 Symbolic hash not yet implemented

Solving puzzle 567/774: MatchingMarkers:1
sat_func def sat(cut_position: int, ring="MvI", lower=0):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
modified_func def sat(cut_position: int, ring=wrap_str('MvI'), lower=wrap_int(0)):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: wrap_int(0) for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= wrap_int(1) if matches[c] > wrap_int(0) else sym_len(line)
        else:
            matches[c.lower()] += wrap_int(1)
    return sym_sum(sym_generator((i == wrap_int(0) for i in matches.values()))) >= lower
Exception -- for puzzle MatchingMarkers:1 Symbolic hash not yet implemented

Solving puzzle 568/774: MatchingMarkers:2
sat_func def sat(cut_position: int, ring="s", lower=0):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
modified_func def sat(cut_position: int, ring=wrap_str('s'), lower=wrap_int(0)):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: wrap_int(0) for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= wrap_int(1) if matches[c] > wrap_int(0) else sym_len(line)
        else:
            matches[c.lower()] += wrap_int(1)
    return sym_sum(sym_generator((i == wrap_int(0) for i in matches.values()))) >= lower
Exception -- for puzzle MatchingMarkers:2 Symbolic hash not yet implemented

Solving puzzle 569/774: MatchingMarkers:3
sat_func def sat(cut_position: int, ring="fyVYVBfGHVYsBrYVgsgHYvVD", lower=0):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
modified_func def sat(cut_position: int, ring=wrap_str('fyVYVBfGHVYsBrYVgsgHYvVD'), lower=wrap_int(0)):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: wrap_int(0) for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= wrap_int(1) if matches[c] > wrap_int(0) else sym_len(line)
        else:
            matches[c.lower()] += wrap_int(1)
    return sym_sum(sym_generator((i == wrap_int(0) for i in matches.values()))) >= lower
Exception -- for puzzle MatchingMarkers:3 Symbolic hash not yet implemented

Solving puzzle 570/774: MatchingMarkers:4
sat_func def sat(cut_position: int, ring="ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf", lower=1):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: 0 for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= (1 if matches[c] > 0 else len(line))
        else:
            matches[c.lower()] += 1
    return sum(i == 0 for i in matches.values()) >= lower
modified_func def sat(cut_position: int, ring=wrap_str('ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf'), lower=wrap_int(1)):
    line = ring[cut_position:] + ring[:cut_position]
    matches = {c: wrap_int(0) for c in line.lower()}
    for c in line:
        if c.islower():
            matches[c] -= wrap_int(1) if matches[c] > wrap_int(0) else sym_len(line)
        else:
            matches[c.lower()] += wrap_int(1)
    return sym_sum(sym_generator((i == wrap_int(0) for i in matches.values()))) >= lower
Exception -- for puzzle MatchingMarkers:4 Symbolic hash not yet implemented

Solving puzzle 571/774: GCD:0
sat_func def sat(n: int, a=15482, b=23223, lower_bound=5):
    return a % n == 0 and b % n == 0 and n >= lower_bound
modified_func def sat(n: int, a=wrap_int(15482), b=wrap_int(23223), lower_bound=wrap_int(5)):
    return (a % n == wrap_int(0)).__and__(b % n == wrap_int(0)).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod 15482 x) 0) (= (mod 23223 x) 0)) (>= x 5)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    7741)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 23223) (= x!1 7741)) 3
      2))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 7741
Yes! Solved for puzzle  GCD:0

Solving puzzle 572/774: GCD:1
sat_func def sat(n: int, a=9, b=9, lower_bound=6):
    return a % n == 0 and b % n == 0 and n >= lower_bound
modified_func def sat(n: int, a=wrap_int(9), b=wrap_int(9), lower_bound=wrap_int(6)):
    return (a % n == wrap_int(0)).__and__(b % n == wrap_int(0)).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod 9 x) 0) (= (mod 9 x) 0)) (>= x 6)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    9)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    1)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 9)
)

Found solution 9
Yes! Solved for puzzle  GCD:1

Solving puzzle 573/774: GCD:2
sat_func def sat(n: int, a=232610, b=3131721474, lower_bound=15000):
    return a % n == 0 and b % n == 0 and n >= lower_bound
modified_func def sat(n: int, a=wrap_int(232610), b=wrap_int(3131721474), lower_bound=wrap_int(15000)):
    return (a % n == wrap_int(0)).__and__(b % n == wrap_int(0)).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod 232610 x) 0) (= (mod 3131721474 x) 0)) (>= x 15000)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    23261)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 3131721474) (= x!1 23261)) 134634
      10))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 46522)
)

Found solution 23261
Yes! Solved for puzzle  GCD:2

Solving puzzle 574/774: GCD:3
sat_func def sat(n: int, a=247586288427023352, b=372021520735824432, lower_bound=1709054537):
    return a % n == 0 and b % n == 0 and n >= lower_bound
modified_func def sat(n: int, a=wrap_int(247586288427023352), b=wrap_int(372021520735824432), lower_bound=wrap_int(1709054537)):
    return (a % n == wrap_int(0)).__and__(b % n == wrap_int(0)).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod 247586288427023352 x) 0) (= (mod 372021520735824432 x) 0)) (>= x 1709054537)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1943286504)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 372021520735824432) (= x!1 1943286504)) 191439358
      127405963))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 1943286504
Yes! Solved for puzzle  GCD:3

Solving puzzle 575/774: GCD:4
sat_func def sat(n: int, a=8797233, b=2370036150831, lower_bound=8364173):
    return a % n == 0 and b % n == 0 and n >= lower_bound
modified_func def sat(n: int, a=wrap_int(8797233), b=wrap_int(2370036150831), lower_bound=wrap_int(8364173)):
    return (a % n == wrap_int(0)).__and__(b % n == wrap_int(0)).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod 8797233 x) 0) (= (mod 2370036150831 x) 0)) (>= x 8364173)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8797233)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 2370036150831) (= x!1 8797233)) 269407
      1))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 8797233)
)

Found solution 8797233
Yes! Solved for puzzle  GCD:4

Solving puzzle 576/774: GCD_multi:0
sat_func def sat(n: int, nums=[77410, 23223, 54187], lower_bound=2):
    return all(i % n == 0 for i in nums) and n >= lower_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(77410), wrap_int(23223), wrap_int(54187)]), lower_bound=wrap_int(2)):
    return all(sym_generator((i % n == wrap_int(0) for i in nums))).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (= (mod 77410 x) 0) (= (mod 23223 x) 0)) (= (mod 54187 x) 0)) (>= x 2)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    7741)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 23223) (= x!1 7741)) 3
    (ite (and (= x!0 54187) (= x!1 7741)) 7
      10)))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 7741)
)

Found solution 7741
Yes! Solved for puzzle  GCD_multi:0

Solving puzzle 577/774: GCD_multi:1
sat_func def sat(n: int, nums=[14, 551755893, 902110495], lower_bound=1):
    return all(i % n == 0 for i in nums) and n >= lower_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(14), wrap_int(551755893), wrap_int(902110495)]), lower_bound=wrap_int(1)):
    return all(sym_generator((i % n == wrap_int(0) for i in nums))).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (= (mod 14 x) 0) (= (mod 551755893 x) 0)) (= (mod 902110495 x) 0)) (>= x 1)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 551755893) (= x!1 1)) 551755893
    (ite (and (= x!0 902110495) (= x!1 1)) 902110495
      14)))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution 1
Yes! Solved for puzzle  GCD_multi:1

Solving puzzle 578/774: GCD_multi:2
sat_func def sat(n: int, nums=[287260676668, 33263981357337, 47314720, 295717, 2957170], lower_bound=98647):
    return all(i % n == 0 for i in nums) and n >= lower_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(287260676668), wrap_int(33263981357337), wrap_int(47314720), wrap_int(295717), wrap_int(2957170)]), lower_bound=wrap_int(98647)):
    return all(sym_generator((i % n == wrap_int(0) for i in nums))).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (= (mod 287260676668 x) 0) (= (mod 33263981357337 x) 0)) (= (mod 47314720 x) 0)) (= (mod 295717 x) 0)) (= (mod 2957170 x) 0)) (>= x 98647)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    295717)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 33263981357337) (= x!1 295717)) 112485861
    (ite (and (= x!0 47314720) (= x!1 295717)) 160
    (ite (and (= x!0 295717) (= x!1 295717)) 1
    (ite (and (= x!0 2957170) (= x!1 295717)) 10
      971404)))))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 295717)
)

Found solution 295717
Yes! Solved for puzzle  GCD_multi:2

Solving puzzle 579/774: GCD_multi:3
sat_func def sat(n: int, nums=[452452, 111673658096, 83221402264, 5027670648, 61177116, 154154, 116116, 1508784124848, 17036343324, 29091062, 100726626], lower_bound=977):
    return all(i % n == 0 for i in nums) and n >= lower_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(452452), wrap_int(111673658096), wrap_int(83221402264), wrap_int(5027670648), wrap_int(61177116), wrap_int(154154), wrap_int(116116), wrap_int(1508784124848), wrap_int(17036343324), wrap_int(29091062), wrap_int(100726626)]), lower_bound=wrap_int(977)):
    return all(sym_generator((i % n == wrap_int(0) for i in nums))).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (and (and (and (and (and (and (= (mod 452452 x) 0) (= (mod 111673658096 x) 0)) (= (mod 83221402264 x) 0)) (= (mod 5027670648 x) 0)) (= (mod 61177116 x) 0)) (= (mod 154154 x) 0)) (= (mod 116116 x) 0)) (= (mod 1508784124848 x) 0)) (= (mod 17036343324 x) 0)) (= (mod 29091062 x) 0)) (= (mod 100726626 x) 0)) (>= x 977)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2002)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 111673658096) (= x!1 2002)) 55781048
    (ite (and (= x!0 83221402264) (= x!1 2002)) 41569132
    (ite (and (= x!0 5027670648) (= x!1 2002)) 2511324
    (ite (and (= x!0 61177116) (= x!1 2002)) 30558
    (ite (and (= x!0 154154) (= x!1 2002)) 77
    (ite (and (= x!0 116116) (= x!1 2002)) 58
    (ite (and (= x!0 1508784124848) (= x!1 2002)) 753638424
    (ite (and (= x!0 17036343324) (= x!1 2002)) 8509662
    (ite (and (= x!0 29091062) (= x!1 2002)) 14531
    (ite (and (= x!0 100726626) (= x!1 2002)) 50313
      226)))))))))))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 2002
Yes! Solved for puzzle  GCD_multi:3

Solving puzzle 580/774: GCD_multi:4
sat_func def sat(n: int, nums=[8154539588421190, 128861795], lower_bound=64216730):
    return all(i % n == 0 for i in nums) and n >= lower_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(8154539588421190), wrap_int(128861795)]), lower_bound=wrap_int(64216730)):
    return all(sym_generator((i % n == wrap_int(0) for i in nums))).__and__(n >= lower_bound)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod 8154539588421190 x) 0) (= (mod 128861795 x) 0)) (>= x 64216730)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    128861795)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 128861795) (= x!1 128861795)) 1
      63281282))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 128861795)
)

Found solution 128861795
Yes! Solved for puzzle  GCD_multi:4

Solving puzzle 581/774: LCM:0
sat_func def sat(n: int, a=15, b=27, upper_bound=150):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
modified_func def sat(n: int, a=wrap_int(15), b=wrap_int(27), upper_bound=wrap_int(150)):
    return (n % a == wrap_int(0)).__and__(n % b == wrap_int(0)).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod x 15) 0) (= (mod x 27) 0)) (and (< 0 x) (<= x 150))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    135)
)
### output for cvc5
sat
(
(define-fun x () Int 135)
)

Found solution 135
Yes! Solved for puzzle  LCM:0

Solving puzzle 582/774: LCM:1
sat_func def sat(n: int, a=41234205765, b=597597185, upper_bound=73349253728):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
modified_func def sat(n: int, a=wrap_int(41234205765), b=wrap_int(597597185), upper_bound=wrap_int(73349253728)):
    return (n % a == wrap_int(0)).__and__(n % b == wrap_int(0)).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod x 41234205765) 0) (= (mod x 597597185) 0)) (and (< 0 x) (<= x 73349253728))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    41234205765)
)
### output for cvc5
sat
(
(define-fun x () Int 41234205765)
)

Found solution 41234205765
Yes! Solved for puzzle  LCM:1

Solving puzzle 583/774: LCM:2
sat_func def sat(n: int, a=7601351956456, b=2974663988, upper_bound=389421039754872576):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
modified_func def sat(n: int, a=wrap_int(7601351956456), b=wrap_int(2974663988), upper_bound=wrap_int(389421039754872576)):
    return (n % a == wrap_int(0)).__and__(n % b == wrap_int(0)).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod x 7601351956456) 0) (= (mod x 2974663988) 0)) (and (< 0 x) (<= x 389421039754872576))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    290531273127704776)
)
### output for cvc5
sat
(
(define-fun x () Int 290531273127704776)
)

Found solution 290531273127704776
Yes! Solved for puzzle  LCM:2

Solving puzzle 584/774: LCM:3
sat_func def sat(n: int, a=201717041833890, b=3585167190, upper_bound=731493653565433):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
modified_func def sat(n: int, a=wrap_int(201717041833890), b=wrap_int(3585167190), upper_bound=wrap_int(731493653565433)):
    return (n % a == wrap_int(0)).__and__(n % b == wrap_int(0)).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod x 201717041833890) 0) (= (mod x 3585167190) 0)) (and (< 0 x) (<= x 731493653565433))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    605151125501670)
)
### output for cvc5
sat
(
(define-fun x () Int 605151125501670)
)

Found solution 605151125501670
Yes! Solved for puzzle  LCM:3

Solving puzzle 585/774: LCM:4
sat_func def sat(n: int, a=79680, b=661339968, upper_bound=410128528659):
    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound
modified_func def sat(n: int, a=wrap_int(79680), b=wrap_int(661339968), upper_bound=wrap_int(410128528659)):
    return (n % a == wrap_int(0)).__and__(n % b == wrap_int(0)).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod x 79680) 0) (= (mod x 661339968) 0)) (and (< 0 x) (<= x 410128528659))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    274456086720)
)
### output for cvc5
sat
(
(define-fun x () Int 274456086720)
)

Found solution 274456086720
Yes! Solved for puzzle  LCM:4

Solving puzzle 586/774: LCM_multi:0
sat_func def sat(n: int, nums=[15, 27, 102], upper_bound=5000):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(15), wrap_int(27), wrap_int(102)]), upper_bound=wrap_int(5000)):
    return all(sym_generator((n % i == wrap_int(0) for i in nums))).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (= (mod x 15) 0) (= (mod x 27) 0)) (= (mod x 102) 0)) (and (< 0 x) (<= x 5000))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    4590)
)
### output for cvc5
sat
(
(define-fun x () Int 4590)
)

Found solution 4590
Yes! Solved for puzzle  LCM_multi:0

Solving puzzle 587/774: LCM_multi:1
sat_func def sat(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(46477686772963437), wrap_int(15649966299), wrap_int(37939312240), wrap_int(14036122804591), wrap_int(39209330717234)]), upper_bound=wrap_int(82396663973139497934429093888)):
    return all(sym_generator((n % i == wrap_int(0) for i in nums))).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (= (mod x 46477686772963437) 0) (= (mod x 15649966299) 0)) (= (mod x 37939312240) 0)) (= (mod x 14036122804591) 0)) (= (mod x 39209330717234) 0)) (and (< 0 x) (<= x 82396663973139497934429093888))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    50042020463197425387002406480)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 50042020463197425387002406480
Yes! Solved for puzzle  LCM_multi:1

Solving puzzle 588/774: LCM_multi:2
sat_func def sat(n: int, nums=[55040126016, 4373970014334], upper_bound=219074883886936):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(55040126016), wrap_int(4373970014334)]), upper_bound=wrap_int(219074883886936)):
    return all(sym_generator((n % i == wrap_int(0) for i in nums))).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod x 55040126016) 0) (= (mod x 4373970014334) 0)) (and (< 0 x) (<= x 219074883886936))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    139967040458688)
)
### output for cvc5
sat
(
(define-fun x () Int 139967040458688)
)

Found solution 139967040458688
Yes! Solved for puzzle  LCM_multi:2

Solving puzzle 589/774: LCM_multi:3
sat_func def sat(n: int, nums=[9140, 4882496600, 119119770064, 107772494796, 102424668, 3656, 1188591500932, 116992, 14700627932, 997397016], upper_bound=238661269929569213628364588516267312050595558326272):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(9140), wrap_int(4882496600), wrap_int(119119770064), wrap_int(107772494796), wrap_int(102424668), wrap_int(3656), wrap_int(1188591500932), wrap_int(116992), wrap_int(14700627932), wrap_int(997397016)]), upper_bound=wrap_int(238661269929569213628364588516267312050595558326272)):
    return all(sym_generator((n % i == wrap_int(0) for i in nums))).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (and (and (and (and (and (and (and (and (= (mod x 9140) 0) (= (mod x 4882496600) 0)) (= (mod x 119119770064) 0)) (= (mod x 107772494796) 0)) (= (mod x 102424668) 0)) (= (mod x 3656) 0)) (= (mod x 1188591500932) 0)) (= (mod x 116992) 0)) (= (mod x 14700627932) 0)) (= (mod x 997397016) 0)) (and (< 0 x) (<= x 238661269929569213628364588516267312050595558326272))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    121155327663293093558667262542122448691120854355200)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 121155327663293093558667262542122448691120854355200
Yes! Solved for puzzle  LCM_multi:3

Solving puzzle 590/774: LCM_multi:4
sat_func def sat(n: int, nums=[173261568, 4270662976], upper_bound=17025943527197098):
    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound
modified_func def sat(n: int, nums=wrap_list([wrap_int(173261568), wrap_int(4270662976)]), upper_bound=wrap_int(17025943527197098)):
    return all(sym_generator((n % i == wrap_int(0) for i in nums))).__and__((wrap_int(0) < n).__and__(n <= upper_bound))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (= (mod x 173261568) 0) (= (mod x 4270662976) 0)) (and (< 0 x) (<= x 17025943527197098))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    11561590056582912)
)
### output for cvc5
sat
(
(define-fun x () Int 11561590056582912)
)

Found solution 11561590056582912
Yes! Solved for puzzle  LCM_multi:4

Solving puzzle 591/774: SmallExponentBigSolution:0
sat_func def sat(n: int, b=2, target=5):
    return (b ** n) % n == target
modified_func def sat(n: int, b=wrap_int(2), target=wrap_int(5)):
    return b ** n % n == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (mod (^ 2 x) x) 5))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    0)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    5)
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2 x)")

Found solution 0
Exception in checking result: integer modulo by zero
WARNING: Solution verification failed for puzzle SmallExponentBigSolution:0
Too many constants for extrapolation

Solving puzzle 592/774: SmallExponentBigSolution:1
sat_func def sat(n: int, b=2, target=3):
    return (b ** n) % n == target
modified_func def sat(n: int, b=wrap_int(2), target=wrap_int(3)):
    return b ** n % n == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (mod (^ 2 x) x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    0)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    3)
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 2 x)")

Found solution 0
Exception in checking result: integer modulo by zero
WARNING: Solution verification failed for puzzle SmallExponentBigSolution:1
Too many constants for extrapolation

Solving puzzle 593/774: SmallExponentBigSolution:2
sat_func def sat(n: int, b=1, target=2):
    return (b ** n) % n == target
modified_func def sat(n: int, b=wrap_int(1), target=wrap_int(2)):
    return b ** n % n == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (mod (^ 1 x) x) 2))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    0)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    2)
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 1 x)")

Found solution 0
Exception in checking result: integer modulo by zero
WARNING: Solution verification failed for puzzle SmallExponentBigSolution:2
Too many constants for extrapolation

Solving puzzle 594/774: SmallExponentBigSolution:3
sat_func def sat(n: int, b=69, target=2):
    return (b ** n) % n == target
modified_func def sat(n: int, b=wrap_int(69), target=wrap_int(2)):
    return b ** n % n == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (mod (^ 69 x) x) 2))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    0)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    2)
)
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ 69 x)")

Found solution 0
Exception in checking result: integer modulo by zero
WARNING: Solution verification failed for puzzle SmallExponentBigSolution:3
Too many constants for extrapolation

Solving puzzle 595/774: Factoring:0
sat_func def sat(i: int, n=241864633):
    return 1 < i < n and n % i == 0
modified_func def sat(i: int, n=wrap_int(241864633)):
    return (wrap_int(1) < i).__and__(i < n).__and__(n % i == wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (< 1 x) (< x 241864633)) (= (mod 241864633 x) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    14543)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    16631)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution 14543
Yes! Solved for puzzle  Factoring:0

Solving puzzle 596/774: Factoring:1
sat_func def sat(i: int, n=16):
    return 1 < i < n and n % i == 0
modified_func def sat(i: int, n=wrap_int(16)):
    return (wrap_int(1) < i).__and__(i < n).__and__(n % i == wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (< 1 x) (< x 16)) (= (mod 16 x) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2)
)
### output for cvc5
sat
(
(define-fun x () Int 2)
)

Found solution 2
Yes! Solved for puzzle  Factoring:1

Solving puzzle 597/774: Factoring:2
sat_func def sat(i: int, n=1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139):
    return 1 < i < n and n % i == 0
modified_func def sat(i: int, n=wrap_int(1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139)):
    return (wrap_int(1) < i).__and__(i < n).__and__(n % i == wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (< 1 x) (< x 1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139)) (= (mod 1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139 x) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Factoring:2
One large constant for extrapolation
Solving simpler variation replaced 1522605027922533360535618378132637429718068114961380688657908494580122963258952897654000350692006139 with 3
sat_func def sat(i: int, n=3):
    return 1 < i < n and n % i == 0
modified_func def sat(i: int, n=wrap_int(3)):
    return (wrap_int(1) < i).__and__(i < n).__and__(n % i == wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (< 1 x) (< x 3)) (= (mod 3 x) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Factoring:2

Solving puzzle 598/774: Factoring:3
sat_func def sat(i: int, n=35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667):
    return 1 < i < n and n % i == 0
modified_func def sat(i: int, n=wrap_int(35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667)):
    return (wrap_int(1) < i).__and__(i < n).__and__(n % i == wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (< 1 x) (< x 35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667)) (= (mod 35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667 x) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Factoring:3
One large constant for extrapolation
Solving simpler variation replaced 35794234179725868774991807832568455403003778024228226193532908190484670252364677411513516111204504060317568667 with 3
sat_func def sat(i: int, n=3):
    return 1 < i < n and n % i == 0
modified_func def sat(i: int, n=wrap_int(3)):
    return (wrap_int(1) < i).__and__(i < n).__and__(n % i == wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (< 1 x) (< x 3)) (= (mod 3 x) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Factoring:3

Solving puzzle 599/774: Factoring:4
sat_func def sat(i: int, n=3363):
    return 1 < i < n and n % i == 0
modified_func def sat(i: int, n=wrap_int(3363)):
    return (wrap_int(1) < i).__and__(i < n).__and__(n % i == wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (and (< 1 x) (< x 3363)) (= (mod 3363 x) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    1121)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 1121)
)

Found solution 3
Yes! Solved for puzzle  Factoring:4

Solving puzzle 600/774: DiscreteLog:0
sat_func def sat(n: int, g=44337, p=69337, t=38187):
    return pow(g, n, p) == t
modified_func def sat(n: int, g=wrap_int(44337), p=wrap_int(69337), t=wrap_int(38187)):
    return pow(g, n, p) == t
Exception -- for puzzle DiscreteLog:0 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 601/774: DiscreteLog:1
sat_func def sat(n: int, g=7, p=204706270385532838059744535166974274803608394340123459695798674591526591372685229510652847339705797622075505069831043486651682279, t=127402180119973946824269244334322849749382042586931621654557735290322914679095998681860978813046595166455458144280588076766033781):
    return pow(g, n, p) == t
modified_func def sat(n: int, g=wrap_int(7), p=wrap_int(204706270385532838059744535166974274803608394340123459695798674591526591372685229510652847339705797622075505069831043486651682279), t=wrap_int(127402180119973946824269244334322849749382042586931621654557735290322914679095998681860978813046595166455458144280588076766033781)):
    return pow(g, n, p) == t
Exception -- for puzzle DiscreteLog:1 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 602/774: DiscreteLog:2
sat_func def sat(n: int, g=13, p=21, t=1):
    return pow(g, n, p) == t
modified_func def sat(n: int, g=wrap_int(13), p=wrap_int(21), t=wrap_int(1)):
    return pow(g, n, p) == t
Exception -- for puzzle DiscreteLog:2 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 603/774: DiscreteLog:3
sat_func def sat(n: int, g=101873924449108026052, p=576036946901458671597, t=330515716425197141833):
    return pow(g, n, p) == t
modified_func def sat(n: int, g=wrap_int(101873924449108026052), p=wrap_int(576036946901458671597), t=wrap_int(330515716425197141833)):
    return pow(g, n, p) == t
Exception -- for puzzle DiscreteLog:3 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 604/774: DiscreteLog:4
sat_func def sat(n: int, g=1696881788, p=8006168143, t=7111327686):
    return pow(g, n, p) == t
modified_func def sat(n: int, g=wrap_int(1696881788), p=wrap_int(8006168143), t=wrap_int(7111327686)):
    return pow(g, n, p) == t
Exception -- for puzzle DiscreteLog:4 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 605/774: GCD17:0
sat_func def sat(n: int):
    i = n ** 17 + 9
    j = (n + 1) ** 17 + 9

    while i != 0:  # compute gcd using Euclid's algorithm
        (i, j) = (j % i, i)

    return n >= 0 and j != 1
modified_func def sat(n: int):
    i = n ** wrap_int(17) + wrap_int(9)
    j = (n + wrap_int(1)) ** wrap_int(17) + wrap_int(9)
    while i != wrap_int(0):
        i, j = (j % i, i)
    return (n >= wrap_int(0)).__and__(j != wrap_int(1))
Timed out for puzzle GCD17:0

Solving puzzle 606/774: CollatzCycleUnsolved:0
sat_func def sat(n: int):
    m = n
    while n > 4:
        n = 3 * n + 1 if n % 2 else n // 2
        if n == m:
            return True
modified_func def sat(n: int):
    m = n
    while n > wrap_int(4):
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) else n // wrap_int(2)
        if n == m:
            return True
Exception -- for puzzle CollatzCycleUnsolved:0 some arg is none: (MockExpr(op='not', args=(MockExpr(op='>', args=(MockExpr(op='Int', args=('x',), _name=None), MockExpr(op='IntVal', args=(4,), _name=None)), _name=None),), _name=None), None)

Solving puzzle 607/774: CollatzGeneralizedUnsolved:0
sat_func def sat(start: int):
    n = start  # could be positive or negative ...
    while abs(n) > 1000:
        n = 3 * n + 1 if n % 2 else n // 2
        if n == start:
            return True
modified_func def sat(start: int):
    n = start
    while abs(n) > wrap_int(1000):
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) else n // wrap_int(2)
        if n == start:
            return True
Exception -- for puzzle CollatzGeneralizedUnsolved:0 some arg is none: (MockExpr(op='not', args=(MockExpr(op='>', args=(MockExpr(op='ite', args=(MockExpr(op='>=', args=[MockExpr(op='Int', args=('x',), _name=None), 0], _name=None), MockExpr(op='Int', args=('x',), _name=None), MockExpr(op='-', args=[MockExpr(op='Int', args=('x',), _name=None)], _name=None)), _name=None), MockExpr(op='IntVal', args=(1000,), _name=None)), _name=None),), _name=None), None)

Solving puzzle 608/774: CollatzDelay:0
sat_func def sat(n: int, t=197, upper=20):
    m = n
    for i in range(t):
        if n <= 1:
            return False
        n = 3 * n + 1 if n % 2 else n // 2
    return n == 1 and m <= 2 ** upper
modified_func def sat(n: int, t=wrap_int(197), upper=wrap_int(20)):
    m = n
    for i in sym_range(t):
        if n <= wrap_int(1):
            return False
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) else n // wrap_int(2)
    return (n == wrap_int(1)).__and__(m <= wrap_int(2) ** upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (<= x 1) false))
(assert (=> (and (not (<= x 1)) (not (<= (+ (* 3 x) 1) 1)) (not (<= (+ (* 3 (+ (* 3 x) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1)) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1)) 1)) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1)) 1)) 1)) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1) 1)) (not (<= (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1)) 1) 1)) (not (<= (+...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 6 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle CollatzDelay:0
One large constant for extrapolation
Solving simpler variation replaced 197 with 3
sat_func def sat(n: int, t=3, upper=20):
    m = n
    for i in range(t):
        if n <= 1:
            return False
        n = 3 * n + 1 if n % 2 else n // 2
    return n == 1 and m <= 2 ** upper
modified_func def sat(n: int, t=wrap_int(3), upper=wrap_int(20)):
    m = n
    for i in sym_range(t):
        if n <= wrap_int(1):
            return False
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) else n // wrap_int(2)
    return (n == wrap_int(1)).__and__(m <= wrap_int(2) ** upper)
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (=> (<= x 1) false))
(assert (=> (and (not (<= x 1)) (not (<= (+ (* 3 x) 1) 1)) (not (<= (+ (* 3 (+ (* 3 x) 1)) 1) 1))) (and (= (+ (* 3 (+ (* 3 (+ (* 3 x) 1)) 1)) 1) 1) (<= x 400))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 6 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle CollatzDelay:0

Solving puzzle 609/774: CollatzDelay:1
sat_func def sat(n: int, t=1000, upper=150):
    m = n
    for i in range(t):
        if n <= 1:
            return False
        n = 3 * n + 1 if n % 2 else n // 2
    return n == 1 and m <= 2 ** upper
modified_func def sat(n: int, t=wrap_int(1000), upper=wrap_int(150)):
    m = n
    for i in sym_range(t):
        if n <= wrap_int(1):
            return False
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) else n // wrap_int(2)
    return (n == wrap_int(1)).__and__(m <= wrap_int(2) ** upper)
Exception -- for puzzle CollatzDelay:1 maximum recursion depth exceeded

Solving puzzle 610/774: CollatzDelay:2
sat_func def sat(n: int, t=2000, upper=206):
    m = n
    for i in range(t):
        if n <= 1:
            return False
        n = 3 * n + 1 if n % 2 else n // 2
    return n == 1 and m <= 2 ** upper
modified_func def sat(n: int, t=wrap_int(2000), upper=wrap_int(206)):
    m = n
    for i in sym_range(t):
        if n <= wrap_int(1):
            return False
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) else n // wrap_int(2)
    return (n == wrap_int(1)).__and__(m <= wrap_int(2) ** upper)
Exception -- for puzzle CollatzDelay:2 maximum recursion depth exceeded

Solving puzzle 611/774: CollatzDelay:3
sat_func def sat(n: int, t=2283, upper=238):
    m = n
    for i in range(t):
        if n <= 1:
            return False
        n = 3 * n + 1 if n % 2 else n // 2
    return n == 1 and m <= 2 ** upper
modified_func def sat(n: int, t=wrap_int(2283), upper=wrap_int(238)):
    m = n
    for i in sym_range(t):
        if n <= wrap_int(1):
            return False
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) else n // wrap_int(2)
    return (n == wrap_int(1)).__and__(m <= wrap_int(2) ** upper)
Exception -- for puzzle CollatzDelay:3 maximum recursion depth exceeded

Solving puzzle 612/774: Lehmer:0
sat_func def sat(n: int):
    return pow(2, n, n) == 3
modified_func def sat(n: int):
    return pow(wrap_int(2), n, n) == wrap_int(3)
Exception -- for puzzle Lehmer:0 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 613/774: BirthdayParadox:0
sat_func def sat(n: int, year_len=365):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
modified_func def sat(n: int, year_len=wrap_int(365)):
    prob = 1.0
    for i in sym_range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** wrap_int(2) <= wrap_int(1) / year_len
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= (^ (- (* (/ (- 365 i_0) 365) 1.0) 0.5) 2) (/ 1 365)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.104: expecting same arithmetic types to POW")

Found solution 0
WARNING: Solution verification failed for puzzle BirthdayParadox:0
One large constant for extrapolation
Solving simpler variation replaced 365 with 3
sat_func def sat(n: int, year_len=3):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
modified_func def sat(n: int, year_len=wrap_int(3)):
    prob = 1.0
    for i in sym_range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** wrap_int(2) <= wrap_int(1) / year_len
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= (^ (- (* (/ (- 3 i_0) 3) 1.0) 0.5) 2) (/ 1 3)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.100: expecting same arithmetic types to POW")

Found solution 0

Solving puzzle 614/774: BirthdayParadox:1
sat_func def sat(n: int, year_len=60182):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
modified_func def sat(n: int, year_len=wrap_int(60182)):
    prob = 1.0
    for i in sym_range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** wrap_int(2) <= wrap_int(1) / year_len
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= (^ (- (* (/ (- 60182 i_0) 60182) 1.0) 0.5) 2) (/ 1 60182)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.108: expecting same arithmetic types to POW")

Found solution 0
WARNING: Solution verification failed for puzzle BirthdayParadox:1
One large constant for extrapolation
Solving simpler variation replaced 60182 with 3
sat_func def sat(n: int, year_len=3):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
modified_func def sat(n: int, year_len=wrap_int(3)):
    prob = 1.0
    for i in sym_range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** wrap_int(2) <= wrap_int(1) / year_len
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= (^ (- (* (/ (- 3 i_0) 3) 1.0) 0.5) 2) (/ 1 3)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.100: expecting same arithmetic types to POW")

Found solution 0

Solving puzzle 615/774: BirthdayParadox:2
sat_func def sat(n: int, year_len=2):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
modified_func def sat(n: int, year_len=wrap_int(2)):
    prob = 1.0
    for i in sym_range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** wrap_int(2) <= wrap_int(1) / year_len
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= (^ (- (* (/ (- 2 i_0) 2) 1.0) 0.5) 2) (/ 1 2)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.100: expecting same arithmetic types to POW")

Found solution 0
Yes! Solved for puzzle  BirthdayParadox:2

Solving puzzle 616/774: BirthdayParadox:3
sat_func def sat(n: int, year_len=3):
    prob = 1.0
    for i in range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** 2 <= 1/year_len
modified_func def sat(n: int, year_len=wrap_int(3)):
    prob = 1.0
    for i in sym_range(n):
        prob *= (year_len - i) / year_len
    return (prob - 0.5) ** wrap_int(2) <= wrap_int(1) / year_len
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 x)) (<= (^ (- (* (/ (- 3 i_0) 3) 1.0) 0.5) 2) (/ 1 3)))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.100: expecting same arithmetic types to POW")

Found solution 0
Yes! Solved for puzzle  BirthdayParadox:3

Solving puzzle 617/774: BirthdayParadoxMonteCarlo:0
sat_func def sat(n: int, year_len=365):
    import random
    random.seed(0)
    K = 1000  # number of samples
    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K
    return (prob - 0.5) ** 2 <= year_len
modified_func def sat(n: int, year_len=wrap_int(365)):
    import random
    random.seed(wrap_int(0))
    K = wrap_int(1000)
    prob = sym_sum(sym_generator((sym_len({random.randrange(year_len) for i in sym_range(n)}) < n for j in sym_range(K)))) / K
    return (prob - 0.5) ** wrap_int(2) <= year_len
Exception -- for puzzle BirthdayParadoxMonteCarlo:0 The only supported seed types are: None,
int, float, str, bytes, and bytearray.

Solving puzzle 618/774: BirthdayParadoxMonteCarlo:1
sat_func def sat(n: int, year_len=60182):
    import random
    random.seed(0)
    K = 1000  # number of samples
    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K
    return (prob - 0.5) ** 2 <= year_len
modified_func def sat(n: int, year_len=wrap_int(60182)):
    import random
    random.seed(wrap_int(0))
    K = wrap_int(1000)
    prob = sym_sum(sym_generator((sym_len({random.randrange(year_len) for i in sym_range(n)}) < n for j in sym_range(K)))) / K
    return (prob - 0.5) ** wrap_int(2) <= year_len
Exception -- for puzzle BirthdayParadoxMonteCarlo:1 The only supported seed types are: None,
int, float, str, bytes, and bytearray.

Solving puzzle 619/774: BirthdayParadoxMonteCarlo:2
sat_func def sat(n: int, year_len=2):
    import random
    random.seed(0)
    K = 1000  # number of samples
    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K
    return (prob - 0.5) ** 2 <= year_len
modified_func def sat(n: int, year_len=wrap_int(2)):
    import random
    random.seed(wrap_int(0))
    K = wrap_int(1000)
    prob = sym_sum(sym_generator((sym_len({random.randrange(year_len) for i in sym_range(n)}) < n for j in sym_range(K)))) / K
    return (prob - 0.5) ** wrap_int(2) <= year_len
Exception -- for puzzle BirthdayParadoxMonteCarlo:2 The only supported seed types are: None,
int, float, str, bytes, and bytearray.

Solving puzzle 620/774: BirthdayParadoxMonteCarlo:3
sat_func def sat(n: int, year_len=3):
    import random
    random.seed(0)
    K = 1000  # number of samples
    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K
    return (prob - 0.5) ** 2 <= year_len
modified_func def sat(n: int, year_len=wrap_int(3)):
    import random
    random.seed(wrap_int(0))
    K = wrap_int(1000)
    prob = sym_sum(sym_generator((sym_len({random.randrange(year_len) for i in sym_range(n)}) < n for j in sym_range(K)))) / K
    return (prob - 0.5) ** wrap_int(2) <= year_len
Exception -- for puzzle BirthdayParadoxMonteCarlo:3 The only supported seed types are: None,
int, float, str, bytes, and bytearray.

Solving puzzle 621/774: ExponentialProbability:0
sat_func def sat(p_stop: float, steps=10, target_prob=0.5):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(10), target_prob=0.5):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) 0.5) 0) (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) 0.5) (- (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) 0.5))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 779: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.71: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:0
Too many constants for extrapolation

Solving puzzle 622/774: ExponentialProbability:1
sat_func def sat(p_stop: float, steps=43, target_prob=0.2661542669448821):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(43), target_prob=0.2661542669448821):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) (* x (^ (- 1 x) 11))) (* x (^ (- 1 x) 12))) (* x (^ (- 1 x) 13))) (* x (^ (- 1 x) 14))) (* x (^ (- 1 x) 15))) (* x (^ (- 1 x) 16))) (* x (^ (- 1 x) 17))) (* x (^ (- 1 x) 18))) (* x (^ (- 1 x) 19))) (* x (^ (- 1 x) 20))) (* x (^ (- 1 x) 21))) (* x (^ (- 1 x) 22))) (* x (^ (- 1 x) 23))) (* x (^ (- 1 x) 24))) (* x (^ (- 1 x) 25))) (* x (^ (- 1 x) 26))) (* x (^ (- 1 x) 27))) (* x (^ (- 1 x) 28))) (* x (^ (- 1 x) 29))) (* x (^ (- 1 x) 30))) (* x (^ (- 1 x) 31))) (* x (^ (- 1 x) 32))) (* x (^ (- 1 x) 33))) (* x (^ (- 1 x) 34))) (* x (^ (- 1 x) 35))) (* x (^ (- 1 x) 36))) (* x (^ (- 1 x) 37))) (* x (^ (- 1 x) 38))...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 3299: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.170: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:1
One large constant for extrapolation
Solving simpler variation replaced 2661542669448821 with 3
sat_func def sat(p_stop: float, steps=43, target_prob=0.3):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(43), target_prob=0.3):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) (* x (^ (- 1 x) 11))) (* x (^ (- 1 x) 12))) (* x (^ (- 1 x) 13))) (* x (^ (- 1 x) 14))) (* x (^ (- 1 x) 15))) (* x (^ (- 1 x) 16))) (* x (^ (- 1 x) 17))) (* x (^ (- 1 x) 18))) (* x (^ (- 1 x) 19))) (* x (^ (- 1 x) 20))) (* x (^ (- 1 x) 21))) (* x (^ (- 1 x) 22))) (* x (^ (- 1 x) 23))) (* x (^ (- 1 x) 24))) (* x (^ (- 1 x) 25))) (* x (^ (- 1 x) 26))) (* x (^ (- 1 x) 27))) (* x (^ (- 1 x) 28))) (* x (^ (- 1 x) 29))) (* x (^ (- 1 x) 30))) (* x (^ (- 1 x) 31))) (* x (^ (- 1 x) 32))) (* x (^ (- 1 x) 33))) (* x (^ (- 1 x) 34))) (* x (^ (- 1 x) 35))) (* x (^ (- 1 x) 36))) (* x (^ (- 1 x) 37))) (* x (^ (- 1 x) 38))...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 3254: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.170: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:1

Solving puzzle 623/774: ExponentialProbability:2
sat_func def sat(p_stop: float, steps=91, target_prob=0.03729141037377781):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(91), target_prob=0.03729141037377781):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) (* x (^ (- 1 x) 11))) (* x (^ (- 1 x) 12))) (* x (^ (- 1 x) 13))) (* x (^ (- 1 x) 14))) (* x (^ (- 1 x) 15))) (* x (^ (- 1 x) 16))) (* x (^ (- 1 x) 17))) (* x (^ (- 1 x) 18))) (* x (^ (- 1 x) 19))) (* x (^ (- 1 x) 20))) (* x (^ (- 1 x) 21))) (* x (^ (- 1 x) 22))) (* x (^ (- 1 x) 23))) (* x (^ (- 1 x) 24))) (* x (^ (- 1 x) 25))) (* x (^ (- 1 x) 26))) (* x (^ (- 1 x) 27))) (* x (^ (- 1 x) 28))) (* x (^ (- 1 x) 29))) (* x (^ (- 1 x) 30))) (* x (^ (- 1 x) 31))) (* x (^ ...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 6902: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.314: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:2
One large constant for extrapolation
Solving simpler variation replaced 03729141037377781 with 3
sat_func def sat(p_stop: float, steps=91, target_prob=0.3):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(91), target_prob=0.3):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) (* x (^ (- 1 x) 11))) (* x (^ (- 1 x) 12))) (* x (^ (- 1 x) 13))) (* x (^ (- 1 x) 14))) (* x (^ (- 1 x) 15))) (* x (^ (- 1 x) 16))) (* x (^ (- 1 x) 17))) (* x (^ (- 1 x) 18))) (* x (^ (- 1 x) 19))) (* x (^ (- 1 x) 20))) (* x (^ (- 1 x) 21))) (* x (^ (- 1 x) 22))) (* x (^ (- 1 x) 23))) (* x (^ (- 1 x) 24))) (* x (^ (- 1 x) 25))) (* x (^ (- 1 x) 26))) (* x (^ (- 1 x) 27))) (* x (^ (- 1 x) 28))) (* x (^ (- 1 x) 29))) (* x (^ (- 1 x) 30))) (* x (^ (- 1 x) 31))) (* x (^ ...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 6854: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.314: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:2

Solving puzzle 624/774: ExponentialProbability:3
sat_func def sat(p_stop: float, steps=11, target_prob=0.9742781783529525):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(11), target_prob=0.9742781783529525):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) 0.9742781783529525) 0) (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) 0.9742781783529525) (- (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) 0.9742781783529525))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 899: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.74: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:3
One large constant for extrapolation
Solving simpler variation replaced 9742781783529525 with 3
sat_func def sat(p_stop: float, steps=11, target_prob=0.3):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(11), target_prob=0.3):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) 0.3) 0) (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) 0.3) (- (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) 0.3))) 1e-06))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 854: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.74: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:3

Solving puzzle 625/774: ExponentialProbability:4
sat_func def sat(p_stop: float, steps=65, target_prob=0.8318555442956944):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(65), target_prob=0.8318555442956944):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) (* x (^ (- 1 x) 11))) (* x (^ (- 1 x) 12))) (* x (^ (- 1 x) 13))) (* x (^ (- 1 x) 14))) (* x (^ (- 1 x) 15))) (* x (^ (- 1 x) 16))) (* x (^ (- 1 x) 17))) (* x (^ (- 1 x) 18))) (* x (^ (- 1 x) 19))) (* x (^ (- 1 x) 20))) (* x (^ (- 1 x) 21))) (* x (^ (- 1 x) 22))) (* x (^ (- 1 x) 23))) (* x (^ (- 1 x) 24))) (* x (^ (- 1 x) 25))) (* x (^ (- 1 x) 26))) (* x (^ (- 1 x) 27))) (* x (^ (- 1 x) 28))) (* x (^ (- 1 x) 29))) (* x (^ (- 1 x) 30))) (* x (^ (- 1 x) 31))) (* x (^ (- 1 x) 32))) (* x (^ (- 1 x) 33))) (* x (^ (- 1 x) 34))) (* x (^ (- 1 x) 35))...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 4949: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.236: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:4
One large constant for extrapolation
Solving simpler variation replaced 8318555442956944 with 3
sat_func def sat(p_stop: float, steps=65, target_prob=0.3):
    prob = sum(p_stop*(1-p_stop)**t for t in range(steps))
    return abs(prob - target_prob) < 1e-6
modified_func def sat(p_stop: float, steps=wrap_int(65), target_prob=0.3):
    prob = sym_sum(sym_generator((p_stop * (wrap_int(1) - p_stop) ** t for t in sym_range(steps))))
    return abs(prob - target_prob) < 1e-06
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (* x (^ (- 1 x) 0)) 0) (* x (^ (- 1 x) 1))) (* x (^ (- 1 x) 2))) (* x (^ (- 1 x) 3))) (* x (^ (- 1 x) 4))) (* x (^ (- 1 x) 5))) (* x (^ (- 1 x) 6))) (* x (^ (- 1 x) 7))) (* x (^ (- 1 x) 8))) (* x (^ (- 1 x) 9))) (* x (^ (- 1 x) 10))) (* x (^ (- 1 x) 11))) (* x (^ (- 1 x) 12))) (* x (^ (- 1 x) 13))) (* x (^ (- 1 x) 14))) (* x (^ (- 1 x) 15))) (* x (^ (- 1 x) 16))) (* x (^ (- 1 x) 17))) (* x (^ (- 1 x) 18))) (* x (^ (- 1 x) 19))) (* x (^ (- 1 x) 20))) (* x (^ (- 1 x) 21))) (* x (^ (- 1 x) 22))) (* x (^ (- 1 x) 23))) (* x (^ (- 1 x) 24))) (* x (^ (- 1 x) 25))) (* x (^ (- 1 x) 26))) (* x (^ (- 1 x) 27))) (* x (^ (- 1 x) 28))) (* x (^ (- 1 x) 29))) (* x (^ (- 1 x) 30))) (* x (^ (- 1 x) 31))) (* x (^ (- 1 x) 32))) (* x (^ (- 1 x) 33))) (* x (^ (- 1 x) 34))) (* x (^ (- 1 x) 35))...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
(error "line 3 column 4904: unknown constant e-06")
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.236: expecting same arithmetic types to POW")

Could not find any solution for puzzle ExponentialProbability:4

Solving puzzle 626/774: HelloWorld:0
sat_func def sat(s: str):
    return s + 'world' == 'Hello world'
modified_func def sat(s: str):
    return s + wrap_str('world') == wrap_str('Hello world')
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.++ x "world") "Hello world"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "Hello ")
)
### output for cvc5
sat
(
(define-fun x () String "Hello ")
)

Found solution Hello 
Yes! Solved for puzzle  HelloWorld:0

Solving puzzle 627/774: BackWorlds:0
sat_func def sat(s: str):
    return s[::-1] + 'world' == 'Hello world'
modified_func def sat(s: str):
    return s[::-1] + wrap_str('world') == wrap_str('Hello world')
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (= (str.++ (str.reverse x) "world") "Hello world"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    " olleH")
)
### output for cvc5
sat
(
(define-fun x () String " olleH")
)

Found solution  olleH
Yes! Solved for puzzle  BackWorlds:0

Solving puzzle 628/774: StrAdd:0
sat_func def sat(st: str, a="world", b="Hello world"):
    return st + a == b
modified_func def sat(st: str, a=wrap_str('world'), b=wrap_str('Hello world')):
    return st + a == b
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.++ x "world") "Hello world"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "Hello ")
)
### output for cvc5
sat
(
(define-fun x () String "Hello ")
)

Found solution Hello 
Yes! Solved for puzzle  StrAdd:0

Solving puzzle 629/774: StrAdd:1
sat_func def sat(st: str, a="zine", b="cerofilimybazine"):
    return st + a == b
modified_func def sat(st: str, a=wrap_str('zine'), b=wrap_str('cerofilimybazine')):
    return st + a == b
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.++ x "zine") "cerofilimybazine"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "cerofilimyba")
)
### output for cvc5
sat
(
(define-fun x () String "cerofilimyba")
)

Found solution cerofilimyba
Yes! Solved for puzzle  StrAdd:1

Solving puzzle 630/774: StrAdd:2
sat_func def sat(st: str, a="id", b="xakid"):
    return st + a == b
modified_func def sat(st: str, a=wrap_str('id'), b=wrap_str('xakid')):
    return st + a == b
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.++ x "id") "xakid"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "xak")
)
### output for cvc5
sat
(
(define-fun x () String "xak")
)

Found solution xak
Yes! Solved for puzzle  StrAdd:2

Solving puzzle 631/774: StrAdd:3
sat_func def sat(st: str, a="dyr", b="dyr"):
    return st + a == b
modified_func def sat(st: str, a=wrap_str('dyr'), b=wrap_str('dyr')):
    return st + a == b
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.++ x "dyr") "dyr"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution 
Yes! Solved for puzzle  StrAdd:3

Solving puzzle 632/774: StrAdd:4
sat_func def sat(st: str, a="s", b="tos"):
    return st + a == b
modified_func def sat(st: str, a=wrap_str('s'), b=wrap_str('tos')):
    return st + a == b
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.++ x "s") "tos"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "to")
)
### output for cvc5
sat
(
(define-fun x () String "to")
)

Found solution to
Yes! Solved for puzzle  StrAdd:4

Solving puzzle 633/774: StrSetLen:0
sat_func def sat(s: str, dups=2021):
    return len(set(s)) == len(s) - dups
modified_func def sat(s: str, dups=wrap_int(2021)):
    return sym_len(set(s)) == sym_len(s) - dups
Exception -- for puzzle StrSetLen:0 Symbolic hash not yet implemented

Solving puzzle 634/774: StrSetLen:1
sat_func def sat(s: str, dups=0):
    return len(set(s)) == len(s) - dups
modified_func def sat(s: str, dups=wrap_int(0)):
    return sym_len(set(s)) == sym_len(s) - dups
Exception -- for puzzle StrSetLen:1 Symbolic hash not yet implemented

Solving puzzle 635/774: StrSetLen:2
sat_func def sat(s: str, dups=1):
    return len(set(s)) == len(s) - dups
modified_func def sat(s: str, dups=wrap_int(1)):
    return sym_len(set(s)) == sym_len(s) - dups
Exception -- for puzzle StrSetLen:2 Symbolic hash not yet implemented

Solving puzzle 636/774: StrSetLen:3
sat_func def sat(s: str, dups=2):
    return len(set(s)) == len(s) - dups
modified_func def sat(s: str, dups=wrap_int(2)):
    return sym_len(set(s)) == sym_len(s) - dups
Exception -- for puzzle StrSetLen:3 Symbolic hash not yet implemented

Solving puzzle 637/774: StrMul:0
sat_func def sat(s: str, target="foofoofoofoo", n=2):
    return s * n == target
modified_func def sat(s: str, target=wrap_str('foofoofoofoo'), n=wrap_int(2)):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (= (str_multiply x 2) "foofoofoofoo"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "foofoo")
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution foofoo
Yes! Solved for puzzle  StrMul:0

Solving puzzle 638/774: StrMul:1
sat_func def sat(s: str, target="biquacagegichisykbiquacagegichisykbiquacagegichisyk", n=3):
    return s * n == target
modified_func def sat(s: str, target=wrap_str('biquacagegichisykbiquacagegichisykbiquacagegichisyk'), n=wrap_int(3)):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (= (str_multiply x 3) "biquacagegichisykbiquacagegichisykbiquacagegichisyk"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "biquacagegichisyk")
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution biquacagegichisyk
Yes! Solved for puzzle  StrMul:1

Solving puzzle 639/774: StrMul:2
sat_func def sat(s: str, target="hutextogoxanithiru", n=1):
    return s * n == target
modified_func def sat(s: str, target=wrap_str('hutextogoxanithiru'), n=wrap_int(1)):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (= (str_multiply x 1) "hutextogoxanithiru"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "hutextogoxanithiru")
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution hutextogoxanithiru
Yes! Solved for puzzle  StrMul:2

Solving puzzle 640/774: StrMul:3
sat_func def sat(s: str, target="sisisisisisisisisisisisisisi", n=7):
    return s * n == target
modified_func def sat(s: str, target=wrap_str('sisisisisisisisisisisisisisi'), n=wrap_int(7)):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (= (str_multiply x 7) "sisisisisisisisisisisisisisi"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "sisi")
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution sisi
Yes! Solved for puzzle  StrMul:3

Solving puzzle 641/774: StrMul:4
sat_func def sat(s: str, target="fuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxe", n=7):
    return s * n == target
modified_func def sat(s: str, target=wrap_str('fuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxe'), n=wrap_int(7)):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x String)
(assert (= (str_multiply x 7) "fuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxefuchomurybaxe"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "fuchomurybaxe")
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution fuchomurybaxe
Yes! Solved for puzzle  StrMul:4

Solving puzzle 642/774: StrMul2:0
sat_func def sat(n: int, target="foofoofoofoo", s="foofoo"):
    return s * n == target
modified_func def sat(n: int, target=wrap_str('foofoofoofoo'), s=wrap_str('foofoo')):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str_multiply "foofoo" x) "foofoofoofoo"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Could not find any solution for puzzle StrMul2:0
Too many constants for extrapolation

Solving puzzle 643/774: StrMul2:1
sat_func def sat(n: int, target="", s="jan"):
    return s * n == target
modified_func def sat(n: int, target=wrap_str(''), s=wrap_str('jan')):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str_multiply "jan" x) ""))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 0
Yes! Solved for puzzle  StrMul2:1

Solving puzzle 644/774: StrMul2:2
sat_func def sat(n: int, target="koquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyc", s="koquuwibehyc"):
    return s * n == target
modified_func def sat(n: int, target=wrap_str('koquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyc'), s=wrap_str('koquuwibehyc')):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str_multiply "koquuwibehyc" x) "koquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyckoquuwibehyc"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    7)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 7
Yes! Solved for puzzle  StrMul2:2

Solving puzzle 645/774: StrMul2:3
sat_func def sat(n: int, target="kasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyz", s="kasujyzkasujyz"):
    return s * n == target
modified_func def sat(n: int, target=wrap_str('kasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyz'), s=wrap_str('kasujyzkasujyz')):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str_multiply "kasujyzkasujyz" x) "kasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyzkasujyz"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 8
Yes! Solved for puzzle  StrMul2:3

Solving puzzle 646/774: StrMul2:4
sat_func def sat(n: int, target="kedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuth", s="kedezygijithequuthkedezygijithequuth"):
    return s * n == target
modified_func def sat(n: int, target=wrap_str('kedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuth'), s=wrap_str('kedezygijithequuthkedezygijithequuth')):
    return s * n == target
### smt2
(set-logic ALL)

(define-fun-rec str.rev ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.rev (str.substr s 0 (- (str.len s) 1))))))
(define-fun-rec str_multiply_helper ((s String) (n Int) (acc String)) String
  (ite (<= n 0)
    acc
    (str_multiply_helper s (- n 1) (str.++ acc s))))
(define-fun str_multiply ((s String) (n Int)) String
  (ite (< n 0)
    (str.rev (str_multiply_helper s (- 0 n) ""))
    (str_multiply_helper s n "")))

(declare-const x Int)
(assert (= (str_multiply "kedezygijithequuthkedezygijithequuth" x) "kedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuthkedezygijithequuth"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.17: Symbol `str.rev' is shadowing a theory function symbol")

Found solution 8
Yes! Solved for puzzle  StrMul2:4

Solving puzzle 647/774: StrLen:0
sat_func def sat(s: str, n=1000):
    return len(s) == n
modified_func def sat(s: str, n=wrap_int(1000)):
    return sym_len(s) == n
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 1000))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
)

Found solution AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Yes! Solved for puzzle  StrLen:0

Solving puzzle 648/774: StrLen:1
sat_func def sat(s: str, n=39):
    return len(s) == n
modified_func def sat(s: str, n=wrap_int(39)):
    return sym_len(s) == n
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 39))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg")
)
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
)

Found solution ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefg
Yes! Solved for puzzle  StrLen:1

Solving puzzle 649/774: StrLen:2
sat_func def sat(s: str, n=790):
    return len(s) == n
modified_func def sat(s: str, n=wrap_int(790)):
    return sym_len(s) == n
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 790))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
)

Found solution AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Yes! Solved for puzzle  StrLen:2

Solving puzzle 650/774: StrLen:3
sat_func def sat(s: str, n=485):
    return len(s) == n
modified_func def sat(s: str, n=wrap_int(485)):
    return sym_len(s) == n
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 485))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
)

Found solution AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Yes! Solved for puzzle  StrLen:3

Solving puzzle 651/774: StrLen:4
sat_func def sat(s: str, n=4031):
    return len(s) == n
modified_func def sat(s: str, n=wrap_int(4031)):
    return sym_len(s) == n
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.len x) 4031))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
)

Found solution AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Yes! Solved for puzzle  StrLen:4

Solving puzzle 652/774: StrAt:0
sat_func def sat(i: int, s="cat", target="a"):
    return s[i] == target
modified_func def sat(i: int, s=wrap_str('cat'), target=wrap_str('a')):
    return s[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (str.substr "cat" x (- (+ x 1) x)) "a"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1)
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution 1
Yes! Solved for puzzle  StrAt:0

Solving puzzle 653/774: StrAt:1
sat_func def sat(i: int, s="quadyquady", target="a"):
    return s[i] == target
modified_func def sat(i: int, s=wrap_str('quadyquady'), target=wrap_str('a')):
    return s[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (str.substr "quadyquady" x (- (+ x 1) x)) "a"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2)
)
### output for cvc5
sat
(
(define-fun x () Int 7)
)

Found solution 2
Yes! Solved for puzzle  StrAt:1

Solving puzzle 654/774: StrAt:2
sat_func def sat(i: int, s="quixatextofazejate", target="i"):
    return s[i] == target
modified_func def sat(i: int, s=wrap_str('quixatextofazejate'), target=wrap_str('i')):
    return s[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (str.substr "quixatextofazejate" x (- (+ x 1) x)) "i"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2)
)
### output for cvc5
sat
(
(define-fun x () Int 2)
)

Found solution 2
Yes! Solved for puzzle  StrAt:2

Solving puzzle 655/774: StrAt:3
sat_func def sat(i: int, s="thethe", target="e"):
    return s[i] == target
modified_func def sat(i: int, s=wrap_str('thethe'), target=wrap_str('e')):
    return s[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (str.substr "thethe" x (- (+ x 1) x)) "e"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2)
)
### output for cvc5
sat
(
(define-fun x () Int 5)
)

Found solution 2
Yes! Solved for puzzle  StrAt:3

Solving puzzle 656/774: StrAt:4
sat_func def sat(i: int, s="bucudibucudibucudi", target="b"):
    return s[i] == target
modified_func def sat(i: int, s=wrap_str('bucudibucudibucudi'), target=wrap_str('b')):
    return s[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (str.substr "bucudibucudibucudi" x (- (+ x 1) x)) "b"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Yes! Solved for puzzle  StrAt:4

Solving puzzle 657/774: StrNegAt:0
sat_func def sat(i: int, s="cat", target="a"):
    return s[i] == target and i < 0
modified_func def sat(i: int, s=wrap_str('cat'), target=wrap_str('a')):
    return (s[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= (str.substr "cat" x (- (+ x 1) x)) "a") (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle StrNegAt:0
Too many constants for extrapolation

Solving puzzle 658/774: StrNegAt:1
sat_func def sat(i: int, s="ch", target="c"):
    return s[i] == target and i < 0
modified_func def sat(i: int, s=wrap_str('ch'), target=wrap_str('c')):
    return (s[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= (str.substr "ch" x (- (+ x 1) x)) "c") (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle StrNegAt:1
Too many constants for extrapolation

Solving puzzle 659/774: StrNegAt:2
sat_func def sat(i: int, s="nydivimocuvacetext", target="y"):
    return s[i] == target and i < 0
modified_func def sat(i: int, s=wrap_str('nydivimocuvacetext'), target=wrap_str('y')):
    return (s[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= (str.substr "nydivimocuvacetext" x (- (+ x 1) x)) "y") (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle StrNegAt:2
Too many constants for extrapolation

Solving puzzle 660/774: StrNegAt:3
sat_func def sat(i: int, s="chyxchyx", target="x"):
    return s[i] == target and i < 0
modified_func def sat(i: int, s=wrap_str('chyxchyx'), target=wrap_str('x')):
    return (s[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= (str.substr "chyxchyx" x (- (+ x 1) x)) "x") (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle StrNegAt:3
Too many constants for extrapolation

Solving puzzle 661/774: StrNegAt:4
sat_func def sat(i: int, s="tuchuworyquofojyzusutuchuworyquofojyzusutuchuworyquofojyzusu", target="h"):
    return s[i] == target and i < 0
modified_func def sat(i: int, s=wrap_str('tuchuworyquofojyzusutuchuworyquofojyzusutuchuworyquofojyzusu'), target=wrap_str('h')):
    return (s[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= (str.substr "tuchuworyquofojyzusutuchuworyquofojyzusutuchuworyquofojyzusu" x (- (+ x 1) x)) "h") (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 5 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle StrNegAt:4
Too many constants for extrapolation

Solving puzzle 662/774: StrIndex:0
sat_func def sat(s: str, big_str="foobar", index=2):
    return big_str.index(s) == index
modified_func def sat(s: str, big_str=wrap_str('foobar'), index=wrap_int(2)):
    return big_str.index(s) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof "foobar" x 0) 2))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ob")
)
### output for cvc5
sat
(
(define-fun x () String "obar")
)

Found solution ob
Yes! Solved for puzzle  StrIndex:0

Solving puzzle 663/774: StrIndex:1
sat_func def sat(s: str, big_str="fukulagatextuj", index=10):
    return big_str.index(s) == index
modified_func def sat(s: str, big_str=wrap_str('fukulagatextuj'), index=wrap_int(10)):
    return big_str.index(s) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof "fukulagatextuj" x 0) 10))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "x")
)
### output for cvc5
sat
(
(define-fun x () String "xtuj")
)

Found solution x
Yes! Solved for puzzle  StrIndex:1

Solving puzzle 664/774: StrIndex:2
sat_func def sat(s: str, big_str="nunalurejijunopyrewithocukopojot", index=12):
    return big_str.index(s) == index
modified_func def sat(s: str, big_str=wrap_str('nunalurejijunopyrewithocukopojot'), index=wrap_int(12)):
    return big_str.index(s) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof "nunalurejijunopyrewithocukopojot" x 0) 12))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "no")
)
### output for cvc5
sat
(
(define-fun x () String "nopyrewithocukopojot")
)

Found solution no
Yes! Solved for puzzle  StrIndex:2

Solving puzzle 665/774: StrIndex:3
sat_func def sat(s: str, big_str="fu", index=1):
    return big_str.index(s) == index
modified_func def sat(s: str, big_str=wrap_str('fu'), index=wrap_int(1)):
    return big_str.index(s) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof "fu" x 0) 1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "u")
)
### output for cvc5
sat
(
(define-fun x () String "u")
)

Found solution u
Yes! Solved for puzzle  StrIndex:3

Solving puzzle 666/774: StrIndex:4
sat_func def sat(s: str, big_str="fatextemedyrotichipicecojon", index=24):
    return big_str.index(s) == index
modified_func def sat(s: str, big_str=wrap_str('fatextemedyrotichipicecojon'), index=wrap_int(24)):
    return big_str.index(s) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof "fatextemedyrotichipicecojon" x 0) 24))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "j")
)
### output for cvc5
sat
(
(define-fun x () String "jon")
)

Found solution j
Yes! Solved for puzzle  StrIndex:4

Solving puzzle 667/774: StrIndex2:0
sat_func def sat(big_str: str, sub_str="foobar", index=2):
    return big_str.index(sub_str) == index
modified_func def sat(big_str: str, sub_str=wrap_str('foobar'), index=wrap_int(2)):
    return big_str.index(sub_str) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof x "foobar" 0) 2))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "fffoobar")
)
### output for cvc5
sat
(
(define-fun x () String "AAfoobar")
)

Found solution fffoobar
Yes! Solved for puzzle  StrIndex2:0

Solving puzzle 668/774: StrIndex2:1
sat_func def sat(big_str: str, sub_str="quadox", index=75):
    return big_str.index(sub_str) == index
modified_func def sat(big_str: str, sub_str=wrap_str('quadox'), index=wrap_int(75)):
    return big_str.index(sub_str) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof x "quadox" 0) 75))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAquadox")
)

Found solution AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAquadox
Yes! Solved for puzzle  StrIndex2:1

Solving puzzle 669/774: StrIndex2:2
sat_func def sat(big_str: str, sub_str="votextymuvethic", index=880):
    return big_str.index(sub_str) == index
modified_func def sat(big_str: str, sub_str=wrap_str('votextymuvethic'), index=wrap_int(880)):
    return big_str.index(sub_str) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof x "votextymuvethic" 0) 880))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvotextymuvethic")
)

Found solution AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvotextymuvethic
Yes! Solved for puzzle  StrIndex2:2

Solving puzzle 670/774: StrIndex2:3
sat_func def sat(big_str: str, sub_str="pyrumymasekalihochyvibisamaquythifedetextityvath", index=0):
    return big_str.index(sub_str) == index
modified_func def sat(big_str: str, sub_str=wrap_str('pyrumymasekalihochyvibisamaquythifedetextityvath'), index=wrap_int(0)):
    return big_str.index(sub_str) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof x "pyrumymasekalihochyvibisamaquythifedetextityvath" 0) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "pyrumymasekalihochyvibisamaquythifedetextityvathpyrumymasekalihochyvibisamaquythifedetextityvath")
)
### output for cvc5
sat
(
(define-fun x () String "pyrumymasekalihochyvibisamaquythifedetextityvath")
)

Found solution pyrumymasekalihochyvibisamaquythifedetextityvathpyrumymasekalihochyvibisamaquythifedetextityvath
Yes! Solved for puzzle  StrIndex2:3

Solving puzzle 671/774: StrIndex2:4
sat_func def sat(big_str: str, sub_str="nofufaxunetextesitocedezyxuxexyfoquichitiracyquat", index=185):
    return big_str.index(sub_str) == index
modified_func def sat(big_str: str, sub_str=wrap_str('nofufaxunetextesitocedezyxuxexyfoquichitiracyquat'), index=wrap_int(185)):
    return big_str.index(sub_str) == index
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.indexof x "nofufaxunetextesitocedezyxuxexyfoquichitiracyquat" 0) 185))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnofufaxunetextesitocedezyxuxexyfoquichitiracyquat")
)

Found solution AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnofufaxunetextesitocedezyxuxexyfoquichitiracyquat
Yes! Solved for puzzle  StrIndex2:4

Solving puzzle 672/774: StrIn:0
sat_func def sat(s: str, a="hello", b="yellow", length=4):
    return len(s) == length and s in a and s in b
modified_func def sat(s: str, a=wrap_str('hello'), b=wrap_str('yellow'), length=wrap_int(4)):
    return (sym_len(s) == length).__and__(sym_in(s, a)).__and__(sym_in(s, b))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (= (str.len x) 4) (str.contains "hello" x)) (str.contains "yellow" x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "ello")
)
### output for cvc5
sat
(
(define-fun x () String "ello")
)

Found solution ello
Yes! Solved for puzzle  StrIn:0

Solving puzzle 673/774: StrIn:1
sat_func def sat(s: str, a="vuzogaguzechicowejeguthemeralic", b="kybyjifidoquifwejeguthemelihitextodeju", length=11):
    return len(s) == length and s in a and s in b
modified_func def sat(s: str, a=wrap_str('vuzogaguzechicowejeguthemeralic'), b=wrap_str('kybyjifidoquifwejeguthemelihitextodeju'), length=wrap_int(11)):
    return (sym_len(s) == length).__and__(sym_in(s, a)).__and__(sym_in(s, b))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (= (str.len x) 11) (str.contains "vuzogaguzechicowejeguthemeralic" x)) (str.contains "kybyjifidoquifwejeguthemelihitextodeju" x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "wejegutheme")
)
### output for cvc5
sat
(
(define-fun x () String "wejegutheme")
)

Found solution wejegutheme
Yes! Solved for puzzle  StrIn:1

Solving puzzle 674/774: StrIn:2
sat_func def sat(s: str, a="kehorithxyfurexatextoxivuquunusethawatextebu", b="pxyfurexatextoxivuquuwynicixo", length=20):
    return len(s) == length and s in a and s in b
modified_func def sat(s: str, a=wrap_str('kehorithxyfurexatextoxivuquunusethawatextebu'), b=wrap_str('pxyfurexatextoxivuquuwynicixo'), length=wrap_int(20)):
    return (sym_len(s) == length).__and__(sym_in(s, a)).__and__(sym_in(s, b))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (= (str.len x) 20) (str.contains "kehorithxyfurexatextoxivuquunusethawatextebu" x)) (str.contains "pxyfurexatextoxivuquuwynicixo" x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "xyfurexatextoxivuquu")
)
### output for cvc5
sat
(
(define-fun x () String "xyfurexatextoxivuquu")
)

Found solution xyfurexatextoxivuquu
Yes! Solved for puzzle  StrIn:2

Solving puzzle 675/774: StrIn:3
sat_func def sat(s: str, a="bafywihequyjicivicharyquynikixuhinyqu", b="syrapetagecvicharyquynirorazecheth", length=12):
    return len(s) == length and s in a and s in b
modified_func def sat(s: str, a=wrap_str('bafywihequyjicivicharyquynikixuhinyqu'), b=wrap_str('syrapetagecvicharyquynirorazecheth'), length=wrap_int(12)):
    return (sym_len(s) == length).__and__(sym_in(s, a)).__and__(sym_in(s, b))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (= (str.len x) 12) (str.contains "bafywihequyjicivicharyquynikixuhinyqu" x)) (str.contains "syrapetagecvicharyquynirorazecheth" x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "vicharyquyni")
)
### output for cvc5
sat
(
(define-fun x () String "vicharyquyni")
)

Found solution vicharyquyni
Yes! Solved for puzzle  StrIn:3

Solving puzzle 676/774: StrIn:4
sat_func def sat(s: str, a="diquatextaxubowafucevyhuquuthexitacavobychajexytextug", b="thachevolatvyhuquuthexitacavobyjokobuchudymal", length=20):
    return len(s) == length and s in a and s in b
modified_func def sat(s: str, a=wrap_str('diquatextaxubowafucevyhuquuthexitacavobychajexytextug'), b=wrap_str('thachevolatvyhuquuthexitacavobyjokobuchudymal'), length=wrap_int(20)):
    return (sym_len(s) == length).__and__(sym_in(s, a)).__and__(sym_in(s, b))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (and (= (str.len x) 20) (str.contains "diquatextaxubowafucevyhuquuthexitacavobychajexytextug" x)) (str.contains "thachevolatvyhuquuthexitacavobyjokobuchudymal" x)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "vyhuquuthexitacavoby")
)
### output for cvc5
sat
(
(define-fun x () String "vyhuquuthexitacavoby")
)

Found solution vyhuquuthexitacavoby
Yes! Solved for puzzle  StrIn:4

Solving puzzle 677/774: StrCount:0
sat_func def sat(string: str, substring="a", count=10, length=100):
    return string.count(substring) == count and len(string) == length
modified_func def sat(string: str, substring=wrap_str('a'), count=wrap_int(10), length=wrap_int(100)):
    return (string.count(substring) == count).__and__(sym_len(string) == length)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "a") 0))
(assert (and (= (str.count x "a") 10) (= (str.len x) 100)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "aaaaaaaaaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa")
)

Found solution aaaaaaaaaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa
Yes! Solved for puzzle  StrCount:0

Solving puzzle 678/774: StrCount:1
sat_func def sat(string: str, substring="ky", count=66, length=133):
    return string.count(substring) == count and len(string) == length
modified_func def sat(string: str, substring=wrap_str('ky'), count=wrap_int(66), length=wrap_int(133)):
    return (string.count(substring) == count).__and__(sym_len(string) == length)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "ky") 0))
(assert (and (= (str.count x "ky") 66) (= (str.len x) 133)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrCount:1
One large constant for extrapolation
Solving simpler variation replaced 133 with 3
sat_func def sat(string: str, substring="ky", count=66, length=3):
    return string.count(substring) == count and len(string) == length
modified_func def sat(string: str, substring=wrap_str('ky'), count=wrap_int(66), length=wrap_int(3)):
    return (string.count(substring) == count).__and__(sym_len(string) == length)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "ky") 0))
(assert (and (= (str.count x "ky") 66) (= (str.len x) 3)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 18 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle StrCount:1

Solving puzzle 679/774: StrCount:2
sat_func def sat(string: str, substring="jepy", count=87, length=650):
    return string.count(substring) == count and len(string) == length
modified_func def sat(string: str, substring=wrap_str('jepy'), count=wrap_int(87), length=wrap_int(650)):
    return (string.count(substring) == count).__and__(sym_len(string) == length)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "jepy") 0))
(assert (and (= (str.count x "jepy") 87) (= (str.len x) 650)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrCount:2
One large constant for extrapolation
Solving simpler variation replaced 650 with 3
sat_func def sat(string: str, substring="jepy", count=87, length=3):
    return string.count(substring) == count and len(string) == length
modified_func def sat(string: str, substring=wrap_str('jepy'), count=wrap_int(87), length=wrap_int(3)):
    return (string.count(substring) == count).__and__(sym_len(string) == length)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "jepy") 0))
(assert (and (= (str.count x "jepy") 87) (= (str.len x) 3)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 18 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle StrCount:2

Solving puzzle 680/774: StrCount:3
sat_func def sat(string: str, substring="hothyfyt", count=3, length=417):
    return string.count(substring) == count and len(string) == length
modified_func def sat(string: str, substring=wrap_str('hothyfyt'), count=wrap_int(3), length=wrap_int(417)):
    return (string.count(substring) == count).__and__(sym_len(string) == length)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "hothyfyt") 0))
(assert (and (= (str.count x "hothyfyt") 3) (= (str.len x) 417)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () String "hothyfythothyfytAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhothyfyt")
)

Found solution hothyfythothyfytAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhothyfyt
Yes! Solved for puzzle  StrCount:3

Solving puzzle 681/774: StrCount:4
sat_func def sat(string: str, substring="moz", count=70, length=210):
    return string.count(substring) == count and len(string) == length
modified_func def sat(string: str, substring=wrap_str('moz'), count=wrap_int(70), length=wrap_int(210)):
    return (string.count(substring) == count).__and__(sym_len(string) == length)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "moz") 0))
(assert (and (= (str.count x "moz") 70) (= (str.len x) 210)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrCount:4
One large constant for extrapolation
Solving simpler variation replaced 210 with 3
sat_func def sat(string: str, substring="moz", count=70, length=3):
    return string.count(substring) == count and len(string) == length
modified_func def sat(string: str, substring=wrap_str('moz'), count=wrap_int(70), length=wrap_int(3)):
    return (string.count(substring) == count).__and__(sym_len(string) == length)
### smt2
(set-logic ALL)

(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x String)
(assert (>= (str.count x "moz") 0))
(assert (and (= (str.count x "moz") 70) (= (str.len x) 3)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 18 column 10: model is not available")
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle StrCount:4

Solving puzzle 682/774: StrSplit:0
sat_func def sat(x: str, parts=['I', 'love', 'dumplings', '!'], length=100):
    return len(x) == length and x.split() == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('I'), wrap_str('love'), wrap_str('dumplings'), wrap_str('!')]), length=wrap_int(100)):
    return (sym_len(x) == length).__and__(x.split() == parts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (and (= (str.len x) 100) (= (str.split x " ") (cons "I" (cons "love" (cons "dumplings" (cons "!" (as nil (List String)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplit:0
One large constant for extrapolation
Solving simpler variation replaced 100 with 3
sat_func def sat(x: str, parts=['I', 'love', 'dumplings', '!'], length=3):
    return len(x) == length and x.split() == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('I'), wrap_str('love'), wrap_str('dumplings'), wrap_str('!')]), length=wrap_int(3)):
    return (sym_len(x) == length).__and__(x.split() == parts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (and (= (str.len x) 3) (= (str.split x " ") (cons "I" (cons "love" (cons "dumplings" (cons "!" (as nil (List String)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 138 column 10: model is not available")
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplit:0

Solving puzzle 683/774: StrSplit:1
sat_func def sat(x: str, parts=['thala', 'chaliriliq', 'chufyselikizap'], length=116):
    return len(x) == length and x.split() == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('thala'), wrap_str('chaliriliq'), wrap_str('chufyselikizap')]), length=wrap_int(116)):
    return (sym_len(x) == length).__and__(x.split() == parts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (and (= (str.len x) 116) (= (str.split x " ") (cons "thala" (cons "chaliriliq" (cons "chufyselikizap" (as nil (List String))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplit:1
One large constant for extrapolation
Solving simpler variation replaced 116 with 3
sat_func def sat(x: str, parts=['thala', 'chaliriliq', 'chufyselikizap'], length=3):
    return len(x) == length and x.split() == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('thala'), wrap_str('chaliriliq'), wrap_str('chufyselikizap')]), length=wrap_int(3)):
    return (sym_len(x) == length).__and__(x.split() == parts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (and (= (str.len x) 3) (= (str.split x " ") (cons "thala" (cons "chaliriliq" (cons "chufyselikizap" (as nil (List String))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
unsat
(error "line 138 column 10: model is not available")
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplit:1

Solving puzzle 684/774: StrSplit:2
sat_func def sat(x: str, parts=['lepytextati', 'ki', 'fy'], length=69):
    return len(x) == length and x.split() == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('lepytextati'), wrap_str('ki'), wrap_str('fy')]), length=wrap_int(69)):
    return (sym_len(x) == length).__and__(x.split() == parts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (and (= (str.len x) 69) (= (str.split x " ") (cons "lepytextati" (cons "ki" (cons "fy" (as nil (List String))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplit:2
Too many constants for extrapolation

Solving puzzle 685/774: StrSplit:3
sat_func def sat(x: str, parts=['quyhigechyhy'], length=38):
    return len(x) == length and x.split() == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('quyhigechyhy')]), length=wrap_int(38)):
    return (sym_len(x) == length).__and__(x.split() == parts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (and (= (str.len x) 38) (= (str.split x " ") (cons "quyhigechyhy" (as nil (List String))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplit:3
Too many constants for extrapolation

Solving puzzle 686/774: StrSplit:4
sat_func def sat(x: str, parts=['je', 'pojacyda', 'papucet', 'wesobaq'], length=40):
    return len(x) == length and x.split() == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('je'), wrap_str('pojacyda'), wrap_str('papucet'), wrap_str('wesobaq')]), length=wrap_int(40)):
    return (sym_len(x) == length).__and__(x.split() == parts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (and (= (str.len x) 40) (= (str.split x " ") (cons "je" (cons "pojacyda" (cons "papucet" (cons "wesobaq" (as nil (List String)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplit:4
Too many constants for extrapolation

Solving puzzle 687/774: StrSplitter:0
sat_func def sat(x: str, parts=['I', 'love', 'dumplings', '!', ''], string="I_love_dumplings_!_"):
    return string.split(x) == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('I'), wrap_str('love'), wrap_str('dumplings'), wrap_str('!'), wrap_str('')]), string=wrap_str('I_love_dumplings_!_')):
    return string.split(x) == parts
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (= (str.split "I_love_dumplings_!_" x) (cons "I" (cons "love" (cons "dumplings" (cons "!" (cons "" (as nil (List String)))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplitter:0
Too many constants for extrapolation

Solving puzzle 688/774: StrSplitter:1
sat_func def sat(x: str, parts=['kowot', 'quimimy'], string="kowottextihocavikirofegyfquimimy"):
    return string.split(x) == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('kowot'), wrap_str('quimimy')]), string=wrap_str('kowottextihocavikirofegyfquimimy')):
    return string.split(x) == parts
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (= (str.split "kowottextihocavikirofegyfquimimy" x) (cons "kowot" (cons "quimimy" (as nil (List String))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplitter:1
Too many constants for extrapolation

Solving puzzle 689/774: StrSplitter:2
sat_func def sat(x: str, parts=['f', 'thixaresiquagipoquas', 'fytylu', 'jywaxaw'], string="fdetthixaresiquagipoquasdetfytyludetjywaxaw"):
    return string.split(x) == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('f'), wrap_str('thixaresiquagipoquas'), wrap_str('fytylu'), wrap_str('jywaxaw')]), string=wrap_str('fdetthixaresiquagipoquasdetfytyludetjywaxaw')):
    return string.split(x) == parts
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (= (str.split "fdetthixaresiquagipoquasdetfytyludetjywaxaw" x) (cons "f" (cons "thixaresiquagipoquas" (cons "fytylu" (cons "jywaxaw" (as nil (List String))))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplitter:2
Too many constants for extrapolation

Solving puzzle 690/774: StrSplitter:3
sat_func def sat(x: str, parts=['tibuzumurun', 'hakebixutextolonyf', 'bothuraquobara'], string="tibuzumurunhocyxihakebixutextolonyfhocyxibothuraquobara"):
    return string.split(x) == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('tibuzumurun'), wrap_str('hakebixutextolonyf'), wrap_str('bothuraquobara')]), string=wrap_str('tibuzumurunhocyxihakebixutextolonyfhocyxibothuraquobara')):
    return string.split(x) == parts
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (= (str.split "tibuzumurunhocyxihakebixutextolonyfhocyxibothuraquobara" x) (cons "tibuzumurun" (cons "hakebixutextolonyf" (cons "bothuraquobara" (as nil (List String)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplitter:3
Too many constants for extrapolation

Solving puzzle 691/774: StrSplitter:4
sat_func def sat(x: str, parts=['fitextu', 'chythawequeku', 'th'], string="fitextufyhachochythawequekufyhachoth"):
    return string.split(x) == parts
modified_func def sat(x: str, parts=wrap_list([wrap_str('fitextu'), wrap_str('chythawequeku'), wrap_str('th')]), string=wrap_str('fitextufyhachochythawequekufyhachoth')):
    return string.split(x) == parts
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


; Helper function to check if a character matches the delimiter
(define-fun is-delimiter ((c String) (delim String)) Bool
  (= c delim))

; Helper function to get the substring from start to end (exclusive)
(define-fun substring ((s String) (start Int) (end Int)) String
  (let ((len (- end start)))
    (ite (or (< start 0) (< len 0) (> end (str.len s)))
         ""
         (str.substr s start len))))

; Recursive helper function to do the actual splitting
; This simulates a loop through the string
(define-fun-rec loop-split ((s String) (delim String) (start Int) (pos Int) 
                            (result (List String)) (len Int)) (List String)
  (ite (>= pos len)
       ; If we reached the end of the string, add the final substring
       (let ((final-part (substring s start len)))
         (cons final-part result))
       ; If not at the end, check if current character is a delimiter
       (ite (is-delimiter (str.at s pos) delim)
            ; If it's a delimiter, add the substring to result and continue
            (let ((part (substring s start pos)))
              (let ((new-result (cons part result)))
                (loop-split s delim (+ pos 1) (+ pos 1) new-result len)))
            ; If not a delimiter, just continue
            (loop-split s delim start (+ pos 1) result len))))

(define-fun str.split ((s String) (delim String)) (List String)
  (let ((len (str.len s)))
    (ite (= len 0)
         (cons "" (as nil (List String)))
         (let ((result (as nil (List String)))
               (start 0))
           ; We need to manually iterate through the string
           ; and build our list of substrings
           (let ((result (loop-split s delim 0 0 result len)))
             result)))))

(declare-const x String)
(assert (= (str.split "fitextufyhachochythawequekufyhachoth" x) (cons "fitextu" (cons "chythawequeku" (cons "th" (as nil (List String)))))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrSplitter:4
Too many constants for extrapolation

Solving puzzle 692/774: StrJoiner:0
sat_func def sat(x: str, parts=['I!!', '!love', 'dumplings', '!', ''], string="I!!!!!love!!dumplings!!!!!"):
    return x.join(parts) == string
modified_func def sat(x: str, parts=wrap_list([wrap_str('I!!'), wrap_str('!love'), wrap_str('dumplings'), wrap_str('!'), wrap_str('')]), string=wrap_str('I!!!!!love!!dumplings!!!!!')):
    return x.join(parts) == string
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x String)
(assert (= (python.join (cons "I!!" (cons "!love" (cons "dumplings" (cons "!" (cons "" (as nil (List String))))))) x) "I!!!!!love!!dumplings!!!!!"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!!")
)
### output for cvc5
sat
(
(define-fun x () String "!!")
)

Found solution !!
Yes! Solved for puzzle  StrJoiner:0

Solving puzzle 693/774: StrJoiner:1
sat_func def sat(x: str, parts=['tatext'], string="tatext"):
    return x.join(parts) == string
modified_func def sat(x: str, parts=wrap_list([wrap_str('tatext')]), string=wrap_str('tatext')):
    return x.join(parts) == string
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x String)
(assert (= (python.join (cons "tatext" (as nil (List String))) x) "tatext"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!0!")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution !0!
Yes! Solved for puzzle  StrJoiner:1

Solving puzzle 694/774: StrJoiner:2
sat_func def sat(x: str, parts=[], string=""):
    return x.join(parts) == string
modified_func def sat(x: str, parts=wrap_list([]), string=wrap_str('')):
    return x.join(parts) == string
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x String)
(assert (= (python.join (as nil (List String)) x) ""))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!0!")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution !0!
Yes! Solved for puzzle  StrJoiner:2

Solving puzzle 695/774: StrJoiner:3
sat_func def sat(x: str, parts=['ruquug'], string="ruquug"):
    return x.join(parts) == string
modified_func def sat(x: str, parts=wrap_list([wrap_str('ruquug')]), string=wrap_str('ruquug')):
    return x.join(parts) == string
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x String)
(assert (= (python.join (cons "ruquug" (as nil (List String))) x) "ruquug"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "!0!")
)
### output for cvc5
sat
(
(define-fun x () String "")
)

Found solution !0!
Yes! Solved for puzzle  StrJoiner:3

Solving puzzle 696/774: StrJoiner:4
sat_func def sat(x: str, parts=['numegixuly', 'koxyfihimurukothasyl'], string="numegixulypyjetkoxyfihimurukothasyl"):
    return x.join(parts) == string
modified_func def sat(x: str, parts=wrap_list([wrap_str('numegixuly'), wrap_str('koxyfihimurukothasyl')]), string=wrap_str('numegixulypyjetkoxyfihimurukothasyl')):
    return x.join(parts) == string
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

;; List utility functions
(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x String)
(assert (= (python.join (cons "numegixuly" (cons "koxyfihimurukothasyl" (as nil (List String)))) x) "numegixulypyjetkoxyfihimurukothasyl"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "pyjet")
)
### output for cvc5
sat
(
(define-fun x () String "pyjet")
)

Found solution pyjet
Yes! Solved for puzzle  StrJoiner:4

Solving puzzle 697/774: ListAt:0
sat_func def sat(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18):
    return li[i] == target
modified_func def sat(i: int, li=wrap_list([wrap_int(17), wrap_int(31), wrap_int(91), wrap_int(18), wrap_int(42), wrap_int(1), wrap_int(9)]), target=wrap_int(18)):
    return li[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 7))
(assert (> x -7))
(assert (= (ite (or (= x 6) (= x -1)) 9 (ite (or (= x 5) (= x -2)) 1 (ite (or (= x 4) (= x -3)) 42 (ite (or (= x 3) (= x -4)) 18 (ite (or (= x 2) (= x -5)) 91 (ite (or (= x 1) (= x -6)) 31 17)))))) 18))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 4))
)
### output for cvc5
sat
(
(define-fun x () Int 3)
)

Found solution -4
Yes! Solved for puzzle  ListAt:0

Solving puzzle 698/774: ListAt:1
sat_func def sat(i: int, li=[-62, -29, 73, -21, -45, -20, -74, -69, 30, -25, 16, 82, -31, 93, -20, 75, 68, 86], target=73):
    return li[i] == target
modified_func def sat(i: int, li=wrap_list([-wrap_int(62), -wrap_int(29), wrap_int(73), -wrap_int(21), -wrap_int(45), -wrap_int(20), -wrap_int(74), -wrap_int(69), wrap_int(30), -wrap_int(25), wrap_int(16), wrap_int(82), -wrap_int(31), wrap_int(93), -wrap_int(20), wrap_int(75), wrap_int(68), wrap_int(86)]), target=wrap_int(73)):
    return li[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 18))
(assert (> x -18))
(assert (= (ite (or (= x 17) (= x -1)) 86 (ite (or (= x 16) (= x -2)) 68 (ite (or (= x 15) (= x -3)) 75 (ite (or (= x 14) (= x -4)) -20 (ite (or (= x 13) (= x -5)) 93 (ite (or (= x 12) (= x -6)) -31 (ite (or (= x 11) (= x -7)) 82 (ite (or (= x 10) (= x -8)) 16 (ite (or (= x 9) (= x -9)) -25 (ite (or (= x 8) (= x -10)) 30 (ite (or (= x 7) (= x -11)) -69 (ite (or (= x 6) (= x -12)) -74 (ite (or (= x 5) (= x -13)) -20 (ite (or (= x 4) (= x -14)) -45 (ite (or (= x 3) (= x -15)) -21 (ite (or (= x 2) (= x -16)) 73 (ite (or (= x 1) (= x -17)) -29 -62))))))))))))))))) 73))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 16))
)
### output for cvc5
sat
(
(define-fun x () Int 2)
)

Found solution -16
Yes! Solved for puzzle  ListAt:1

Solving puzzle 699/774: ListAt:2
sat_func def sat(i: int, li=[99, 51, -28, -69, -90, -15, 7, -67], target=51):
    return li[i] == target
modified_func def sat(i: int, li=wrap_list([wrap_int(99), wrap_int(51), -wrap_int(28), -wrap_int(69), -wrap_int(90), -wrap_int(15), wrap_int(7), -wrap_int(67)]), target=wrap_int(51)):
    return li[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 8))
(assert (> x -8))
(assert (= (ite (or (= x 7) (= x -1)) -67 (ite (or (= x 6) (= x -2)) 7 (ite (or (= x 5) (= x -3)) -15 (ite (or (= x 4) (= x -4)) -90 (ite (or (= x 3) (= x -5)) -69 (ite (or (= x 2) (= x -6)) -28 (ite (or (= x 1) (= x -7)) 51 99))))))) 51))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 7))
)
### output for cvc5
sat
(
(define-fun x () Int 1)
)

Found solution -7
Yes! Solved for puzzle  ListAt:2

Solving puzzle 700/774: ListAt:3
sat_func def sat(i: int, li=[-68, 81, 13, -5, 81, 75, -3, -73, -89, 72], target=13):
    return li[i] == target
modified_func def sat(i: int, li=wrap_list([-wrap_int(68), wrap_int(81), wrap_int(13), -wrap_int(5), wrap_int(81), wrap_int(75), -wrap_int(3), -wrap_int(73), -wrap_int(89), wrap_int(72)]), target=wrap_int(13)):
    return li[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 10))
(assert (> x -10))
(assert (= (ite (or (= x 9) (= x -1)) 72 (ite (or (= x 8) (= x -2)) -89 (ite (or (= x 7) (= x -3)) -73 (ite (or (= x 6) (= x -4)) -3 (ite (or (= x 5) (= x -5)) 75 (ite (or (= x 4) (= x -6)) 81 (ite (or (= x 3) (= x -7)) -5 (ite (or (= x 2) (= x -8)) 13 (ite (or (= x 1) (= x -9)) 81 -68))))))))) 13))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 8))
)
### output for cvc5
sat
(
(define-fun x () Int 2)
)

Found solution -8
Yes! Solved for puzzle  ListAt:3

Solving puzzle 701/774: ListAt:4
sat_func def sat(i: int, li=[51, -68, -57, 8, 77, -80, -28, -24, 11, 40, 57, 60, 53], target=11):
    return li[i] == target
modified_func def sat(i: int, li=wrap_list([wrap_int(51), -wrap_int(68), -wrap_int(57), wrap_int(8), wrap_int(77), -wrap_int(80), -wrap_int(28), -wrap_int(24), wrap_int(11), wrap_int(40), wrap_int(57), wrap_int(60), wrap_int(53)]), target=wrap_int(11)):
    return li[i] == target
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 13))
(assert (> x -13))
(assert (= (ite (or (= x 12) (= x -1)) 53 (ite (or (= x 11) (= x -2)) 60 (ite (or (= x 10) (= x -3)) 57 (ite (or (= x 9) (= x -4)) 40 (ite (or (= x 8) (= x -5)) 11 (ite (or (= x 7) (= x -6)) -24 (ite (or (= x 6) (= x -7)) -28 (ite (or (= x 5) (= x -8)) -80 (ite (or (= x 4) (= x -9)) 77 (ite (or (= x 3) (= x -10)) 8 (ite (or (= x 2) (= x -11)) -57 (ite (or (= x 1) (= x -12)) -68 51)))))))))))) 11))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 5))
)
### output for cvc5
sat
(
(define-fun x () Int 8)
)

Found solution -5
Yes! Solved for puzzle  ListAt:4

Solving puzzle 702/774: ListNegAt:0
sat_func def sat(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=91):
    return li[i] == target and i < 0
modified_func def sat(i: int, li=wrap_list([wrap_int(17), wrap_int(31), wrap_int(91), wrap_int(18), wrap_int(42), wrap_int(1), wrap_int(9)]), target=wrap_int(91)):
    return (li[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 7))
(assert (> x -7))
(assert (and (= (ite (or (= x 6) (= x -1)) 9 (ite (or (= x 5) (= x -2)) 1 (ite (or (= x 4) (= x -3)) 42 (ite (or (= x 3) (= x -4)) 18 (ite (or (= x 2) (= x -5)) 91 (ite (or (= x 1) (= x -6)) 31 17)))))) 91) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 5))
)
### output for cvc5
sat
(
(define-fun x () Int (- 5))
)

Found solution -5
Yes! Solved for puzzle  ListNegAt:0

Solving puzzle 703/774: ListNegAt:1
sat_func def sat(i: int, li=[78, 91, -67, -5, 30, -42, 68, 32, 96, -55, -39, -46, 90], target=-39):
    return li[i] == target and i < 0
modified_func def sat(i: int, li=wrap_list([wrap_int(78), wrap_int(91), -wrap_int(67), -wrap_int(5), wrap_int(30), -wrap_int(42), wrap_int(68), wrap_int(32), wrap_int(96), -wrap_int(55), -wrap_int(39), -wrap_int(46), wrap_int(90)]), target=-wrap_int(39)):
    return (li[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 13))
(assert (> x -13))
(assert (and (= (ite (or (= x 12) (= x -1)) 90 (ite (or (= x 11) (= x -2)) -46 (ite (or (= x 10) (= x -3)) -39 (ite (or (= x 9) (= x -4)) -55 (ite (or (= x 8) (= x -5)) 96 (ite (or (= x 7) (= x -6)) 32 (ite (or (= x 6) (= x -7)) 68 (ite (or (= x 5) (= x -8)) -42 (ite (or (= x 4) (= x -9)) 30 (ite (or (= x 3) (= x -10)) -5 (ite (or (= x 2) (= x -11)) -67 (ite (or (= x 1) (= x -12)) 91 78)))))))))))) -39) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 3))
)
### output for cvc5
sat
(
(define-fun x () Int (- 3))
)

Found solution -3
Yes! Solved for puzzle  ListNegAt:1

Solving puzzle 704/774: ListNegAt:2
sat_func def sat(i: int, li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42):
    return li[i] == target and i < 0
modified_func def sat(i: int, li=wrap_list([-wrap_int(60), wrap_int(9), wrap_int(1), -wrap_int(42), wrap_int(31), wrap_int(70), wrap_int(5), wrap_int(1), wrap_int(42), -wrap_int(90), -wrap_int(20)]), target=-wrap_int(42)):
    return (li[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 11))
(assert (> x -11))
(assert (and (= (ite (or (= x 10) (= x -1)) -20 (ite (or (= x 9) (= x -2)) -90 (ite (or (= x 8) (= x -3)) 42 (ite (or (= x 7) (= x -4)) 1 (ite (or (= x 6) (= x -5)) 5 (ite (or (= x 5) (= x -6)) 70 (ite (or (= x 4) (= x -7)) 31 (ite (or (= x 3) (= x -8)) -42 (ite (or (= x 2) (= x -9)) 1 (ite (or (= x 1) (= x -10)) 9 -60)))))))))) -42) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 8))
)
### output for cvc5
sat
(
(define-fun x () Int (- 8))
)

Found solution -8
Yes! Solved for puzzle  ListNegAt:2

Solving puzzle 705/774: ListNegAt:3
sat_func def sat(i: int, li=[41, -52, -40, -35, 53, -98, 83, 63, -18, 74, -8, -93, -3, 22, 30], target=53):
    return li[i] == target and i < 0
modified_func def sat(i: int, li=wrap_list([wrap_int(41), -wrap_int(52), -wrap_int(40), -wrap_int(35), wrap_int(53), -wrap_int(98), wrap_int(83), wrap_int(63), -wrap_int(18), wrap_int(74), -wrap_int(8), -wrap_int(93), -wrap_int(3), wrap_int(22), wrap_int(30)]), target=wrap_int(53)):
    return (li[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 15))
(assert (> x -15))
(assert (and (= (ite (or (= x 14) (= x -1)) 30 (ite (or (= x 13) (= x -2)) 22 (ite (or (= x 12) (= x -3)) -3 (ite (or (= x 11) (= x -4)) -93 (ite (or (= x 10) (= x -5)) -8 (ite (or (= x 9) (= x -6)) 74 (ite (or (= x 8) (= x -7)) -18 (ite (or (= x 7) (= x -8)) 63 (ite (or (= x 6) (= x -9)) 83 (ite (or (= x 5) (= x -10)) -98 (ite (or (= x 4) (= x -11)) 53 (ite (or (= x 3) (= x -12)) -35 (ite (or (= x 2) (= x -13)) -40 (ite (or (= x 1) (= x -14)) -52 41)))))))))))))) 53) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 11))
)
### output for cvc5
sat
(
(define-fun x () Int (- 11))
)

Found solution -11
Yes! Solved for puzzle  ListNegAt:3

Solving puzzle 706/774: ListNegAt:4
sat_func def sat(i: int, li=[95, 51, 76, 63, -97, -32], target=-32):
    return li[i] == target and i < 0
modified_func def sat(i: int, li=wrap_list([wrap_int(95), wrap_int(51), wrap_int(76), wrap_int(63), -wrap_int(97), -wrap_int(32)]), target=-wrap_int(32)):
    return (li[i] == target).__and__(i < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (< x 6))
(assert (> x -6))
(assert (and (= (ite (or (= x 5) (= x -1)) -32 (ite (or (= x 4) (= x -2)) -97 (ite (or (= x 3) (= x -3)) 63 (ite (or (= x 2) (= x -4)) 76 (ite (or (= x 1) (= x -5)) 51 95))))) -32) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1))
)

Found solution -1
Yes! Solved for puzzle  ListNegAt:4

Solving puzzle 707/774: ListIndex:0
sat_func def sat(item: int, li=[17, 2, 3, 9, 11, 11], index=4):
    return li.index(item) == index
modified_func def sat(item: int, li=wrap_list([wrap_int(17), wrap_int(2), wrap_int(3), wrap_int(9), wrap_int(11), wrap_int(11)]), index=wrap_int(4)):
    return li.index(item) == index
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (ite (= 17 x) 0 (ite (= 2 x) 1 (ite (= 3 x) 2 (ite (= 9 x) 3 (ite (= 11 x) 4 (ite (= 11 x) 5 -1)))))) 4))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    11)
)
### output for cvc5
sat
(
(define-fun x () Int 11)
)

Found solution 11
Yes! Solved for puzzle  ListIndex:0

Solving puzzle 708/774: ListIndex:1
sat_func def sat(item: int, li=[93, -13, -56, 19], index=2):
    return li.index(item) == index
modified_func def sat(item: int, li=wrap_list([wrap_int(93), -wrap_int(13), -wrap_int(56), wrap_int(19)]), index=wrap_int(2)):
    return li.index(item) == index
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (ite (= 93 x) 0 (ite (= -13 x) 1 (ite (= -56 x) 2 (ite (= 19 x) 3 -1)))) 2))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 56))
)
### output for cvc5
sat
(
(define-fun x () Int (- 56))
)

Found solution -56
Yes! Solved for puzzle  ListIndex:1

Solving puzzle 709/774: ListIndex:2
sat_func def sat(item: int, li=[-79, 49, 4, -75, -66, -76, 37, -62, -35, -79, 68, 82, -11, -71, 63, -82, 22, 65], index=2):
    return li.index(item) == index
modified_func def sat(item: int, li=wrap_list([-wrap_int(79), wrap_int(49), wrap_int(4), -wrap_int(75), -wrap_int(66), -wrap_int(76), wrap_int(37), -wrap_int(62), -wrap_int(35), -wrap_int(79), wrap_int(68), wrap_int(82), -wrap_int(11), -wrap_int(71), wrap_int(63), -wrap_int(82), wrap_int(22), wrap_int(65)]), index=wrap_int(2)):
    return li.index(item) == index
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (ite (= -79 x) 0 (ite (= 49 x) 1 (ite (= 4 x) 2 (ite (= -75 x) 3 (ite (= -66 x) 4 (ite (= -76 x) 5 (ite (= 37 x) 6 (ite (= -62 x) 7 (ite (= -35 x) 8 (ite (= -79 x) 9 (ite (= 68 x) 10 (ite (= 82 x) 11 (ite (= -11 x) 12 (ite (= -71 x) 13 (ite (= 63 x) 14 (ite (= -82 x) 15 (ite (= 22 x) 16 (ite (= 65 x) 17 -1)))))))))))))))))) 2))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    4)
)
### output for cvc5
sat
(
(define-fun x () Int 4)
)

Found solution 4
Yes! Solved for puzzle  ListIndex:2

Solving puzzle 710/774: ListIndex:3
sat_func def sat(item: int, li=[96, -61, 50, -49, -1, -23, -35], index=3):
    return li.index(item) == index
modified_func def sat(item: int, li=wrap_list([wrap_int(96), -wrap_int(61), wrap_int(50), -wrap_int(49), -wrap_int(1), -wrap_int(23), -wrap_int(35)]), index=wrap_int(3)):
    return li.index(item) == index
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (ite (= 96 x) 0 (ite (= -61 x) 1 (ite (= 50 x) 2 (ite (= -49 x) 3 (ite (= -1 x) 4 (ite (= -23 x) 5 (ite (= -35 x) 6 -1))))))) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 49))
)
### output for cvc5
sat
(
(define-fun x () Int (- 49))
)

Found solution -49
Yes! Solved for puzzle  ListIndex:3

Solving puzzle 711/774: ListIndex:4
sat_func def sat(item: int, li=[26, -90, 89], index=0):
    return li.index(item) == index
modified_func def sat(item: int, li=wrap_list([wrap_int(26), -wrap_int(90), wrap_int(89)]), index=wrap_int(0)):
    return li.index(item) == index
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (ite (= 26 x) 0 (ite (= -90 x) 1 (ite (= 89 x) 2 -1))) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    26)
)
### output for cvc5
sat
(
(define-fun x () Int 26)
)

Found solution 26
Yes! Solved for puzzle  ListIndex:4

Solving puzzle 712/774: ListIn:0
sat_func def sat(s: str, a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']):
    return s in a and s in b
modified_func def sat(s: str, a=wrap_list([wrap_str('cat'), wrap_str('dot'), wrap_str('bird')]), b=wrap_list([wrap_str('tree'), wrap_str('fly'), wrap_str('dot')])):
    return sym_in(s, a).__and__(sym_in(s, b))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "cat") (= x "dot") (= x "bird")) (or (= x "tree") (= x "fly") (= x "dot"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "dot")
)
### output for cvc5
sat
(
(define-fun x () String "dot")
)

Found solution dot
Yes! Solved for puzzle  ListIn:0

Solving puzzle 713/774: ListIn:1
sat_func def sat(s: str, a=['xetex', 'jomuboxuc', 'nyfiranuri', 'curu', 'jehykexethinun', 'bumekynuxinit', 'cymelatabegi', 'jumuvufotextasa', 'cotharasyfukakiwoc', 'fuvyvavi', 'gohavelomet', 'hibymomotohywehathi', 'jyzucakaq', 'chihyx', 'wukikogy', 'pegydozetebegafugyf', 'chywadetextekesyjup', 'xysecaw', 'ryzafusul', 'lojychurep', 'vivutolimifa', 'pysiquikywoty', 'thitexturykasoquifet', 'va', 'nagetextilac', 'tex', 'zechocha', 'susatexty', 'ch'], b=['vesaredu', 'textyjun', 'hijilenafotycoch', 'fofytextulidajekymos', 'thudothukuzaxug', 'dythezutolihibinafyj', 'hadid', 'zyly', 'mu', 'chywadetextekesyjup', 'zekyrivequi', 'pebycipohivam', 'texterekuwudut', 'c', 'sanidithuh', 'ritextuchik', 'ny', 'cym', 'cirok', 'kavuquithochazethej', 'zikechep', 'kesitabuduzu', 'duchequ', 'fuluhesowyjugehusab', 'tof', 'tu', 'textichagekochoquovo', 'bo', 'thac', 'hytextac', 'nerehufymex', 'jezyletextiquebositi', 'm', 'kathithowefyvoced', 'rityjivoxadydyzatiq', 'nuxaritutebacygevyq', 'thyjaxirumenaquuxy', 'gizydylot', 'textite', 'guchikek', 'fas', 'pabipapiro', 'fechiduchu', 'pexijis', 'gojep', 'quinatextit', 'chaqu', 'xyxyjos', 'pudibothytigiwumucex', 'josadubizy', 'jy', 'komazibomapothequev', 'licogatextuliletuxi', 'gus', 'nylyxyjibikimet', 'tafo']):
    return s in a and s in b
modified_func def sat(s: str, a=wrap_list([wrap_str('xetex'), wrap_str('jomuboxuc'), wrap_str('nyfiranuri'), wrap_str('curu'), wrap_str('jehykexethinun'), wrap_str('bumekynuxinit'), wrap_str('cymelatabegi'), wrap_str('jumuvufotextasa'), wrap_str('cotharasyfukakiwoc'), wrap_str('fuvyvavi'), wrap_str('gohavelomet'), wrap_str('hibymomotohywehathi'), wrap_str('jyzucakaq'), wrap_str('chihyx'), wrap_str('wukikogy'), wrap_str('pegydozetebegafugyf'), wrap_str('chywadetextekesyjup'), wrap_str('xysecaw'), wrap_str('ryzafusul'), wrap_str('lojychurep'), wrap_str('vivutolimifa'), wrap_str('pysiquikywoty'), wrap_str('thitexturykasoquifet'), wrap_str('va'), wrap_str('nagetextilac'), wrap_str('tex'), wrap_str('zechocha'), wrap_str('susatexty'), wrap_str('ch')]), b=wrap_list([wrap_str('vesaredu'), wrap_str('textyjun'), wrap_str('hijilenafotycoch'), wrap_str('fofytextulidajekymos'), wrap_str('thudothukuzaxug'), wrap_str('dythezutolihibinafyj'), wrap_str('hadid'), wrap_str('zyly'), wrap_str('mu'), wrap_str('chywadetextekesyjup'), wrap_str('zekyrivequi'), wrap_str('pebycipohivam'), wrap_str('texterekuwudut'), wrap_str('c'), wrap_str('sanidithuh'), wrap_str('ritextuchik'), wrap_str('ny'), wrap_str('cym'), wrap_str('cirok'), wrap_str('kavuquithochazethej'), wrap_str('zikechep'), wrap_str('kesitabuduzu'), wrap_str('duchequ'), wrap_str('fuluhesowyjugehusab'), wrap_str('tof'), wrap_str('tu'), wrap_str('textichagekochoquovo'), wrap_str('bo'), wrap_str('thac'), wrap_str('hytextac'), wrap_str('nerehufymex'), wrap_str('jezyletextiquebositi'), wrap_str('m'), wrap_str('kathithowefyvoced'), wrap_str('rityjivoxadydyzatiq'), wrap_str('nuxaritutebacygevyq'), wrap_str('thyjaxirumenaquuxy'), wrap_str('gizydylot'), wrap_str('textite'), wrap_str('guchikek'), wrap_str('fas'), wrap_str('pabipapiro'), wrap_str('fechiduchu'), wrap_str('pexijis'), wrap_str('gojep'), wrap_str('quinatextit'), wrap_str('chaqu'), wrap_str('xyxyjos'), wrap_str('pudibothytigiwumucex'), wrap_str('josadubizy'), wrap_str('jy'), wrap_str('komazibomapothequev'), wrap_str('licogatextuliletuxi'), wrap_str('gus'), wrap_str('nylyxyjibikimet'), wrap_str('tafo')])):
    return sym_in(s, a).__and__(sym_in(s, b))
### smt2
(set-logic ALL)

(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x String)
(assert (and (or (= x "xetex") (= x "jomuboxuc") (= x "nyfiranuri") (= x "curu") (= x "jehykexethinun") (= x "bumekynuxinit") (= x "cymelatabegi") (= x "jumuvufotextasa") (= x "cotharasyfukakiwoc") (= x "fuvyvavi") (= x "gohavelomet") (= x "hibymomotohywehathi") (= x "jyzucakaq") (= x "chihyx") (= x "wukikogy") (= x "pegydozetebegafugyf") (= x "chywadetextekesyjup") (= x "xysecaw") (= x "ryzafusul") (= x "lojychurep") (= x "vivutolimifa") (= x "pysiquikywoty") (= x "thitexturykasoquifet") (= x "va") (= x "nagetextilac") (= x "tex") (= x "zechocha") (= x "susatexty") (= x "ch")) (or (= x "vesaredu") (= x "textyjun") (= x "hijilenafotycoch") (= x "fofytextulidajekymos") (= x "thudothukuzaxug") (= x "dythezutolihibinafyj") (= x "hadid") (= x "zyly") (= x "mu") (= x "chywadetextekesyjup") (= x "zekyrivequi") (= x "pebycipohivam") (= x "texterekuwudut") (= x "c") (= x "sanidithuh") (= x "ritextuchik") (= x "ny") (= x "cym") (= x "cirok") (= x "kavuquithochazethej") (= x "zikechep") (= x "ke...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "chywadetextekesyjup")
)
### output for cvc5
sat
(
(define-fun x () String "chywadetextekesyjup")
)

Found solution chywadetextekesyjup
Yes! Solved for puzzle  ListIn:1

Solving puzzle 714/774: ListIn:2
sat_func def sat(s: str, a=['bututimatabel', 'zezahabiry', 'mipytext', 'bujokacyrulihir', 'cyvagofaquothoseza', 'guhebalequepytex', 'tyhithuthygatextity', 'chizichuc', 'textoxodenekokechona', 'texte', 'mygafifet', 'vixathokivy', 'xe', 'moq', 'quokopy', 'cixoka', 'wiz', 'wyturasutabidipif', 'q', 'gochujuvub', 'textogow', 'rogizasog', 'fimoxynudob', 'byjythohimowyquich', 'moduxatanogococ', 'tunuchikywichykyxyge', 'namixotextes', 'nocoguthosoxonahu', 'xorydyhi', 'dadohojex', 'pi', 'wiquocaso', 'tyjegu', 'juquath', 'dythufyn', 'sehafur', 'sylupivyzequefujet', 'hotextylyquahudivov', 'wunich', 'fijyhilyc', 'rirymequunezuv', 'zizunylihadowys', 'zesuxikevaquus', 'thecisequevyth', 'cucyquefytextu', 'xy', 'quuxin', 'miherahita', 'texatextoxyta', 'tythyjuly', 'tehesyju', 'reg', 'ridilusycanejap', 'fo', 'chucatazyrejucathibi', 'textythacete', 'huhiquekychyh', 'xykuvebylyhinyc', 'zadedixoxoparyducena', 'wycathomoniva', 'textuwuwathiziq', 'textijiw', 'rigidichukuchexorute', 'majixodokalij', 'hexebitoxumuvodese', 'hybat', 'thojutextomochote', 'textaxuquyg', 'queluhatex'], b=['gume', 'zatum', 'kochaxybupy', 'gex', 'vithiby', 'lygarethaquedehabub', 'tochek', 'v', 'wis', 'remywerinyboweropot', 'nybichychafizurup', 'zokabugyc', 'ny', 'moruwicoponuricuw', 'zirijikuhabivywah', 'dus', 'toxirit', 'gilanih', 'hif', 'vuhezobinehahewi', 'quujihus', 'chej', 'g', 'pypomaquiwusisyvuma', 'to', 'c', 'chutesumalanozeb', 'chupehozukiquodisese', 'xygiwot', 'semubaquav', 'pihiwidosudetextet', 'quegatagicu', 'quutydychy', 'chuzeby', 'jefythasapag', 'bytathoti', 'thimobaquykisabepec', 'saluwax', 'thi', 'kyneroravexuquoto', 'jusudybahebuxypepahe', 'f', 'zapufefek', 'mumogawen', 'quotyhot', 'hybamukelo', 'picatextujycotodyj', 'be', 'pytextyfa', 'tile', 'dotextazuchubuk', 'choguc', 'wi', 'setepicydavumahebe', 'wyjo', 'mirukuwyfuwihoqu', 'q', 'kegytegu', 'kegoquibyguxexajebid', 'hyfech', 'humovomefoly', 'tupetox', 'gevogibax', 'vuxotext', 'miluparaj', 'bathad', 'tily', 'theranydygiryc', 'dasaxatext', 'guhebalequepytex', 'v', 'gocuxomecapylewaj']):
    return s in a and s in b
modified_func def sat(s: str, a=wrap_list([wrap_str('bututimatabel'), wrap_str('zezahabiry'), wrap_str('mipytext'), wrap_str('bujokacyrulihir'), wrap_str('cyvagofaquothoseza'), wrap_str('guhebalequepytex'), wrap_str('tyhithuthygatextity'), wrap_str('chizichuc'), wrap_str('textoxodenekokechona'), wrap_str('texte'), wrap_str('mygafifet'), wrap_str('vixathokivy'), wrap_str('xe'), wrap_str('moq'), wrap_str('quokopy'), wrap_str('cixoka'), wrap_str('wiz'), wrap_str('wyturasutabidipif'), wrap_str('q'), wrap_str('gochujuvub'), wrap_str('textogow'), wrap_str('rogizasog'), wrap_str('fimoxynudob'), wrap_str('byjythohimowyquich'), wrap_str('moduxatanogococ'), wrap_str('tunuchikywichykyxyge'), wrap_str('namixotextes'), wrap_str('nocoguthosoxonahu'), wrap_str('xorydyhi'), wrap_str('dadohojex'), wrap_str('pi'), wrap_str('wiquocaso'), wrap_str('tyjegu'), wrap_str('juquath'), wrap_str('dythufyn'), wrap_str('sehafur'), wrap_str('sylupivyzequefujet'), wrap_str('hotextylyquahudivov'), wrap_str('wunich'), wrap_str('fijyhilyc'), wrap_str('rirymequunezuv'), wrap_str('zizunylihadowys'), wrap_str('zesuxikevaquus'), wrap_str('thecisequevyth'), wrap_str('cucyquefytextu'), wrap_str('xy'), wrap_str('quuxin'), wrap_str('miherahita'), wrap_str('texatextoxyta'), wrap_str('tythyjuly'), wrap_str('tehesyju'), wrap_str('reg'), wrap_str('ridilusycanejap'), wrap_str('fo'), wrap_str('chucatazyrejucathibi'), wrap_str('textythacete'), wrap_str('huhiquekychyh'), wrap_str('xykuvebylyhinyc'), wrap_str('zadedixoxoparyducena'), wrap_str('wycathomoniva'), wrap_str('textuwuwathiziq'), wrap_str('textijiw'), wrap_str('rigidichukuchexorute'), wrap_str('majixodokalij'), wrap_str('hexebitoxumuvodese'), wrap_str('hybat'), wrap_str('thojutextomochote'), wrap_str('textaxuquyg'), wrap_str('queluhatex')]), b=wrap_list([wrap_str('gume'), wrap_str('zatum'), wrap_str('kochaxybupy'), wrap_str('gex'), wrap_str('vithiby'), wrap_str('lygarethaquedehabub'), wrap_str('tochek'), wrap_str('v'), wrap_str('wis'), wrap_str('remywerinyboweropot'), wrap_str('nybichychafizurup'), wrap_str('zokabugyc'), wrap_str('ny'), wrap_str('moruwicoponuricuw'), wrap_str('zirijikuhabivywah'), wrap_str('dus'), wrap_str('toxirit'), wrap_str('gilanih'), wrap_str('hif'), wrap_str('vuhezobinehahewi'), wrap_str('quujihus'), wrap_str('chej'), wrap_str('g'), wrap_str('pypomaquiwusisyvuma'), wrap_str('to'), wrap_str('c'), wrap_str('chutesumalanozeb'), wrap_str('chupehozukiquodisese'), wrap_str('xygiwot'), wrap_str('semubaquav'), wrap_str('pihiwidosudetextet'), wrap_str('quegatagicu'), wrap_str('quutydychy'), wrap_str('chuzeby'), wrap_str('jefythasapag'), wrap_str('bytathoti'), wrap_str('thimobaquykisabepec'), wrap_str('saluwax'), wrap_str('thi'), wrap_str('kyneroravexuquoto'), wrap_str('jusudybahebuxypepahe'), wrap_str('f'), wrap_str('zapufefek'), wrap_str('mumogawen'), wrap_str('quotyhot'), wrap_str('hybamukelo'), wrap_str('picatextujycotodyj'), wrap_str('be'), wrap_str('pytextyfa'), wrap_str('tile'), wrap_str('dotextazuchubuk'), wrap_str('choguc'), wrap_str('wi'), wrap_str('setepicydavumahebe'), wrap_str('wyjo'), wrap_str('mirukuwyfuwihoqu'), wrap_str('q'), wrap_str('kegytegu'), wrap_str('kegoquibyguxexajebid'), wrap_str('hyfech'), wrap_str('humovomefoly'), wrap_str('tupetox'), wrap_str('gevogibax'), wrap_str('vuxotext'), wrap_str('miluparaj'), wrap_str('bathad'), wrap_str('tily'), wrap_str('theranydygiryc'), wrap_str('dasaxatext'), wrap_str('guhebalequepytex'), wrap_str('v'), wrap_str('gocuxomecapylewaj')])):
    return sym_in(s, a).__and__(sym_in(s, b))
### smt2
(set-logic ALL)

(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x String)
(assert (and (or (= x "bututimatabel") (= x "zezahabiry") (= x "mipytext") (= x "bujokacyrulihir") (= x "cyvagofaquothoseza") (= x "guhebalequepytex") (= x "tyhithuthygatextity") (= x "chizichuc") (= x "textoxodenekokechona") (= x "texte") (= x "mygafifet") (= x "vixathokivy") (= x "xe") (= x "moq") (= x "quokopy") (= x "cixoka") (= x "wiz") (= x "wyturasutabidipif") (= x "q") (= x "gochujuvub") (= x "textogow") (= x "rogizasog") (= x "fimoxynudob") (= x "byjythohimowyquich") (= x "moduxatanogococ") (= x "tunuchikywichykyxyge") (= x "namixotextes") (= x "nocoguthosoxonahu") (= x "xorydyhi") (= x "dadohojex") (= x "pi") (= x "wiquocaso") (= x "tyjegu") (= x "juquath") (= x "dythufyn") (= x "sehafur") (= x "sylupivyzequefujet") (= x "hotextylyquahudivov") (= x "wunich") (= x "fijyhilyc") (= x "rirymequunezuv") (= x "zizunylihadowys") (= x "zesuxikevaquus") (= x "thecisequevyth") (= x "cucyquefytextu") (= x "xy") (= x "quuxin") (= x "miherahita") (= x "texatextoxyta") (= x "tythyjuly") (=...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "guhebalequepytex")
)
### output for cvc5
sat
(
(define-fun x () String "guhebalequepytex")
)

Found solution guhebalequepytex
Yes! Solved for puzzle  ListIn:2

Solving puzzle 715/774: ListIn:3
sat_func def sat(s: str, a=['thachak', 'xuchyzyzazi', 'bilewejoquowylo', 'chogokim', 'kuloxozu', 'capokaf', 'didadadejunukosazi', 'zethucun', 'tygorub', 'lochydigyt', 'dyquuhycusi', 'wagupolovapy', 'chowace', 'zozawethychax', 'xohuhuqui', 'tatylisigar', 'c', 'kakopuzysycasewit', 'rekatebinidyvuchitet', 'popi', 'chepebaze', 'textut', 'fymehap', 'c', 'wodumogovolacabasot', 'tixihidafutexto', 'dycubichucyneweve', 'setofa', 'cudaxediquy', 'namof', 'qua', 'chetextof', 'cochydededaxyzuj', 'winutaj', 'nidyjutothovobydizy', 'sichequaxohojethihy', 'cubusycip', 'pynoconic', 'kyt', 'thop', 'kewotochelocyboz', 'z', 'c', 'q', 'bonyquyx', 'jothec', 'fyzozynygiperythada', 'lipadatuzisaduthyt', 'nithujyxymethot', 'vewariq', 'nejitextole', 'raxiv', 'hamim', 'qua', 'kytextehekaryp', 'jaquu', 'wozuthevith', 'f', 'jugevizyfu', 'cywo', 'w', 'surajotext', 'vilujetutitachivy', 'textequysuninutuqu', 'fevawybok', 'lythehythu', 'nykochachofitit', 'gikenadubit', 'thexyjy', 'piquyzyxichoc', 'rilaquucham', 'fa', 'mysihumotexto', 'xochogekumipoquidi', 'jimynusyte', 'textexysuzipichaw', 'mut', 'jiwyx', 'tojiwedoxevosubavy', 'dix', 'dogetexto', 'chysafyzelefocothin', 'xitext', 'machibokudyh', 'ronebupapapygyceb', 'dedytejyretavewytasi', 'jobog', 'namychyt', 'textycapudul', 'jaxybatexto', 'pamuwysafupaxowus', 'lycazivafyj', 'lelologufenofajogofi', 'thety', 'bunotextoca', 'nexaravuq', 'natu'], b=['namychyt', 'mathapachobat', 'timorohopotak']):
    return s in a and s in b
modified_func def sat(s: str, a=wrap_list([wrap_str('thachak'), wrap_str('xuchyzyzazi'), wrap_str('bilewejoquowylo'), wrap_str('chogokim'), wrap_str('kuloxozu'), wrap_str('capokaf'), wrap_str('didadadejunukosazi'), wrap_str('zethucun'), wrap_str('tygorub'), wrap_str('lochydigyt'), wrap_str('dyquuhycusi'), wrap_str('wagupolovapy'), wrap_str('chowace'), wrap_str('zozawethychax'), wrap_str('xohuhuqui'), wrap_str('tatylisigar'), wrap_str('c'), wrap_str('kakopuzysycasewit'), wrap_str('rekatebinidyvuchitet'), wrap_str('popi'), wrap_str('chepebaze'), wrap_str('textut'), wrap_str('fymehap'), wrap_str('c'), wrap_str('wodumogovolacabasot'), wrap_str('tixihidafutexto'), wrap_str('dycubichucyneweve'), wrap_str('setofa'), wrap_str('cudaxediquy'), wrap_str('namof'), wrap_str('qua'), wrap_str('chetextof'), wrap_str('cochydededaxyzuj'), wrap_str('winutaj'), wrap_str('nidyjutothovobydizy'), wrap_str('sichequaxohojethihy'), wrap_str('cubusycip'), wrap_str('pynoconic'), wrap_str('kyt'), wrap_str('thop'), wrap_str('kewotochelocyboz'), wrap_str('z'), wrap_str('c'), wrap_str('q'), wrap_str('bonyquyx'), wrap_str('jothec'), wrap_str('fyzozynygiperythada'), wrap_str('lipadatuzisaduthyt'), wrap_str('nithujyxymethot'), wrap_str('vewariq'), wrap_str('nejitextole'), wrap_str('raxiv'), wrap_str('hamim'), wrap_str('qua'), wrap_str('kytextehekaryp'), wrap_str('jaquu'), wrap_str('wozuthevith'), wrap_str('f'), wrap_str('jugevizyfu'), wrap_str('cywo'), wrap_str('w'), wrap_str('surajotext'), wrap_str('vilujetutitachivy'), wrap_str('textequysuninutuqu'), wrap_str('fevawybok'), wrap_str('lythehythu'), wrap_str('nykochachofitit'), wrap_str('gikenadubit'), wrap_str('thexyjy'), wrap_str('piquyzyxichoc'), wrap_str('rilaquucham'), wrap_str('fa'), wrap_str('mysihumotexto'), wrap_str('xochogekumipoquidi'), wrap_str('jimynusyte'), wrap_str('textexysuzipichaw'), wrap_str('mut'), wrap_str('jiwyx'), wrap_str('tojiwedoxevosubavy'), wrap_str('dix'), wrap_str('dogetexto'), wrap_str('chysafyzelefocothin'), wrap_str('xitext'), wrap_str('machibokudyh'), wrap_str('ronebupapapygyceb'), wrap_str('dedytejyretavewytasi'), wrap_str('jobog'), wrap_str('namychyt'), wrap_str('textycapudul'), wrap_str('jaxybatexto'), wrap_str('pamuwysafupaxowus'), wrap_str('lycazivafyj'), wrap_str('lelologufenofajogofi'), wrap_str('thety'), wrap_str('bunotextoca'), wrap_str('nexaravuq'), wrap_str('natu')]), b=wrap_list([wrap_str('namychyt'), wrap_str('mathapachobat'), wrap_str('timorohopotak')])):
    return sym_in(s, a).__and__(sym_in(s, b))
### smt2
(set-logic ALL)

(define-fun-rec bin.rec ((x Int) (n Int)) String
  (ite (<= n 0)
       ""
       (let ((bit (mod x 2))
             (rest (div x 2)))
         (str.++ (bin.rec rest (- n 1))
                 (ite (= bit 0) "0" "1")))))

(define-fun bin ((x Int)) String
  (str.++ "0b" (bin.rec x 32)))

(declare-const x String)
(assert (and (or (= x "thachak") (= x "xuchyzyzazi") (= x "bilewejoquowylo") (= x "chogokim") (= x "kuloxozu") (= x "capokaf") (= x "didadadejunukosazi") (= x "zethucun") (= x "tygorub") (= x "lochydigyt") (= x "dyquuhycusi") (= x "wagupolovapy") (= x "chowace") (= x "zozawethychax") (= x "xohuhuqui") (= x "tatylisigar") (= x "c") (= x "kakopuzysycasewit") (= x "rekatebinidyvuchitet") (= x "popi") (= x "chepebaze") (= x "textut") (= x "fymehap") (= x "c") (= x "wodumogovolacabasot") (= x "tixihidafutexto") (= x "dycubichucyneweve") (= x "setofa") (= x "cudaxediquy") (= x "namof") (= x "qua") (= x "chetextof") (= x "cochydededaxyzuj") (= x "winutaj") (= x "nidyjutothovobydizy") (= x "sichequaxohojethihy") (= x "cubusycip") (= x "pynoconic") (= x "kyt") (= x "thop") (= x "kewotochelocyboz") (= x "z") (= x "c") (= x "q") (= x "bonyquyx") (= x "jothec") (= x "fyzozynygiperythada") (= x "lipadatuzisaduthyt") (= x "nithujyxymethot") (= x "vewariq") (= x "nejitextole") (= x "raxiv") (= x "ham...
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "namychyt")
)
### output for cvc5
sat
(
(define-fun x () String "namychyt")
)

Found solution namychyt
Yes! Solved for puzzle  ListIn:3

Solving puzzle 716/774: ListIn:4
sat_func def sat(s: str, a=['quisolu', 'nixyquigaseq', 'fawaholafojelaxud', 'cuxoniso', 'defejaz', 'mytext', 'gochavowetheva', 'xijehychojexat', 'duthagobejudozi', 'thiquijuquorybu'], b=['cys', 'zatext', 'cifihihechujozimo', 'jycichithetyk', 'becitonamuhuligyv', 'sadak', 'hochavinapatanapiz', 'fiwidifop', 'funidosikeput', 'fewat', 'mypyhalevituvit', 'quytynuthothy', 'c', 'zydecodul', 'vahychuke', 'wy', 'mytext', 'tex', 'quevasowodique', 'hythiquunymychilyl', 'luxivyvocuwa']):
    return s in a and s in b
modified_func def sat(s: str, a=wrap_list([wrap_str('quisolu'), wrap_str('nixyquigaseq'), wrap_str('fawaholafojelaxud'), wrap_str('cuxoniso'), wrap_str('defejaz'), wrap_str('mytext'), wrap_str('gochavowetheva'), wrap_str('xijehychojexat'), wrap_str('duthagobejudozi'), wrap_str('thiquijuquorybu')]), b=wrap_list([wrap_str('cys'), wrap_str('zatext'), wrap_str('cifihihechujozimo'), wrap_str('jycichithetyk'), wrap_str('becitonamuhuligyv'), wrap_str('sadak'), wrap_str('hochavinapatanapiz'), wrap_str('fiwidifop'), wrap_str('funidosikeput'), wrap_str('fewat'), wrap_str('mypyhalevituvit'), wrap_str('quytynuthothy'), wrap_str('c'), wrap_str('zydecodul'), wrap_str('vahychuke'), wrap_str('wy'), wrap_str('mytext'), wrap_str('tex'), wrap_str('quevasowodique'), wrap_str('hythiquunymychilyl'), wrap_str('luxivyvocuwa')])):
    return sym_in(s, a).__and__(sym_in(s, b))
### smt2
(set-logic ALL)
(declare-const x String)
(assert (and (or (= x "quisolu") (= x "nixyquigaseq") (= x "fawaholafojelaxud") (= x "cuxoniso") (= x "defejaz") (= x "mytext") (= x "gochavowetheva") (= x "xijehychojexat") (= x "duthagobejudozi") (= x "thiquijuquorybu")) (or (= x "cys") (= x "zatext") (= x "cifihihechujozimo") (= x "jycichithetyk") (= x "becitonamuhuligyv") (= x "sadak") (= x "hochavinapatanapiz") (= x "fiwidifop") (= x "funidosikeput") (= x "fewat") (= x "mypyhalevituvit") (= x "quytynuthothy") (= x "c") (= x "zydecodul") (= x "vahychuke") (= x "wy") (= x "mytext") (= x "tex") (= x "quevasowodique") (= x "hythiquunymychilyl") (= x "luxivyvocuwa"))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "mytext")
)
### output for cvc5
sat
(
(define-fun x () String "mytext")
)

Found solution mytext
Yes! Solved for puzzle  ListIn:4

Solving puzzle 717/774: IntNeg:0
sat_func def sat(x: int, a=93252338):
    return -x == a
modified_func def sat(x: int, a=wrap_int(93252338)):
    return -x == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x) 93252338))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 93252338))
)
### output for cvc5
sat
(
(define-fun x () Int (- 93252338))
)

Found solution -93252338
Yes! Solved for puzzle  IntNeg:0

Solving puzzle 718/774: IntNeg:1
sat_func def sat(x: int, a=-7788910835979672):
    return -x == a
modified_func def sat(x: int, a=-wrap_int(7788910835979672)):
    return -x == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x) -7788910835979672))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    7788910835979672)
)
### output for cvc5
sat
(
(define-fun x () Int 7788910835979672)
)

Found solution 7788910835979672
Yes! Solved for puzzle  IntNeg:1

Solving puzzle 719/774: IntNeg:2
sat_func def sat(x: int, a=6734672221833987):
    return -x == a
modified_func def sat(x: int, a=wrap_int(6734672221833987)):
    return -x == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x) 6734672221833987))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 6734672221833987))
)
### output for cvc5
sat
(
(define-fun x () Int (- 6734672221833987))
)

Found solution -6734672221833987
Yes! Solved for puzzle  IntNeg:2

Solving puzzle 720/774: IntNeg:3
sat_func def sat(x: int, a=-6405550227918699):
    return -x == a
modified_func def sat(x: int, a=-wrap_int(6405550227918699)):
    return -x == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x) -6405550227918699))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    6405550227918699)
)
### output for cvc5
sat
(
(define-fun x () Int 6405550227918699)
)

Found solution 6405550227918699
Yes! Solved for puzzle  IntNeg:3

Solving puzzle 721/774: IntNeg:4
sat_func def sat(x: int, a=-5741705983914418):
    return -x == a
modified_func def sat(x: int, a=-wrap_int(5741705983914418)):
    return -x == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x) -5741705983914418))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    5741705983914418)
)
### output for cvc5
sat
(
(define-fun x () Int 5741705983914418)
)

Found solution 5741705983914418
Yes! Solved for puzzle  IntNeg:4

Solving puzzle 722/774: IntSum:0
sat_func def sat(x: int, a=1073258, b=72352549):
    return a + x == b
modified_func def sat(x: int, a=wrap_int(1073258), b=wrap_int(72352549)):
    return a + x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ 1073258 x) 72352549))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    71279291)
)
### output for cvc5
sat
(
(define-fun x () Int 71279291)
)

Found solution 71279291
Yes! Solved for puzzle  IntSum:0

Solving puzzle 723/774: IntSum:1
sat_func def sat(x: int, a=7176599374880969, b=1013347182263591):
    return a + x == b
modified_func def sat(x: int, a=wrap_int(7176599374880969), b=wrap_int(1013347182263591)):
    return a + x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ 7176599374880969 x) 1013347182263591))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 6163252192617378))
)
### output for cvc5
sat
(
(define-fun x () Int (- 6163252192617378))
)

Found solution -6163252192617378
Yes! Solved for puzzle  IntSum:1

Solving puzzle 724/774: IntSum:2
sat_func def sat(x: int, a=-6408240447142191, b=7741323537672506):
    return a + x == b
modified_func def sat(x: int, a=-wrap_int(6408240447142191), b=wrap_int(7741323537672506)):
    return a + x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ -6408240447142191 x) 7741323537672506))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    14149563984814697)
)
### output for cvc5
sat
(
(define-fun x () Int 14149563984814697)
)

Found solution 14149563984814697
Yes! Solved for puzzle  IntSum:2

Solving puzzle 725/774: IntSum:3
sat_func def sat(x: int, a=1918969259925371, b=3648647147996329):
    return a + x == b
modified_func def sat(x: int, a=wrap_int(1918969259925371), b=wrap_int(3648647147996329)):
    return a + x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ 1918969259925371 x) 3648647147996329))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    1729677888070958)
)
### output for cvc5
sat
(
(define-fun x () Int 1729677888070958)
)

Found solution 1729677888070958
Yes! Solved for puzzle  IntSum:3

Solving puzzle 726/774: IntSum:4
sat_func def sat(x: int, a=6476308373242647, b=-1096573562602401):
    return a + x == b
modified_func def sat(x: int, a=wrap_int(6476308373242647), b=-wrap_int(1096573562602401)):
    return a + x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ 6476308373242647 x) -1096573562602401))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 7572881935845048))
)
### output for cvc5
sat
(
(define-fun x () Int (- 7572881935845048))
)

Found solution -7572881935845048
Yes! Solved for puzzle  IntSum:4

Solving puzzle 727/774: IntSub:0
sat_func def sat(x: int, a=-382, b=14546310):
    return x - a == b
modified_func def sat(x: int, a=-wrap_int(382), b=wrap_int(14546310)):
    return x - a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x -382) 14546310))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    14545928)
)
### output for cvc5
sat
(
(define-fun x () Int 14545928)
)

Found solution 14545928
Yes! Solved for puzzle  IntSub:0

Solving puzzle 728/774: IntSub:1
sat_func def sat(x: int, a=4461955033869751, b=-3951840325269410):
    return x - a == b
modified_func def sat(x: int, a=wrap_int(4461955033869751), b=-wrap_int(3951840325269410)):
    return x - a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x 4461955033869751) -3951840325269410))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    510114708600341)
)
### output for cvc5
sat
(
(define-fun x () Int 510114708600341)
)

Found solution 510114708600341
Yes! Solved for puzzle  IntSub:1

Solving puzzle 729/774: IntSub:2
sat_func def sat(x: int, a=9688203125538303, b=-293093369321912):
    return x - a == b
modified_func def sat(x: int, a=wrap_int(9688203125538303), b=-wrap_int(293093369321912)):
    return x - a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x 9688203125538303) -293093369321912))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    9395109756216391)
)
### output for cvc5
sat
(
(define-fun x () Int 9395109756216391)
)

Found solution 9395109756216391
Yes! Solved for puzzle  IntSub:2

Solving puzzle 730/774: IntSub:3
sat_func def sat(x: int, a=-8057207922876252, b=-3934955257447294):
    return x - a == b
modified_func def sat(x: int, a=-wrap_int(8057207922876252), b=-wrap_int(3934955257447294)):
    return x - a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x -8057207922876252) -3934955257447294))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 11992163180323546))
)
### output for cvc5
sat
(
(define-fun x () Int (- 11992163180323546))
)

Found solution -11992163180323546
Yes! Solved for puzzle  IntSub:3

Solving puzzle 731/774: IntSub:4
sat_func def sat(x: int, a=-5902383651753979, b=304676399871652):
    return x - a == b
modified_func def sat(x: int, a=-wrap_int(5902383651753979), b=wrap_int(304676399871652)):
    return x - a == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- x -5902383651753979) 304676399871652))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 5597707251882327))
)
### output for cvc5
sat
(
(define-fun x () Int (- 5597707251882327))
)

Found solution -5597707251882327
Yes! Solved for puzzle  IntSub:4

Solving puzzle 732/774: IntSub2:0
sat_func def sat(x: int, a=8665464, b=-93206):
    return a - x == b
modified_func def sat(x: int, a=wrap_int(8665464), b=-wrap_int(93206)):
    return a - x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- 8665464 x) -93206))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    8758670)
)
### output for cvc5
sat
(
(define-fun x () Int 8758670)
)

Found solution 8758670
Yes! Solved for puzzle  IntSub2:0

Solving puzzle 733/774: IntSub2:1
sat_func def sat(x: int, a=1954051265970332, b=1312727165482691):
    return a - x == b
modified_func def sat(x: int, a=wrap_int(1954051265970332), b=wrap_int(1312727165482691)):
    return a - x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- 1954051265970332 x) 1312727165482691))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    641324100487641)
)
### output for cvc5
sat
(
(define-fun x () Int 641324100487641)
)

Found solution 641324100487641
Yes! Solved for puzzle  IntSub2:1

Solving puzzle 734/774: IntSub2:2
sat_func def sat(x: int, a=-1159353965692778, b=4654551691407885):
    return a - x == b
modified_func def sat(x: int, a=-wrap_int(1159353965692778), b=wrap_int(4654551691407885)):
    return a - x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- -1159353965692778 x) 4654551691407885))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 5813905657100663))
)
### output for cvc5
sat
(
(define-fun x () Int (- 5813905657100663))
)

Found solution -5813905657100663
Yes! Solved for puzzle  IntSub2:2

Solving puzzle 735/774: IntSub2:3
sat_func def sat(x: int, a=7793575617602525, b=-4351726326349125):
    return a - x == b
modified_func def sat(x: int, a=wrap_int(7793575617602525), b=-wrap_int(4351726326349125)):
    return a - x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- 7793575617602525 x) -4351726326349125))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    12145301943951650)
)
### output for cvc5
sat
(
(define-fun x () Int 12145301943951650)
)

Found solution 12145301943951650
Yes! Solved for puzzle  IntSub2:3

Solving puzzle 736/774: IntSub2:4
sat_func def sat(x: int, a=-8783800228130606, b=-508993556991975):
    return a - x == b
modified_func def sat(x: int, a=-wrap_int(8783800228130606), b=-wrap_int(508993556991975)):
    return a - x == b
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (- -8783800228130606 x) -508993556991975))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 8274806671138631))
)
### output for cvc5
sat
(
(define-fun x () Int (- 8274806671138631))
)

Found solution -8274806671138631
Yes! Solved for puzzle  IntSub2:4

Solving puzzle 737/774: IntMul:0
sat_func def sat(n: int, a=14302, b=5):
    return b * n + (a % b) == a
modified_func def sat(n: int, a=wrap_int(14302), b=wrap_int(5)):
    return b * n + a % b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ (* 5 x) 2) 14302))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2860)
)
### output for cvc5
sat
(
(define-fun x () Int 2860)
)

Found solution 2860
Yes! Solved for puzzle  IntMul:0

Solving puzzle 738/774: IntMul:1
sat_func def sat(n: int, a=-646156, b=-63):
    return b * n + (a % b) == a
modified_func def sat(n: int, a=-wrap_int(646156), b=-wrap_int(63)):
    return b * n + a % b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ (* -63 x) -28) -646156))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    10256)
)
### output for cvc5
sat
(
(define-fun x () Int 10256)
)

Found solution 10256
Yes! Solved for puzzle  IntMul:1

Solving puzzle 739/774: IntMul:2
sat_func def sat(n: int, a=159568, b=59):
    return b * n + (a % b) == a
modified_func def sat(n: int, a=wrap_int(159568), b=wrap_int(59)):
    return b * n + a % b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ (* 59 x) 32) 159568))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    2704)
)
### output for cvc5
sat
(
(define-fun x () Int 2704)
)

Found solution 2704
Yes! Solved for puzzle  IntMul:2

Solving puzzle 740/774: IntMul:3
sat_func def sat(n: int, a=-141336, b=72):
    return b * n + (a % b) == a
modified_func def sat(n: int, a=-wrap_int(141336), b=wrap_int(72)):
    return b * n + a % b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ (* 72 x) 0) -141336))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1963))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1963))
)

Found solution -1963
Yes! Solved for puzzle  IntMul:3

Solving puzzle 741/774: IntMul:4
sat_func def sat(n: int, a=855955, b=33):
    return b * n + (a % b) == a
modified_func def sat(n: int, a=wrap_int(855955), b=wrap_int(33)):
    return b * n + a % b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (+ (* 33 x) 1) 855955))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    25938)
)
### output for cvc5
sat
(
(define-fun x () Int 25938)
)

Found solution 25938
Yes! Solved for puzzle  IntMul:4

Solving puzzle 742/774: IntDiv:0
sat_func def sat(n: int, a=3, b=23463462):
    return b // n == a
modified_func def sat(n: int, a=wrap_int(3), b=wrap_int(23463462)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div 23463462 x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    3)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Exception in checking result: integer division or modulo by zero
WARNING: Solution verification failed for puzzle IntDiv:0
One large constant for extrapolation
Solving simpler variation replaced 23463462 with 3
sat_func def sat(n: int, a=3, b=3):
    return b // n == a
modified_func def sat(n: int, a=wrap_int(3), b=wrap_int(3)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div 3 x) 3))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    3)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Exception in checking result: integer division or modulo by zero
WARNING: Solution verification failed for puzzle IntDiv:0

Solving puzzle 743/774: IntDiv:1
sat_func def sat(n: int, a=-1, b=1594400229362061):
    return b // n == a
modified_func def sat(n: int, a=-wrap_int(1), b=wrap_int(1594400229362061)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div 1594400229362061 x) -1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 797200114681031))
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (- 1))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution -797200114681031
WARNING: Solution verification failed for puzzle IntDiv:1
One large constant for extrapolation
Solving simpler variation replaced 1594400229362061 with 3
sat_func def sat(n: int, a=-1, b=3):
    return b // n == a
modified_func def sat(n: int, a=-wrap_int(1), b=wrap_int(3)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div 3 x) -1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 2))
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (- 1))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution -2
WARNING: Solution verification failed for puzzle IntDiv:1

Solving puzzle 744/774: IntDiv:2
sat_func def sat(n: int, a=12, b=-9988218457242775):
    return b // n == a
modified_func def sat(n: int, a=wrap_int(12), b=-wrap_int(9988218457242775)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div -9988218457242775 x) 12))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 832351538103565))
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    12)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution -832351538103565
WARNING: Solution verification failed for puzzle IntDiv:2
One large constant for extrapolation
Solving simpler variation replaced 9988218457242775 with 3
sat_func def sat(n: int, a=12, b=-3):
    return b // n == a
modified_func def sat(n: int, a=wrap_int(12), b=-wrap_int(3)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div -3 x) 12))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    12)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    (- 4))
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Exception in checking result: integer division or modulo by zero
WARNING: Solution verification failed for puzzle IntDiv:2

Solving puzzle 745/774: IntDiv:3
sat_func def sat(n: int, a=0, b=-1230085432451862):
    return b // n == a
modified_func def sat(n: int, a=wrap_int(0), b=-wrap_int(1230085432451862)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div -1230085432451862 x) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    0)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Exception in checking result: integer division or modulo by zero
WARNING: Solution verification failed for puzzle IntDiv:3
One large constant for extrapolation
Solving simpler variation replaced 1230085432451862 with 3
sat_func def sat(n: int, a=0, b=-3):
    return b // n == a
modified_func def sat(n: int, a=wrap_int(0), b=-wrap_int(3)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div -3 x) 0))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    0)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Exception in checking result: integer division or modulo by zero
WARNING: Solution verification failed for puzzle IntDiv:3

Solving puzzle 746/774: IntDiv:4
sat_func def sat(n: int, a=1, b=9554566410382856):
    return b // n == a
modified_func def sat(n: int, a=wrap_int(1), b=wrap_int(9554566410382856)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div 9554566410382856 x) 1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    1)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Exception in checking result: integer division or modulo by zero
WARNING: Solution verification failed for puzzle IntDiv:4
One large constant for extrapolation
Solving simpler variation replaced 9554566410382856 with 3
sat_func def sat(n: int, a=1, b=3):
    return b // n == a
modified_func def sat(n: int, a=wrap_int(1), b=wrap_int(3)):
    return b // n == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div 3 x) 1))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    0)
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    1)
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
sat
(
(define-fun x () Int 0)
)

Found solution 0
Exception in checking result: integer division or modulo by zero
WARNING: Solution verification failed for puzzle IntDiv:4

Solving puzzle 747/774: IntDiv2:0
sat_func def sat(n: int, a=345346363, b=10):
    return n // b == a
modified_func def sat(n: int, a=wrap_int(345346363), b=wrap_int(10)):
    return n // b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div x 10) 345346363))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    3453463630)
)
### output for cvc5
sat
(
(define-fun x () Int 3453463630)
)

Found solution 3453463630
Yes! Solved for puzzle  IntDiv2:0

Solving puzzle 748/774: IntDiv2:1
sat_func def sat(n: int, a=-3411193412414137, b=-9070455318026063):
    return n // b == a
modified_func def sat(n: int, a=-wrap_int(3411193412414137), b=-wrap_int(9070455318026063)):
    return n // b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div x -9070455318026063) -3411193412414137))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    30941077428447282103938315652631)
)
### output for cvc5
sat
(
(define-fun x () Int 30941077428447282103938315652631)
)

Found solution 30941077428447282103938315652631
Yes! Solved for puzzle  IntDiv2:1

Solving puzzle 749/774: IntDiv2:2
sat_func def sat(n: int, a=-1950797984487873, b=6211965468307518):
    return n // b == a
modified_func def sat(n: int, a=-wrap_int(1950797984487873), b=wrap_int(6211965468307518)):
    return n // b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div x 6211965468307518) -1950797984487873))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 12118289715282572235363305729214))
)
### output for cvc5
sat
(
(define-fun x () Int (- 12118289715282566023397837421697))
)

Found solution -12118289715282572235363305729214
Yes! Solved for puzzle  IntDiv2:2

Solving puzzle 750/774: IntDiv2:3
sat_func def sat(n: int, a=1186580710227962, b=5023840456205809):
    return n // b == a
modified_func def sat(n: int, a=wrap_int(1186580710227962), b=wrap_int(5023840456205809)):
    return n // b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div x 5023840456205809) 1186580710227962))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    5961192176596657467421978631258)
)
### output for cvc5
sat
(
(define-fun x () Int 5961192176596657467421978631258)
)

Found solution 5961192176596657467421978631258
Yes! Solved for puzzle  IntDiv2:3

Solving puzzle 751/774: IntDiv2:4
sat_func def sat(n: int, a=6976962948831358, b=7353202892973126):
    return n // b == a
modified_func def sat(n: int, a=wrap_int(6976962948831358), b=wrap_int(7353202892973126)):
    return n // b == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (div x 7353202892973126) 6976962948831358))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    51303024139513053712431800085108)
)
### output for cvc5
sat
(
(define-fun x () Int 51303024139513053712431800085108)
)

Found solution 51303024139513053712431800085108
Yes! Solved for puzzle  IntDiv2:4

Solving puzzle 752/774: IntSquareRoot:0
sat_func def sat(x: int, a=10201202001):
    return x ** 2 == a
modified_func def sat(x: int, a=wrap_int(10201202001)):
    return x ** wrap_int(2) == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 2) 10201202001))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 101001))
)
### output for cvc5
sat
(
(define-fun x () Int (- 101001))
)

Found solution -101001
Yes! Solved for puzzle  IntSquareRoot:0

Solving puzzle 753/774: IntSquareRoot:1
sat_func def sat(x: int, a=2617350631613713636):
    return x ** 2 == a
modified_func def sat(x: int, a=wrap_int(2617350631613713636)):
    return x ** wrap_int(2) == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 2) 2617350631613713636))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1617822806))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1617822806))
)

Found solution -1617822806
Yes! Solved for puzzle  IntSquareRoot:1

Solving puzzle 754/774: IntSquareRoot:2
sat_func def sat(x: int, a=100703210763886864):
    return x ** 2 == a
modified_func def sat(x: int, a=wrap_int(100703210763886864)):
    return x ** wrap_int(2) == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 2) 100703210763886864))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 317337692))
)
### output for cvc5
sat
(
(define-fun x () Int (- 317337692))
)

Found solution -317337692
Yes! Solved for puzzle  IntSquareRoot:2

Solving puzzle 755/774: IntSquareRoot:3
sat_func def sat(x: int, a=12515426721927424):
    return x ** 2 == a
modified_func def sat(x: int, a=wrap_int(12515426721927424)):
    return x ** wrap_int(2) == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 2) 12515426721927424))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 111872368))
)
### output for cvc5
sat
(
(define-fun x () Int (- 111872368))
)

Found solution -111872368
Yes! Solved for puzzle  IntSquareRoot:3

Solving puzzle 756/774: IntSquareRoot:4
sat_func def sat(x: int, a=717898768141464900):
    return x ** 2 == a
modified_func def sat(x: int, a=wrap_int(717898768141464900)):
    return x ** wrap_int(2) == a
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (= (^ x 2) 717898768141464900))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 847289070))
)
### output for cvc5
sat
(
(define-fun x () Int (- 847289070))
)

Found solution -847289070
Yes! Solved for puzzle  IntSquareRoot:4

Solving puzzle 757/774: IntNegSquareRoot:0
sat_func def sat(n: int, a=10000200001):
    return a == n * n and n < 0
modified_func def sat(n: int, a=wrap_int(10000200001)):
    return (a == n * n).__and__(n < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= 10000200001 (* x x)) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 100001))
)
### output for cvc5
sat
(
(define-fun x () Int (- 100001))
)

Found solution -100001
Yes! Solved for puzzle  IntNegSquareRoot:0

Solving puzzle 758/774: IntNegSquareRoot:1
sat_func def sat(n: int, a=1153723843107852129):
    return a == n * n and n < 0
modified_func def sat(n: int, a=wrap_int(1153723843107852129)):
    return (a == n * n).__and__(n < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= 1153723843107852129 (* x x)) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1074115377))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1074115377))
)

Found solution -1074115377
Yes! Solved for puzzle  IntNegSquareRoot:1

Solving puzzle 759/774: IntNegSquareRoot:2
sat_func def sat(n: int, a=1940392439040171204):
    return a == n * n and n < 0
modified_func def sat(n: int, a=wrap_int(1940392439040171204)):
    return (a == n * n).__and__(n < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= 1940392439040171204 (* x x)) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1392979698))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1392979698))
)

Found solution -1392979698
Yes! Solved for puzzle  IntNegSquareRoot:2

Solving puzzle 760/774: IntNegSquareRoot:3
sat_func def sat(n: int, a=1256820805863398416):
    return a == n * n and n < 0
modified_func def sat(n: int, a=wrap_int(1256820805863398416)):
    return (a == n * n).__and__(n < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= 1256820805863398416 (* x x)) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1121080196))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1121080196))
)

Found solution -1121080196
Yes! Solved for puzzle  IntNegSquareRoot:3

Solving puzzle 761/774: IntNegSquareRoot:4
sat_func def sat(n: int, a=1001282815140004804):
    return a == n * n and n < 0
modified_func def sat(n: int, a=wrap_int(1001282815140004804)):
    return (a == n * n).__and__(n < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (and (= 1001282815140004804 (* x x)) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Int
    (- 1000641202))
)
### output for cvc5
sat
(
(define-fun x () Int (- 1000641202))
)

Found solution -1000641202
Yes! Solved for puzzle  IntNegSquareRoot:4

Solving puzzle 762/774: FloatSquareRoot:0
sat_func def sat(x: float, a=1020):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(1020)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 1020) 0) (- (^ x 2) 1020) (- (- (^ x 2) 1020))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle FloatSquareRoot:0
One large constant for extrapolation
Solving simpler variation replaced 1020 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(3)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle FloatSquareRoot:0

Solving puzzle 763/774: FloatSquareRoot:1
sat_func def sat(x: float, a=6173281296):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(6173281296)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 6173281296) 0) (- (^ x 2) 6173281296) (- (- (^ x 2) 6173281296))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 157141.0 2.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution 78570.5
WARNING: Solution verification failed for puzzle FloatSquareRoot:1
One large constant for extrapolation
Solving simpler variation replaced 6173281296 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(3)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle FloatSquareRoot:1

Solving puzzle 764/774: FloatSquareRoot:2
sat_func def sat(x: float, a=7987622700):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(7987622700)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 7987622700) 0) (- (^ x 2) 7987622700) (- (- (^ x 2) 7987622700))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (/ 357495.0 4.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution 89373.75
WARNING: Solution verification failed for puzzle FloatSquareRoot:2
One large constant for extrapolation
Solving simpler variation replaced 7987622700 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(3)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle FloatSquareRoot:2

Solving puzzle 765/774: FloatSquareRoot:3
sat_func def sat(x: float, a=2732656229):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(2732656229)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 2732656229) 0) (- (^ x 2) 2732656229) (- (- (^ x 2) 2732656229))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 52275.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution -52275.0
WARNING: Solution verification failed for puzzle FloatSquareRoot:3
One large constant for extrapolation
Solving simpler variation replaced 2732656229 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(3)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle FloatSquareRoot:3

Solving puzzle 766/774: FloatSquareRoot:4
sat_func def sat(x: float, a=1873585696):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(1873585696)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 1873585696) 0) (- (^ x 2) 1873585696) (- (- (^ x 2) 1873585696))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 43285.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution -43285.0
WARNING: Solution verification failed for puzzle FloatSquareRoot:4
One large constant for extrapolation
Solving simpler variation replaced 1873585696 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3
modified_func def sat(x: float, a=wrap_int(3)):
    return abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    0.0)
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.30: expecting same arithmetic types to POW")

Found solution 0.0
WARNING: Solution verification failed for puzzle FloatSquareRoot:4

Solving puzzle 767/774: FloatNegSquareRoot:0
sat_func def sat(x: float, a=1020):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(1020)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 1020) 0) (- (^ x 2) 1020) (- (- (^ x 2) 1020))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 1.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -1.0
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:0
One large constant for extrapolation
Solving simpler variation replaced 1020 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(3)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 1.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -1.0
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:0

Solving puzzle 768/774: FloatNegSquareRoot:1
sat_func def sat(x: float, a=2681275499):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(2681275499)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 2681275499) 0) (- (^ x 2) 2681275499) (- (- (^ x 2) 2681275499))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- (/ 103563.0 2.0)))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -51781.5
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:1
One large constant for extrapolation
Solving simpler variation replaced 2681275499 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(3)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 1.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -1.0
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:1

Solving puzzle 769/774: FloatNegSquareRoot:2
sat_func def sat(x: float, a=1363713245):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(1363713245)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 1363713245) 0) (- (^ x 2) 1363713245) (- (- (^ x 2) 1363713245))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 36929.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -36929.0
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:2
One large constant for extrapolation
Solving simpler variation replaced 1363713245 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(3)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 1.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -1.0
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:2

Solving puzzle 770/774: FloatNegSquareRoot:3
sat_func def sat(x: float, a=3858703402):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(3858703402)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 3858703402) 0) (- (^ x 2) 3858703402) (- (- (^ x 2) 3858703402))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- (/ 124237.0 2.0)))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -62118.5
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:3
One large constant for extrapolation
Solving simpler variation replaced 3858703402 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(3)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 1.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -1.0
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:3

Solving puzzle 771/774: FloatNegSquareRoot:4
sat_func def sat(x: float, a=3804892221):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(3804892221)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 3804892221) 0) (- (^ x 2) 3804892221) (- (- (^ x 2) 3804892221))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 61684.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -61684.0
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:4
One large constant for extrapolation
Solving simpler variation replaced 3804892221 with 3
sat_func def sat(x: float, a=3):
    return abs(x ** 2 - a) < 10 ** -3 and x < 0
modified_func def sat(x: float, a=wrap_int(3)):
    return (abs(x ** wrap_int(2) - a) < wrap_int(10) ** (-wrap_int(3))).__and__(x < wrap_int(0))
### smt2
(set-logic ALL)
(declare-const x Real)
(assert (and (< (ite (>= (- (^ x 2) 3) 0) (- (^ x 2) 3) (- (- (^ x 2) 3))) 59049) (< x 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () Real
    (- 1.0))
)
### output for cvc5
(error "Parse Error: tmp.smt2:3.35: expecting same arithmetic types to POW")

Found solution -1.0
WARNING: Solution verification failed for puzzle FloatNegSquareRoot:4

Solving puzzle 772/774: Tutorial1:0
sat_func def sat(s: str):
    return "Hello " + s == "Hello world"
modified_func def sat(s: str):
    return wrap_str('Hello ') + s == wrap_str('Hello world')
### smt2
(set-logic ALL)
(declare-const x String)
(assert (= (str.++ "Hello " x) "Hello world"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "world")
)
### output for cvc5
sat
(
(define-fun x () String "world")
)

Found solution world
Yes! Solved for puzzle  Tutorial1:0

Solving puzzle 773/774: Tutorial2:0
sat_func def sat(s: str):
    return "Hello " + s[::-1] == "Hello world"
modified_func def sat(s: str):
    return wrap_str('Hello ') + s[::-1] == wrap_str('Hello world')
### smt2
(set-logic ALL)

(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x String)
(assert (= (str.++ "Hello " (str.reverse x)) "Hello world"))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () String
    "dlrow")
)
### output for cvc5
sat
(
(define-fun x () String "dlrow")
)

Found solution dlrow
Yes! Solved for puzzle  Tutorial2:0

Solving puzzle 774/774: Tutorial5:0
sat_func def sat(n: int):
    return str(n * n).startswith("123456789")
modified_func def sat(n: int):
    return sym_str(n * n).startswith('123456789')
### smt2
(set-logic ALL)
(declare-const x Int)
(assert (str.prefixof "123456789" (str.from_int (* x x))))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
timeout
### output for cvc5
sat
(
(define-fun x () Int (- 111111111))
)

Found solution -111111111
Yes! Solved for puzzle  Tutorial5:0

## Current status

The symbolic execution alone currently solves:
- 61% (218 out of 360) of `int` puzzles,
- 34% (125 out of 363) of `str` puzzles,
- 18% (9 out of 51) of `float` puzzles,
- 45% (352 out of 774) overall.

with the following errors:
- 9 timeouts after 3 seconds at staging time (while generating the SMTLIB program)
- 118 errors at at staging time
- 187 SMTLIB programs returning `sat` but the original `sat` function failing on synthesized model input,
- 161 SMTLIB programs returning non-`sat` (e.g. `unsat`, `unknown` or timing out after 2 seconds
timeouts after staging (while building the SMTLIB program), errors during staging time, the SMTLIB
- 941 (out of 1715) puzzles not yet even attempted because their type is not `int` or `str`, such as `float`, `list` (of various specialization), etc.

### Extrapolation
- 120 smaller problems tried
- 21 successes on smaller problem

