Starting with 1715 puzzles...
Running benchmarks on 732 puzzles...
Filtered to puzzles of answer types: ['List[int]', 'List[str]']

Solving puzzle 1/732: Study_3:0
sat_func def sat(li: List[int]):
    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))
modified_func def sat(li: List[int]):
    return (sym_sorted(li) == list(sym_range(999))).__and__(all(sym_generator((li[i] != i for i in sym_range(sym_len(li))))))
Exception -- for puzzle Study_3:0 Cannot convert symbolic integer to index

Solving puzzle 2/732: Study_4:0
sat_func def sat(li: List[int]):
    return len(li) == 10 and li.count(li[3]) == 2
modified_func def sat(li: List[int]):
    return (sym_len(li) == wrap_int(10)).__and__(li.count(li[wrap_int(3)]) == wrap_int(2))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (= (list.length.int x) 10) (= (list.count.int x (list.get.int x 3)) 2)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 0 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 1 (as nil (List Int)))))))))))))
)

Found solution [0, 1, 1, 0, 1, 1, 1, 1, 1, 1]
Yes! Solved for puzzle  Study_4:0

Solving puzzle 3/732: Study_5:0
sat_func def sat(li: List[int]):
    return all([li.count(i) == i for i in range(10)])
modified_func def sat(li: List[int]):
    return all([li.count(i) == i for i in sym_range(10)])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (= (list.count.int x 0) 0) (= (list.count.int x 1) 1)) (= (list.count.int x 2) 2)) (= (list.count.int x 3) 3)) (= (list.count.int x 4) 4)) (= (list.count.int x 5) 5)) (= (list.count.int x 6) 6)) (= (list.count.int x 7) 7)) (= (list.count.int x 8) 8)) (= (list.count.int x 9) 9)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Study_5:0
Too many constants for extrapolation

Solving puzzle 4/732: Study_8:0
sat_func def sat(ls: List[str]):
    return ls[1234] in ls[1235] and ls[1234] != ls[1235]
modified_func def sat(ls: List[str]):
    return sym_in(ls[wrap_int(1234)], ls[wrap_int(1235)]).__and__(ls[wrap_int(1234)] != ls[wrap_int(1235)])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (and (str.contains (list.get.string x 1235) (list.get.string x 1234)) (not (= (list.get.string x 1234) (list.get.string x 1235)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Study_8:0
Two large constants for extrapolation
Solving simpler variation replaced 1234 with 3 and 1235 with 5
sat_func def sat(ls: List[str]):
    return ls[3] in ls[5] and ls[3] != ls[5]
modified_func def sat(ls: List[str]):
    return sym_in(ls[wrap_int(3)], ls[wrap_int(5)]).__and__(ls[wrap_int(3)] != ls[wrap_int(5)])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (and (str.contains (list.get.string x 5) (list.get.string x 3)) (not (= (list.get.string x 3) (list.get.string x 5)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "" ((as cons (List String)) "" ((as cons (List String)) "" ((as cons (List String)) "" ((as cons (List String)) "" ((as cons (List String)) "A" (as nil (List String)))))))))
)

Found solution ['', '', '', '', '', 'A']

Solving puzzle 5/732: Study_9:0
sat_func def sat(li: List[int]):
    return ["The quick brown fox jumps over the lazy dog"[i] for i in li] == list(
        "The five boxing wizards jump quickly")
modified_func def sat(li: List[int]):
    return [wrap_str('The quick brown fox jumps over the lazy dog')[i] for i in li] == list(wrap_str('The five boxing wizards jump quickly'))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_0 Int)) (=> (and (>= list_pos_0 0) (< list_pos_0 (list.length.int x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Study_9:0
Too many constants for extrapolation

Solving puzzle 6/732: Study_11:0
sat_func def sat(ls: List[str]):
    return min(ls) == max(ls) == str(len(ls))
modified_func def sat(ls: List[str]):
    return (min(ls) == max(ls)).__and__(max(ls) == sym_str(sym_len(ls)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_3 Int)) (=> (and (>= list_pos_3 0) (< list_pos_3 (list.length.string x))) (forall ((list_pos_2 Int)) (=> (and (>= list_pos_2 0) (< list_pos_2 (list.length.string x))) (forall ((list_pos_1 Int)) (=> (and (>= list_pos_1 0) (< list_pos_1 (list.length.string x))) (and (= (list.get.string x list_pos_1) (list.get.string x list_pos_2)) (= (list.get.string x list_pos_3) (str.from_int (list.length.string x)))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle Study_11:0
Too many constants for extrapolation

Solving puzzle 7/732: Study_12:0
sat_func def sat(li: List[int]):
    return all(i + j == 9 for i, j in zip([4] + li, li)) and len(li) == 1000
modified_func def sat(li: List[int]):
    return all(sym_generator((i + j == wrap_int(9) for i, j in sym_zip(wrap_list([wrap_int(4)]) + li, li)))).__and__(sym_len(li) == wrap_int(1000))
Exception -- for puzzle Study_12:0 found bad constraint NotImplemented of type <class 'NotImplementedType'>

Solving puzzle 8/732: Study_14:0
sat_func def sat(li: List[int]):
    return all([sum(li[:i]) == i for i in range(20)])
modified_func def sat(li: List[int]):
    return all([sym_sum(li[:i]) == i for i in sym_range(20)])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_23 Int)) (=> (and (>= list_pos_23 0) (< list_pos_23 (list.length.int (list.slice.int x 0 19 1)))) (forall ((list_pos_22 Int)) (=> (and (>= list_pos_22 0) (< list_pos_22 (list.length.int (list.slice.int x 0 18 1)))) (forall ((list_pos_21 Int)) (=> (and (>= list_pos_21 0) (< list_pos_21 (list.length.int (list.slice.int x 0 17 1)))) (forall ((list_pos_20 Int)) (=> (and (>= list_pos_20 0) (< list_pos_20 (list.length.int (list.slice.int x 0 16 1)))) (forall ((list_pos_19 Int)) (=> (and (>= list_pos_19 0) (< list_pos_19 (list.length.int (list.slice.int x 0 15 1)))) (forall ((list_pos_18 Int)) (=> (and (>= list_pos_18 0) (< list_pos_18 (list.length.int (list.slice.int x 0 14 1)))) (forall ((list_pos_17 Int)) (=> (and (>= list_pos_17 0) (< list_pos_17 (list.length.int (list.slice.int x 0 13 1)))) (forall ((list_pos_16 Int)) (=> (and (>= list_pos_16 0) (< list_pos_16 (list.length.int (list.slice.int x 0 12 1)))) (forall ((list_pos_15 Int)) (=> (and (>= list_pos_15 0) ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Study_14:0
Too many constants for extrapolation

Solving puzzle 9/732: Study_15:0
sat_func def sat(li: List[int]):
    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))
modified_func def sat(li: List[int]):
    return all(sym_generator((sym_sum(li[:i]) == wrap_int(2) ** i - wrap_int(1) for i in sym_range(20))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_43 Int)) (=> (and (>= list_pos_43 0) (< list_pos_43 (list.length.int (list.slice.int x 0 19 1)))) (forall ((list_pos_42 Int)) (=> (and (>= list_pos_42 0) (< list_pos_42 (list.length.int (list.slice.int x 0 18 1)))) (forall ((list_pos_41 Int)) (=> (and (>= list_pos_41 0) (< list_pos_41 (list.length.int (list.slice.int x 0 17 1)))) (forall ((list_pos_40 Int)) (=> (and (>= list_pos_40 0) (< list_pos_40 (list.length.int (list.slice.int x 0 16 1)))) (forall ((list_pos_39 Int)) (=> (and (>= list_pos_39 0) (< list_pos_39 (list.length.int (list.slice.int x 0 15 1)))) (forall ((list_pos_38 Int)) (=> (and (>= list_pos_38 0) (< list_pos_38 (list.length.int (list.slice.int x 0 14 1)))) (forall ((list_pos_37 Int)) (=> (and (>= list_pos_37 0) (< list_pos_37 (list.length.int (list.slice.int x 0 13 1)))) (forall ((list_pos_36 Int)) (=> (and (>= list_pos_36 0) (< list_pos_36 (list.length.int (list.slice.int x 0 12 1)))) (forall ((list_pos_35 Int)) (=> (and (>= list_pos_35 0) ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Study_15:0
Too many constants for extrapolation

Solving puzzle 10/732: Study_18:0
sat_func def sat(ls: List[str]):
    return [s + t for s in ls for t in ls if s != t] == 'berlin berger linber linger gerber gerlin'.split()
modified_func def sat(ls: List[str]):
    return [s + t for s in ls for t in ls if s != t] == wrap_str('berlin berger linber linger gerber gerlin').split()
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_45 Int)) (=> (and (>= list_pos_45 0) (< list_pos_45 (list.length.string x))) (forall ((list_pos_44 Int)) (=> (and (>= list_pos_44 0) (< list_pos_44 (list.length.string x))) (=> (not (= (list.get.string x list_pos_44) (list.get.string x list_pos_45))) false))))))
(assert (forall ((list_pos_47 Int)) (=> (and (>= list_pos_47 0) (< list_pos_47 (list.length.string x))) (forall ((list_pos_46 Int)) (=> (and (>= list_pos_46 0) (< list_pos_46 (list.length.string x))) (forall ((list_pos_45 Int)) (=> (and (>= list_pos_45 0) (< list_pos_45 (list.length.string x))) (forall ((list_pos_44 Int)) (=> (and (>= list_pos_44 0) (< list_pos_44 (list.length.string x))) (=> (not (not (= (list.get.string x list_pos_46) (list.get.string x list_pos_47)))) false))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle Study_18:0
Too many constants for extrapolation

Solving puzzle 11/732: Study_19:0
sat_func def sat(li: List[int]):
    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}
modified_func def sat(li: List[int]):
    return {i + j for i in li for j in li} == {wrap_int(0), wrap_int(1), wrap_int(2), wrap_int(3), wrap_int(4), wrap_int(5), wrap_int(6), wrap_int(17), wrap_int(18), wrap_int(19), wrap_int(20), wrap_int(34)}
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_49 Int)) (=> (and (>= list_pos_49 0) (< list_pos_49 (list.length.int x))) (forall ((list_pos_48 Int)) (=> (and (>= list_pos_48 0) (< list_pos_48 (list.length.int x))) false)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Study_19:0
Too many constants for extrapolation

Solving puzzle 12/732: Study_20:0
sat_func def sat(li: List[int]):
    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128]))
modified_func def sat(li: List[int]):
    return all(sym_generator((sym_in(j, {i - wrap_int(1), i + wrap_int(1), wrap_int(3) * i}) for i, j in sym_zip(wrap_list([wrap_int(0)]) + li, li + wrap_list([wrap_int(128)])))))
Exception -- for puzzle Study_20:0 'set' object has no attribute 'contains'

Solving puzzle 13/732: Study_21:0
sat_func def sat(li: List[int]):
    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3
modified_func def sat(li: List[int]):
    return all([li[i] != li[i + wrap_int(1)] for i in sym_range(10)]).__and__(sym_len(set(li)) == wrap_int(3))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_50 Int)) (=> (and (>= list_pos_50 0) (< list_pos_50 (list.length.int x))) (and (and (and (and (and (and (and (and (and (and (not (= (list.get.int x 0) (list.get.int x 1))) (not (= (list.get.int x 1) (list.get.int x 2)))) (not (= (list.get.int x 2) (list.get.int x 3)))) (not (= (list.get.int x 3) (list.get.int x 4)))) (not (= (list.get.int x 4) (list.get.int x 5)))) (not (= (list.get.int x 5) (list.get.int x 6)))) (not (= (list.get.int x 6) (list.get.int x 7)))) (not (= (list.get.int x 7) (list.get.int x 8)))) (not (= (list.get.int x 8) (list.get.int x 9)))) (not (= (list.get.int x 9) (list.get.int x 10)))) false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Study_21:0
Too many constants for extrapolation

Solving puzzle 14/732: Study_23:0
sat_func def sat(ls: List[str]):
    return tuple(ls) in zip('dee', 'doo', 'dah!')
modified_func def sat(ls: List[str]):
    return sym_in(tuple(ls), sym_zip(wrap_str('dee'), wrap_str('doo'), wrap_str('dah!')))
Exception -- for puzzle Study_23:0 Cannot convert symbolic integer to index

Solving puzzle 15/732: Study_24:0
sat_func def sat(li: List[int]):
    return li.count(17) == 3 and li.count(3) >= 2
modified_func def sat(li: List[int]):
    return (li.count(wrap_int(17)) == wrap_int(3)).__and__(li.count(wrap_int(3)) >= wrap_int(2))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (= (list.count.int x 17) 3) (>= (list.count.int x 3) 2)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 17 ((as cons (List Int)) 17 ((as cons (List Int)) 17 ((as cons (List Int)) 3 ((as cons (List Int)) 3 (as nil (List Int))))))))
)

Found solution [17, 17, 17, 3, 3]
Yes! Solved for puzzle  Study_24:0

Solving puzzle 16/732: Study_26:0
sat_func def sat(ls: List[str]):
    return "".join(ls) == str(8 ** 88) and all(len(s) == 8 for s in ls)
modified_func def sat(ls: List[str]):
    return (wrap_str('').join(ls) == sym_str(wrap_int(8) ** wrap_int(88))).__and__(all(sym_generator((sym_len(s) == wrap_int(8) for s in ls))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (forall ((list_pos_51 Int)) (=> (and (>= list_pos_51 0) (< list_pos_51 (list.length.string x))) (and (= (python.join x "") "3596345248055296") (= (str.len (list.get.string x list_pos_51)) 8)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle Study_26:0
Too many constants for extrapolation

Solving puzzle 17/732: Study_27:0
sat_func def sat(li: List[int]):
    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]
modified_func def sat(li: List[int]):
    return (li[li[wrap_int(0)]] != li[li[wrap_int(1)]]).__and__(li[li[li[wrap_int(0)]]] == li[li[li[wrap_int(1)]]])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (not (= (list.get.int x (list.get.int x 0)) (list.get.int x (list.get.int x 1)))) (= (list.get.int x (list.get.int x (list.get.int x 0))) (list.get.int x (list.get.int x (list.get.int x 1))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle Study_27:0
Too many constants for extrapolation

Solving puzzle 18/732: Study_28:0
sat_func def sat(li: List[int]):
    return all(i in range(1000) and abs(i - j) >= 10 for i in li for j in li if i != j) and len(set(li)) == 100
modified_func def sat(li: List[int]):
    return all(sym_generator((sym_in(i, sym_range(1000)).__and__(abs(i - j) >= wrap_int(10)) for i in li for j in li if i != j))).__and__(sym_len(set(li)) == wrap_int(100))
Exception -- for puzzle Study_28:0 'range' object has no attribute 'contains'

Solving puzzle 19/732: Study_29:0
sat_func def sat(l: List[int]):
    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j) and len(set(l)) > 995
modified_func def sat(l: List[int]):
    return all(sym_generator((sym_in(i, sym_range(1000)).__and__(abs(i * i - j * j) >= wrap_int(10)) for i in l for j in l if i != j))).__and__(sym_len(set(l)) > wrap_int(995))
Exception -- for puzzle Study_29:0 'range' object has no attribute 'contains'

Solving puzzle 20/732: Study_30:0
sat_func def sat(li: List[int]):
    return all([123 * li[i] % 1000 < 123 * li[i + 1] % 1000 and li[i] in range(1000) for i in range(20)])
modified_func def sat(li: List[int]):
    return all([(wrap_int(123) * li[i] % wrap_int(1000) < wrap_int(123) * li[i + wrap_int(1)] % wrap_int(1000)).__and__(sym_in(li[i], sym_range(1000))) for i in sym_range(20)])
Exception -- for puzzle Study_30:0 'range' object has no attribute 'contains'

Solving puzzle 21/732: LongestMonotonicSubstring:0
sat_func def sat(x: List[int], length=13, s="Dynamic programming solves this puzzle!!!"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(13), s=wrap_str('Dynamic programming solves this puzzle!!!')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__((x[i + wrap_int(1)] > x[i]).__and__(x[i] >= wrap_int(0))) for i in sym_range(length - 1))))
Exception -- for puzzle LongestMonotonicSubstring:0 '<=' not supported between instances of 'SymbolicSlice' and 'SymbolicSlice'

Solving puzzle 22/732: LongestMonotonicSubstring:1
sat_func def sat(x: List[int], length=193, s="    !!\"\"\"#$$%&&')''((()!))****X**++,,,,---...///0111114445556888::::;s;;<<==,=>>>>ABBBBBCDEEEEEEEFGHIIKKKKLMNOOPPPQQQRRRRASUUUVVVWWXXZZZ[]]]!``aEaabbbccccPcdeeeeefghjjjjkkkllmmooooKpppppqsttwt'$ww=wLwwyyyyzz{"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(193), s=wrap_str('    !!"""#$$%&&\')\'\'((()!))****X**++,,,,---...///0111114445556888::::;s;;<<==,=>>>>ABBBBBCDEEEEEEEFGHIIKKKKLMNOOPPPQQQRRRRASUUUVVVWWXXZZZ[]]]!``aEaabbbccccPcdeeeeefghjjjjkkkllmmooooKpppppqsttwt\'$ww=wLwwyyyyzz{')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__((x[i + wrap_int(1)] > x[i]).__and__(x[i] >= wrap_int(0))) for i in sym_range(length - 1))))
Exception -- for puzzle LongestMonotonicSubstring:1 '<=' not supported between instances of 'SymbolicSlice' and 'SymbolicSlice'

Solving puzzle 23/732: LongestMonotonicSubstring:2
sat_func def sat(x: List[int], length=737, s="    _   !m!!!!!!!!!!!V!\"=\"\"\"\"\"l#####$$r$$$$$$$$$%%%%%&&&&&&y&''''''@'''''<(((())))))******+++++++p,,,,,!,-----w-----o-....,.......//////D000000000000111111111222222,23h33c33334444444'4455555555566666R6@9777777T7888888-8994999999999::::::::::;;;;;;;P;;;<<<:<<^<)<<sn<<<====u=*=>>>>>>>>>???A?j??8??.?@@O@@@@@@ArAA&ABBBBBBBBBCCCCCDDDEEEEEEEEE%E(EEEEEFF!FFG-GGGGGGGGHHCHHHIGIsIIIInIIIIJJJRJFJJKKKKKKa0K<KKLL.LLLLLLMMMnMMM_MMMNNNONNOOOOOPPPP4LPPPPQQ\\QQQbQQQ7QQRRRRR\"RRSSSSSSTTgTTTTUUtUUUUUVVVVVVVVVVVqVVVMWWRWWWWWWWW%XXXXXXXXXXYYYYYZZZZZZZZZ2y[S[[[I[[[[\\$g\"\\\\\\\\T]]]]]]]]]]^^o^^______________`?&`I`y````aaaaaabbbbcccccc3ddddIu;L*dddeeee#eee]ffff1f]=fffffffffgggghhxhhhhhhiigiiiiiiiDiiCiiiijLjjIljjjjjjjkklllllmmmmJymmmmnnnnMnnnnnnoooiobooXoopppppqy5qqqdqqrrIrrrrJrssssssssTsstt'ttttZttt@tttuluuuuu0uuuvvxvvvv\\vv3vvvvwwwwwwba.wwx4xxxxxxxxxxxxxJyyyyyyyyyyzzzzzzzz{{{{{{{{"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(737), s=wrap_str('    _   !m!!!!!!!!!!!V!"="""""l#####$$r$$$$$$$$$%%%%%&&&&&&y&\'\'\'\'\'\'@\'\'\'\'\'<(((())))))******+++++++p,,,,,!,-----w-----o-....,.......//////D000000000000111111111222222,23h33c33334444444\'4455555555566666R6@9777777T7888888-8994999999999::::::::::;;;;;;;P;;;<<<:<<^<)<<sn<<<====u=*=>>>>>>>>>???A?j??8??.?@@O@@@@@@ArAA&ABBBBBBBBBCCCCCDDDEEEEEEEEE%E(EEEEEFF!FFG-GGGGGGGGHHCHHHIGIsIIIInIIIIJJJRJFJJKKKKKKa0K<KKLL.LLLLLLMMMnMMM_MMMNNNONNOOOOOPPPP4LPPPPQQ\\QQQbQQQ7QQRRRRR"RRSSSSSSTTgTTTTUUtUUUUUVVVVVVVVVVVqVVVMWWRWWWWWWWW%XXXXXXXXXXYYYYYZZZZZZZZZ2y[S[[[I[[[[\\$g"\\\\\\\\T]]]]]]]]]]^^o^^______________`?&`I`y````aaaaaabbbbcccccc3ddddIu;L*dddeeee#eee]ffff1f]=fffffffffgggghhxhhhhhhiigiiiiiiiDiiCiiiijLjjIljjjjjjjkklllllmmmmJymmmmnnnnMnnnnnnoooiobooXoopppppqy5qqqdqqrrIrrrrJrssssssssTsstt\'ttttZttt@tttuluuuuu0uuuvvxvvvv\\vv3vvvvwwwwwwba.wwx4xxxxxxxxxxxxxJyyyyyyyyyyzzzzzzzz{{{{{{{{')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__((x[i + wrap_int(1)] > x[i]).__and__(x[i] >= wrap_int(0))) for i in sym_range(length - 1))))
Exception -- for puzzle LongestMonotonicSubstring:2 '<=' not supported between instances of 'SymbolicSlice' and 'SymbolicSlice'

Solving puzzle 24/732: LongestMonotonicSubstring:3
sat_func def sat(x: List[int], length=0, s=""):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(0), s=wrap_str('')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__((x[i + wrap_int(1)] > x[i]).__and__(x[i] >= wrap_int(0))) for i in sym_range(length - 1))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Yes! Solved for puzzle  LongestMonotonicSubstring:3

Solving puzzle 25/732: LongestMonotonicSubstring:4
sat_func def sat(x: List[int], length=1, s="xwV"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] >= 0 for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(1), s=wrap_str('xwV')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__((x[i + wrap_int(1)] > x[i]).__and__(x[i] >= wrap_int(0))) for i in sym_range(length - 1))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Yes! Solved for puzzle  LongestMonotonicSubstring:4

Solving puzzle 26/732: LongestMonotonicSubstringTricky:0
sat_func def sat(x: List[int], length=20, s="Dynamic programming solves this classic job-interview puzzle!!!"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(20), s=wrap_str('Dynamic programming solves this classic job-interview puzzle!!!')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__(x[i + wrap_int(1)] > x[i]) for i in sym_range(length - 1))))
Exception -- for puzzle LongestMonotonicSubstringTricky:0 '<=' not supported between instances of 'SymbolicSlice' and 'SymbolicSlice'

Solving puzzle 27/732: LongestMonotonicSubstringTricky:1
sat_func def sat(x: List[int], length=535, s="RRRS  S !L!eSSSS!TTT+!TTTUU!!UU!UU\"U\"\"\"VVV\"\"\"VK#WW##gfW##X##6$$X$XX@$XXP%%%YY%+YY%&ZZ)%ZZ&#Z&[&[[[[\\'\\\\]\\\\]''']]']]]^^(^R^((^))^)^^*^_*_L____**;**_``*```++`+`+[+++``,m,,`,,-aa@aa[a-arb-b--b(vzbb-.b.6.ccc.cKcc.cc//c/cc//dddddd/0deeeee000e0f0ff0f01ff11f1<1gg;g12R2g22233gg33g333g3g445555566ghhh66799h9hhh9h999iEii/iYi::i::j:jvv:;;;;jj<j<<k===kkkk===ll=l=l>>l>ll0>l>m>m@mmm??0m^,?nn???n?sn@@oo@DobAAooAo7AAppppBqC$qqqqCCCCqqqqrDrrrrrrrDbrsDDDEsEs9asssfttEtttEEEtEEtFFtuuLFuuuFFFvF0FGvGGGvvvvRwwwwxGHxHHHx+HIxxIexxIIyyyPCyyyII,yIyyIzIJzJJQJzKzzKz{KK{{{{{[K{K{KK{?{KLLLLLLLMMM>NNNNNOOOOOOOOPPPQQQQQQQRRR"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(535), s=wrap_str('RRRS  S !L!eSSSS!TTT+!TTTUU!!UU!UU"U"""VVV"""VK#WW##gfW##X##6$$X$XX@$XXP%%%YY%+YY%&ZZ)%ZZ&#Z&[&[[[[\\\'\\\\]\\\\]\'\'\']]\']]]^^(^R^((^))^)^^*^_*_L____**;**_``*```++`+`+[+++``,m,,`,,-aa@aa[a-arb-b--b(vzbb-.b.6.ccc.cKcc.cc//c/cc//dddddd/0deeeee000e0f0ff0f01ff11f1<1gg;g12R2g22233gg33g333g3g445555566ghhh66799h9hhh9h999iEii/iYi::i::j:jvv:;;;;jj<j<<k===kkkk===ll=l=l>>l>ll0>l>m>m@mmm??0m^,?nn???n?sn@@oo@DobAAooAo7AAppppBqC$qqqqCCCCqqqqrDrrrrrrrDbrsDDDEsEs9asssfttEtttEEEtEEtFFtuuLFuuuFFFvF0FGvGGGvvvvRwwwwxGHxHHHx+HIxxIexxIIyyyPCyyyII,yIyyIzIJzJJQJzKzzKz{KK{{{{{[K{K{KK{?{KLLLLLLLMMM>NNNNNOOOOOOOOPPPQQQQQQQRRR')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__(x[i + wrap_int(1)] > x[i]) for i in sym_range(length - 1))))
Exception -- for puzzle LongestMonotonicSubstringTricky:1 '<=' not supported between instances of 'SymbolicSlice' and 'SymbolicSlice'

Solving puzzle 28/732: LongestMonotonicSubstringTricky:2
sat_func def sat(x: List[int], length=1, s="O!A{SeKv"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(1), s=wrap_str('O!A{SeKv')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__(x[i + wrap_int(1)] > x[i]) for i in sym_range(length - 1))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Yes! Solved for puzzle  LongestMonotonicSubstringTricky:2

Solving puzzle 29/732: LongestMonotonicSubstringTricky:3
sat_func def sat(x: List[int], length=61, s=" OW##P%T'UW)X+X-YY]^_`bd/044e5egk7lm779:<m?D@ADnnpDEFIpNNOqqwxx"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(61), s=wrap_str(" OW##P%T'UW)X+X-YY]^_`bd/044e5egk7lm779:<m?D@ADnnpDEFIpNNOqqwxx")):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__(x[i + wrap_int(1)] > x[i]) for i in sym_range(length - 1))))
Exception -- for puzzle LongestMonotonicSubstringTricky:3 '<=' not supported between instances of 'SymbolicSlice' and 'SymbolicSlice'

Solving puzzle 30/732: LongestMonotonicSubstringTricky:4
sat_func def sat(x: List[int], length=19, s="1>C>DmJh5\"Ju,\"Q8zJ_u-O-VfnVTZ?W'm=jq.\\l&%m$cU.nqv2\\**.o\">]FZ5owil>l*kIM wcLd<*UX`\"_u'DC3R$8wr;jT]CW\"F$QKeRPMzZY'U42&Km dRr8b$T3x)w2v,_k(dR,F:`=c$MjE_Kf/KCXFg^ueiO.U%S8_](:GF;`2`^O%eAqSRAHW0dYg5!u<ZV@usa`-<<ET@xZ)&<6=ogIhp9jJ/`$/_jEa-N$oZVT6#]^]x5u!$ Xk?g=TMwVGZqTU(OeH!Jbgz!9`%yxq(GN+@yD6RM1M#:geJpIPw1l{xxK!z'tXS5-S+vvE(nO:I_`l14Gz@U^.Ra73g!iH\\\"0{*>F@K'q>2HgCc^:baOy[,9vJtFWPAed2w_7zHLl&.x^:XLwwtS+Ocr#, *qXmo9Sp,Z>{l&ElT>RNZ:.5f6,yedMqH8?jA=_@oK;X\\pm>r0Il0+k\\,&'u*(S`]>u?(4M\\3=0 F<Jh?v`wz85A=?q3FUP<HiW[t0QB-Dx=e=ggmY29G4[HR!4i-*y@s$0)E'XPud6)gt(O[RWVf]ci,4.(:  8H[**k[g* T`z.Y2)Oq5`R8H$$joU/xfl*e4 \\z>*MS8wqj0(HwK?gvpuma{V5inBL\",39`%*r$uPi=%:s!<?{FCb-zILUAT?kdy\"B;sfYu#DoVp-'+]z:/c8eo2v&UAoeXEe:w#JZHKR\\3Xmxf'9jlHli*PTR-y`sdqRnv=;E$s]m!%I*`<*&.5N)wrI\"C=4^9RP5'9[5\"uG(4YU{3_aPHffi<E*+nVYQq37UP(P#wU9;p0Si.vyM1e?tXWZ9dRho1i!(we-<waQrvITH6vkTCG2 9hxMvtZ8QdR%WQ[B^0X1B;Vm&g/o=;YlD5[`Oh"):
    return all(s[x[i]] <= s[x[i + 1]] and x[i + 1] > x[i] for i in range(length - 1))
modified_func def sat(x: List[int], length=wrap_int(19), s=wrap_str('1>C>DmJh5"Ju,"Q8zJ_u-O-VfnVTZ?W\'m=jq.\\l&%m$cU.nqv2\\**.o">]FZ5owil>l*kIM wcLd<*UX`"_u\'DC3R$8wr;jT]CW"F$QKeRPMzZY\'U42&Km dRr8b$T3x)w2v,_k(dR,F:`=c$MjE_Kf/KCXFg^ueiO.U%S8_](:GF;`2`^O%eAqSRAHW0dYg5!u<ZV@usa`-<<ET@xZ)&<6=ogIhp9jJ/`$/_jEa-N$oZVT6#]^]x5u!$ Xk?g=TMwVGZqTU(OeH!Jbgz!9`%yxq(GN+@yD6RM1M#:geJpIPw1l{xxK!z\'tXS5-S+vvE(nO:I_`l14Gz@U^.Ra73g!iH\\"0{*>F@K\'q>2HgCc^:baOy[,9vJtFWPAed2w_7zHLl&.x^:XLwwtS+Ocr#, *qXmo9Sp,Z>{l&ElT>RNZ:.5f6,yedMqH8?jA=_@oK;X\\pm>r0Il0+k\\,&\'u*(S`]>u?(4M\\3=0 F<Jh?v`wz85A=?q3FUP<HiW[t0QB-Dx=e=ggmY29G4[HR!4i-*y@s$0)E\'XPud6)gt(O[RWVf]ci,4.(:  8H[**k[g* T`z.Y2)Oq5`R8H$$joU/xfl*e4 \\z>*MS8wqj0(HwK?gvpuma{V5inBL",39`%*r$uPi=%:s!<?{FCb-zILUAT?kdy"B;sfYu#DoVp-\'+]z:/c8eo2v&UAoeXEe:w#JZHKR\\3Xmxf\'9jlHli*PTR-y`sdqRnv=;E$s]m!%I*`<*&.5N)wrI"C=4^9RP5\'9[5"uG(4YU{3_aPHffi<E*+nVYQq37UP(P#wU9;p0Si.vyM1e?tXWZ9dRho1i!(we-<waQrvITH6vkTCG2 9hxMvtZ8QdR%WQ[B^0X1B;Vm&g/o=;YlD5[`Oh')):
    return all(sym_generator(((s[x[i]] <= s[x[i + wrap_int(1)]]).__and__(x[i + wrap_int(1)] > x[i]) for i in sym_range(length - 1))))
Exception -- for puzzle LongestMonotonicSubstringTricky:4 '<=' not supported between instances of 'SymbolicSlice' and 'SymbolicSlice'

Solving puzzle 31/732: BooleanPythagoreanTriples:0
sat_func def sat(colors: List[int], n=100):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
modified_func def sat(colors: List[int], n=wrap_int(100)):
    _assert((set(colors) <= {wrap_int(0), wrap_int(1)}).__and__(sym_len(colors) >= n))
    squares = {i ** wrap_int(2): colors[i] for i in sym_range(1, sym_len(colors))}
    return sym_not(any(sym_generator(((c == d).__and__(d == squares.get(i + j)) for i, c in squares.items() for j, d in squares.items()))))
Exception -- for puzzle BooleanPythagoreanTriples:0 'NoneType' object has no attribute 'z3_expr'

Solving puzzle 32/732: BooleanPythagoreanTriples:1
sat_func def sat(colors: List[int], n=7824):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
modified_func def sat(colors: List[int], n=wrap_int(7824)):
    _assert((set(colors) <= {wrap_int(0), wrap_int(1)}).__and__(sym_len(colors) >= n))
    squares = {i ** wrap_int(2): colors[i] for i in sym_range(1, sym_len(colors))}
    return sym_not(any(sym_generator(((c == d).__and__(d == squares.get(i + j)) for i, c in squares.items() for j, d in squares.items()))))
Exception -- for puzzle BooleanPythagoreanTriples:1 'NoneType' object has no attribute 'z3_expr'

Solving puzzle 33/732: BooleanPythagoreanTriples:2
sat_func def sat(colors: List[int], n=0):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
modified_func def sat(colors: List[int], n=wrap_int(0)):
    _assert((set(colors) <= {wrap_int(0), wrap_int(1)}).__and__(sym_len(colors) >= n))
    squares = {i ** wrap_int(2): colors[i] for i in sym_range(1, sym_len(colors))}
    return sym_not(any(sym_generator(((c == d).__and__(d == squares.get(i + j)) for i, c in squares.items() for j, d in squares.items()))))
Exception -- for puzzle BooleanPythagoreanTriples:2 'NoneType' object has no attribute 'z3_expr'

Solving puzzle 34/732: BooleanPythagoreanTriples:3
sat_func def sat(colors: List[int], n=1):
    assert set(colors) <= {0, 1} and len(colors) >= n
    squares = {i ** 2: colors[i] for i in range(1, len(colors))}
    return not any(c == d == squares.get(i + j) for i, c in squares.items() for j, d in squares.items())
modified_func def sat(colors: List[int], n=wrap_int(1)):
    _assert((set(colors) <= {wrap_int(0), wrap_int(1)}).__and__(sym_len(colors) >= n))
    squares = {i ** wrap_int(2): colors[i] for i in sym_range(1, sym_len(colors))}
    return sym_not(any(sym_generator(((c == d).__and__(d == squares.get(i + j)) for i, c in squares.items() for j, d in squares.items()))))
Exception -- for puzzle BooleanPythagoreanTriples:3 'NoneType' object has no attribute 'z3_expr'

Solving puzzle 35/732: ClockAngle:0
sat_func def sat(hands: List[int], target_angle=45):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
modified_func def sat(hands: List[int], target_angle=wrap_int(45)):
    h, m = hands
    _assert((wrap_int(0) < h).__and__(h <= wrap_int(12)).__and__((wrap_int(0) <= m).__and__(m < wrap_int(60))))
    hour_angle = wrap_int(30) * h + m / wrap_int(2)
    minute_angle = wrap_int(6) * m
    return sym_in(abs(hour_angle - minute_angle), wrap_list([target_angle, wrap_int(360) - target_angle]))
Exception -- for puzzle ClockAngle:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 36/732: ClockAngle:1
sat_func def sat(hands: List[int], target_angle=39):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
modified_func def sat(hands: List[int], target_angle=wrap_int(39)):
    h, m = hands
    _assert((wrap_int(0) < h).__and__(h <= wrap_int(12)).__and__((wrap_int(0) <= m).__and__(m < wrap_int(60))))
    hour_angle = wrap_int(30) * h + m / wrap_int(2)
    minute_angle = wrap_int(6) * m
    return sym_in(abs(hour_angle - minute_angle), wrap_list([target_angle, wrap_int(360) - target_angle]))
Exception -- for puzzle ClockAngle:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 37/732: ClockAngle:2
sat_func def sat(hands: List[int], target_angle=133):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
modified_func def sat(hands: List[int], target_angle=wrap_int(133)):
    h, m = hands
    _assert((wrap_int(0) < h).__and__(h <= wrap_int(12)).__and__((wrap_int(0) <= m).__and__(m < wrap_int(60))))
    hour_angle = wrap_int(30) * h + m / wrap_int(2)
    minute_angle = wrap_int(6) * m
    return sym_in(abs(hour_angle - minute_angle), wrap_list([target_angle, wrap_int(360) - target_angle]))
Exception -- for puzzle ClockAngle:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 38/732: ClockAngle:3
sat_func def sat(hands: List[int], target_angle=138):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
modified_func def sat(hands: List[int], target_angle=wrap_int(138)):
    h, m = hands
    _assert((wrap_int(0) < h).__and__(h <= wrap_int(12)).__and__((wrap_int(0) <= m).__and__(m < wrap_int(60))))
    hour_angle = wrap_int(30) * h + m / wrap_int(2)
    minute_angle = wrap_int(6) * m
    return sym_in(abs(hour_angle - minute_angle), wrap_list([target_angle, wrap_int(360) - target_angle]))
Exception -- for puzzle ClockAngle:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 39/732: ClockAngle:4
sat_func def sat(hands: List[int], target_angle=68):
    h, m = hands
    assert 0 < h <= 12 and 0 <= m < 60
    hour_angle = 30 * h + m / 2
    minute_angle = 6 * m
    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]
modified_func def sat(hands: List[int], target_angle=wrap_int(68)):
    h, m = hands
    _assert((wrap_int(0) < h).__and__(h <= wrap_int(12)).__and__((wrap_int(0) <= m).__and__(m < wrap_int(60))))
    hour_angle = wrap_int(30) * h + m / wrap_int(2)
    minute_angle = wrap_int(6) * m
    return sym_in(abs(hour_angle - minute_angle), wrap_list([target_angle, wrap_int(360) - target_angle]))
Exception -- for puzzle ClockAngle:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 40/732: PostageStamp:0
sat_func def sat(stamps: List[int], target=80, max_stamps=4, options=[10, 32, 8]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
modified_func def sat(stamps: List[int], target=wrap_int(80), max_stamps=wrap_int(4), options=wrap_list([wrap_int(10), wrap_int(32), wrap_int(8)])):
    for s in stamps:
        _assert(sym_in(s, options))
    return (sym_len(stamps) <= max_stamps).__and__(sym_sum(stamps) == target)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_65 Int)) (=> (and (>= list_pos_65 0) (< list_pos_65 (list.length.int x))) (or (= (list.get.int x list_pos_65) 10) (= (list.get.int x list_pos_65) 32) (= (list.get.int x list_pos_65) 8)))))
(assert (forall ((list_pos_66 Int)) (=> (and (>= list_pos_66 0) (< list_pos_66 (list.length.int x))) (forall ((list_pos_65 Int)) (=> (and (>= list_pos_65 0) (< list_pos_65 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (list.get.int x list_pos_66) 0) 80)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle PostageStamp:0
Too many constants for extrapolation

Solving puzzle 41/732: PostageStamp:1
sat_func def sat(stamps: List[int], target=271, max_stamps=8, options=[37, 37, 12, 87, 39]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
modified_func def sat(stamps: List[int], target=wrap_int(271), max_stamps=wrap_int(8), options=wrap_list([wrap_int(37), wrap_int(37), wrap_int(12), wrap_int(87), wrap_int(39)])):
    for s in stamps:
        _assert(sym_in(s, options))
    return (sym_len(stamps) <= max_stamps).__and__(sym_sum(stamps) == target)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_67 Int)) (=> (and (>= list_pos_67 0) (< list_pos_67 (list.length.int x))) (or (= (list.get.int x list_pos_67) 37) (= (list.get.int x list_pos_67) 37) (= (list.get.int x list_pos_67) 12) (= (list.get.int x list_pos_67) 87) (= (list.get.int x list_pos_67) 39)))))
(assert (forall ((list_pos_68 Int)) (=> (and (>= list_pos_68 0) (< list_pos_68 (list.length.int x))) (forall ((list_pos_67 Int)) (=> (and (>= list_pos_67 0) (< list_pos_67 (list.length.int x))) (and (<= (list.length.int x) 8) (= (+ (list.get.int x list_pos_68) 0) 271)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle PostageStamp:1
One large constant for extrapolation
Solving simpler variation replaced 271 with 3
sat_func def sat(stamps: List[int], target=3, max_stamps=8, options=[37, 37, 12, 87, 39]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
modified_func def sat(stamps: List[int], target=wrap_int(3), max_stamps=wrap_int(8), options=wrap_list([wrap_int(37), wrap_int(37), wrap_int(12), wrap_int(87), wrap_int(39)])):
    for s in stamps:
        _assert(sym_in(s, options))
    return (sym_len(stamps) <= max_stamps).__and__(sym_sum(stamps) == target)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_69 Int)) (=> (and (>= list_pos_69 0) (< list_pos_69 (list.length.int x))) (or (= (list.get.int x list_pos_69) 37) (= (list.get.int x list_pos_69) 37) (= (list.get.int x list_pos_69) 12) (= (list.get.int x list_pos_69) 87) (= (list.get.int x list_pos_69) 39)))))
(assert (forall ((list_pos_70 Int)) (=> (and (>= list_pos_70 0) (< list_pos_70 (list.length.int x))) (forall ((list_pos_69 Int)) (=> (and (>= list_pos_69 0) (< list_pos_69 (list.length.int x))) (and (<= (list.length.int x) 8) (= (+ (list.get.int x list_pos_70) 0) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle PostageStamp:1

Solving puzzle 42/732: PostageStamp:2
sat_func def sat(stamps: List[int], target=3, max_stamps=3, options=[18, 1, 43, 81]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
modified_func def sat(stamps: List[int], target=wrap_int(3), max_stamps=wrap_int(3), options=wrap_list([wrap_int(18), wrap_int(1), wrap_int(43), wrap_int(81)])):
    for s in stamps:
        _assert(sym_in(s, options))
    return (sym_len(stamps) <= max_stamps).__and__(sym_sum(stamps) == target)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_71 Int)) (=> (and (>= list_pos_71 0) (< list_pos_71 (list.length.int x))) (or (= (list.get.int x list_pos_71) 18) (= (list.get.int x list_pos_71) 1) (= (list.get.int x list_pos_71) 43) (= (list.get.int x list_pos_71) 81)))))
(assert (forall ((list_pos_72 Int)) (=> (and (>= list_pos_72 0) (< list_pos_72 (list.length.int x))) (forall ((list_pos_71 Int)) (=> (and (>= list_pos_71 0) (< list_pos_71 (list.length.int x))) (and (<= (list.length.int x) 3) (= (+ (list.get.int x list_pos_72) 0) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle PostageStamp:2
Too many constants for extrapolation

Solving puzzle 43/732: PostageStamp:3
sat_func def sat(stamps: List[int], target=19, max_stamps=2, options=[19, 14, 81]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
modified_func def sat(stamps: List[int], target=wrap_int(19), max_stamps=wrap_int(2), options=wrap_list([wrap_int(19), wrap_int(14), wrap_int(81)])):
    for s in stamps:
        _assert(sym_in(s, options))
    return (sym_len(stamps) <= max_stamps).__and__(sym_sum(stamps) == target)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_73 Int)) (=> (and (>= list_pos_73 0) (< list_pos_73 (list.length.int x))) (or (= (list.get.int x list_pos_73) 19) (= (list.get.int x list_pos_73) 14) (= (list.get.int x list_pos_73) 81)))))
(assert (forall ((list_pos_74 Int)) (=> (and (>= list_pos_74 0) (< list_pos_74 (list.length.int x))) (forall ((list_pos_73 Int)) (=> (and (>= list_pos_73 0) (< list_pos_73 (list.length.int x))) (and (<= (list.length.int x) 2) (= (+ (list.get.int x list_pos_74) 0) 19)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle PostageStamp:3
Too many constants for extrapolation

Solving puzzle 44/732: PostageStamp:4
sat_func def sat(stamps: List[int], target=56, max_stamps=1, options=[25, 22, 8, 84, 60, 56, 54, 7, 8]):
    for s in stamps:
        assert s in options
    return len(stamps) <= max_stamps and sum(stamps) == target
modified_func def sat(stamps: List[int], target=wrap_int(56), max_stamps=wrap_int(1), options=wrap_list([wrap_int(25), wrap_int(22), wrap_int(8), wrap_int(84), wrap_int(60), wrap_int(56), wrap_int(54), wrap_int(7), wrap_int(8)])):
    for s in stamps:
        _assert(sym_in(s, options))
    return (sym_len(stamps) <= max_stamps).__and__(sym_sum(stamps) == target)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_75 Int)) (=> (and (>= list_pos_75 0) (< list_pos_75 (list.length.int x))) (or (= (list.get.int x list_pos_75) 25) (= (list.get.int x list_pos_75) 22) (= (list.get.int x list_pos_75) 8) (= (list.get.int x list_pos_75) 84) (= (list.get.int x list_pos_75) 60) (= (list.get.int x list_pos_75) 56) (= (list.get.int x list_pos_75) 54) (= (list.get.int x list_pos_75) 7) (= (list.get.int x list_pos_75) 8)))))
(assert (forall ((list_pos_76 Int)) (=> (and (>= list_pos_76 0) (< list_pos_76 (list.length.int x))) (forall ((list_pos_75 Int)) (=> (and (>= list_pos_75 0) (< list_pos_75 (list.length.int x))) (and (<= (list.length.int x) 1) (= (+ (list.get.int x list_pos_76) 0) 56)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle PostageStamp:4
Too many constants for extrapolation

Solving puzzle 45/732: AllPandigitalSquares:0
sat_func def sat(nums: List[int]):
    return [sorted([int(s) for s in str(n * n)]) for n in set(nums)] == [list(range(10))] * 174
modified_func def sat(nums: List[int]):
    return [sym_sorted([sym_int(s) for s in sym_str(n * n)]) for n in set(nums)] == wrap_list([list(sym_range(10))]) * wrap_int(174)
Exception -- for puzzle AllPandigitalSquares:0 'list' object has no attribute 'z3_expr'

Solving puzzle 46/732: VerbalArithmetic:0
sat_func def sat(li: List[int], words=['SEND', 'MORE', 'MONEY']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
modified_func def sat(li: List[int], words=wrap_list([wrap_str('SEND'), wrap_str('MORE'), wrap_str('MONEY')])):
    _assert((sym_len(li) == sym_len(words)).__and__(all(sym_generator(((i > wrap_int(0)).__and__(sym_len(sym_str(i)) == sym_len(w)) for i, w in sym_zip(li, words))))))
    _assert(sym_len({c for w in words for c in w}) == sym_len({(d, c) for i, w in sym_zip(li, words) for d, c in sym_zip(sym_str(i), w)}))
    return sym_sum(li[:-1]) == li[-wrap_int(1)]
Exception -- for puzzle VerbalArithmetic:0 Symbolic hash not yet implemented

Solving puzzle 47/732: VerbalArithmetic:1
sat_func def sat(li: List[int], words=['FORTY', 'TEN', 'TEN', 'SIXTY']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
modified_func def sat(li: List[int], words=wrap_list([wrap_str('FORTY'), wrap_str('TEN'), wrap_str('TEN'), wrap_str('SIXTY')])):
    _assert((sym_len(li) == sym_len(words)).__and__(all(sym_generator(((i > wrap_int(0)).__and__(sym_len(sym_str(i)) == sym_len(w)) for i, w in sym_zip(li, words))))))
    _assert(sym_len({c for w in words for c in w}) == sym_len({(d, c) for i, w in sym_zip(li, words) for d, c in sym_zip(sym_str(i), w)}))
    return sym_sum(li[:-1]) == li[-wrap_int(1)]
Exception -- for puzzle VerbalArithmetic:1 Symbolic hash not yet implemented

Solving puzzle 48/732: VerbalArithmetic:2
sat_func def sat(li: List[int], words=['GREEN', 'ORANGE', 'COLORS']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
modified_func def sat(li: List[int], words=wrap_list([wrap_str('GREEN'), wrap_str('ORANGE'), wrap_str('COLORS')])):
    _assert((sym_len(li) == sym_len(words)).__and__(all(sym_generator(((i > wrap_int(0)).__and__(sym_len(sym_str(i)) == sym_len(w)) for i, w in sym_zip(li, words))))))
    _assert(sym_len({c for w in words for c in w}) == sym_len({(d, c) for i, w in sym_zip(li, words) for d, c in sym_zip(sym_str(i), w)}))
    return sym_sum(li[:-1]) == li[-wrap_int(1)]
Exception -- for puzzle VerbalArithmetic:2 Symbolic hash not yet implemented

Solving puzzle 49/732: VerbalArithmetic:3
sat_func def sat(li: List[int], words=['fqjb', 'awqw', 'lfll', 'fvvvb']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
modified_func def sat(li: List[int], words=wrap_list([wrap_str('fqjb'), wrap_str('awqw'), wrap_str('lfll'), wrap_str('fvvvb')])):
    _assert((sym_len(li) == sym_len(words)).__and__(all(sym_generator(((i > wrap_int(0)).__and__(sym_len(sym_str(i)) == sym_len(w)) for i, w in sym_zip(li, words))))))
    _assert(sym_len({c for w in words for c in w}) == sym_len({(d, c) for i, w in sym_zip(li, words) for d, c in sym_zip(sym_str(i), w)}))
    return sym_sum(li[:-1]) == li[-wrap_int(1)]
Exception -- for puzzle VerbalArithmetic:3 Symbolic hash not yet implemented

Solving puzzle 50/732: VerbalArithmetic:4
sat_func def sat(li: List[int], words=['tnnq', 'sna', 'ajjc', 'isun', 'usub', 'caiun']):
    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))
    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})
    return sum(li[:-1]) == li[-1]
modified_func def sat(li: List[int], words=wrap_list([wrap_str('tnnq'), wrap_str('sna'), wrap_str('ajjc'), wrap_str('isun'), wrap_str('usub'), wrap_str('caiun')])):
    _assert((sym_len(li) == sym_len(words)).__and__(all(sym_generator(((i > wrap_int(0)).__and__(sym_len(sym_str(i)) == sym_len(w)) for i, w in sym_zip(li, words))))))
    _assert(sym_len({c for w in words for c in w}) == sym_len({(d, c) for i, w in sym_zip(li, words) for d, c in sym_zip(sym_str(i), w)}))
    return sym_sum(li[:-1]) == li[-wrap_int(1)]
Exception -- for puzzle VerbalArithmetic:4 Symbolic hash not yet implemented

Solving puzzle 51/732: SlidingPuzzle:0
sat_func def sat(moves: List[int], start=[[5, 0, 2, 3], [1, 9, 6, 7], [4, 14, 8, 11], [12, 13, 10, 15]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
modified_func def sat(moves: List[int], start=wrap_list([wrap_list([wrap_int(5), wrap_int(0), wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(9), wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(4), wrap_int(14), wrap_int(8), wrap_int(11)]), wrap_list([wrap_int(12), wrap_int(13), wrap_int(10), wrap_int(15)])])):
    locs = {i: wrap_list([x, y]) for y, row in enumerate(start) for x, i in enumerate(row)}
    for i in moves:
        _assert(abs(locs[wrap_int(0)][wrap_int(0)] - locs[i][wrap_int(0)]) + abs(locs[wrap_int(0)][wrap_int(1)] - locs[i][wrap_int(1)]) == wrap_int(1))
        locs[wrap_int(0)], locs[i] = (locs[i], locs[wrap_int(0)])
    return all(sym_generator((locs[i] == wrap_list([i % sym_len(start[wrap_int(0)]), i // sym_len(start)]) for i in locs)))
Exception -- for puzzle SlidingPuzzle:0 SymbolicInt(None)

Solving puzzle 52/732: SlidingPuzzle:1
sat_func def sat(moves: List[int], start=[[1, 5, 0], [3, 2, 8], [6, 4, 7]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
modified_func def sat(moves: List[int], start=wrap_list([wrap_list([wrap_int(1), wrap_int(5), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(2), wrap_int(8)]), wrap_list([wrap_int(6), wrap_int(4), wrap_int(7)])])):
    locs = {i: wrap_list([x, y]) for y, row in enumerate(start) for x, i in enumerate(row)}
    for i in moves:
        _assert(abs(locs[wrap_int(0)][wrap_int(0)] - locs[i][wrap_int(0)]) + abs(locs[wrap_int(0)][wrap_int(1)] - locs[i][wrap_int(1)]) == wrap_int(1))
        locs[wrap_int(0)], locs[i] = (locs[i], locs[wrap_int(0)])
    return all(sym_generator((locs[i] == wrap_list([i % sym_len(start[wrap_int(0)]), i // sym_len(start)]) for i in locs)))
Exception -- for puzzle SlidingPuzzle:1 SymbolicInt(None)

Solving puzzle 53/732: SlidingPuzzle:2
sat_func def sat(moves: List[int], start=[[6, 0, 3], [7, 1, 4], [8, 2, 5]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
modified_func def sat(moves: List[int], start=wrap_list([wrap_list([wrap_int(6), wrap_int(0), wrap_int(3)]), wrap_list([wrap_int(7), wrap_int(1), wrap_int(4)]), wrap_list([wrap_int(8), wrap_int(2), wrap_int(5)])])):
    locs = {i: wrap_list([x, y]) for y, row in enumerate(start) for x, i in enumerate(row)}
    for i in moves:
        _assert(abs(locs[wrap_int(0)][wrap_int(0)] - locs[i][wrap_int(0)]) + abs(locs[wrap_int(0)][wrap_int(1)] - locs[i][wrap_int(1)]) == wrap_int(1))
        locs[wrap_int(0)], locs[i] = (locs[i], locs[wrap_int(0)])
    return all(sym_generator((locs[i] == wrap_list([i % sym_len(start[wrap_int(0)]), i // sym_len(start)]) for i in locs)))
Exception -- for puzzle SlidingPuzzle:2 SymbolicInt(None)

Solving puzzle 54/732: SlidingPuzzle:3
sat_func def sat(moves: List[int], start=[[0, 1], [2, 3]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
modified_func def sat(moves: List[int], start=wrap_list([wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(2), wrap_int(3)])])):
    locs = {i: wrap_list([x, y]) for y, row in enumerate(start) for x, i in enumerate(row)}
    for i in moves:
        _assert(abs(locs[wrap_int(0)][wrap_int(0)] - locs[i][wrap_int(0)]) + abs(locs[wrap_int(0)][wrap_int(1)] - locs[i][wrap_int(1)]) == wrap_int(1))
        locs[wrap_int(0)], locs[i] = (locs[i], locs[wrap_int(0)])
    return all(sym_generator((locs[i] == wrap_list([i % sym_len(start[wrap_int(0)]), i // sym_len(start)]) for i in locs)))
Exception -- for puzzle SlidingPuzzle:3 SymbolicInt(None)

Solving puzzle 55/732: SlidingPuzzle:4
sat_func def sat(moves: List[int], start=[[2, 1], [0, 3]]):

    locs = {i: [x, y] for y, row in enumerate(start) for x, i in enumerate(row)}  # locations, 0 stands for blank
    for i in moves:
        assert abs(locs[0][0] - locs[i][0]) + abs(locs[0][1] - locs[i][1]) == 1
        locs[0], locs[i] = locs[i], locs[0]
    return all(locs[i] == [i % len(start[0]), i // len(start)] for i in locs)
modified_func def sat(moves: List[int], start=wrap_list([wrap_list([wrap_int(2), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(3)])])):
    locs = {i: wrap_list([x, y]) for y, row in enumerate(start) for x, i in enumerate(row)}
    for i in moves:
        _assert(abs(locs[wrap_int(0)][wrap_int(0)] - locs[i][wrap_int(0)]) + abs(locs[wrap_int(0)][wrap_int(1)] - locs[i][wrap_int(1)]) == wrap_int(1))
        locs[wrap_int(0)], locs[i] = (locs[i], locs[wrap_int(0)])
    return all(sym_generator((locs[i] == wrap_list([i % sym_len(start[wrap_int(0)]), i // sym_len(start)]) for i in locs)))
Exception -- for puzzle SlidingPuzzle:4 SymbolicInt(None)

Solving puzzle 56/732: SeparateParenGroups:0
sat_func def sat(ls: List[str], combined="() (()) ((() () ())) (() )"):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
modified_func def sat(ls: List[str], combined=wrap_str('() (()) ((() () ())) (() )')):
    for s in ls:
        _assert(s.count('(') == s.count(')'))
        _assert(all(sym_generator((s[:i].count('(') > s[:i].count(')') for i in sym_range(1, sym_len(s))))))
    return wrap_str('').join(ls) == combined.replace(wrap_str(' '), wrap_str(''))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x (List String))
(assert (forall ((list_pos_83 Int)) (=> (and (>= list_pos_83 0) (< list_pos_83 (list.length.string x))) (>= (str.count (list.get.string x list_pos_83) "(") 0))))
(assert (forall ((list_pos_83 Int)) (=> (and (>= list_pos_83 0) (< list_pos_83 (list.length.string x))) (>= (str.count (list.get.string x list_pos_83) ")") 0))))
(assert (forall ((list_pos_83 Int)) (=> (and (>= list_pos_83 0) (< list_pos_83 (list.length.string x))) (= (str.count (list.get.string x list_pos_83) "(") (str.count (list.get.string x list_pos_83) ")")))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_83)))) (forall ((list_pos_83 Int)) (=> (and (>= list_pos_83 0) (< list_pos_83 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_83) 0 i_0) "(") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_83)))) (forall ((list_pos_83 Int)) (=> (and (>= list_pos_83 0) (< list_pos_83 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_83) 0 i_0) ")") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_83)))) (forall ((list_pos_83 Int)) (=> (and (>= list_pos_83 0) (< list_pos_83 (list.length.string x))) (> (str.count (python.str.substr (list.get.string x list_pos_83) 0 i_0) "(") (str.count (python.str.substr (list.get.string x list_pos_83) 0 i_0) ")")))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_83)))) (forall ((list_pos_83 Int)) (=> (and (>= list_pos_83 0) (< list_pos_83 (list.length.string x))) (= (python.join x "") "()(())((()()()))(())"))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:130.84: Symbol 'list_pos_83' not declared as a variable")

Could not find any solution for puzzle SeparateParenGroups:0
Too many constants for extrapolation

Solving puzzle 57/732: SeparateParenGroups:1
sat_func def sat(ls: List[str], combined="()  () "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
modified_func def sat(ls: List[str], combined=wrap_str('()  () ')):
    for s in ls:
        _assert(s.count('(') == s.count(')'))
        _assert(all(sym_generator((s[:i].count('(') > s[:i].count(')') for i in sym_range(1, sym_len(s))))))
    return wrap_str('').join(ls) == combined.replace(wrap_str(' '), wrap_str(''))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x (List String))
(assert (forall ((list_pos_84 Int)) (=> (and (>= list_pos_84 0) (< list_pos_84 (list.length.string x))) (>= (str.count (list.get.string x list_pos_84) "(") 0))))
(assert (forall ((list_pos_84 Int)) (=> (and (>= list_pos_84 0) (< list_pos_84 (list.length.string x))) (>= (str.count (list.get.string x list_pos_84) ")") 0))))
(assert (forall ((list_pos_84 Int)) (=> (and (>= list_pos_84 0) (< list_pos_84 (list.length.string x))) (= (str.count (list.get.string x list_pos_84) "(") (str.count (list.get.string x list_pos_84) ")")))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_84)))) (forall ((list_pos_84 Int)) (=> (and (>= list_pos_84 0) (< list_pos_84 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_84) 0 i_0) "(") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_84)))) (forall ((list_pos_84 Int)) (=> (and (>= list_pos_84 0) (< list_pos_84 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_84) 0 i_0) ")") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_84)))) (forall ((list_pos_84 Int)) (=> (and (>= list_pos_84 0) (< list_pos_84 (list.length.string x))) (> (str.count (python.str.substr (list.get.string x list_pos_84) 0 i_0) "(") (str.count (python.str.substr (list.get.string x list_pos_84) 0 i_0) ")")))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_84)))) (forall ((list_pos_84 Int)) (=> (and (>= list_pos_84 0) (< list_pos_84 (list.length.string x))) (= (python.join x "") "()()"))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:130.84: Symbol 'list_pos_84' not declared as a variable")

Could not find any solution for puzzle SeparateParenGroups:1
Too many constants for extrapolation

Solving puzzle 58/732: SeparateParenGroups:2
sat_func def sat(ls: List[str], combined=" ((((() ())( ( ))())))   "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
modified_func def sat(ls: List[str], combined=wrap_str(' ((((() ())( ( ))())))   ')):
    for s in ls:
        _assert(s.count('(') == s.count(')'))
        _assert(all(sym_generator((s[:i].count('(') > s[:i].count(')') for i in sym_range(1, sym_len(s))))))
    return wrap_str('').join(ls) == combined.replace(wrap_str(' '), wrap_str(''))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x (List String))
(assert (forall ((list_pos_85 Int)) (=> (and (>= list_pos_85 0) (< list_pos_85 (list.length.string x))) (>= (str.count (list.get.string x list_pos_85) "(") 0))))
(assert (forall ((list_pos_85 Int)) (=> (and (>= list_pos_85 0) (< list_pos_85 (list.length.string x))) (>= (str.count (list.get.string x list_pos_85) ")") 0))))
(assert (forall ((list_pos_85 Int)) (=> (and (>= list_pos_85 0) (< list_pos_85 (list.length.string x))) (= (str.count (list.get.string x list_pos_85) "(") (str.count (list.get.string x list_pos_85) ")")))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_85)))) (forall ((list_pos_85 Int)) (=> (and (>= list_pos_85 0) (< list_pos_85 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_85) 0 i_0) "(") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_85)))) (forall ((list_pos_85 Int)) (=> (and (>= list_pos_85 0) (< list_pos_85 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_85) 0 i_0) ")") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_85)))) (forall ((list_pos_85 Int)) (=> (and (>= list_pos_85 0) (< list_pos_85 (list.length.string x))) (> (str.count (python.str.substr (list.get.string x list_pos_85) 0 i_0) "(") (str.count (python.str.substr (list.get.string x list_pos_85) 0 i_0) ")")))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_85)))) (forall ((list_pos_85 Int)) (=> (and (>= list_pos_85 0) (< list_pos_85 (list.length.string x))) (= (python.join x "") "((((()())(())())))"))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:130.84: Symbol 'list_pos_85' not declared as a variable")

Could not find any solution for puzzle SeparateParenGroups:2
Too many constants for extrapolation

Solving puzzle 59/732: SeparateParenGroups:3
sat_func def sat(ls: List[str], combined="()   "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
modified_func def sat(ls: List[str], combined=wrap_str('()   ')):
    for s in ls:
        _assert(s.count('(') == s.count(')'))
        _assert(all(sym_generator((s[:i].count('(') > s[:i].count(')') for i in sym_range(1, sym_len(s))))))
    return wrap_str('').join(ls) == combined.replace(wrap_str(' '), wrap_str(''))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x (List String))
(assert (forall ((list_pos_86 Int)) (=> (and (>= list_pos_86 0) (< list_pos_86 (list.length.string x))) (>= (str.count (list.get.string x list_pos_86) "(") 0))))
(assert (forall ((list_pos_86 Int)) (=> (and (>= list_pos_86 0) (< list_pos_86 (list.length.string x))) (>= (str.count (list.get.string x list_pos_86) ")") 0))))
(assert (forall ((list_pos_86 Int)) (=> (and (>= list_pos_86 0) (< list_pos_86 (list.length.string x))) (= (str.count (list.get.string x list_pos_86) "(") (str.count (list.get.string x list_pos_86) ")")))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_86)))) (forall ((list_pos_86 Int)) (=> (and (>= list_pos_86 0) (< list_pos_86 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_86) 0 i_0) "(") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_86)))) (forall ((list_pos_86 Int)) (=> (and (>= list_pos_86 0) (< list_pos_86 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_86) 0 i_0) ")") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_86)))) (forall ((list_pos_86 Int)) (=> (and (>= list_pos_86 0) (< list_pos_86 (list.length.string x))) (> (str.count (python.str.substr (list.get.string x list_pos_86) 0 i_0) "(") (str.count (python.str.substr (list.get.string x list_pos_86) 0 i_0) ")")))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_86)))) (forall ((list_pos_86 Int)) (=> (and (>= list_pos_86 0) (< list_pos_86 (list.length.string x))) (= (python.join x "") "()"))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:130.84: Symbol 'list_pos_86' not declared as a variable")

Could not find any solution for puzzle SeparateParenGroups:3
Too many constants for extrapolation

Solving puzzle 60/732: SeparateParenGroups:4
sat_func def sat(ls: List[str], combined="(() )(( )()  ) ((( (()))(()(()() ( )( ()) )( ( )( )) (() )) )()) (( ))    "):
    for s in ls:
        assert s.count("(") == s.count(")")
        assert all(s[:i].count("(") > s[:i].count(")") for i in range(1, len(s)))  # s is not further divisible
    return ''.join(ls) == combined.replace(' ', '')
modified_func def sat(ls: List[str], combined=wrap_str('(() )(( )()  ) ((( (()))(()(()() ( )( ()) )( ( )( )) (() )) )()) (( ))    ')):
    for s in ls:
        _assert(s.count('(') == s.count(')'))
        _assert(all(sym_generator((s[:i].count('(') > s[:i].count(')') for i in sym_range(1, sym_len(s))))))
    return wrap_str('').join(ls) == combined.replace(wrap_str(' '), wrap_str(''))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))


(define-fun-rec str.count.rec ((s String) (sub String) (start Int)) Int
  (let ((idx (str.indexof s sub start)))
    (ite (or (= idx (- 1)) (> start (str.len s)))
         0
         (+ 1 (str.count.rec s sub (+ idx (str.len sub)))))))

(define-fun str.count ((s String) (sub String)) Int
  (ite (= (str.len sub) 0)
       (+ 1 (str.len s))
       (str.count.rec s sub 0)))

(declare-const x (List String))
(assert (forall ((list_pos_87 Int)) (=> (and (>= list_pos_87 0) (< list_pos_87 (list.length.string x))) (>= (str.count (list.get.string x list_pos_87) "(") 0))))
(assert (forall ((list_pos_87 Int)) (=> (and (>= list_pos_87 0) (< list_pos_87 (list.length.string x))) (>= (str.count (list.get.string x list_pos_87) ")") 0))))
(assert (forall ((list_pos_87 Int)) (=> (and (>= list_pos_87 0) (< list_pos_87 (list.length.string x))) (= (str.count (list.get.string x list_pos_87) "(") (str.count (list.get.string x list_pos_87) ")")))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_87)))) (forall ((list_pos_87 Int)) (=> (and (>= list_pos_87 0) (< list_pos_87 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_87) 0 i_0) "(") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_87)))) (forall ((list_pos_87 Int)) (=> (and (>= list_pos_87 0) (< list_pos_87 (list.length.string x))) (>= (str.count (python.str.substr (list.get.string x list_pos_87) 0 i_0) ")") 0))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_87)))) (forall ((list_pos_87 Int)) (=> (and (>= list_pos_87 0) (< list_pos_87 (list.length.string x))) (> (str.count (python.str.substr (list.get.string x list_pos_87) 0 i_0) "(") (str.count (python.str.substr (list.get.string x list_pos_87) 0 i_0) ")")))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 1) (< i_0 (str.len (list.get.string x list_pos_87)))) (forall ((list_pos_87 Int)) (=> (and (>= list_pos_87 0) (< list_pos_87 (list.length.string x))) (= (python.join x "") "(())(()())((((()))(()(()()()(()))(()())(())))())(())"))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:130.84: Symbol 'list_pos_87' not declared as a variable")

Could not find any solution for puzzle SeparateParenGroups:4
Too many constants for extrapolation

Solving puzzle 61/732: FirstNegCumulative:0
sat_func def sat(firsts: List[int], balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [100, -100, -101], [-1]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
modified_func def sat(firsts: List[int], balances=wrap_list([wrap_list([wrap_int(2), wrap_int(7), -wrap_int(2), wrap_int(4), wrap_int(3), -wrap_int(15), wrap_int(10), -wrap_int(45), wrap_int(3)]), wrap_list([wrap_int(3), wrap_int(4), -wrap_int(17), -wrap_int(1)]), wrap_list([wrap_int(100), -wrap_int(100), -wrap_int(101)]), wrap_list([-wrap_int(1)])])):
    for i, bals in enumerate(balances):
        total = wrap_int(0)
        for b in bals:
            total += b
            if total < wrap_int(0):
                _assert(total == firsts[i])
                break
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= -1 (list.get.int x 0)))
(assert (= -10 (list.get.int x 1)))
(assert (= -101 (list.get.int x 2)))
(assert (= -1 (list.get.int x 3)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 1) ((as cons (List Int)) (- 10) (as nil (List Int)))))
)

Found solution [-1, -10]
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle FirstNegCumulative:0
Two large constants for extrapolation
Solving simpler variation replaced 100 with 3 and 101 with 5
sat_func def sat(firsts: List[int], balances=[[2, 7, -2, 4, 3, -15, 10, -45, 3], [3, 4, -17, -1], [3, -3, -5], [-1]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
modified_func def sat(firsts: List[int], balances=wrap_list([wrap_list([wrap_int(2), wrap_int(7), -wrap_int(2), wrap_int(4), wrap_int(3), -wrap_int(15), wrap_int(10), -wrap_int(45), wrap_int(3)]), wrap_list([wrap_int(3), wrap_int(4), -wrap_int(17), -wrap_int(1)]), wrap_list([wrap_int(3), -wrap_int(3), -wrap_int(5)]), wrap_list([-wrap_int(1)])])):
    for i, bals in enumerate(balances):
        total = wrap_int(0)
        for b in bals:
            total += b
            if total < wrap_int(0):
                _assert(total == firsts[i])
                break
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= -1 (list.get.int x 0)))
(assert (= -10 (list.get.int x 1)))
(assert (= -5 (list.get.int x 2)))
(assert (= -1 (list.get.int x 3)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 1) ((as cons (List Int)) (- 10) (as nil (List Int)))))
)

Found solution [-1, -10]
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle FirstNegCumulative:0

Solving puzzle 62/732: FirstNegCumulative:1
sat_func def sat(firsts: List[int], balances=[[-1500518832, 928669978, -8834236111, 5315367227, 9459906565], [-922459571, 980368404, 2797206106, -8743339029, 1937237746], [-5581999780, -8355044389, 7691080588, 8819548586, -8678046394, 81698589, -1909402868], [-1496460602, -254633700, 1563740297, 2090111052, -2538220111, 2872427340, 3374773774], [8943500651, -9334877156, -8549860005, 7833776489, 6973829595, 7722681537, 535145192, -1822889532, 1811860043, -7700960933], [-1026876, -8774841983, 8413152214, 6772330745, 5578115818, -3502599311, 3134009997, 463541762, 3083435301], [-4305579008, 5200456205, -7357895007]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
modified_func def sat(firsts: List[int], balances=wrap_list([wrap_list([-wrap_int(1500518832), wrap_int(928669978), -wrap_int(8834236111), wrap_int(5315367227), wrap_int(9459906565)]), wrap_list([-wrap_int(922459571), wrap_int(980368404), wrap_int(2797206106), -wrap_int(8743339029), wrap_int(1937237746)]), wrap_list([-wrap_int(5581999780), -wrap_int(8355044389), wrap_int(7691080588), wrap_int(8819548586), -wrap_int(8678046394), wrap_int(81698589), -wrap_int(1909402868)]), wrap_list([-wrap_int(1496460602), -wrap_int(254633700), wrap_int(1563740297), wrap_int(2090111052), -wrap_int(2538220111), wrap_int(2872427340), wrap_int(3374773774)]), wrap_list([wrap_int(8943500651), -wrap_int(9334877156), -wrap_int(8549860005), wrap_int(7833776489), wrap_int(6973829595), wrap_int(7722681537), wrap_int(535145192), -wrap_int(1822889532), wrap_int(1811860043), -wrap_int(7700960933)]), wrap_list([-wrap_int(1026876), -wrap_int(8774841983), wrap_int(8413152214), wrap_int(6772330745), wrap_int(5578115818), -wrap_int(3502599311), wrap_int(3134009997), wrap_int(463541762), wrap_int(3083435301)]), wrap_list([-wrap_int(4305579008), wrap_int(5200456205), -wrap_int(7357895007)])])):
    for i, bals in enumerate(balances):
        total = wrap_int(0)
        for b in bals:
            total += b
            if total < wrap_int(0):
                _assert(total == firsts[i])
                break
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= -1500518832 (list.get.int x 0)))
(assert (= -922459571 (list.get.int x 1)))
(assert (= -5581999780 (list.get.int x 2)))
(assert (= -1496460602 (list.get.int x 3)))
(assert (= -391376505 (list.get.int x 4)))
(assert (= -1026876 (list.get.int x 5)))
(assert (= -4305579008 (list.get.int x 6)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 1500518832) ((as cons (List Int)) (- 922459571) ((as cons (List Int)) (- 5581999780) ((as cons (List Int)) (- 1496460602) ((as cons (List Int)) (- 391376505) ((as cons (List Int)) (- 1026876) ((as cons (List Int)) (- 4305579008) ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))))))
)

Found solution [-1500518832, -922459571, -5581999780, -1496460602, -391376505, -1026876, -4305579008, 0, 0]
Yes! Solved for puzzle  FirstNegCumulative:1

Solving puzzle 63/732: FirstNegCumulative:2
sat_func def sat(firsts: List[int], balances=[[914333345, -1563107339, 668467168, 9415600365, -8131416309, 8389610356, 7604207836, -4164203506, -2291145775], [4697936594, -7745934015], [-4651520348, -3085645067, -4519068178, -7950040818, -9543066562, 5606895475, -1534568525, -8229155741], [-2634952680, 3565837670], [-3239154229, -3459559891, -9783565309, 2874293724], [-3904981094, -7396874754], [-9841547454, -7990665221, 5130235947, -5311423002], [-4206303129, 4047239354, 5652054537, 7165867290]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
modified_func def sat(firsts: List[int], balances=wrap_list([wrap_list([wrap_int(914333345), -wrap_int(1563107339), wrap_int(668467168), wrap_int(9415600365), -wrap_int(8131416309), wrap_int(8389610356), wrap_int(7604207836), -wrap_int(4164203506), -wrap_int(2291145775)]), wrap_list([wrap_int(4697936594), -wrap_int(7745934015)]), wrap_list([-wrap_int(4651520348), -wrap_int(3085645067), -wrap_int(4519068178), -wrap_int(7950040818), -wrap_int(9543066562), wrap_int(5606895475), -wrap_int(1534568525), -wrap_int(8229155741)]), wrap_list([-wrap_int(2634952680), wrap_int(3565837670)]), wrap_list([-wrap_int(3239154229), -wrap_int(3459559891), -wrap_int(9783565309), wrap_int(2874293724)]), wrap_list([-wrap_int(3904981094), -wrap_int(7396874754)]), wrap_list([-wrap_int(9841547454), -wrap_int(7990665221), wrap_int(5130235947), -wrap_int(5311423002)]), wrap_list([-wrap_int(4206303129), wrap_int(4047239354), wrap_int(5652054537), wrap_int(7165867290)])])):
    for i, bals in enumerate(balances):
        total = wrap_int(0)
        for b in bals:
            total += b
            if total < wrap_int(0):
                _assert(total == firsts[i])
                break
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= -648773994 (list.get.int x 0)))
(assert (= -3047997421 (list.get.int x 1)))
(assert (= -4651520348 (list.get.int x 2)))
(assert (= -2634952680 (list.get.int x 3)))
(assert (= -3239154229 (list.get.int x 4)))
(assert (= -3904981094 (list.get.int x 5)))
(assert (= -9841547454 (list.get.int x 6)))
(assert (= -4206303129 (list.get.int x 7)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 648773994) ((as cons (List Int)) (- 3047997421) ((as cons (List Int)) (- 4651520348) ((as cons (List Int)) (- 2634952680) ((as cons (List Int)) (- 3239154229) ((as cons (List Int)) (- 3904981094) ((as cons (List Int)) (- 9841547454) ((as cons (List Int)) (- 4206303129) ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int)))))))))))))
)

Found solution [-648773994, -3047997421, -4651520348, -2634952680, -3239154229, -3904981094, -9841547454, -4206303129, 0, 0]
Yes! Solved for puzzle  FirstNegCumulative:2

Solving puzzle 64/732: FirstNegCumulative:3
sat_func def sat(firsts: List[int], balances=[[-3159744279, -5564462797, 9181877256, -581801013, -2730806212, -8069766232], [-2778889563, 6023011147, 6046948312, -1208971488, 2110520757, 7936971409, -4498797430, -7122967646], [-4649451153, -7199067130, 6484358738, -1015824976, 1504326141, 7704654617, 1083805811, -561837290, -9713157689], [-6286190794, 9847932237, -9818551636, -475170800], [-3927971639, 8808808262, 5363473771, 6453926109, -7932299279, 3515829826, -5092391511, 1619970550], [922221935, -3257271738, -4032399516, 5900007512, -2582293019, -1474957782, 2672311585, 5186169557, -4404554166], [3505067196, -649622176, -9390601127, 4030860857], [-8952966741], [2421457437, 531860397, -5157882824, 1563799160, -2925234193, 339874024, -7985065932, 1541877668, 7043758413]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
modified_func def sat(firsts: List[int], balances=wrap_list([wrap_list([-wrap_int(3159744279), -wrap_int(5564462797), wrap_int(9181877256), -wrap_int(581801013), -wrap_int(2730806212), -wrap_int(8069766232)]), wrap_list([-wrap_int(2778889563), wrap_int(6023011147), wrap_int(6046948312), -wrap_int(1208971488), wrap_int(2110520757), wrap_int(7936971409), -wrap_int(4498797430), -wrap_int(7122967646)]), wrap_list([-wrap_int(4649451153), -wrap_int(7199067130), wrap_int(6484358738), -wrap_int(1015824976), wrap_int(1504326141), wrap_int(7704654617), wrap_int(1083805811), -wrap_int(561837290), -wrap_int(9713157689)]), wrap_list([-wrap_int(6286190794), wrap_int(9847932237), -wrap_int(9818551636), -wrap_int(475170800)]), wrap_list([-wrap_int(3927971639), wrap_int(8808808262), wrap_int(5363473771), wrap_int(6453926109), -wrap_int(7932299279), wrap_int(3515829826), -wrap_int(5092391511), wrap_int(1619970550)]), wrap_list([wrap_int(922221935), -wrap_int(3257271738), -wrap_int(4032399516), wrap_int(5900007512), -wrap_int(2582293019), -wrap_int(1474957782), wrap_int(2672311585), wrap_int(5186169557), -wrap_int(4404554166)]), wrap_list([wrap_int(3505067196), -wrap_int(649622176), -wrap_int(9390601127), wrap_int(4030860857)]), wrap_list([-wrap_int(8952966741)]), wrap_list([wrap_int(2421457437), wrap_int(531860397), -wrap_int(5157882824), wrap_int(1563799160), -wrap_int(2925234193), wrap_int(339874024), -wrap_int(7985065932), wrap_int(1541877668), wrap_int(7043758413)])])):
    for i, bals in enumerate(balances):
        total = wrap_int(0)
        for b in bals:
            total += b
            if total < wrap_int(0):
                _assert(total == firsts[i])
                break
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= -3159744279 (list.get.int x 0)))
(assert (= -2778889563 (list.get.int x 1)))
(assert (= -4649451153 (list.get.int x 2)))
(assert (= -6286190794 (list.get.int x 3)))
(assert (= -3927971639 (list.get.int x 4)))
(assert (= -2335049803 (list.get.int x 5)))
(assert (= -6535156107 (list.get.int x 6)))
(assert (= -8952966741 (list.get.int x 7)))
(assert (= -2204564990 (list.get.int x 8)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FirstNegCumulative:3
Too many constants for extrapolation

Solving puzzle 65/732: FirstNegCumulative:4
sat_func def sat(firsts: List[int], balances=[[-2041524901, -9443452974, 6724922319], [9512986005, -7256441789, -8146859479, -648834428, 9137465613, 6849232316, -3669774686, -2798878807], [-700370861, -7254999326, 1316572844, -6690887070, 1763578306], [-71670187, 5659836631, 4279460608, 3047233262, -3918077853, 465790429, -1844240292], [-4058863322, 9667272009, 46010424, -5378831171, 6550560002, -1392053235, -2356282119], [-6617394020, -122757412, 5783268011, -7742860607, 3581304886, 5357960664, 6017029257, -1679200889], [-3456426106, -3386028090, -6864999581, -4690984097, -2321291466, -5583489756]]):
    for i, bals in enumerate(balances):
        total = 0
        for b in bals:
            total += b
            if total < 0:
                assert total == firsts[i]
                break
    return True
modified_func def sat(firsts: List[int], balances=wrap_list([wrap_list([-wrap_int(2041524901), -wrap_int(9443452974), wrap_int(6724922319)]), wrap_list([wrap_int(9512986005), -wrap_int(7256441789), -wrap_int(8146859479), -wrap_int(648834428), wrap_int(9137465613), wrap_int(6849232316), -wrap_int(3669774686), -wrap_int(2798878807)]), wrap_list([-wrap_int(700370861), -wrap_int(7254999326), wrap_int(1316572844), -wrap_int(6690887070), wrap_int(1763578306)]), wrap_list([-wrap_int(71670187), wrap_int(5659836631), wrap_int(4279460608), wrap_int(3047233262), -wrap_int(3918077853), wrap_int(465790429), -wrap_int(1844240292)]), wrap_list([-wrap_int(4058863322), wrap_int(9667272009), wrap_int(46010424), -wrap_int(5378831171), wrap_int(6550560002), -wrap_int(1392053235), -wrap_int(2356282119)]), wrap_list([-wrap_int(6617394020), -wrap_int(122757412), wrap_int(5783268011), -wrap_int(7742860607), wrap_int(3581304886), wrap_int(5357960664), wrap_int(6017029257), -wrap_int(1679200889)]), wrap_list([-wrap_int(3456426106), -wrap_int(3386028090), -wrap_int(6864999581), -wrap_int(4690984097), -wrap_int(2321291466), -wrap_int(5583489756)])])):
    for i, bals in enumerate(balances):
        total = wrap_int(0)
        for b in bals:
            total += b
            if total < wrap_int(0):
                _assert(total == firsts[i])
                break
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= -2041524901 (list.get.int x 0)))
(assert (= -5890315263 (list.get.int x 1)))
(assert (= -700370861 (list.get.int x 2)))
(assert (= -71670187 (list.get.int x 3)))
(assert (= -4058863322 (list.get.int x 4)))
(assert (= -6617394020 (list.get.int x 5)))
(assert (= -3456426106 (list.get.int x 6)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 2041524901) ((as cons (List Int)) (- 5890315263) ((as cons (List Int)) (- 700370861) ((as cons (List Int)) (- 71670187) ((as cons (List Int)) (- 4058863322) ((as cons (List Int)) (- 6617394020) ((as cons (List Int)) (- 3456426106) ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))))))
)

Found solution [-2041524901, -5890315263, -700370861, -71670187, -4058863322, -6617394020, -3456426106, 0, 0]
Yes! Solved for puzzle  FirstNegCumulative:4

Solving puzzle 66/732: Intersperse:0
sat_func def sat(li: List[int], nums=[12, 23, -2, 5, 0], sep=4):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
modified_func def sat(li: List[int], nums=wrap_list([wrap_int(12), wrap_int(23), -wrap_int(2), wrap_int(5), wrap_int(0)]), sep=wrap_int(4)):
    return (li[::2] == nums).__and__(li[1::2] == wrap_list([sep]) * (sym_len(nums) - wrap_int(1)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (list.slice.int x 0 -1 2) (cons 12 (cons 23 (cons -2 (cons 5 (cons 0 (as nil (List Int)))))))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Intersperse:0
Too many constants for extrapolation

Solving puzzle 67/732: Intersperse:1
sat_func def sat(li: List[int], nums=[], sep=23):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
modified_func def sat(li: List[int], nums=wrap_list([]), sep=wrap_int(23)):
    return (li[::2] == nums).__and__(li[1::2] == wrap_list([sep]) * (sym_len(nums) - wrap_int(1)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (list.slice.int x 0 -1 2) (as nil (List Int))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Intersperse:1
Too many constants for extrapolation

Solving puzzle 68/732: Intersperse:2
sat_func def sat(li: List[int], nums=[90, 23, 0, 0, 36, 61, 73], sep=14):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
modified_func def sat(li: List[int], nums=wrap_list([wrap_int(90), wrap_int(23), wrap_int(0), wrap_int(0), wrap_int(36), wrap_int(61), wrap_int(73)]), sep=wrap_int(14)):
    return (li[::2] == nums).__and__(li[1::2] == wrap_list([sep]) * (sym_len(nums) - wrap_int(1)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (list.slice.int x 0 -1 2) (cons 90 (cons 23 (cons 0 (cons 0 (cons 36 (cons 61 (cons 73 (as nil (List Int)))))))))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Intersperse:2
Too many constants for extrapolation

Solving puzzle 69/732: Intersperse:3
sat_func def sat(li: List[int], nums=[41, 60, 18, 34, 31], sep=2):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
modified_func def sat(li: List[int], nums=wrap_list([wrap_int(41), wrap_int(60), wrap_int(18), wrap_int(34), wrap_int(31)]), sep=wrap_int(2)):
    return (li[::2] == nums).__and__(li[1::2] == wrap_list([sep]) * (sym_len(nums) - wrap_int(1)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (list.slice.int x 0 -1 2) (cons 41 (cons 60 (cons 18 (cons 34 (cons 31 (as nil (List Int)))))))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Intersperse:3
Too many constants for extrapolation

Solving puzzle 70/732: Intersperse:4
sat_func def sat(li: List[int], nums=[39, 94, 99, 46, 93], sep=25):
    return li[::2] == nums and li[1::2] == [sep] * (len(nums) - 1)
modified_func def sat(li: List[int], nums=wrap_list([wrap_int(39), wrap_int(94), wrap_int(99), wrap_int(46), wrap_int(93)]), sep=wrap_int(25)):
    return (li[::2] == nums).__and__(li[1::2] == wrap_list([sep]) * (sym_len(nums) - wrap_int(1)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (list.slice.int x 0 -1 2) (cons 39 (cons 94 (cons 99 (cons 46 (cons 93 (as nil (List Int)))))))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle Intersperse:4
Too many constants for extrapolation

Solving puzzle 71/732: DeepestParens:0
sat_func def sat(depths: List[int], parens="() (()) ((()()())) (((((((())))))))"):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
modified_func def sat(depths: List[int], parens=wrap_str('() (()) ((()()())) (((((((())))))))')):
    groups = parens.split()
    for depth, group in sym_zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == wrap_str('('):
                budget -= wrap_int(1)
                if budget == wrap_int(0):
                    success = True
                _assert(budget >= wrap_int(0))
            else:
                _assert(c == wrap_str(')'))
                budget += wrap_int(1)
        _assert(success)
    return sym_len(groups) == sym_len(depths)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (< zip_pos_0 4))
(assert (>= zip_pos_0 -4))
(assert (forall ((str_pos_1 Int)) (=> (and (>= str_pos_1 0) (< str_pos_1 (str.len (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()")))))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()"))) str_pos_1) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) (>= (- (list.get.int x zip_pos_0) 1) 0)))))
(assert (forall ((str_pos_1 Int)) (=> (and (>= str_pos_1 0) (< str_pos_1 (str.len (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()")))))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()"))) str_pos_1) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) true))))
(assert (forall ((str_pos_1 Int)) (=> (and (>= str_pos_1 0) (< str_pos_1 (str.len (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()")))))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()"))) str_pos_1) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) (= (list.length.int x) 4)))))
(assert (forall ((str_pos_1 Int)) (=> (and (>= str_pos_1 0) (< str_pos_1 (str.len (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()")))))) (< zip_pos_1 4))))
(assert (forall ((str_pos_1 Int)) (=> (and (>= str_pos_1 0) (< str_pos_1 (str.len (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()")))))) (>= zip_pos_1 -4))))
(assert (forall ((str_pos_2 Int)) (=> (and (>= str_pos_2 0) (< str_pos_2 (str.len (ite (or (= zip_pos_1 3) (= zip_pos_1 -1)) "(((((((())))))))" (ite (or (= zip_pos_1 2) (= zip_pos_1 -2)) "((()()()))" (ite (or (= zip_pos_1 1) (= zip_pos_1 -3)) "(())" "()")))))) (forall ((str_pos_1 Int)) (=> (and (>= str_pos_1 0) (< str_pos_1 (str.len (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()")))))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 3) (= zip_pos_1 -1)) "(((((((())))))))" (ite (or (= zip_pos_1 2) (= zip_pos_1 -2)) "((()()()))" (ite (or (= zip_pos_1 1) (= zip_pos_1 -3)) "(())" "()"))) str_pos_2) "(")) (= (python.str.at (ite (or (= zip_pos_1 3) (= zip_pos_1 -1)) "(((((((())))))))" (ite (or (= zip_pos_1 2) (= zip_pos_1 -2)) "((()()()))" (ite (or (= zip_pos_1 1) (= zip_pos_1 -3)) "(())" "()"))) str_pos_2) ")")))))))
(assert (forall ((str_pos_2 Int)) (=> (and (>= str_pos_2 0) (< str_pos_2 (str.len (ite (or (= zip_pos_1 3) (= zip_pos_1 -1)) "(((((((())))))))" (ite (or (= zip_pos_1 2) (= zip_pos_1 -2)) "((()()()))" (ite (or (= zip_pos_1 1) (= zip_pos_1 -3)) "(())" "()")))))) (forall ((str_pos_1 Int)) (=> (and (>= str_pos_1 0) (< str_pos_1 (str.len (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()")))))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 3) (= zip_pos_1 -1)) "(((((((())))))))" (ite (or (= zip_pos_1 2) (= zip_pos_1 -2)) "((()()()))" (ite (or (= zip_pos_1 1) (= zip_pos_1 -3)) "(())" "()"))) str_pos_2) "(")) false))))))
(assert (forall ((str_pos_2 Int)) (=> (and (>= str_pos_2 0) (< str_pos_2 (str.len (ite (or (= zip_pos_1 3) (= zip_pos_1 -1)) "(((((((())))))))" (ite (or (= zip_pos_1 2) (= zip_pos_1 -2)) "((()()()))" (ite (or (= zip_pos_1 1) (= zip_pos_1 -3)) "(())" "()")))))) (forall ((str_pos_1 Int)) (=> (and (>= str_pos_1 0) (< str_pos_1 (str.len (ite (or (= zip_pos_0 3) (= zip_pos_0 -1)) "(((((((())))))))" (ite (or (= zip_pos_0 2) (= zip_pos_0 -2)) "((()()()))" (ite (or (= zip_pos_0 1) (= zip_pos_0 -3)) "(())" "()")))))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 3) (= zip_pos_1 -1)) "(((((((())))))))" (ite (or (= zip_pos_1 2) (= zip_pos_1 -2)) "((()()()))" (ite (or (= zip_pos_1 1) (= zip_pos_1 -3)) "(())" "()"))) str_pos_2) "(")) (= (list.length.int x) 4)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:104.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle DeepestParens:0
Too many constants for extrapolation

Solving puzzle 72/732: DeepestParens:1
sat_func def sat(depths: List[int], parens=""):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
modified_func def sat(depths: List[int], parens=wrap_str('')):
    groups = parens.split()
    for depth, group in sym_zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == wrap_str('('):
                budget -= wrap_int(1)
                if budget == wrap_int(0):
                    success = True
                _assert(budget >= wrap_int(0))
            else:
                _assert(c == wrap_str(')'))
                budget += wrap_int(1)
        _assert(success)
    return sym_len(groups) == sym_len(depths)
Exception -- for puzzle DeepestParens:1 'NoneType' object is not iterable

Solving puzzle 73/732: DeepestParens:2
sat_func def sat(depths: List[int], parens="(()) (((()(((()())()())))))(())()"):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
modified_func def sat(depths: List[int], parens=wrap_str('(()) (((()(((()())()())))))(())()')):
    groups = parens.split()
    for depth, group in sym_zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == wrap_str('('):
                budget -= wrap_int(1)
                if budget == wrap_int(0):
                    success = True
                _assert(budget >= wrap_int(0))
            else:
                _assert(c == wrap_str(')'))
                budget += wrap_int(1)
        _assert(success)
    return sym_len(groups) == sym_len(depths)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (< zip_pos_0 2))
(assert (>= zip_pos_0 -2))
(assert (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())")))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())") str_pos_3) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) (>= (- (list.get.int x zip_pos_0) 1) 0)))))
(assert (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())")))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())") str_pos_3) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) true))))
(assert (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())")))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())") str_pos_3) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) (= (list.length.int x) 2)))))
(assert (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())")))) (< zip_pos_1 2))))
(assert (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())")))) (>= zip_pos_1 -2))))
(assert (forall ((str_pos_4 Int)) (=> (and (>= str_pos_4 0) (< str_pos_4 (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "(((()(((()())()())))))(())()" "(())")))) (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())")))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "(((()(((()())()())))))(())()" "(())") str_pos_4) "(")) (= (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "(((()(((()())()())))))(())()" "(())") str_pos_4) ")")))))))
(assert (forall ((str_pos_4 Int)) (=> (and (>= str_pos_4 0) (< str_pos_4 (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "(((()(((()())()())))))(())()" "(())")))) (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())")))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "(((()(((()())()())))))(())()" "(())") str_pos_4) "(")) false))))))
(assert (forall ((str_pos_4 Int)) (=> (and (>= str_pos_4 0) (< str_pos_4 (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "(((()(((()())()())))))(())()" "(())")))) (forall ((str_pos_3 Int)) (=> (and (>= str_pos_3 0) (< str_pos_3 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "(((()(((()())()())))))(())()" "(())")))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "(((()(((()())()())))))(())()" "(())") str_pos_4) "(")) (= (list.length.int x) 2)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:104.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle DeepestParens:2
Too many constants for extrapolation

Solving puzzle 74/732: DeepestParens:3
sat_func def sat(depths: List[int], parens="(()) ()()(()())() () ()(())() ()((()))"):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
modified_func def sat(depths: List[int], parens=wrap_str('(()) ()()(()())() () ()(())() ()((()))')):
    groups = parens.split()
    for depth, group in sym_zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == wrap_str('('):
                budget -= wrap_int(1)
                if budget == wrap_int(0):
                    success = True
                _assert(budget >= wrap_int(0))
            else:
                _assert(c == wrap_str(')'))
                budget += wrap_int(1)
        _assert(success)
    return sym_len(groups) == sym_len(depths)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (< zip_pos_0 5))
(assert (>= zip_pos_0 -5))
(assert (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())"))))))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())")))) str_pos_5) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) (>= (- (list.get.int x zip_pos_0) 1) 0)))))
(assert (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())"))))))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())")))) str_pos_5) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) true))))
(assert (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())"))))))) (=> (and (= (python.str.at (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())")))) str_pos_5) "(") (= (- (list.get.int x zip_pos_0) 1) 0)) (= (list.length.int x) 5)))))
(assert (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())"))))))) (< zip_pos_1 5))))
(assert (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())"))))))) (>= zip_pos_1 -5))))
(assert (forall ((str_pos_6 Int)) (=> (and (>= str_pos_6 0) (< str_pos_6 (str.len (ite (or (= zip_pos_1 4) (= zip_pos_1 -1)) "()((()))" (ite (or (= zip_pos_1 3) (= zip_pos_1 -2)) "()(())()" (ite (or (= zip_pos_1 2) (= zip_pos_1 -3)) "()" (ite (or (= zip_pos_1 1) (= zip_pos_1 -4)) "()()(()())()" "(())"))))))) (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())"))))))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 4) (= zip_pos_1 -1)) "()((()))" (ite (or (= zip_pos_1 3) (= zip_pos_1 -2)) "()(())()" (ite (or (= zip_pos_1 2) (= zip_pos_1 -3)) "()" (ite (or (= zip_pos_1 1) (= zip_pos_1 -4)) "()()(()())()" "(())")))) str_pos_6) "(")) (= (python.str.at (ite (or (= zip_pos_1 4) (= zip_pos_1 -1)) "()((()))" (ite (or (= zip_pos_1 3) (= zip_pos_1 -2)) "()(...
(assert (forall ((str_pos_6 Int)) (=> (and (>= str_pos_6 0) (< str_pos_6 (str.len (ite (or (= zip_pos_1 4) (= zip_pos_1 -1)) "()((()))" (ite (or (= zip_pos_1 3) (= zip_pos_1 -2)) "()(())()" (ite (or (= zip_pos_1 2) (= zip_pos_1 -3)) "()" (ite (or (= zip_pos_1 1) (= zip_pos_1 -4)) "()()(()())()" "(())"))))))) (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())"))))))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 4) (= zip_pos_1 -1)) "()((()))" (ite (or (= zip_pos_1 3) (= zip_pos_1 -2)) "()(())()" (ite (or (= zip_pos_1 2) (= zip_pos_1 -3)) "()" (ite (or (= zip_pos_1 1) (= zip_pos_1 -4)) "()()(()())()" "(())")))) str_pos_6) "(")) false))))))
(assert (forall ((str_pos_6 Int)) (=> (and (>= str_pos_6 0) (< str_pos_6 (str.len (ite (or (= zip_pos_1 4) (= zip_pos_1 -1)) "()((()))" (ite (or (= zip_pos_1 3) (= zip_pos_1 -2)) "()(())()" (ite (or (= zip_pos_1 2) (= zip_pos_1 -3)) "()" (ite (or (= zip_pos_1 1) (= zip_pos_1 -4)) "()()(()())()" "(())"))))))) (forall ((str_pos_5 Int)) (=> (and (>= str_pos_5 0) (< str_pos_5 (str.len (ite (or (= zip_pos_0 4) (= zip_pos_0 -1)) "()((()))" (ite (or (= zip_pos_0 3) (= zip_pos_0 -2)) "()(())()" (ite (or (= zip_pos_0 2) (= zip_pos_0 -3)) "()" (ite (or (= zip_pos_0 1) (= zip_pos_0 -4)) "()()(()())()" "(())"))))))) (=> (not (= (python.str.at (ite (or (= zip_pos_1 4) (= zip_pos_1 -1)) "()((()))" (ite (or (= zip_pos_1 3) (= zip_pos_1 -2)) "()(())()" (ite (or (= zip_pos_1 2) (= zip_pos_1 -3)) "()" (ite (or (= zip_pos_1 1) (= zip_pos_1 -4)) "()()(()())()" "(())")))) str_pos_6) "(")) (= (list.length.int x) 5)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:104.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle DeepestParens:3
Too many constants for extrapolation

Solving puzzle 75/732: DeepestParens:4
sat_func def sat(depths: List[int], parens="()()(())()(())"):
    groups = parens.split()
    for depth, group in zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == '(':
                budget -= 1
                if budget == 0:
                    success = True
                assert budget >= 0
            else:
                assert c == ')'
                budget += 1
        assert success

    return len(groups) == len(depths)
modified_func def sat(depths: List[int], parens=wrap_str('()()(())()(())')):
    groups = parens.split()
    for depth, group in sym_zip(depths, groups):
        budget = depth
        success = False
        for c in group:
            if c == wrap_str('('):
                budget -= wrap_int(1)
                if budget == wrap_int(0):
                    success = True
                _assert(budget >= wrap_int(0))
            else:
                _assert(c == wrap_str(')'))
                budget += wrap_int(1)
        _assert(success)
    return sym_len(groups) == sym_len(depths)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< zip_pos_0 1))
(assert (>= zip_pos_0 -1))
(assert (=> (= (- (list.get.int x zip_pos_0) 1) 0) (>= (- (list.get.int x zip_pos_0) 1) 0)))
(assert (=> (= (- (list.get.int x zip_pos_0) 1) 0) true))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0)) (>= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0)))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0)) true))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0)) (>= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0)) (>= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0)) true))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0)) true))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (>= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) true))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (>= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (>= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) true))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) true))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) true))
(assert (=> (and (= (- (list.get.int x zip_pos_0) 1) 0) (= (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 0) (= (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0) (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_0) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (= (list.length.int x) 1)))
(assert (< zip_pos_1 1))
(assert (>= zip_pos_1 -1))
(assert (=> (not (= (- (list.get.int x zip_pos_1) 1) 0)) (>= (- (list.get.int x zip_pos_1) 1) 0)))
(assert (=> (not (= (- (list.get.int x zip_pos_1) 1) 0)) true))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0))) (>= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0))) true))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0))) (>= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0))) (>= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0))) true))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0))) true))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0))) (>= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0))) true))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0))) (>= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0))) (>= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0))) true))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0))) true))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0))) false))
(assert (=> (and (not (= (- (list.get.int x zip_pos_1) 1) 0)) (not (= (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0)) (not (= (- (- (+ (- (+ (+ (- (- (+ (- (+ (- (list.get.int x zip_pos_1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 1) 0))) (= (list.length.int x) 1)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle DeepestParens:4
Too many constants for extrapolation

Solving puzzle 76/732: FindContainers:0
sat_func def sat(containers: List[str], strings=['cat', 'dog', 'shatter', 'bear', 'at', 'ta'], substring="at"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
modified_func def sat(containers: List[str], strings=wrap_list([wrap_str('cat'), wrap_str('dog'), wrap_str('shatter'), wrap_str('bear'), wrap_str('at'), wrap_str('ta')]), substring=wrap_str('at')):
    i = wrap_int(0)
    for s in strings:
        if sym_in(substring, s):
            _assert(containers[i] == s)
            i += wrap_int(1)
    return i == sym_len(containers)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.get.string x 0) "cat"))
(assert (= (list.get.string x 1) "shatter"))
(assert (= (list.get.string x 2) "at"))
(assert (= 3 (list.length.string x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "cat" ((as cons (List String)) "shatter" ((as cons (List String)) "at" (as nil (List String))))))
)

Found solution ['cat', 'shatter', 'at']
Yes! Solved for puzzle  FindContainers:0

Solving puzzle 77/732: FindContainers:1
sat_func def sat(containers: List[str], strings=['ty', 'jy', 'jsesnicy'], substring="ses"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
modified_func def sat(containers: List[str], strings=wrap_list([wrap_str('ty'), wrap_str('jy'), wrap_str('jsesnicy')]), substring=wrap_str('ses')):
    i = wrap_int(0)
    for s in strings:
        if sym_in(substring, s):
            _assert(containers[i] == s)
            i += wrap_int(1)
    return i == sym_len(containers)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.get.string x 0) "jsesnicy"))
(assert (= 1 (list.length.string x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "jsesnicy" (as nil (List String))))
)

Found solution ['jsesnicy']
Yes! Solved for puzzle  FindContainers:1

Solving puzzle 78/732: FindContainers:2
sat_func def sat(containers: List[str], strings=['rgyjo', 'tipu', 'mulut', 'wutgypepu'], substring="gy"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
modified_func def sat(containers: List[str], strings=wrap_list([wrap_str('rgyjo'), wrap_str('tipu'), wrap_str('mulut'), wrap_str('wutgypepu')]), substring=wrap_str('gy')):
    i = wrap_int(0)
    for s in strings:
        if sym_in(substring, s):
            _assert(containers[i] == s)
            i += wrap_int(1)
    return i == sym_len(containers)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.get.string x 0) "rgyjo"))
(assert (= (list.get.string x 1) "wutgypepu"))
(assert (= 2 (list.length.string x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "rgyjo" ((as cons (List String)) "wutgypepu" (as nil (List String)))))
)

Found solution ['rgyjo', 'wutgypepu']
Yes! Solved for puzzle  FindContainers:2

Solving puzzle 79/732: FindContainers:3
sat_func def sat(containers: List[str], strings=[], substring="ve"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
modified_func def sat(containers: List[str], strings=wrap_list([]), substring=wrap_str('ve')):
    i = wrap_int(0)
    for s in strings:
        if sym_in(substring, s):
            _assert(containers[i] == s)
            i += wrap_int(1)
    return i == sym_len(containers)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= 0 (list.length.string x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) (as nil (List String)))
)

Found solution []
Yes! Solved for puzzle  FindContainers:3

Solving puzzle 80/732: FindContainers:4
sat_func def sat(containers: List[str], strings=['te', 'dmmo', ''], substring="m"):
    i = 0
    for s in strings:
        if substring in s:
            assert containers[i] == s
            i += 1
    return i == len(containers)
modified_func def sat(containers: List[str], strings=wrap_list([wrap_str('te'), wrap_str('dmmo'), wrap_str('')]), substring=wrap_str('m')):
    i = wrap_int(0)
    for s in strings:
        if sym_in(substring, s):
            _assert(containers[i] == s)
            i += wrap_int(1)
    return i == sym_len(containers)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.get.string x 0) "dmmo"))
(assert (= 1 (list.length.string x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "dmmo" (as nil (List String))))
)

Found solution ['dmmo']
Yes! Solved for puzzle  FindContainers:4

Solving puzzle 81/732: SumProduct:0
sat_func def sat(nums: List[int], tot=14, prod=99):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
modified_func def sat(nums: List[int], tot=wrap_int(14), prod=wrap_int(99)):
    _assert(sym_sum(nums) == tot)
    p = wrap_int(1)
    for n in nums:
        p *= n
    return p == prod
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_88 Int)) (=> (and (>= list_pos_88 0) (< list_pos_88 (list.length.int x))) (= (+ (list.get.int x list_pos_88) 0) 14))))
(assert (forall ((list_pos_89 Int)) (=> (and (>= list_pos_89 0) (< list_pos_89 (list.length.int x))) (forall ((list_pos_88 Int)) (=> (and (>= list_pos_88 0) (< list_pos_88 (list.length.int x))) (= (* 1 (list.get.int x list_pos_89)) 99))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle SumProduct:0
Too many constants for extrapolation

Solving puzzle 82/732: SumProduct:1
sat_func def sat(nums: List[int], tot=-81, prod=13):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
modified_func def sat(nums: List[int], tot=-wrap_int(81), prod=wrap_int(13)):
    _assert(sym_sum(nums) == tot)
    p = wrap_int(1)
    for n in nums:
        p *= n
    return p == prod
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_90 Int)) (=> (and (>= list_pos_90 0) (< list_pos_90 (list.length.int x))) (= (+ (list.get.int x list_pos_90) 0) -81))))
(assert (forall ((list_pos_91 Int)) (=> (and (>= list_pos_91 0) (< list_pos_91 (list.length.int x))) (forall ((list_pos_90 Int)) (=> (and (>= list_pos_90 0) (< list_pos_90 (list.length.int x))) (= (* 1 (list.get.int x list_pos_91)) 13))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle SumProduct:1
Too many constants for extrapolation

Solving puzzle 83/732: SumProduct:2
sat_func def sat(nums: List[int], tot=96, prod=-44):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
modified_func def sat(nums: List[int], tot=wrap_int(96), prod=-wrap_int(44)):
    _assert(sym_sum(nums) == tot)
    p = wrap_int(1)
    for n in nums:
        p *= n
    return p == prod
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_92 Int)) (=> (and (>= list_pos_92 0) (< list_pos_92 (list.length.int x))) (= (+ (list.get.int x list_pos_92) 0) 96))))
(assert (forall ((list_pos_93 Int)) (=> (and (>= list_pos_93 0) (< list_pos_93 (list.length.int x))) (forall ((list_pos_92 Int)) (=> (and (>= list_pos_92 0) (< list_pos_92 (list.length.int x))) (= (* 1 (list.get.int x list_pos_93)) -44))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle SumProduct:2
Too many constants for extrapolation

Solving puzzle 84/732: SumProduct:3
sat_func def sat(nums: List[int], tot=86, prod=24):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
modified_func def sat(nums: List[int], tot=wrap_int(86), prod=wrap_int(24)):
    _assert(sym_sum(nums) == tot)
    p = wrap_int(1)
    for n in nums:
        p *= n
    return p == prod
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_94 Int)) (=> (and (>= list_pos_94 0) (< list_pos_94 (list.length.int x))) (= (+ (list.get.int x list_pos_94) 0) 86))))
(assert (forall ((list_pos_95 Int)) (=> (and (>= list_pos_95 0) (< list_pos_95 (list.length.int x))) (forall ((list_pos_94 Int)) (=> (and (>= list_pos_94 0) (< list_pos_94 (list.length.int x))) (= (* 1 (list.get.int x list_pos_95)) 24))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle SumProduct:3
Too many constants for extrapolation

Solving puzzle 85/732: SumProduct:4
sat_func def sat(nums: List[int], tot=-16, prod=3):
    assert sum(nums) == tot
    p = 1
    for n in nums:
        p *= n
    return p == prod
modified_func def sat(nums: List[int], tot=-wrap_int(16), prod=wrap_int(3)):
    _assert(sym_sum(nums) == tot)
    p = wrap_int(1)
    for n in nums:
        p *= n
    return p == prod
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_96 Int)) (=> (and (>= list_pos_96 0) (< list_pos_96 (list.length.int x))) (= (+ (list.get.int x list_pos_96) 0) -16))))
(assert (forall ((list_pos_97 Int)) (=> (and (>= list_pos_97 0) (< list_pos_97 (list.length.int x))) (forall ((list_pos_96 Int)) (=> (and (>= list_pos_96 0) (< list_pos_96 (list.length.int x))) (= (* 1 (list.get.int x list_pos_97)) 3))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle SumProduct:4
Too many constants for extrapolation

Solving puzzle 86/732: RollingMax:0
sat_func def sat(maxes: List[int], nums=[1, 4, 3, -6, 19]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
modified_func def sat(maxes: List[int], nums=wrap_list([wrap_int(1), wrap_int(4), wrap_int(3), -wrap_int(6), wrap_int(19)])):
    _assert(sym_len(maxes) == sym_len(nums))
    for i in sym_range(sym_len(nums)):
        if i > wrap_int(0):
            _assert(maxes[i] == max(maxes[i - wrap_int(1)], nums[i]))
        else:
            _assert(maxes[wrap_int(0)] == nums[wrap_int(0)])
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 5))
(assert (= (list.get.int x 0) 1))
(assert (=> (> 4 (list.get.int x (- 1 1))) (= (list.get.int x 1) 4)))
(assert (=> (and (> 4 (list.get.int x (- 1 1))) (> 3 (list.get.int x (- 2 1)))) (= (list.get.int x 2) 3)))
(assert (=> (and (> 4 (list.get.int x (- 1 1))) (> 3 (list.get.int x (- 2 1))) (> -6 (list.get.int x (- 3 1)))) (= (list.get.int x 3) -6)))
(assert (=> (and (> 4 (list.get.int x (- 1 1))) (> 3 (list.get.int x (- 2 1))) (> -6 (list.get.int x (- 3 1))) (> 19 (list.get.int x (- 4 1)))) (= (list.get.int x 4) 19)))
(assert (=> (and (> 4 (list.get.int x (- 1 1))) (> 3 (list.get.int x (- 2 1))) (> -6 (list.get.int x (- 3 1))) (> 19 (list.get.int x (- 4 1)))) true))
(assert (= (list.length.int x) 5))
(assert (= (list.get.int x 0) 1))
(assert (=> (not (> 4 (list.get.int x (- 1 1)))) (= (list.get.int x 1) (list.get.int x (- 1 1)))))
(assert (=> (and (not (> 4 (list.get.int x (- 1 1)))) (not (> 3 (list.get.int x (- 2 1))))) (= (list.get.int x 2) (list.get.int x (- 2 1)))))
(assert (=> (and (not (> 4 (list.get.int x (- 1 1)))) (not (> 3 (list.get.int x (- 2 1)))) (not (> -6 (list.get.int x (- 3 1))))) (= (list.get.int x 3) (list.get.int x (- 3 1)))))
(assert (=> (and (not (> 4 (list.get.int x (- 1 1)))) (not (> 3 (list.get.int x (- 2 1)))) (not (> -6 (list.get.int x (- 3 1)))) (not (> 19 (list.get.int x (- 4 1))))) (= (list.get.int x 4) (list.get.int x (- 4 1)))))
(assert (=> (and (not (> 4 (list.get.int x (- 1 1)))) (not (> 3 (list.get.int x (- 2 1)))) (not (> -6 (list.get.int x (- 3 1)))) (not (> 19 (list.get.int x (- 4 1))))) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) 4 ((as cons (List Int)) (- 4) ((as cons (List Int)) (- 5) ((as cons (List Int)) 6 (as nil (List Int))))))))
)

Found solution [1, 4, -4, -5, 6]
Exception in checking result: 
WARNING: Solution verification failed for puzzle RollingMax:0
Too many constants for extrapolation

Solving puzzle 87/732: RollingMax:1
sat_func def sat(maxes: List[int], nums=[-15, -6]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
modified_func def sat(maxes: List[int], nums=wrap_list([-wrap_int(15), -wrap_int(6)])):
    _assert(sym_len(maxes) == sym_len(nums))
    for i in sym_range(sym_len(nums)):
        if i > wrap_int(0):
            _assert(maxes[i] == max(maxes[i - wrap_int(1)], nums[i]))
        else:
            _assert(maxes[wrap_int(0)] == nums[wrap_int(0)])
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 2))
(assert (= (list.get.int x 0) -15))
(assert (=> (> -6 (list.get.int x (- 1 1))) (= (list.get.int x 1) -6)))
(assert (=> (> -6 (list.get.int x (- 1 1))) true))
(assert (= (list.length.int x) 2))
(assert (= (list.get.int x 0) -15))
(assert (=> (not (> -6 (list.get.int x (- 1 1)))) (= (list.get.int x 1) (list.get.int x (- 1 1)))))
(assert (=> (not (> -6 (list.get.int x (- 1 1)))) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 15) ((as cons (List Int)) (- 6) (as nil (List Int)))))
)

Found solution [-15, -6]
Yes! Solved for puzzle  RollingMax:1

Solving puzzle 88/732: RollingMax:2
sat_func def sat(maxes: List[int], nums=[]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
modified_func def sat(maxes: List[int], nums=wrap_list([])):
    _assert(sym_len(maxes) == sym_len(nums))
    for i in sym_range(sym_len(nums)):
        if i > wrap_int(0):
            _assert(maxes[i] == max(maxes[i - wrap_int(1)], nums[i]))
        else:
            _assert(maxes[wrap_int(0)] == nums[wrap_int(0)])
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Yes! Solved for puzzle  RollingMax:2

Solving puzzle 89/732: RollingMax:3
sat_func def sat(maxes: List[int], nums=[-100, 14, -45, 92, 36, -68, -40]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
modified_func def sat(maxes: List[int], nums=wrap_list([-wrap_int(100), wrap_int(14), -wrap_int(45), wrap_int(92), wrap_int(36), -wrap_int(68), -wrap_int(40)])):
    _assert(sym_len(maxes) == sym_len(nums))
    for i in sym_range(sym_len(nums)):
        if i > wrap_int(0):
            _assert(maxes[i] == max(maxes[i - wrap_int(1)], nums[i]))
        else:
            _assert(maxes[wrap_int(0)] == nums[wrap_int(0)])
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 7))
(assert (= (list.get.int x 0) -100))
(assert (=> (> 14 (list.get.int x (- 1 1))) (= (list.get.int x 1) 14)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1)))) (= (list.get.int x 2) -45)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1)))) (= (list.get.int x 3) 92)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1))) (> 36 (list.get.int x (- 4 1)))) (= (list.get.int x 4) 36)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1))) (> 36 (list.get.int x (- 4 1))) (> -68 (list.get.int x (- 5 1)))) (= (list.get.int x 5) -68)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1))) (> 36 (list.get.int x (- 4 1))) (> -68 (list.get.int x (- 5 1))) (> -40 (list.get.int x (- 6 1)))) (= (list.get.int x 6) -40)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1))) (> 36 (list.get.int x (- 4 1))) (> -68 (list.get.int x (- 5 1))) (> -40 (list.get.int x (- 6 1)))) true))
(assert (= (list.length.int x) 7))
(assert (= (list.get.int x 0) -100))
(assert (=> (not (> 14 (list.get.int x (- 1 1)))) (= (list.get.int x 1) (list.get.int x (- 1 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1))))) (= (list.get.int x 2) (list.get.int x (- 2 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1))))) (= (list.get.int x 3) (list.get.int x (- 3 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1)))) (not (> 36 (list.get.int x (- 4 1))))) (= (list.get.int x 4) (list.get.int x (- 4 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1)))) (not (> 36 (list.get.int x (- 4 1)))) (not (> -68 (list.get.int x (- 5 1))))) (= (list.get.int x 5) (list.get.int x (- 5 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1)))) (not (> 36 (list.get.int x (- 4 1)))) (not (> -68 (list.get.int x (- 5 1)))) (not (> -40 (list.get.int x (- 6 1))))) (= (list.get.int x 6) (list.get.int x (- 6 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1)))) (not (> 36 (list.get.int x (- 4 1)))) (not (> -68 (list.get.int x (- 5 1)))) (not (> -40 (list.get.int x (- 6 1))))) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 100) ((as cons (List Int)) 14 ((as cons (List Int)) (- 4) ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) 8 (as nil (List Int))))))))))
)

Found solution [-100, 14, -4, -5, -6, -7, 8]
Exception in checking result: 
WARNING: Solution verification failed for puzzle RollingMax:3
One large constant for extrapolation
Solving simpler variation replaced 100 with 3
sat_func def sat(maxes: List[int], nums=[-3, 14, -45, 92, 36, -68, -40]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
modified_func def sat(maxes: List[int], nums=wrap_list([-wrap_int(3), wrap_int(14), -wrap_int(45), wrap_int(92), wrap_int(36), -wrap_int(68), -wrap_int(40)])):
    _assert(sym_len(maxes) == sym_len(nums))
    for i in sym_range(sym_len(nums)):
        if i > wrap_int(0):
            _assert(maxes[i] == max(maxes[i - wrap_int(1)], nums[i]))
        else:
            _assert(maxes[wrap_int(0)] == nums[wrap_int(0)])
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 7))
(assert (= (list.get.int x 0) -3))
(assert (=> (> 14 (list.get.int x (- 1 1))) (= (list.get.int x 1) 14)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1)))) (= (list.get.int x 2) -45)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1)))) (= (list.get.int x 3) 92)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1))) (> 36 (list.get.int x (- 4 1)))) (= (list.get.int x 4) 36)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1))) (> 36 (list.get.int x (- 4 1))) (> -68 (list.get.int x (- 5 1)))) (= (list.get.int x 5) -68)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1))) (> 36 (list.get.int x (- 4 1))) (> -68 (list.get.int x (- 5 1))) (> -40 (list.get.int x (- 6 1)))) (= (list.get.int x 6) -40)))
(assert (=> (and (> 14 (list.get.int x (- 1 1))) (> -45 (list.get.int x (- 2 1))) (> 92 (list.get.int x (- 3 1))) (> 36 (list.get.int x (- 4 1))) (> -68 (list.get.int x (- 5 1))) (> -40 (list.get.int x (- 6 1)))) true))
(assert (= (list.length.int x) 7))
(assert (= (list.get.int x 0) -3))
(assert (=> (not (> 14 (list.get.int x (- 1 1)))) (= (list.get.int x 1) (list.get.int x (- 1 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1))))) (= (list.get.int x 2) (list.get.int x (- 2 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1))))) (= (list.get.int x 3) (list.get.int x (- 3 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1)))) (not (> 36 (list.get.int x (- 4 1))))) (= (list.get.int x 4) (list.get.int x (- 4 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1)))) (not (> 36 (list.get.int x (- 4 1)))) (not (> -68 (list.get.int x (- 5 1))))) (= (list.get.int x 5) (list.get.int x (- 5 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1)))) (not (> 36 (list.get.int x (- 4 1)))) (not (> -68 (list.get.int x (- 5 1)))) (not (> -40 (list.get.int x (- 6 1))))) (= (list.get.int x 6) (list.get.int x (- 6 1)))))
(assert (=> (and (not (> 14 (list.get.int x (- 1 1)))) (not (> -45 (list.get.int x (- 2 1)))) (not (> 92 (list.get.int x (- 3 1)))) (not (> 36 (list.get.int x (- 4 1)))) (not (> -68 (list.get.int x (- 5 1)))) (not (> -40 (list.get.int x (- 6 1))))) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 3) ((as cons (List Int)) 14 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) 8 ((as cons (List Int)) (- 8) (as nil (List Int))))))))))
)

Found solution [-3, 14, -5, -6, -7, 8, -8]
Exception in checking result: 
WARNING: Solution verification failed for puzzle RollingMax:3

Solving puzzle 90/732: RollingMax:4
sat_func def sat(maxes: List[int], nums=[23, -34, 96]):
    assert len(maxes) == len(nums)
    for i in range(len(nums)):
        if i > 0:
            assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
modified_func def sat(maxes: List[int], nums=wrap_list([wrap_int(23), -wrap_int(34), wrap_int(96)])):
    _assert(sym_len(maxes) == sym_len(nums))
    for i in sym_range(sym_len(nums)):
        if i > wrap_int(0):
            _assert(maxes[i] == max(maxes[i - wrap_int(1)], nums[i]))
        else:
            _assert(maxes[wrap_int(0)] == nums[wrap_int(0)])
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(assert (= (list.get.int x 0) 23))
(assert (=> (> -34 (list.get.int x (- 1 1))) (= (list.get.int x 1) -34)))
(assert (=> (and (> -34 (list.get.int x (- 1 1))) (> 96 (list.get.int x (- 2 1)))) (= (list.get.int x 2) 96)))
(assert (=> (and (> -34 (list.get.int x (- 1 1))) (> 96 (list.get.int x (- 2 1)))) true))
(assert (= (list.length.int x) 3))
(assert (= (list.get.int x 0) 23))
(assert (=> (not (> -34 (list.get.int x (- 1 1)))) (= (list.get.int x 1) (list.get.int x (- 1 1)))))
(assert (=> (and (not (> -34 (list.get.int x (- 1 1)))) (not (> 96 (list.get.int x (- 2 1))))) (= (list.get.int x 2) (list.get.int x (- 2 1)))))
(assert (=> (and (not (> -34 (list.get.int x (- 1 1)))) (not (> 96 (list.get.int x (- 2 1))))) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 23 ((as cons (List Int)) 23 ((as cons (List Int)) 4 (as nil (List Int))))))
)

Found solution [23, 23, 4]
Exception in checking result: 
WARNING: Solution verification failed for puzzle RollingMax:4
Too many constants for extrapolation

Solving puzzle 91/732: CertifiedGCD:0
sat_func def sat(ans: List[int], m=200004931, n=66679984):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
modified_func def sat(ans: List[int], m=wrap_int(200004931), n=wrap_int(66679984)):
    gcd, a, b = ans
    return (m % gcd == n % gcd).__and__(n % gcd == wrap_int(0)).__and__(a * m + b * n == gcd).__and__(gcd > wrap_int(0))
Exception -- for puzzle CertifiedGCD:0 not enough values to unpack (expected 3, got 1)

Solving puzzle 92/732: CertifiedGCD:1
sat_func def sat(ans: List[int], m=2642408, n=828886):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
modified_func def sat(ans: List[int], m=wrap_int(2642408), n=wrap_int(828886)):
    gcd, a, b = ans
    return (m % gcd == n % gcd).__and__(n % gcd == wrap_int(0)).__and__(a * m + b * n == gcd).__and__(gcd > wrap_int(0))
Exception -- for puzzle CertifiedGCD:1 not enough values to unpack (expected 3, got 1)

Solving puzzle 93/732: CertifiedGCD:2
sat_func def sat(ans: List[int], m=184428, n=105545439738):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
modified_func def sat(ans: List[int], m=wrap_int(184428), n=wrap_int(105545439738)):
    gcd, a, b = ans
    return (m % gcd == n % gcd).__and__(n % gcd == wrap_int(0)).__and__(a * m + b * n == gcd).__and__(gcd > wrap_int(0))
Exception -- for puzzle CertifiedGCD:2 not enough values to unpack (expected 3, got 1)

Solving puzzle 94/732: CertifiedGCD:3
sat_func def sat(ans: List[int], m=3956548155, n=103530):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
modified_func def sat(ans: List[int], m=wrap_int(3956548155), n=wrap_int(103530)):
    gcd, a, b = ans
    return (m % gcd == n % gcd).__and__(n % gcd == wrap_int(0)).__and__(a * m + b * n == gcd).__and__(gcd > wrap_int(0))
Exception -- for puzzle CertifiedGCD:3 not enough values to unpack (expected 3, got 1)

Solving puzzle 95/732: CertifiedGCD:4
sat_func def sat(ans: List[int], m=101920, n=55199657760):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
modified_func def sat(ans: List[int], m=wrap_int(101920), n=wrap_int(55199657760)):
    gcd, a, b = ans
    return (m % gcd == n % gcd).__and__(n % gcd == wrap_int(0)).__and__(a * m + b * n == gcd).__and__(gcd > wrap_int(0))
Exception -- for puzzle CertifiedGCD:4 not enough values to unpack (expected 3, got 1)

Solving puzzle 96/732: AllPrefixes:0
sat_func def sat(prefixes: List[str], s="donesezichethofalij"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
modified_func def sat(prefixes: List[str], s=wrap_str('donesezichethofalij')):
    return all(sym_generator((s.startswith(p) for p in prefixes))).__and__(sym_len(set(prefixes)) > sym_len(s))
Exception -- for puzzle AllPrefixes:0 Symbolic hash not yet implemented

Solving puzzle 97/732: AllPrefixes:1
sat_func def sat(prefixes: List[str], s="vuf"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
modified_func def sat(prefixes: List[str], s=wrap_str('vuf')):
    return all(sym_generator((s.startswith(p) for p in prefixes))).__and__(sym_len(set(prefixes)) > sym_len(s))
Exception -- for puzzle AllPrefixes:1 Symbolic hash not yet implemented

Solving puzzle 98/732: AllPrefixes:2
sat_func def sat(prefixes: List[str], s="t"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
modified_func def sat(prefixes: List[str], s=wrap_str('t')):
    return all(sym_generator((s.startswith(p) for p in prefixes))).__and__(sym_len(set(prefixes)) > sym_len(s))
Exception -- for puzzle AllPrefixes:2 Symbolic hash not yet implemented

Solving puzzle 99/732: AllPrefixes:3
sat_func def sat(prefixes: List[str], s="qu"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
modified_func def sat(prefixes: List[str], s=wrap_str('qu')):
    return all(sym_generator((s.startswith(p) for p in prefixes))).__and__(sym_len(set(prefixes)) > sym_len(s))
Exception -- for puzzle AllPrefixes:3 Symbolic hash not yet implemented

Solving puzzle 100/732: AllPrefixes:4
sat_func def sat(prefixes: List[str], s="dugethixuneku"):
    return all(s.startswith(p) for p in prefixes) and len(set(prefixes)) > len(s)
modified_func def sat(prefixes: List[str], s=wrap_str('dugethixuneku')):
    return all(sym_generator((s.startswith(p) for p in prefixes))).__and__(sym_len(set(prefixes)) > sym_len(s))
Exception -- for puzzle AllPrefixes:4 Symbolic hash not yet implemented

Solving puzzle 101/732: DistinctChars:0
sat_func def sat(ans: List[str], s="The quick brown fox jumps over the lazy dog!", n=28):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
modified_func def sat(ans: List[str], s=wrap_str('The quick brown fox jumps over the lazy dog!'), n=wrap_int(28)):
    _assert(all(sym_generator((ans.count(c.lower()) == wrap_int(1) for c in s))))
    _assert(all(sym_generator((c == c.lower() for c in ans))))
    _assert(all(sym_generator((sym_in(c, s.lower()) for c in ans))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (list.count.string x "t") 1) (= (list.count.string x "h") 1)) (= (list.count.string x "e") 1)) (= (list.count.string x " ") 1)) (= (list.count.string x "q") 1)) (= (list.count.string x "u") 1)) (= (list.count.string x "i") 1)) (= (list.count.string x "c") 1)) (= (list.count.string x "k") 1)) (= (list.count.string x " ") 1)) (= (list.count.string x "b") 1)) (= (list.count.string x "r") 1)) (= (list.count.string x "o") 1)) (= (list.count.string x "w") 1)) (= (list.count.string x "n") 1)) (= (list.count.string x " ") 1)) (= (list.count.string x "f") 1)) (= (list.count.string x "o") 1)) (= (list.count.string x "x") 1)) (= (list.count.string x " ") 1)) (= (list.count.string x "j") 1)) (= (list.count.string x "u") 1)) (= (list.count.string x "m") 1)) (= (list.count.stri...
(assert (forall ((list_pos_113 Int)) (=> (and (>= list_pos_113 0) (< list_pos_113 (list.length.string x))) (= (list.get.string x list_pos_113) (str.lower (list.get.string x list_pos_113))))))
(assert (forall ((list_pos_114 Int)) (=> (and (>= list_pos_114 0) (< list_pos_114 (list.length.string x))) (forall ((list_pos_113 Int)) (=> (and (>= list_pos_113 0) (< list_pos_113 (list.length.string x))) (str.contains "the quick brown fox jumps over the lazy dog!" (list.get.string x list_pos_114)))))))
(assert (forall ((list_pos_114 Int)) (=> (and (>= list_pos_114 0) (< list_pos_114 (list.length.string x))) (forall ((list_pos_113 Int)) (=> (and (>= list_pos_113 0) (< list_pos_113 (list.length.string x))) true)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle DistinctChars:0
Too many constants for extrapolation

Solving puzzle 102/732: DistinctChars:1
sat_func def sat(ans: List[str], s="Iu]K,>Q8w", n=9):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
modified_func def sat(ans: List[str], s=wrap_str('Iu]K,>Q8w'), n=wrap_int(9)):
    _assert(all(sym_generator((ans.count(c.lower()) == wrap_int(1) for c in s))))
    _assert(all(sym_generator((c == c.lower() for c in ans))))
    _assert(all(sym_generator((sym_in(c, s.lower()) for c in ans))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (and (and (and (and (and (and (and (and (= (list.count.string x "i") 1) (= (list.count.string x "u") 1)) (= (list.count.string x "]") 1)) (= (list.count.string x "k") 1)) (= (list.count.string x ",") 1)) (= (list.count.string x ">") 1)) (= (list.count.string x "q") 1)) (= (list.count.string x "8") 1)) (= (list.count.string x "w") 1)))
(assert (forall ((list_pos_115 Int)) (=> (and (>= list_pos_115 0) (< list_pos_115 (list.length.string x))) (= (list.get.string x list_pos_115) (str.lower (list.get.string x list_pos_115))))))
(assert (forall ((list_pos_116 Int)) (=> (and (>= list_pos_116 0) (< list_pos_116 (list.length.string x))) (forall ((list_pos_115 Int)) (=> (and (>= list_pos_115 0) (< list_pos_115 (list.length.string x))) (str.contains "iu]k,>q8w" (list.get.string x list_pos_116)))))))
(assert (forall ((list_pos_116 Int)) (=> (and (>= list_pos_116 0) (< list_pos_116 (list.length.string x))) (forall ((list_pos_115 Int)) (=> (and (>= list_pos_115 0) (< list_pos_115 (list.length.string x))) true)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle DistinctChars:1
Too many constants for extrapolation

Solving puzzle 103/732: DistinctChars:2
sat_func def sat(ans: List[str], s="JrUCk=ek&q^xBuvtm", n=15):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
modified_func def sat(ans: List[str], s=wrap_str('JrUCk=ek&q^xBuvtm'), n=wrap_int(15)):
    _assert(all(sym_generator((ans.count(c.lower()) == wrap_int(1) for c in s))))
    _assert(all(sym_generator((c == c.lower() for c in ans))))
    _assert(all(sym_generator((sym_in(c, s.lower()) for c in ans))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (list.count.string x "j") 1) (= (list.count.string x "r") 1)) (= (list.count.string x "u") 1)) (= (list.count.string x "c") 1)) (= (list.count.string x "k") 1)) (= (list.count.string x "=") 1)) (= (list.count.string x "e") 1)) (= (list.count.string x "k") 1)) (= (list.count.string x "&") 1)) (= (list.count.string x "q") 1)) (= (list.count.string x "^") 1)) (= (list.count.string x "x") 1)) (= (list.count.string x "b") 1)) (= (list.count.string x "u") 1)) (= (list.count.string x "v") 1)) (= (list.count.string x "t") 1)) (= (list.count.string x "m") 1)))
(assert (forall ((list_pos_117 Int)) (=> (and (>= list_pos_117 0) (< list_pos_117 (list.length.string x))) (= (list.get.string x list_pos_117) (str.lower (list.get.string x list_pos_117))))))
(assert (forall ((list_pos_118 Int)) (=> (and (>= list_pos_118 0) (< list_pos_118 (list.length.string x))) (forall ((list_pos_117 Int)) (=> (and (>= list_pos_117 0) (< list_pos_117 (list.length.string x))) (str.contains "jruck=ek&q^xbuvtm" (list.get.string x list_pos_118)))))))
(assert (forall ((list_pos_118 Int)) (=> (and (>= list_pos_118 0) (< list_pos_118 (list.length.string x))) (forall ((list_pos_117 Int)) (=> (and (>= list_pos_117 0) (< list_pos_117 (list.length.string x))) true)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle DistinctChars:2
Too many constants for extrapolation

Solving puzzle 104/732: DistinctChars:3
sat_func def sat(ans: List[str], s="V-wKeN", n=6):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
modified_func def sat(ans: List[str], s=wrap_str('V-wKeN'), n=wrap_int(6)):
    _assert(all(sym_generator((ans.count(c.lower()) == wrap_int(1) for c in s))))
    _assert(all(sym_generator((c == c.lower() for c in ans))))
    _assert(all(sym_generator((sym_in(c, s.lower()) for c in ans))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (and (and (and (and (and (= (list.count.string x "v") 1) (= (list.count.string x "-") 1)) (= (list.count.string x "w") 1)) (= (list.count.string x "k") 1)) (= (list.count.string x "e") 1)) (= (list.count.string x "n") 1)))
(assert (forall ((list_pos_119 Int)) (=> (and (>= list_pos_119 0) (< list_pos_119 (list.length.string x))) (= (list.get.string x list_pos_119) (str.lower (list.get.string x list_pos_119))))))
(assert (forall ((list_pos_120 Int)) (=> (and (>= list_pos_120 0) (< list_pos_120 (list.length.string x))) (forall ((list_pos_119 Int)) (=> (and (>= list_pos_119 0) (< list_pos_119 (list.length.string x))) (str.contains "v-wken" (list.get.string x list_pos_120)))))))
(assert (forall ((list_pos_120 Int)) (=> (and (>= list_pos_120 0) (< list_pos_120 (list.length.string x))) (forall ((list_pos_119 Int)) (=> (and (>= list_pos_119 0) (< list_pos_119 (list.length.string x))) true)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle DistinctChars:3
Too many constants for extrapolation

Solving puzzle 105/732: DistinctChars:4
sat_func def sat(ans: List[str], s="F;J*qHN.^YC", n=11):
    assert all(ans.count(c.lower()) == 1 for c in s)
    assert all(c == c.lower() for c in ans)
    assert all(c in s.lower() for c in ans)
    return True
modified_func def sat(ans: List[str], s=wrap_str('F;J*qHN.^YC'), n=wrap_int(11)):
    _assert(all(sym_generator((ans.count(c.lower()) == wrap_int(1) for c in s))))
    _assert(all(sym_generator((c == c.lower() for c in ans))))
    _assert(all(sym_generator((sym_in(c, s.lower()) for c in ans))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (and (and (and (and (and (and (and (and (and (and (= (list.count.string x "f") 1) (= (list.count.string x ";") 1)) (= (list.count.string x "j") 1)) (= (list.count.string x "*") 1)) (= (list.count.string x "q") 1)) (= (list.count.string x "h") 1)) (= (list.count.string x "n") 1)) (= (list.count.string x ".") 1)) (= (list.count.string x "^") 1)) (= (list.count.string x "y") 1)) (= (list.count.string x "c") 1)))
(assert (forall ((list_pos_121 Int)) (=> (and (>= list_pos_121 0) (< list_pos_121 (list.length.string x))) (= (list.get.string x list_pos_121) (str.lower (list.get.string x list_pos_121))))))
(assert (forall ((list_pos_122 Int)) (=> (and (>= list_pos_122 0) (< list_pos_122 (list.length.string x))) (forall ((list_pos_121 Int)) (=> (and (>= list_pos_121 0) (< list_pos_121 (list.length.string x))) (str.contains "f;j*qhn.^yc" (list.get.string x list_pos_122)))))))
(assert (forall ((list_pos_122 Int)) (=> (and (>= list_pos_122 0) (< list_pos_122 (list.length.string x))) (forall ((list_pos_121 Int)) (=> (and (>= list_pos_121 0) (< list_pos_121 (list.length.string x))) true)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle DistinctChars:4
Too many constants for extrapolation

Solving puzzle 106/732: ParseMusic:0
sat_func def sat(beats: List[int], score="o o o| o| .| .| .| o| o| o o o| .|"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
modified_func def sat(beats: List[int], score=wrap_str('o o o| o| .| .| .| o| o| o o o| .|')):
    return wrap_str(' ').join(sym_generator(({wrap_int(1): wrap_str('.|'), wrap_int(2): wrap_str('o|'), wrap_int(4): wrap_str('o')}[b] for b in beats))) == score
Exception -- for puzzle ParseMusic:0 Cannot join items in <class 'generator'>: SymbolicInt(None)

Solving puzzle 107/732: ParseMusic:1
sat_func def sat(beats: List[int], score=".| o .| o| o| o| o| .| o o"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
modified_func def sat(beats: List[int], score=wrap_str('.| o .| o| o| o| o| .| o o')):
    return wrap_str(' ').join(sym_generator(({wrap_int(1): wrap_str('.|'), wrap_int(2): wrap_str('o|'), wrap_int(4): wrap_str('o')}[b] for b in beats))) == score
Exception -- for puzzle ParseMusic:1 Cannot join items in <class 'generator'>: SymbolicInt(None)

Solving puzzle 108/732: ParseMusic:2
sat_func def sat(beats: List[int], score="o| .| .| .| .| o| o .| o| o| o"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
modified_func def sat(beats: List[int], score=wrap_str('o| .| .| .| .| o| o .| o| o| o')):
    return wrap_str(' ').join(sym_generator(({wrap_int(1): wrap_str('.|'), wrap_int(2): wrap_str('o|'), wrap_int(4): wrap_str('o')}[b] for b in beats))) == score
Exception -- for puzzle ParseMusic:2 Cannot join items in <class 'generator'>: SymbolicInt(None)

Solving puzzle 109/732: ParseMusic:3
sat_func def sat(beats: List[int], score=".| o|"):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
modified_func def sat(beats: List[int], score=wrap_str('.| o|')):
    return wrap_str(' ').join(sym_generator(({wrap_int(1): wrap_str('.|'), wrap_int(2): wrap_str('o|'), wrap_int(4): wrap_str('o')}[b] for b in beats))) == score
Exception -- for puzzle ParseMusic:3 Cannot join items in <class 'generator'>: SymbolicInt(None)

Solving puzzle 110/732: ParseMusic:4
sat_func def sat(beats: List[int], score=""):
    return " ".join({1: '.|', 2: 'o|', 4: 'o'}[b] for b in beats) == score
modified_func def sat(beats: List[int], score=wrap_str('')):
    return wrap_str(' ').join(sym_generator(({wrap_int(1): wrap_str('.|'), wrap_int(2): wrap_str('o|'), wrap_int(4): wrap_str('o')}[b] for b in beats))) == score
Exception -- for puzzle ParseMusic:4 Cannot join items in <class 'generator'>: SymbolicInt(None)

Solving puzzle 111/732: OverlappingCount:0
sat_func def sat(ans: List[int], s="Bananannanaannanaanananananana", sub="anan", count=7):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
modified_func def sat(ans: List[int], s=wrap_str('Bananannanaannanaanananananana'), sub=wrap_str('anan'), count=wrap_int(7)):
    return all(sym_generator(((sub == s[i:i + sym_len(sub)]).__and__(i >= wrap_int(0)) for i in ans))).__and__(sym_len(set(ans)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_129 Int)) (=> (and (>= list_pos_129 0) (< list_pos_129 (list.length.int x))) (forall ((list_pos_128 Int)) (=> (and (>= list_pos_128 0) (< list_pos_128 (list.length.int x))) (and (and false (>= (list.get.int x list_pos_128) 0)) (<= 7 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OverlappingCount:0
Too many constants for extrapolation

Solving puzzle 112/732: OverlappingCount:1
sat_func def sat(ans: List[int], s="halidykugadobezebothidububawuvejiquitextyrequamobythynethojahyquutatextoquuzilu", sub="ne", count=1):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
modified_func def sat(ans: List[int], s=wrap_str('halidykugadobezebothidububawuvejiquitextyrequamobythynethojahyquutatextoquuzilu'), sub=wrap_str('ne'), count=wrap_int(1)):
    return all(sym_generator(((sub == s[i:i + sym_len(sub)]).__and__(i >= wrap_int(0)) for i in ans))).__and__(sym_len(set(ans)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_131 Int)) (=> (and (>= list_pos_131 0) (< list_pos_131 (list.length.int x))) (forall ((list_pos_130 Int)) (=> (and (>= list_pos_130 0) (< list_pos_130 (list.length.int x))) (and (and false (>= (list.get.int x list_pos_130) 0)) (<= 1 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OverlappingCount:1
Too many constants for extrapolation

Solving puzzle 113/732: OverlappingCount:2
sat_func def sat(ans: List[int], s="sutapifitextidavyjedakotextopogonudy", sub="te", count=2):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
modified_func def sat(ans: List[int], s=wrap_str('sutapifitextidavyjedakotextopogonudy'), sub=wrap_str('te'), count=wrap_int(2)):
    return all(sym_generator(((sub == s[i:i + sym_len(sub)]).__and__(i >= wrap_int(0)) for i in ans))).__and__(sym_len(set(ans)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_133 Int)) (=> (and (>= list_pos_133 0) (< list_pos_133 (list.length.int x))) (forall ((list_pos_132 Int)) (=> (and (>= list_pos_132 0) (< list_pos_132 (list.length.int x))) (and (and false (>= (list.get.int x list_pos_132) 0)) (<= 2 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OverlappingCount:2
Too many constants for extrapolation

Solving puzzle 114/732: OverlappingCount:3
sat_func def sat(ans: List[int], s="fizyquohachoromuxuquatextidemihithacazynytytextukozarahuwyfuchyquyhidadytext", sub="quohach", count=1):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
modified_func def sat(ans: List[int], s=wrap_str('fizyquohachoromuxuquatextidemihithacazynytytextukozarahuwyfuchyquyhidadytext'), sub=wrap_str('quohach'), count=wrap_int(1)):
    return all(sym_generator(((sub == s[i:i + sym_len(sub)]).__and__(i >= wrap_int(0)) for i in ans))).__and__(sym_len(set(ans)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_135 Int)) (=> (and (>= list_pos_135 0) (< list_pos_135 (list.length.int x))) (forall ((list_pos_134 Int)) (=> (and (>= list_pos_134 0) (< list_pos_134 (list.length.int x))) (and (and false (>= (list.get.int x list_pos_134) 0)) (<= 1 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OverlappingCount:3
Too many constants for extrapolation

Solving puzzle 115/732: OverlappingCount:4
sat_func def sat(ans: List[int], s="wutextega", sub="xtega", count=1):
    return all(sub == s[i:i + len(sub)] and i >= 0 for i in ans) and len(set(ans)) >= count
modified_func def sat(ans: List[int], s=wrap_str('wutextega'), sub=wrap_str('xtega'), count=wrap_int(1)):
    return all(sym_generator(((sub == s[i:i + sym_len(sub)]).__and__(i >= wrap_int(0)) for i in ans))).__and__(sym_len(set(ans)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_137 Int)) (=> (and (>= list_pos_137 0) (< list_pos_137 (list.length.int x))) (forall ((list_pos_136 Int)) (=> (and (>= list_pos_136 0) (< list_pos_136 (list.length.int x))) (and (and false (>= (list.get.int x list_pos_136) 0)) (<= 1 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OverlappingCount:4
Too many constants for extrapolation

Solving puzzle 116/732: FindClosePair:0
sat_func def sat(inds: List[int], nums=[0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
modified_func def sat(inds: List[int], nums=wrap_list([0.31, 21.3, 5.0, 9.0, 11.0, 5.01, 17.2])):
    a, b = inds
    _assert((a != b).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0)))
    for i in sym_range(sym_len(nums)):
        for j in sym_range(i):
            _assert(abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a]))
    return True
Exception -- for puzzle FindClosePair:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 117/732: FindClosePair:1
sat_func def sat(inds: List[int], nums=[-7.587461542549912, 0.7494004368541578, 2.0142388071411013, -1.552072793834526, 0.44845194836415025]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
modified_func def sat(inds: List[int], nums=wrap_list([-7.587461542549912, 0.7494004368541578, 2.0142388071411013, -1.552072793834526, 0.44845194836415025])):
    a, b = inds
    _assert((a != b).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0)))
    for i in sym_range(sym_len(nums)):
        for j in sym_range(i):
            _assert(abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a]))
    return True
Exception -- for puzzle FindClosePair:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 118/732: FindClosePair:2
sat_func def sat(inds: List[int], nums=[-5.253924550449174, 7.798134742325132, 2.84274998450722, -5.355403889716619, -8.14069894708204, 6.276599656475899]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
modified_func def sat(inds: List[int], nums=wrap_list([-5.253924550449174, 7.798134742325132, 2.84274998450722, -5.355403889716619, -8.14069894708204, 6.276599656475899])):
    a, b = inds
    _assert((a != b).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0)))
    for i in sym_range(sym_len(nums)):
        for j in sym_range(i):
            _assert(abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a]))
    return True
Exception -- for puzzle FindClosePair:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 119/732: FindClosePair:3
sat_func def sat(inds: List[int], nums=[8.647950767409466, 6.069423836495417, 8.647950767409466, -4.483139827348948, 7.822521892934297, 6.339621174459673]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
modified_func def sat(inds: List[int], nums=wrap_list([8.647950767409466, 6.069423836495417, 8.647950767409466, -4.483139827348948, 7.822521892934297, 6.339621174459673])):
    a, b = inds
    _assert((a != b).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0)))
    for i in sym_range(sym_len(nums)):
        for j in sym_range(i):
            _assert(abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a]))
    return True
Exception -- for puzzle FindClosePair:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 120/732: FindClosePair:4
sat_func def sat(inds: List[int], nums=[-2.4491102095531385, -2.4896924424294635]):
    a, b = inds
    assert a != b and a >= 0 and b >= 0
    for i in range(len(nums)):
        for j in range(i):
            assert abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a])
    return True
modified_func def sat(inds: List[int], nums=wrap_list([-2.4491102095531385, -2.4896924424294635])):
    a, b = inds
    _assert((a != b).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0)))
    for i in sym_range(sym_len(nums)):
        for j in sym_range(i):
            _assert(abs(nums[i] - nums[j]) >= abs(nums[b] - nums[a]))
    return True
Exception -- for puzzle FindClosePair:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 121/732: FilterInts:0
sat_func def sat(candidates: List[str], int_indices=[2, 4, 7, 9, 101]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
modified_func def sat(candidates: List[str], int_indices=wrap_list([wrap_int(2), wrap_int(4), wrap_int(7), wrap_int(9), wrap_int(101)])):
    for i in int_indices:
        sym_int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                sym_int(s)
                return False
            except ValueError:
                pass
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (> (str.len (list.get.string x 2)) 0))
(assert (> (str.len (list.get.string x 4)) 0))
(assert (> (str.len (list.get.string x 7)) 0))
(assert (> (str.len (list.get.string x 9)) 0))
(assert (> (str.len (list.get.string x 101)) 0))
(assert (forall ((list_pos_143 Int)) (=> (and (>= list_pos_143 0) (< list_pos_143 (list.length.string x))) (> (str.len (list.get.string x list_pos_143)) 0))))
(assert (forall ((list_pos_143 Int)) (=> (and (>= list_pos_143 0) (< list_pos_143 (list.length.string x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FilterInts:0
One large constant for extrapolation
Solving simpler variation replaced 101 with 3
sat_func def sat(candidates: List[str], int_indices=[2, 4, 7, 9, 3]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
modified_func def sat(candidates: List[str], int_indices=wrap_list([wrap_int(2), wrap_int(4), wrap_int(7), wrap_int(9), wrap_int(3)])):
    for i in int_indices:
        sym_int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                sym_int(s)
                return False
            except ValueError:
                pass
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (> (str.len (list.get.string x 2)) 0))
(assert (> (str.len (list.get.string x 4)) 0))
(assert (> (str.len (list.get.string x 7)) 0))
(assert (> (str.len (list.get.string x 9)) 0))
(assert (> (str.len (list.get.string x 3)) 0))
(assert (forall ((list_pos_144 Int)) (=> (and (>= list_pos_144 0) (< list_pos_144 (list.length.string x))) (> (str.len (list.get.string x list_pos_144)) 0))))
(assert (forall ((list_pos_144 Int)) (=> (and (>= list_pos_144 0) (< list_pos_144 (list.length.string x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle FilterInts:0

Solving puzzle 122/732: FilterInts:1
sat_func def sat(candidates: List[str], int_indices=[80, 17, 74]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
modified_func def sat(candidates: List[str], int_indices=wrap_list([wrap_int(80), wrap_int(17), wrap_int(74)])):
    for i in int_indices:
        sym_int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                sym_int(s)
                return False
            except ValueError:
                pass
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (> (str.len (list.get.string x 80)) 0))
(assert (> (str.len (list.get.string x 17)) 0))
(assert (> (str.len (list.get.string x 74)) 0))
(assert (forall ((list_pos_145 Int)) (=> (and (>= list_pos_145 0) (< list_pos_145 (list.length.string x))) (> (str.len (list.get.string x list_pos_145)) 0))))
(assert (forall ((list_pos_145 Int)) (=> (and (>= list_pos_145 0) (< list_pos_145 (list.length.string x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FilterInts:1
Too many constants for extrapolation

Solving puzzle 123/732: FilterInts:2
sat_func def sat(candidates: List[str], int_indices=[56, 37, 17, 83, 35, 22, 4, 78, 79]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
modified_func def sat(candidates: List[str], int_indices=wrap_list([wrap_int(56), wrap_int(37), wrap_int(17), wrap_int(83), wrap_int(35), wrap_int(22), wrap_int(4), wrap_int(78), wrap_int(79)])):
    for i in int_indices:
        sym_int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                sym_int(s)
                return False
            except ValueError:
                pass
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (> (str.len (list.get.string x 56)) 0))
(assert (> (str.len (list.get.string x 37)) 0))
(assert (> (str.len (list.get.string x 17)) 0))
(assert (> (str.len (list.get.string x 83)) 0))
(assert (> (str.len (list.get.string x 35)) 0))
(assert (> (str.len (list.get.string x 22)) 0))
(assert (> (str.len (list.get.string x 4)) 0))
(assert (> (str.len (list.get.string x 78)) 0))
(assert (> (str.len (list.get.string x 79)) 0))
(assert (forall ((list_pos_146 Int)) (=> (and (>= list_pos_146 0) (< list_pos_146 (list.length.string x))) (> (str.len (list.get.string x list_pos_146)) 0))))
(assert (forall ((list_pos_146 Int)) (=> (and (>= list_pos_146 0) (< list_pos_146 (list.length.string x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FilterInts:2
Too many constants for extrapolation

Solving puzzle 124/732: FilterInts:3
sat_func def sat(candidates: List[str], int_indices=[25, 65]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
modified_func def sat(candidates: List[str], int_indices=wrap_list([wrap_int(25), wrap_int(65)])):
    for i in int_indices:
        sym_int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                sym_int(s)
                return False
            except ValueError:
                pass
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (> (str.len (list.get.string x 25)) 0))
(assert (> (str.len (list.get.string x 65)) 0))
(assert (forall ((list_pos_147 Int)) (=> (and (>= list_pos_147 0) (< list_pos_147 (list.length.string x))) (> (str.len (list.get.string x list_pos_147)) 0))))
(assert (forall ((list_pos_147 Int)) (=> (and (>= list_pos_147 0) (< list_pos_147 (list.length.string x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FilterInts:3
Too many constants for extrapolation

Solving puzzle 125/732: FilterInts:4
sat_func def sat(candidates: List[str], int_indices=[92, 74, 83, 90, 9, 76, 66, 0]):
    for i in int_indices:
        int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                int(s)
                return False
            except ValueError:
                pass
    return True
modified_func def sat(candidates: List[str], int_indices=wrap_list([wrap_int(92), wrap_int(74), wrap_int(83), wrap_int(90), wrap_int(9), wrap_int(76), wrap_int(66), wrap_int(0)])):
    for i in int_indices:
        sym_int(candidates[i])
    for i, s in enumerate(candidates):
        if i not in int_indices:
            try:
                sym_int(s)
                return False
            except ValueError:
                pass
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (> (str.len (list.get.string x 92)) 0))
(assert (> (str.len (list.get.string x 74)) 0))
(assert (> (str.len (list.get.string x 83)) 0))
(assert (> (str.len (list.get.string x 90)) 0))
(assert (> (str.len (list.get.string x 9)) 0))
(assert (> (str.len (list.get.string x 76)) 0))
(assert (> (str.len (list.get.string x 66)) 0))
(assert (> (str.len (list.get.string x 0)) 0))
(assert (forall ((list_pos_148 Int)) (=> (and (>= list_pos_148 0) (< list_pos_148 (list.length.string x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FilterInts:4
Too many constants for extrapolation

Solving puzzle 126/732: StrLength:0
sat_func def sat(lengths: List[int], strs=['pneumonoultramicroscopicsilicovolcanoconiosis', ' ', 'foo', '2.5']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
modified_func def sat(lengths: List[int], strs=wrap_list([wrap_str('pneumonoultramicroscopicsilicovolcanoconiosis'), wrap_str(' '), wrap_str('foo'), wrap_str('2.5')])):
    for length, s in sym_zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - wrap_int(1)]
    return sym_len(lengths) == sym_len(strs)
Exception -- for puzzle StrLength:0 found bad constraint False of type <class 'bool'>

Solving puzzle 127/732: StrLength:1
sat_func def sat(lengths: List[int], strs=['=i', '&?Jq 2aNHt', '?uCcQht', 'e>8=4jZNfhZl3&Mko-MfWd<^QR Vf7:2M', ']Y,G2U4ur-7X,T@(Gv$:Y0^C,-$+xM9$X2,*90|', '+>&?Qa%yLWZA2nBDQ8i)zvVWT', 'Ly+NcKgOvg3J)', 's$0^cow)Q917uY', 'ZSA$sIKe|pz@|[<kk,h[eFCiD#xxN7*G*Ic', '2q7eG maF4Gi8gJvJr[mgY,[jt(VL|2']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
modified_func def sat(lengths: List[int], strs=wrap_list([wrap_str('=i'), wrap_str('&?Jq 2aNHt'), wrap_str('?uCcQht'), wrap_str('e>8=4jZNfhZl3&Mko-MfWd<^QR Vf7:2M'), wrap_str(']Y,G2U4ur-7X,T@(Gv$:Y0^C,-$+xM9$X2,*90|'), wrap_str('+>&?Qa%yLWZA2nBDQ8i)zvVWT'), wrap_str('Ly+NcKgOvg3J)'), wrap_str('s$0^cow)Q917uY'), wrap_str('ZSA$sIKe|pz@|[<kk,h[eFCiD#xxN7*G*Ic'), wrap_str('2q7eG maF4Gi8gJvJr[mgY,[jt(VL|2')])):
    for length, s in sym_zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - wrap_int(1)]
    return sym_len(lengths) == sym_len(strs)
Exception -- for puzzle StrLength:1 found bad constraint False of type <class 'bool'>

Solving puzzle 128/732: StrLength:2
sat_func def sat(lengths: List[int], strs=['A/io]X92K;9aWaICuk7[]p|;af9#L#&aIk6I4E=c8u', '64P#$', 'cOpGRh3@ RoUho:YtF9L>/%4=%?ry(+2', '&.Qf?cuJI%m.>pBZY', 'FUeoE;h(#,f5<jC>[%xwK9@EU', '2NNz-,|C*]Vu9E7|!7mA+ oM9<N', '[3 !D2ddGb4aY17(=Q7lQZ&f H)Hrp)]VHFnxy6Jp', 'wg#VJiO-', 'jwBAk$XQ&*95d;[j,Y+', '!t:$CE#)+Pk7De*V|*&Z@u&0+gIhto/&.P*=q|!hw']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
modified_func def sat(lengths: List[int], strs=wrap_list([wrap_str('A/io]X92K;9aWaICuk7[]p|;af9#L#&aIk6I4E=c8u'), wrap_str('64P#$'), wrap_str('cOpGRh3@ RoUho:YtF9L>/%4=%?ry(+2'), wrap_str('&.Qf?cuJI%m.>pBZY'), wrap_str('FUeoE;h(#,f5<jC>[%xwK9@EU'), wrap_str('2NNz-,|C*]Vu9E7|!7mA+ oM9<N'), wrap_str('[3 !D2ddGb4aY17(=Q7lQZ&f H)Hrp)]VHFnxy6Jp'), wrap_str('wg#VJiO-'), wrap_str('jwBAk$XQ&*95d;[j,Y+'), wrap_str('!t:$CE#)+Pk7De*V|*&Z@u&0+gIhto/&.P*=q|!hw')])):
    for length, s in sym_zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - wrap_int(1)]
    return sym_len(lengths) == sym_len(strs)
Exception -- for puzzle StrLength:2 found bad constraint False of type <class 'bool'>

Solving puzzle 129/732: StrLength:3
sat_func def sat(lengths: List[int], strs=['ij+OUM5ZP Q3?', '^D.i+GLGID@2oUVF4', 'VaLA:aPP@5eKY,WK9MS*Ez', '.%fR+&q&0>Y(l%O2ub5<YXU#K.?9g', 'bO6[sMEL.g0^+r0', 'yCKQT^6Ug4al|r!PiMOF[KHz^%:WYTi]-G', '4lORJ/yub%d5gR@@>ciSw-]geHu6NgF9au)r', 'ED!Bz=4nF6  z^kMW-3-&<Eoc9B604*yscpnhcmJ?/', '?!u7%E0G4Z.r- V9LL 1Cd(W9eL=E^58a2xuf)ZYj-ILLW', 'A|NlyRr8uQG2eJm4y<Bu,r#fz&eNB]=hp']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
modified_func def sat(lengths: List[int], strs=wrap_list([wrap_str('ij+OUM5ZP Q3?'), wrap_str('^D.i+GLGID@2oUVF4'), wrap_str('VaLA:aPP@5eKY,WK9MS*Ez'), wrap_str('.%fR+&q&0>Y(l%O2ub5<YXU#K.?9g'), wrap_str('bO6[sMEL.g0^+r0'), wrap_str('yCKQT^6Ug4al|r!PiMOF[KHz^%:WYTi]-G'), wrap_str('4lORJ/yub%d5gR@@>ciSw-]geHu6NgF9au)r'), wrap_str('ED!Bz=4nF6  z^kMW-3-&<Eoc9B604*yscpnhcmJ?/'), wrap_str('?!u7%E0G4Z.r- V9LL 1Cd(W9eL=E^58a2xuf)ZYj-ILLW'), wrap_str('A|NlyRr8uQG2eJm4y<Bu,r#fz&eNB]=hp')])):
    for length, s in sym_zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - wrap_int(1)]
    return sym_len(lengths) == sym_len(strs)
Exception -- for puzzle StrLength:3 found bad constraint False of type <class 'bool'>

Solving puzzle 130/732: StrLength:4
sat_func def sat(lengths: List[int], strs=['g', ';TWy9!004X#d7!0p ', 'eaX%:#7S2IIIUe&#r3=EB1;5K)3j;1Vn', ']cz!vZ]Wq&O]sMR8D', ')o=#sAp-c8:SM&.yRBpCMmS)-', 'Ql d.i(UA/|sFqHQ/c3M>p]exH|sgXQt', 'mwoa[nS-[%R(rf5!)9o.M[', '23Q0Sugd(RKZ+GuLu', 'x^VP2ZX$8', 'q7(GrHGkG6er!7hX+ZeKolCgdlqI0(*um']):
    for length, s in zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - 1]
    return len(lengths) == len(strs)
modified_func def sat(lengths: List[int], strs=wrap_list([wrap_str('g'), wrap_str(';TWy9!004X#d7!0p '), wrap_str('eaX%:#7S2IIIUe&#r3=EB1;5K)3j;1Vn'), wrap_str(']cz!vZ]Wq&O]sMR8D'), wrap_str(')o=#sAp-c8:SM&.yRBpCMmS)-'), wrap_str('Ql d.i(UA/|sFqHQ/c3M>p]exH|sgXQt'), wrap_str('mwoa[nS-[%R(rf5!)9o.M['), wrap_str('23Q0Sugd(RKZ+GuLu'), wrap_str('x^VP2ZX$8'), wrap_str('q7(GrHGkG6er!7hX+ZeKolCgdlqI0(*um')])):
    for length, s in sym_zip(lengths, strs):
        try:
            s[length]
            return False
        except IndexError:
            s[length - wrap_int(1)]
    return sym_len(lengths) == sym_len(strs)
Exception -- for puzzle StrLength:4 found bad constraint False of type <class 'bool'>

Solving puzzle 131/732: PrimeFactorization:0
sat_func def sat(factors: List[int], n=123456, num_factors=8):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(123456), num_factors=wrap_int(8)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 8))
(assert (forall ((list_pos_149 Int)) (=> (and (>= list_pos_149 0) (< list_pos_149 (list.length.int x))) (> (list.get.int x list_pos_149) 1))))
(assert (forall ((list_pos_149 Int)) (=> (and (>= list_pos_149 0) (< list_pos_149 (list.length.int x))) (= (* 1 (list.get.int x list_pos_149)) 123456))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 123456 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) (- 8) ((as cons (List Int)) 9 ((as cons (List Int)) (- 9) ((as cons (List Int)) 10 (as nil (List Int)))))))))))
)

Could not find any solution for puzzle PrimeFactorization:0
One large constant for extrapolation
Solving simpler variation replaced 123456 with 3
sat_func def sat(factors: List[int], n=3, num_factors=8):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(3), num_factors=wrap_int(8)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 8))
(assert (forall ((list_pos_150 Int)) (=> (and (>= list_pos_150 0) (< list_pos_150 (list.length.int x))) (> (list.get.int x list_pos_150) 1))))
(assert (forall ((list_pos_150 Int)) (=> (and (>= list_pos_150 0) (< list_pos_150 (list.length.int x))) (= (* 1 (list.get.int x list_pos_150)) 3))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) (- 8) ((as cons (List Int)) 9 ((as cons (List Int)) (- 9) ((as cons (List Int)) 10 (as nil (List Int)))))))))))
)

Could not find any solution for puzzle PrimeFactorization:0

Solving puzzle 132/732: PrimeFactorization:1
sat_func def sat(factors: List[int], n=1339030, num_factors=6):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(1339030), num_factors=wrap_int(6)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 6))
(assert (forall ((list_pos_151 Int)) (=> (and (>= list_pos_151 0) (< list_pos_151 (list.length.int x))) (> (list.get.int x list_pos_151) 1))))
(assert (forall ((list_pos_151 Int)) (=> (and (>= list_pos_151 0) (< list_pos_151 (list.length.int x))) (= (* 1 (list.get.int x list_pos_151)) 1339030))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 1339030 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) 7 ((as cons (List Int)) (- 7) ((as cons (List Int)) 8 (as nil (List Int)))))))))
)

Could not find any solution for puzzle PrimeFactorization:1
One large constant for extrapolation
Solving simpler variation replaced 1339030 with 3
sat_func def sat(factors: List[int], n=3, num_factors=6):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(3), num_factors=wrap_int(6)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 6))
(assert (forall ((list_pos_152 Int)) (=> (and (>= list_pos_152 0) (< list_pos_152 (list.length.int x))) (> (list.get.int x list_pos_152) 1))))
(assert (forall ((list_pos_152 Int)) (=> (and (>= list_pos_152 0) (< list_pos_152 (list.length.int x))) (= (* 1 (list.get.int x list_pos_152)) 3))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) 7 ((as cons (List Int)) (- 7) ((as cons (List Int)) 8 (as nil (List Int)))))))))
)

Could not find any solution for puzzle PrimeFactorization:1

Solving puzzle 133/732: PrimeFactorization:2
sat_func def sat(factors: List[int], n=141752, num_factors=6):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(141752), num_factors=wrap_int(6)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 6))
(assert (forall ((list_pos_153 Int)) (=> (and (>= list_pos_153 0) (< list_pos_153 (list.length.int x))) (> (list.get.int x list_pos_153) 1))))
(assert (forall ((list_pos_153 Int)) (=> (and (>= list_pos_153 0) (< list_pos_153 (list.length.int x))) (= (* 1 (list.get.int x list_pos_153)) 141752))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 141752 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) 7 ((as cons (List Int)) (- 7) ((as cons (List Int)) 8 (as nil (List Int)))))))))
)

Could not find any solution for puzzle PrimeFactorization:2
One large constant for extrapolation
Solving simpler variation replaced 141752 with 3
sat_func def sat(factors: List[int], n=3, num_factors=6):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(3), num_factors=wrap_int(6)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 6))
(assert (forall ((list_pos_154 Int)) (=> (and (>= list_pos_154 0) (< list_pos_154 (list.length.int x))) (> (list.get.int x list_pos_154) 1))))
(assert (forall ((list_pos_154 Int)) (=> (and (>= list_pos_154 0) (< list_pos_154 (list.length.int x))) (= (* 1 (list.get.int x list_pos_154)) 3))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) 7 ((as cons (List Int)) (- 7) ((as cons (List Int)) 8 (as nil (List Int)))))))))
)

Could not find any solution for puzzle PrimeFactorization:2

Solving puzzle 134/732: PrimeFactorization:3
sat_func def sat(factors: List[int], n=33088, num_factors=8):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(33088), num_factors=wrap_int(8)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 8))
(assert (forall ((list_pos_155 Int)) (=> (and (>= list_pos_155 0) (< list_pos_155 (list.length.int x))) (> (list.get.int x list_pos_155) 1))))
(assert (forall ((list_pos_155 Int)) (=> (and (>= list_pos_155 0) (< list_pos_155 (list.length.int x))) (= (* 1 (list.get.int x list_pos_155)) 33088))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 33088 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) (- 8) ((as cons (List Int)) 9 ((as cons (List Int)) (- 9) ((as cons (List Int)) 10 (as nil (List Int)))))))))))
)

Could not find any solution for puzzle PrimeFactorization:3
One large constant for extrapolation
Solving simpler variation replaced 33088 with 3
sat_func def sat(factors: List[int], n=3, num_factors=8):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(3), num_factors=wrap_int(8)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 8))
(assert (forall ((list_pos_156 Int)) (=> (and (>= list_pos_156 0) (< list_pos_156 (list.length.int x))) (> (list.get.int x list_pos_156) 1))))
(assert (forall ((list_pos_156 Int)) (=> (and (>= list_pos_156 0) (< list_pos_156 (list.length.int x))) (= (* 1 (list.get.int x list_pos_156)) 3))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) (- 8) ((as cons (List Int)) 9 ((as cons (List Int)) (- 9) ((as cons (List Int)) 10 (as nil (List Int)))))))))))
)

Could not find any solution for puzzle PrimeFactorization:3

Solving puzzle 135/732: PrimeFactorization:4
sat_func def sat(factors: List[int], n=2375171125400, num_factors=12):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(2375171125400), num_factors=wrap_int(12)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 12))
(assert (forall ((list_pos_157 Int)) (=> (and (>= list_pos_157 0) (< list_pos_157 (list.length.int x))) (> (list.get.int x list_pos_157) 1))))
(assert (forall ((list_pos_157 Int)) (=> (and (>= list_pos_157 0) (< list_pos_157 (list.length.int x))) (= (* 1 (list.get.int x list_pos_157)) 2375171125400))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 2375171125400 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) (- 8) ((as cons (List Int)) (- 9) ((as cons (List Int)) (- 10) ((as cons (List Int)) (- 11) ((as cons (List Int)) (- 12) ((as cons (List Int)) 13 ((as cons (List Int)) (- 13) ((as cons (List Int)) 14 (as nil (List Int)))))))))))))))
)

Could not find any solution for puzzle PrimeFactorization:4
One large constant for extrapolation
Solving simpler variation replaced 2375171125400 with 3
sat_func def sat(factors: List[int], n=3, num_factors=12):
    assert len(factors) == num_factors
    prod = 1
    for d in factors:
        prod *= d
        assert d > 1
    return prod == n
modified_func def sat(factors: List[int], n=wrap_int(3), num_factors=wrap_int(12)):
    _assert(sym_len(factors) == num_factors)
    prod = wrap_int(1)
    for d in factors:
        prod *= d
        _assert(d > wrap_int(1))
    return prod == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 12))
(assert (forall ((list_pos_158 Int)) (=> (and (>= list_pos_158 0) (< list_pos_158 (list.length.int x))) (> (list.get.int x list_pos_158) 1))))
(assert (forall ((list_pos_158 Int)) (=> (and (>= list_pos_158 0) (< list_pos_158 (list.length.int x))) (= (* 1 (list.get.int x list_pos_158)) 3))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) (- 8) ((as cons (List Int)) (- 9) ((as cons (List Int)) (- 10) ((as cons (List Int)) (- 11) ((as cons (List Int)) (- 12) ((as cons (List Int)) 13 ((as cons (List Int)) (- 13) ((as cons (List Int)) 14 (as nil (List Int)))))))))))))))
)

Could not find any solution for puzzle PrimeFactorization:4

Solving puzzle 136/732: Dedup:0
sat_func def sat(ans: List[int], li=[2, 19, 2, 53, 1, 1, 2, 44, 17, 0, 19, 31]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
modified_func def sat(ans: List[int], li=wrap_list([wrap_int(2), wrap_int(19), wrap_int(2), wrap_int(53), wrap_int(1), wrap_int(1), wrap_int(2), wrap_int(44), wrap_int(17), wrap_int(0), wrap_int(19), wrap_int(31)])):
    return (set(ans) == set(li)).__and__(all(sym_generator((li.index(ans[i]) < li.index(ans[i + wrap_int(1)]) for i in sym_range(sym_len(ans) - 1)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (forall ((list_pos_159 Int)) (=> (and (>= list_pos_159 0) (< list_pos_159 (list.length.int x))) NotImplemented)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.180: Symbol 'NotImplemented' not declared as a variable")

Could not find any solution for puzzle Dedup:0
Too many constants for extrapolation

Solving puzzle 137/732: Dedup:1
sat_func def sat(ans: List[int], li=[3, 3, 7, 9, 7, 2, 9, 4, 1]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
modified_func def sat(ans: List[int], li=wrap_list([wrap_int(3), wrap_int(3), wrap_int(7), wrap_int(9), wrap_int(7), wrap_int(2), wrap_int(9), wrap_int(4), wrap_int(1)])):
    return (set(ans) == set(li)).__and__(all(sym_generator((li.index(ans[i]) < li.index(ans[i + wrap_int(1)]) for i in sym_range(sym_len(ans) - 1)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (forall ((list_pos_160 Int)) (=> (and (>= list_pos_160 0) (< list_pos_160 (list.length.int x))) NotImplemented)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.180: Symbol 'NotImplemented' not declared as a variable")

Could not find any solution for puzzle Dedup:1
Too many constants for extrapolation

Solving puzzle 138/732: Dedup:2
sat_func def sat(ans: List[int], li=[3, 9, 8, 9, 3, 5, 1, 3, 5]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
modified_func def sat(ans: List[int], li=wrap_list([wrap_int(3), wrap_int(9), wrap_int(8), wrap_int(9), wrap_int(3), wrap_int(5), wrap_int(1), wrap_int(3), wrap_int(5)])):
    return (set(ans) == set(li)).__and__(all(sym_generator((li.index(ans[i]) < li.index(ans[i + wrap_int(1)]) for i in sym_range(sym_len(ans) - 1)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (forall ((list_pos_161 Int)) (=> (and (>= list_pos_161 0) (< list_pos_161 (list.length.int x))) NotImplemented)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.180: Symbol 'NotImplemented' not declared as a variable")

Could not find any solution for puzzle Dedup:2
Too many constants for extrapolation

Solving puzzle 139/732: Dedup:3
sat_func def sat(ans: List[int], li=[3, 8, 2, 1, 1, 7, 7, 7, 5, 5, 5, 9, 3, 7, 7]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
modified_func def sat(ans: List[int], li=wrap_list([wrap_int(3), wrap_int(8), wrap_int(2), wrap_int(1), wrap_int(1), wrap_int(7), wrap_int(7), wrap_int(7), wrap_int(5), wrap_int(5), wrap_int(5), wrap_int(9), wrap_int(3), wrap_int(7), wrap_int(7)])):
    return (set(ans) == set(li)).__and__(all(sym_generator((li.index(ans[i]) < li.index(ans[i + wrap_int(1)]) for i in sym_range(sym_len(ans) - 1)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (forall ((list_pos_162 Int)) (=> (and (>= list_pos_162 0) (< list_pos_162 (list.length.int x))) NotImplemented)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.180: Symbol 'NotImplemented' not declared as a variable")

Could not find any solution for puzzle Dedup:3
Too many constants for extrapolation

Solving puzzle 140/732: Dedup:4
sat_func def sat(ans: List[int], li=[0, 3, 3, 2, 7, 0, 0, 6, 2, 4, 4, 5]):
    return set(ans) == set(li) and all(li.index(ans[i]) < li.index(ans[i + 1]) for i in range(len(ans) - 1))
modified_func def sat(ans: List[int], li=wrap_list([wrap_int(0), wrap_int(3), wrap_int(3), wrap_int(2), wrap_int(7), wrap_int(0), wrap_int(0), wrap_int(6), wrap_int(2), wrap_int(4), wrap_int(4), wrap_int(5)])):
    return (set(ans) == set(li)).__and__(all(sym_generator((li.index(ans[i]) < li.index(ans[i + wrap_int(1)]) for i in sym_range(sym_len(ans) - 1)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (forall ((list_pos_163 Int)) (=> (and (>= list_pos_163 0) (< list_pos_163 (list.length.int x))) NotImplemented)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.180: Symbol 'NotImplemented' not declared as a variable")

Could not find any solution for puzzle Dedup:4
Too many constants for extrapolation

Solving puzzle 141/732: FindExtensions:0
sat_func def sat(extensions: List[str], strings=['cat', 'dog', 'shatter', 'donut', 'at', 'todo'], prefix="do"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
modified_func def sat(extensions: List[str], strings=wrap_list([wrap_str('cat'), wrap_str('dog'), wrap_str('shatter'), wrap_str('donut'), wrap_str('at'), wrap_str('todo')]), prefix=wrap_str('do')):
    i = wrap_int(0)
    for s in strings:
        if s.startswith(prefix):
            _assert(extensions[i] == s)
            i += wrap_int(1)
    return i == sym_len(extensions)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (str.prefixof "do" "cat") (= (list.get.string x 0) "cat")))
(assert (=> (and (str.prefixof "do" "cat") (str.prefixof "do" "dog")) (= (list.get.string x 1) "dog")))
(assert (=> (and (str.prefixof "do" "cat") (str.prefixof "do" "dog") (str.prefixof "do" "shatter")) (= (list.get.string x 2) "shatter")))
(assert (=> (and (str.prefixof "do" "cat") (str.prefixof "do" "dog") (str.prefixof "do" "shatter") (str.prefixof "do" "donut")) (= (list.get.string x 3) "donut")))
(assert (=> (and (str.prefixof "do" "cat") (str.prefixof "do" "dog") (str.prefixof "do" "shatter") (str.prefixof "do" "donut") (str.prefixof "do" "at")) (= (list.get.string x 4) "at")))
(assert (=> (and (str.prefixof "do" "cat") (str.prefixof "do" "dog") (str.prefixof "do" "shatter") (str.prefixof "do" "donut") (str.prefixof "do" "at") (str.prefixof "do" "todo")) (= (list.get.string x 5) "todo")))
(assert (=> (and (str.prefixof "do" "cat") (str.prefixof "do" "dog") (str.prefixof "do" "shatter") (str.prefixof "do" "donut") (str.prefixof "do" "at") (str.prefixof "do" "todo")) (= 6 (list.length.string x))))
(assert (=> (and (not (str.prefixof "do" "cat")) (not (str.prefixof "do" "dog")) (not (str.prefixof "do" "shatter")) (not (str.prefixof "do" "donut")) (not (str.prefixof "do" "at")) (not (str.prefixof "do" "todo"))) (= 0 (list.length.string x))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) (as nil (List String)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle FindExtensions:0
Too many constants for extrapolation

Solving puzzle 142/732: FindExtensions:1
sat_func def sat(extensions: List[str], strings=['cot', 'z'], prefix="ca"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
modified_func def sat(extensions: List[str], strings=wrap_list([wrap_str('cot'), wrap_str('z')]), prefix=wrap_str('ca')):
    i = wrap_int(0)
    for s in strings:
        if s.startswith(prefix):
            _assert(extensions[i] == s)
            i += wrap_int(1)
    return i == sym_len(extensions)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (str.prefixof "ca" "cot") (= (list.get.string x 0) "cot")))
(assert (=> (and (str.prefixof "ca" "cot") (str.prefixof "ca" "z")) (= (list.get.string x 1) "z")))
(assert (=> (and (str.prefixof "ca" "cot") (str.prefixof "ca" "z")) (= 2 (list.length.string x))))
(assert (=> (and (not (str.prefixof "ca" "cot")) (not (str.prefixof "ca" "z"))) (= 0 (list.length.string x))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) (as nil (List String)))
)

Found solution []
Yes! Solved for puzzle  FindExtensions:1

Solving puzzle 143/732: FindExtensions:2
sat_func def sat(extensions: List[str], strings=['jof', 'thibi'], prefix="le"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
modified_func def sat(extensions: List[str], strings=wrap_list([wrap_str('jof'), wrap_str('thibi')]), prefix=wrap_str('le')):
    i = wrap_int(0)
    for s in strings:
        if s.startswith(prefix):
            _assert(extensions[i] == s)
            i += wrap_int(1)
    return i == sym_len(extensions)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (str.prefixof "le" "jof") (= (list.get.string x 0) "jof")))
(assert (=> (and (str.prefixof "le" "jof") (str.prefixof "le" "thibi")) (= (list.get.string x 1) "thibi")))
(assert (=> (and (str.prefixof "le" "jof") (str.prefixof "le" "thibi")) (= 2 (list.length.string x))))
(assert (=> (and (not (str.prefixof "le" "jof")) (not (str.prefixof "le" "thibi"))) (= 0 (list.length.string x))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) (as nil (List String)))
)

Found solution []
Yes! Solved for puzzle  FindExtensions:2

Solving puzzle 144/732: FindExtensions:3
sat_func def sat(extensions: List[str], strings=['t'], prefix="t"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
modified_func def sat(extensions: List[str], strings=wrap_list([wrap_str('t')]), prefix=wrap_str('t')):
    i = wrap_int(0)
    for s in strings:
        if s.startswith(prefix):
            _assert(extensions[i] == s)
            i += wrap_int(1)
    return i == sym_len(extensions)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (str.prefixof "t" "t") (= (list.get.string x 0) "t")))
(assert (=> (str.prefixof "t" "t") (= 1 (list.length.string x))))
(assert (=> (not (str.prefixof "t" "t")) (= 0 (list.length.string x))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "t" (as nil (List String))))
)

Found solution ['t']
Yes! Solved for puzzle  FindExtensions:3

Solving puzzle 145/732: FindExtensions:4
sat_func def sat(extensions: List[str], strings=['cpud', 'cpal', 'cv', 'cchut'], prefix="c"):
    i = 0
    for s in strings:
        if s.startswith(prefix):
            assert extensions[i] == s
            i += 1
    return i == len(extensions)
modified_func def sat(extensions: List[str], strings=wrap_list([wrap_str('cpud'), wrap_str('cpal'), wrap_str('cv'), wrap_str('cchut')]), prefix=wrap_str('c')):
    i = wrap_int(0)
    for s in strings:
        if s.startswith(prefix):
            _assert(extensions[i] == s)
            i += wrap_int(1)
    return i == sym_len(extensions)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (str.prefixof "c" "cpud") (= (list.get.string x 0) "cpud")))
(assert (=> (and (str.prefixof "c" "cpud") (str.prefixof "c" "cpal")) (= (list.get.string x 1) "cpal")))
(assert (=> (and (str.prefixof "c" "cpud") (str.prefixof "c" "cpal") (str.prefixof "c" "cv")) (= (list.get.string x 2) "cv")))
(assert (=> (and (str.prefixof "c" "cpud") (str.prefixof "c" "cpal") (str.prefixof "c" "cv") (str.prefixof "c" "cchut")) (= (list.get.string x 3) "cchut")))
(assert (=> (and (str.prefixof "c" "cpud") (str.prefixof "c" "cpal") (str.prefixof "c" "cv") (str.prefixof "c" "cchut")) (= 4 (list.length.string x))))
(assert (=> (and (not (str.prefixof "c" "cpud")) (not (str.prefixof "c" "cpal")) (not (str.prefixof "c" "cv")) (not (str.prefixof "c" "cchut"))) (= 0 (list.length.string x))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "cpud" ((as cons (List String)) "cpal" ((as cons (List String)) "cv" ((as cons (List String)) "cchut" (as nil (List String)))))))
)

Found solution ['cpud', 'cpal', 'cv', 'cchut']
Yes! Solved for puzzle  FindExtensions:4

Solving puzzle 146/732: FindPositives:0
sat_func def sat(positives: List[int], nums=[2, 2342, -2, 32, -8, -5, 2342, 0, -9, 44, 11]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
modified_func def sat(positives: List[int], nums=wrap_list([wrap_int(2), wrap_int(2342), -wrap_int(2), wrap_int(32), -wrap_int(8), -wrap_int(5), wrap_int(2342), wrap_int(0), -wrap_int(9), wrap_int(44), wrap_int(11)])):
    stack = positives[::-1]
    for n in nums:
        _assert((n <= wrap_int(0)).__or__(n == stack.pop()))
    return stack == wrap_list([])
Exception -- for puzzle FindPositives:0 'SymbolicList' object has no attribute 'pop'

Solving puzzle 147/732: FindPositives:1
sat_func def sat(positives: List[int], nums=[53, 33, 73, 47, 35, 24, 56, 89, 85]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
modified_func def sat(positives: List[int], nums=wrap_list([wrap_int(53), wrap_int(33), wrap_int(73), wrap_int(47), wrap_int(35), wrap_int(24), wrap_int(56), wrap_int(89), wrap_int(85)])):
    stack = positives[::-1]
    for n in nums:
        _assert((n <= wrap_int(0)).__or__(n == stack.pop()))
    return stack == wrap_list([])
Exception -- for puzzle FindPositives:1 'SymbolicList' object has no attribute 'pop'

Solving puzzle 148/732: FindPositives:2
sat_func def sat(positives: List[int], nums=[61, -64, -11, -3, -96, -69, -18, -99, 87]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
modified_func def sat(positives: List[int], nums=wrap_list([wrap_int(61), -wrap_int(64), -wrap_int(11), -wrap_int(3), -wrap_int(96), -wrap_int(69), -wrap_int(18), -wrap_int(99), wrap_int(87)])):
    stack = positives[::-1]
    for n in nums:
        _assert((n <= wrap_int(0)).__or__(n == stack.pop()))
    return stack == wrap_list([])
Exception -- for puzzle FindPositives:2 'SymbolicList' object has no attribute 'pop'

Solving puzzle 149/732: FindPositives:3
sat_func def sat(positives: List[int], nums=[62, 3, -84]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
modified_func def sat(positives: List[int], nums=wrap_list([wrap_int(62), wrap_int(3), -wrap_int(84)])):
    stack = positives[::-1]
    for n in nums:
        _assert((n <= wrap_int(0)).__or__(n == stack.pop()))
    return stack == wrap_list([])
Exception -- for puzzle FindPositives:3 'SymbolicList' object has no attribute 'pop'

Solving puzzle 150/732: FindPositives:4
sat_func def sat(positives: List[int], nums=[]):
    stack = positives[::-1]
    for n in nums:
        assert n <= 0 or n == stack.pop()
    return stack == []
modified_func def sat(positives: List[int], nums=wrap_list([])):
    stack = positives[::-1]
    for n in nums:
        _assert((n <= wrap_int(0)).__or__(n == stack.pop()))
    return stack == wrap_list([])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (= (list.slice.int x 0 -1 -1) (as nil (List Int))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Yes! Solved for puzzle  FindPositives:4

Solving puzzle 151/732: FermatComposites:0
sat_func def sat(certificates: List[int], nums=[1449, 14, 21, 105, 217]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
modified_func def sat(certificates: List[int], nums=wrap_list([wrap_int(1449), wrap_int(14), wrap_int(21), wrap_int(105), wrap_int(217)])):
    return all(sym_generator((pow(cert, n - wrap_int(1), n) > wrap_int(1) for cert, n in sym_zip(certificates, nums)))).__and__(sym_len(certificates) == sym_len(nums))
Exception -- for puzzle FermatComposites:0 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 152/732: FermatComposites:1
sat_func def sat(certificates: List[int], nums=[2299290630, 2051931473, 1592080723, 533977507, 6381433197, 6645010323, 5590359939, 1543343895, 1032597423]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
modified_func def sat(certificates: List[int], nums=wrap_list([wrap_int(2299290630), wrap_int(2051931473), wrap_int(1592080723), wrap_int(533977507), wrap_int(6381433197), wrap_int(6645010323), wrap_int(5590359939), wrap_int(1543343895), wrap_int(1032597423)])):
    return all(sym_generator((pow(cert, n - wrap_int(1), n) > wrap_int(1) for cert, n in sym_zip(certificates, nums)))).__and__(sym_len(certificates) == sym_len(nums))
Exception -- for puzzle FermatComposites:1 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 153/732: FermatComposites:2
sat_func def sat(certificates: List[int], nums=[962036141, 941419353, 5954955179, 5140095171, 3027040707, 6069862645, 591197645, 2485033263]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
modified_func def sat(certificates: List[int], nums=wrap_list([wrap_int(962036141), wrap_int(941419353), wrap_int(5954955179), wrap_int(5140095171), wrap_int(3027040707), wrap_int(6069862645), wrap_int(591197645), wrap_int(2485033263)])):
    return all(sym_generator((pow(cert, n - wrap_int(1), n) > wrap_int(1) for cert, n in sym_zip(certificates, nums)))).__and__(sym_len(certificates) == sym_len(nums))
Exception -- for puzzle FermatComposites:2 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 154/732: FermatComposites:3
sat_func def sat(certificates: List[int], nums=[99210055, 4171577125, 459354525, 1534026075, 4255533095, 2441396441, 155962261]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
modified_func def sat(certificates: List[int], nums=wrap_list([wrap_int(99210055), wrap_int(4171577125), wrap_int(459354525), wrap_int(1534026075), wrap_int(4255533095), wrap_int(2441396441), wrap_int(155962261)])):
    return all(sym_generator((pow(cert, n - wrap_int(1), n) > wrap_int(1) for cert, n in sym_zip(certificates, nums)))).__and__(sym_len(certificates) == sym_len(nums))
Exception -- for puzzle FermatComposites:3 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 155/732: FermatComposites:4
sat_func def sat(certificates: List[int], nums=[2629304451, 4885026075, 2283948525, 4145214425]):
    return all(pow(cert, n - 1, n) > 1 for cert, n in zip(certificates, nums)) and len(certificates) == len(nums)
modified_func def sat(certificates: List[int], nums=wrap_list([wrap_int(2629304451), wrap_int(4885026075), wrap_int(2283948525), wrap_int(4145214425)])):
    return all(sym_generator((pow(cert, n - wrap_int(1), n) > wrap_int(1) for cert, n in sym_zip(certificates, nums)))).__and__(sym_len(certificates) == sym_len(nums))
Exception -- for puzzle FermatComposites:4 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 156/732: TwoThirdsSorted:0
sat_func def sat(li: List[int], orig=[1, -2, 3, 17, 8, 4, 12, 3, 18, 5, -29, 0, 0]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
modified_func def sat(li: List[int], orig=wrap_list([wrap_int(1), -wrap_int(2), wrap_int(3), wrap_int(17), wrap_int(8), wrap_int(4), wrap_int(12), wrap_int(3), wrap_int(18), wrap_int(5), -wrap_int(29), wrap_int(0), wrap_int(0)])):
    _assert(orig[::3] == li[::3], wrap_str('Keep every third entry fixed'))
    _assert(sym_sorted(li) == sym_sorted(orig), wrap_str('Not even a permutation'))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(1)] for i in sym_range(1, sym_len(li) - 1, 3)))))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(2)] for i in sym_range(2, sym_len(li) - 2, 3)))))
    return True
Exception -- for puzzle TwoThirdsSorted:0 Cannot convert symbolic integer to index

Solving puzzle 157/732: TwoThirdsSorted:1
sat_func def sat(li: List[int], orig=[-10, 9, 0, -6, 0, -7, -2, 4, 8, 2, 3, -9, -8, 9, -4, -4]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
modified_func def sat(li: List[int], orig=wrap_list([-wrap_int(10), wrap_int(9), wrap_int(0), -wrap_int(6), wrap_int(0), -wrap_int(7), -wrap_int(2), wrap_int(4), wrap_int(8), wrap_int(2), wrap_int(3), -wrap_int(9), -wrap_int(8), wrap_int(9), -wrap_int(4), -wrap_int(4)])):
    _assert(orig[::3] == li[::3], wrap_str('Keep every third entry fixed'))
    _assert(sym_sorted(li) == sym_sorted(orig), wrap_str('Not even a permutation'))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(1)] for i in sym_range(1, sym_len(li) - 1, 3)))))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(2)] for i in sym_range(2, sym_len(li) - 2, 3)))))
    return True
Exception -- for puzzle TwoThirdsSorted:1 Cannot convert symbolic integer to index

Solving puzzle 158/732: TwoThirdsSorted:2
sat_func def sat(li: List[int], orig=[0, 7, -3, -3, 2, 2, 5, -9, -9]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
modified_func def sat(li: List[int], orig=wrap_list([wrap_int(0), wrap_int(7), -wrap_int(3), -wrap_int(3), wrap_int(2), wrap_int(2), wrap_int(5), -wrap_int(9), -wrap_int(9)])):
    _assert(orig[::3] == li[::3], wrap_str('Keep every third entry fixed'))
    _assert(sym_sorted(li) == sym_sorted(orig), wrap_str('Not even a permutation'))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(1)] for i in sym_range(1, sym_len(li) - 1, 3)))))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(2)] for i in sym_range(2, sym_len(li) - 2, 3)))))
    return True
Exception -- for puzzle TwoThirdsSorted:2 Cannot convert symbolic integer to index

Solving puzzle 159/732: TwoThirdsSorted:3
sat_func def sat(li: List[int], orig=[-1, -1, 0, 6, 3, -1, 4, -1, 1, 9, -4, -1, 6, 4, -7, -4, 1]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
modified_func def sat(li: List[int], orig=wrap_list([-wrap_int(1), -wrap_int(1), wrap_int(0), wrap_int(6), wrap_int(3), -wrap_int(1), wrap_int(4), -wrap_int(1), wrap_int(1), wrap_int(9), -wrap_int(4), -wrap_int(1), wrap_int(6), wrap_int(4), -wrap_int(7), -wrap_int(4), wrap_int(1)])):
    _assert(orig[::3] == li[::3], wrap_str('Keep every third entry fixed'))
    _assert(sym_sorted(li) == sym_sorted(orig), wrap_str('Not even a permutation'))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(1)] for i in sym_range(1, sym_len(li) - 1, 3)))))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(2)] for i in sym_range(2, sym_len(li) - 2, 3)))))
    return True
Exception -- for puzzle TwoThirdsSorted:3 Cannot convert symbolic integer to index

Solving puzzle 160/732: TwoThirdsSorted:4
sat_func def sat(li: List[int], orig=[]):
    assert orig[::3] == li[::3], "Keep every third entry fixed"
    assert sorted(li) == sorted(orig), "Not even a permutation"
    assert all(li[i] <= li[i + 1] for i in range(1, len(li) - 1, 3))
    assert all(li[i] <= li[i + 2] for i in range(2, len(li) - 2, 3))
    return True
modified_func def sat(li: List[int], orig=wrap_list([])):
    _assert(orig[::3] == li[::3], wrap_str('Keep every third entry fixed'))
    _assert(sym_sorted(li) == sym_sorted(orig), wrap_str('Not even a permutation'))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(1)] for i in sym_range(1, sym_len(li) - 1, 3)))))
    _assert(all(sym_generator((li[i] <= li[i + wrap_int(2)] for i in sym_range(2, sym_len(li) - 2, 3)))))
    return True
Exception -- for puzzle TwoThirdsSorted:4 Cannot convert symbolic integer to index

Solving puzzle 161/732: UniqueSorted:0
sat_func def sat(li: List[int], orig=[1, 1, 3, 2, 0, 8, 32, -4, 0]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
modified_func def sat(li: List[int], orig=wrap_list([wrap_int(1), wrap_int(1), wrap_int(3), wrap_int(2), wrap_int(0), wrap_int(8), wrap_int(32), -wrap_int(4), wrap_int(0)])):
    for i in sym_range(sym_len(li) - 1):
        _assert(li[i] < li[i + wrap_int(1)])
        _assert(sym_in(li[i], orig))
    for n in orig:
        _assert(sym_in(n, li))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (< (list.get.int x i_0) (list.get.int x (+ i_0 1))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (or (= (list.get.int x i_0) 1) (= (list.get.int x i_0) 1) (= (list.get.int x i_0) 3) (= (list.get.int x i_0) 2) (= (list.get.int x i_0) 0) (= (list.get.int x i_0) 8) (= (list.get.int x i_0) 32) (= (list.get.int x i_0) -4) (= (list.get.int x i_0) 0)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 1))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 1))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 3))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 2))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 8))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 32))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -4))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UniqueSorted:0
Too many constants for extrapolation

Solving puzzle 162/732: UniqueSorted:1
sat_func def sat(li: List[int], orig=[-9, 1, -5, 6, -1, 3, 5, 8, -10, -2, 3, -9, -10]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
modified_func def sat(li: List[int], orig=wrap_list([-wrap_int(9), wrap_int(1), -wrap_int(5), wrap_int(6), -wrap_int(1), wrap_int(3), wrap_int(5), wrap_int(8), -wrap_int(10), -wrap_int(2), wrap_int(3), -wrap_int(9), -wrap_int(10)])):
    for i in sym_range(sym_len(li) - 1):
        _assert(li[i] < li[i + wrap_int(1)])
        _assert(sym_in(li[i], orig))
    for n in orig:
        _assert(sym_in(n, li))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (< (list.get.int x i_0) (list.get.int x (+ i_0 1))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (or (= (list.get.int x i_0) -9) (= (list.get.int x i_0) 1) (= (list.get.int x i_0) -5) (= (list.get.int x i_0) 6) (= (list.get.int x i_0) -1) (= (list.get.int x i_0) 3) (= (list.get.int x i_0) 5) (= (list.get.int x i_0) 8) (= (list.get.int x i_0) -10) (= (list.get.int x i_0) -2) (= (list.get.int x i_0) 3) (= (list.get.int x i_0) -9) (= (list.get.int x i_0) -10)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -9))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 1))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 6))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -1))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 3))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 8))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -10))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -2))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 3))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -9))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -10))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UniqueSorted:1
Too many constants for extrapolation

Solving puzzle 163/732: UniqueSorted:2
sat_func def sat(li: List[int], orig=[-3, 7, 9, -10, -10, 5, 2, 8]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
modified_func def sat(li: List[int], orig=wrap_list([-wrap_int(3), wrap_int(7), wrap_int(9), -wrap_int(10), -wrap_int(10), wrap_int(5), wrap_int(2), wrap_int(8)])):
    for i in sym_range(sym_len(li) - 1):
        _assert(li[i] < li[i + wrap_int(1)])
        _assert(sym_in(li[i], orig))
    for n in orig:
        _assert(sym_in(n, li))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (< (list.get.int x i_0) (list.get.int x (+ i_0 1))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (or (= (list.get.int x i_0) -3) (= (list.get.int x i_0) 7) (= (list.get.int x i_0) 9) (= (list.get.int x i_0) -10) (= (list.get.int x i_0) -10) (= (list.get.int x i_0) 5) (= (list.get.int x i_0) 2) (= (list.get.int x i_0) 8)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -3))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 7))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 9))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -10))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -10))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 2))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 8))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UniqueSorted:2
Too many constants for extrapolation

Solving puzzle 164/732: UniqueSorted:3
sat_func def sat(li: List[int], orig=[-6]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
modified_func def sat(li: List[int], orig=wrap_list([-wrap_int(6)])):
    for i in sym_range(sym_len(li) - 1):
        _assert(li[i] < li[i + wrap_int(1)])
        _assert(sym_in(li[i], orig))
    for n in orig:
        _assert(sym_in(n, li))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (< (list.get.int x i_0) (list.get.int x (+ i_0 1))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x i_0) -6))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -6))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UniqueSorted:3
Too many constants for extrapolation

Solving puzzle 165/732: UniqueSorted:4
sat_func def sat(li: List[int], orig=[1, -5, 6, 2, -7, -6, 5, -5, 3, 7, 4, -10, -2, 3, 7, 9, -3, 8, 7]):
    for i in range(len(li) - 1):
        assert li[i] < li[i + 1]
        assert li[i] in orig
    for n in orig:
        assert n in li
    return True
modified_func def sat(li: List[int], orig=wrap_list([wrap_int(1), -wrap_int(5), wrap_int(6), wrap_int(2), -wrap_int(7), -wrap_int(6), wrap_int(5), -wrap_int(5), wrap_int(3), wrap_int(7), wrap_int(4), -wrap_int(10), -wrap_int(2), wrap_int(3), wrap_int(7), wrap_int(9), -wrap_int(3), wrap_int(8), wrap_int(7)])):
    for i in sym_range(sym_len(li) - 1):
        _assert(li[i] < li[i + wrap_int(1)])
        _assert(sym_in(li[i], orig))
    for n in orig:
        _assert(sym_in(n, li))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (< (list.get.int x i_0) (list.get.int x (+ i_0 1))))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (or (= (list.get.int x i_0) 1) (= (list.get.int x i_0) -5) (= (list.get.int x i_0) 6) (= (list.get.int x i_0) 2) (= (list.get.int x i_0) -7) (= (list.get.int x i_0) -6) (= (list.get.int x i_0) 5) (= (list.get.int x i_0) -5) (= (list.get.int x i_0) 3) (= (list.get.int x i_0) 7) (= (list.get.int x i_0) 4) (= (list.get.int x i_0) -10) (= (list.get.int x i_0) -2) (= (list.get.int x i_0) 3) (= (list.get.int x i_0) 7) (= (list.get.int x i_0) 9) (= (list.get.int x i_0) -3) (= (list.get.int x i_0) 8) (= (list.get.int x i_0) 7)))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 1))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 6))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 2))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -7))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -6))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -5))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 3))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 7))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 4))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -10))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -2))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 3))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 7))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 9))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x -3))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 8))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (list.contains.int x 7))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UniqueSorted:4
Too many constants for extrapolation

Solving puzzle 166/732: HalfSorted:0
sat_func def sat(li: List[int], orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 19521]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
modified_func def sat(li: List[int], orig=wrap_list([wrap_int(1), wrap_int(6), wrap_int(3), wrap_int(41), wrap_int(19), wrap_int(4), wrap_int(12), wrap_int(3), wrap_int(18), wrap_int(5), -wrap_int(29), wrap_int(0), wrap_int(19521)])):
    return (orig[1::2] == li[1::2]).__and__(li[::2] == sym_sorted(orig[::2]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (cons 6 (cons 41 (cons 4 (cons 3 (cons 5 (cons 0 (as nil (List Int)))))))) (list.slice.int x 1 -1 2)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle HalfSorted:0
One large constant for extrapolation
Solving simpler variation replaced 19521 with 3
sat_func def sat(li: List[int], orig=[1, 6, 3, 41, 19, 4, 12, 3, 18, 5, -29, 0, 3]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
modified_func def sat(li: List[int], orig=wrap_list([wrap_int(1), wrap_int(6), wrap_int(3), wrap_int(41), wrap_int(19), wrap_int(4), wrap_int(12), wrap_int(3), wrap_int(18), wrap_int(5), -wrap_int(29), wrap_int(0), wrap_int(3)])):
    return (orig[1::2] == li[1::2]).__and__(li[::2] == sym_sorted(orig[::2]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (cons 6 (cons 41 (cons 4 (cons 3 (cons 5 (cons 0 (as nil (List Int)))))))) (list.slice.int x 1 -1 2)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle HalfSorted:0

Solving puzzle 167/732: HalfSorted:1
sat_func def sat(li: List[int], orig=[-1, -9, 7, 8, -8, 2, -7]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
modified_func def sat(li: List[int], orig=wrap_list([-wrap_int(1), -wrap_int(9), wrap_int(7), wrap_int(8), -wrap_int(8), wrap_int(2), -wrap_int(7)])):
    return (orig[1::2] == li[1::2]).__and__(li[::2] == sym_sorted(orig[::2]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (cons -9 (cons 8 (cons 2 (as nil (List Int))))) (list.slice.int x 1 -1 2)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle HalfSorted:1
Too many constants for extrapolation

Solving puzzle 168/732: HalfSorted:2
sat_func def sat(li: List[int], orig=[4, -3, -8]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
modified_func def sat(li: List[int], orig=wrap_list([wrap_int(4), -wrap_int(3), -wrap_int(8)])):
    return (orig[1::2] == li[1::2]).__and__(li[::2] == sym_sorted(orig[::2]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (cons -3 (as nil (List Int))) (list.slice.int x 1 -1 2)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle HalfSorted:2
Too many constants for extrapolation

Solving puzzle 169/732: HalfSorted:3
sat_func def sat(li: List[int], orig=[3, 6, -7, 1, 2, -10, 6, -8, -9, -9, 6, -7, 7, -6, 1, 4, -8, -1, 8]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
modified_func def sat(li: List[int], orig=wrap_list([wrap_int(3), wrap_int(6), -wrap_int(7), wrap_int(1), wrap_int(2), -wrap_int(10), wrap_int(6), -wrap_int(8), -wrap_int(9), -wrap_int(9), wrap_int(6), -wrap_int(7), wrap_int(7), -wrap_int(6), wrap_int(1), wrap_int(4), -wrap_int(8), -wrap_int(1), wrap_int(8)])):
    return (orig[1::2] == li[1::2]).__and__(li[::2] == sym_sorted(orig[::2]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (cons 6 (cons 1 (cons -10 (cons -8 (cons -9 (cons -7 (cons -6 (cons 4 (cons -1 (as nil (List Int))))))))))) (list.slice.int x 1 -1 2)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle HalfSorted:3
Too many constants for extrapolation

Solving puzzle 170/732: HalfSorted:4
sat_func def sat(li: List[int], orig=[-7, 6, 8, 8, -3, -5, -6, -5, 6, 7, 5, 7, -9, 9, -7, 4, -8, 8, -9]):
    return orig[1::2] == li[1::2] and li[::2] == sorted(orig[::2])
modified_func def sat(li: List[int], orig=wrap_list([-wrap_int(7), wrap_int(6), wrap_int(8), wrap_int(8), -wrap_int(3), -wrap_int(5), -wrap_int(6), -wrap_int(5), wrap_int(6), wrap_int(7), wrap_int(5), wrap_int(7), -wrap_int(9), wrap_int(9), -wrap_int(7), wrap_int(4), -wrap_int(8), wrap_int(8), -wrap_int(9)])):
    return (orig[1::2] == li[1::2]).__and__(li[::2] == sym_sorted(orig[::2]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (and (= (cons 6 (cons 8 (cons -5 (cons -5 (cons 7 (cons 7 (cons 9 (cons 4 (cons 8 (as nil (List Int))))))))))) (list.slice.int x 1 -1 2)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle HalfSorted:4
Too many constants for extrapolation

Solving puzzle 171/732: TripleZeroSum:0
sat_func def sat(inds: List[int], nums=[12, 6, 41, 15, -10452, 18242, 10440, 6, 6, 6, 6]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
modified_func def sat(inds: List[int], nums=wrap_list([wrap_int(12), wrap_int(6), wrap_int(41), wrap_int(15), -wrap_int(10452), wrap_int(18242), wrap_int(10440), wrap_int(6), wrap_int(6), wrap_int(6), wrap_int(6)])):
    return (sym_len(inds) == wrap_int(3)).__and__(sym_sum(sym_generator((nums[i] for i in inds))) == wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_164 Int)) (=> (and (>= list_pos_164 0) (< list_pos_164 (list.length.int x))) (< (list.get.int x list_pos_164) 11))))
(assert (forall ((list_pos_164 Int)) (=> (and (>= list_pos_164 0) (< list_pos_164 (list.length.int x))) (>= (list.get.int x list_pos_164) -11))))
(assert (forall ((list_pos_164 Int)) (=> (and (>= list_pos_164 0) (< list_pos_164 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (ite (or (= (list.get.int x list_pos_164) 10) (= (list.get.int x list_pos_164) -1)) 6 (ite (or (= (list.get.int x list_pos_164) 9) (= (list.get.int x list_pos_164) -2)) 6 (ite (or (= (list.get.int x list_pos_164) 8) (= (list.get.int x list_pos_164) -3)) 6 (ite (or (= (list.get.int x list_pos_164) 7) (= (list.get.int x list_pos_164) -4)) 6 (ite (or (= (list.get.int x list_pos_164) 6) (= (list.get.int x list_pos_164) -5)) 10440 (ite (or (= (list.get.int x list_pos_164) 5) (= (list.get.int x list_pos_164) -6)) 18242 (ite (or (= (list.get.int x list_pos_164) 4) (= (list.get.int x list_pos_164) -7)) -10452 (ite (or (= (list.get.int x list_pos_164) 3) (= (list.get.int x list_pos_164) -8)) 15 (ite (or (= (list.get.int x list_pos_164) 2) (= (list.get.int x list_pos_164) -9)) 41 (ite (or (= (list.get.int x list_pos_164) 1) (= (list.get.int x list_pos_164) ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle TripleZeroSum:0
Too many constants for extrapolation

Solving puzzle 172/732: TripleZeroSum:1
sat_func def sat(inds: List[int], nums=[-52, -16, 68, -27, 3]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
modified_func def sat(inds: List[int], nums=wrap_list([-wrap_int(52), -wrap_int(16), wrap_int(68), -wrap_int(27), wrap_int(3)])):
    return (sym_len(inds) == wrap_int(3)).__and__(sym_sum(sym_generator((nums[i] for i in inds))) == wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_165 Int)) (=> (and (>= list_pos_165 0) (< list_pos_165 (list.length.int x))) (< (list.get.int x list_pos_165) 5))))
(assert (forall ((list_pos_165 Int)) (=> (and (>= list_pos_165 0) (< list_pos_165 (list.length.int x))) (>= (list.get.int x list_pos_165) -5))))
(assert (forall ((list_pos_165 Int)) (=> (and (>= list_pos_165 0) (< list_pos_165 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (ite (or (= (list.get.int x list_pos_165) 4) (= (list.get.int x list_pos_165) -1)) 3 (ite (or (= (list.get.int x list_pos_165) 3) (= (list.get.int x list_pos_165) -2)) -27 (ite (or (= (list.get.int x list_pos_165) 2) (= (list.get.int x list_pos_165) -3)) 68 (ite (or (= (list.get.int x list_pos_165) 1) (= (list.get.int x list_pos_165) -4)) -16 -52)))) 0) 0)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle TripleZeroSum:1
Too many constants for extrapolation

Solving puzzle 173/732: TripleZeroSum:2
sat_func def sat(inds: List[int], nums=[-64, -74, -18, -57, 89, -14, -25, 11, -60, -78]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
modified_func def sat(inds: List[int], nums=wrap_list([-wrap_int(64), -wrap_int(74), -wrap_int(18), -wrap_int(57), wrap_int(89), -wrap_int(14), -wrap_int(25), wrap_int(11), -wrap_int(60), -wrap_int(78)])):
    return (sym_len(inds) == wrap_int(3)).__and__(sym_sum(sym_generator((nums[i] for i in inds))) == wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_166 Int)) (=> (and (>= list_pos_166 0) (< list_pos_166 (list.length.int x))) (< (list.get.int x list_pos_166) 10))))
(assert (forall ((list_pos_166 Int)) (=> (and (>= list_pos_166 0) (< list_pos_166 (list.length.int x))) (>= (list.get.int x list_pos_166) -10))))
(assert (forall ((list_pos_166 Int)) (=> (and (>= list_pos_166 0) (< list_pos_166 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (ite (or (= (list.get.int x list_pos_166) 9) (= (list.get.int x list_pos_166) -1)) -78 (ite (or (= (list.get.int x list_pos_166) 8) (= (list.get.int x list_pos_166) -2)) -60 (ite (or (= (list.get.int x list_pos_166) 7) (= (list.get.int x list_pos_166) -3)) 11 (ite (or (= (list.get.int x list_pos_166) 6) (= (list.get.int x list_pos_166) -4)) -25 (ite (or (= (list.get.int x list_pos_166) 5) (= (list.get.int x list_pos_166) -5)) -14 (ite (or (= (list.get.int x list_pos_166) 4) (= (list.get.int x list_pos_166) -6)) 89 (ite (or (= (list.get.int x list_pos_166) 3) (= (list.get.int x list_pos_166) -7)) -57 (ite (or (= (list.get.int x list_pos_166) 2) (= (list.get.int x list_pos_166) -8)) -18 (ite (or (= (list.get.int x list_pos_166) 1) (= (list.get.int x list_pos_166) -9)) -74 -64))))))))) 0) 0)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle TripleZeroSum:2
Too many constants for extrapolation

Solving puzzle 174/732: TripleZeroSum:3
sat_func def sat(inds: List[int], nums=[-90, 63, 70, 21, 42, 20]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
modified_func def sat(inds: List[int], nums=wrap_list([-wrap_int(90), wrap_int(63), wrap_int(70), wrap_int(21), wrap_int(42), wrap_int(20)])):
    return (sym_len(inds) == wrap_int(3)).__and__(sym_sum(sym_generator((nums[i] for i in inds))) == wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_167 Int)) (=> (and (>= list_pos_167 0) (< list_pos_167 (list.length.int x))) (< (list.get.int x list_pos_167) 6))))
(assert (forall ((list_pos_167 Int)) (=> (and (>= list_pos_167 0) (< list_pos_167 (list.length.int x))) (>= (list.get.int x list_pos_167) -6))))
(assert (forall ((list_pos_167 Int)) (=> (and (>= list_pos_167 0) (< list_pos_167 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (ite (or (= (list.get.int x list_pos_167) 5) (= (list.get.int x list_pos_167) -1)) 20 (ite (or (= (list.get.int x list_pos_167) 4) (= (list.get.int x list_pos_167) -2)) 42 (ite (or (= (list.get.int x list_pos_167) 3) (= (list.get.int x list_pos_167) -3)) 21 (ite (or (= (list.get.int x list_pos_167) 2) (= (list.get.int x list_pos_167) -4)) 70 (ite (or (= (list.get.int x list_pos_167) 1) (= (list.get.int x list_pos_167) -5)) 63 -90))))) 0) 0)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle TripleZeroSum:3
Too many constants for extrapolation

Solving puzzle 175/732: TripleZeroSum:4
sat_func def sat(inds: List[int], nums=[-14, 65, -7, -75, 54, 78, -61, 136, -85, 44]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
modified_func def sat(inds: List[int], nums=wrap_list([-wrap_int(14), wrap_int(65), -wrap_int(7), -wrap_int(75), wrap_int(54), wrap_int(78), -wrap_int(61), wrap_int(136), -wrap_int(85), wrap_int(44)])):
    return (sym_len(inds) == wrap_int(3)).__and__(sym_sum(sym_generator((nums[i] for i in inds))) == wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_168 Int)) (=> (and (>= list_pos_168 0) (< list_pos_168 (list.length.int x))) (< (list.get.int x list_pos_168) 10))))
(assert (forall ((list_pos_168 Int)) (=> (and (>= list_pos_168 0) (< list_pos_168 (list.length.int x))) (>= (list.get.int x list_pos_168) -10))))
(assert (forall ((list_pos_168 Int)) (=> (and (>= list_pos_168 0) (< list_pos_168 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (ite (or (= (list.get.int x list_pos_168) 9) (= (list.get.int x list_pos_168) -1)) 44 (ite (or (= (list.get.int x list_pos_168) 8) (= (list.get.int x list_pos_168) -2)) -85 (ite (or (= (list.get.int x list_pos_168) 7) (= (list.get.int x list_pos_168) -3)) 136 (ite (or (= (list.get.int x list_pos_168) 6) (= (list.get.int x list_pos_168) -4)) -61 (ite (or (= (list.get.int x list_pos_168) 5) (= (list.get.int x list_pos_168) -5)) 78 (ite (or (= (list.get.int x list_pos_168) 4) (= (list.get.int x list_pos_168) -6)) 54 (ite (or (= (list.get.int x list_pos_168) 3) (= (list.get.int x list_pos_168) -7)) -75 (ite (or (= (list.get.int x list_pos_168) 2) (= (list.get.int x list_pos_168) -8)) -7 (ite (or (= (list.get.int x list_pos_168) 1) (= (list.get.int x list_pos_168) -9)) 65 -14))))))))) 0) 0)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle TripleZeroSum:4
One large constant for extrapolation
Solving simpler variation replaced 136 with 3
sat_func def sat(inds: List[int], nums=[-14, 65, -7, -75, 54, 78, -61, 3, -85, 44]):
    return len(inds) == 3 and sum(nums[i] for i in inds) == 0
modified_func def sat(inds: List[int], nums=wrap_list([-wrap_int(14), wrap_int(65), -wrap_int(7), -wrap_int(75), wrap_int(54), wrap_int(78), -wrap_int(61), wrap_int(3), -wrap_int(85), wrap_int(44)])):
    return (sym_len(inds) == wrap_int(3)).__and__(sym_sum(sym_generator((nums[i] for i in inds))) == wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_169 Int)) (=> (and (>= list_pos_169 0) (< list_pos_169 (list.length.int x))) (< (list.get.int x list_pos_169) 10))))
(assert (forall ((list_pos_169 Int)) (=> (and (>= list_pos_169 0) (< list_pos_169 (list.length.int x))) (>= (list.get.int x list_pos_169) -10))))
(assert (forall ((list_pos_169 Int)) (=> (and (>= list_pos_169 0) (< list_pos_169 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (ite (or (= (list.get.int x list_pos_169) 9) (= (list.get.int x list_pos_169) -1)) 44 (ite (or (= (list.get.int x list_pos_169) 8) (= (list.get.int x list_pos_169) -2)) -85 (ite (or (= (list.get.int x list_pos_169) 7) (= (list.get.int x list_pos_169) -3)) 3 (ite (or (= (list.get.int x list_pos_169) 6) (= (list.get.int x list_pos_169) -4)) -61 (ite (or (= (list.get.int x list_pos_169) 5) (= (list.get.int x list_pos_169) -5)) 78 (ite (or (= (list.get.int x list_pos_169) 4) (= (list.get.int x list_pos_169) -6)) 54 (ite (or (= (list.get.int x list_pos_169) 3) (= (list.get.int x list_pos_169) -7)) -75 (ite (or (= (list.get.int x list_pos_169) 2) (= (list.get.int x list_pos_169) -8)) -7 (ite (or (= (list.get.int x list_pos_169) 1) (= (list.get.int x list_pos_169) -9)) 65 -14))))))))) 0) 0)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle TripleZeroSum:4

Solving puzzle 176/732: ListInc:0
sat_func def sat(new_list: List[int], old_list=[321, 12, 532, 129, 9, -12, 4, 56, 90, 0]):
    return [i - 1 for i in new_list] == old_list
modified_func def sat(new_list: List[int], old_list=wrap_list([wrap_int(321), wrap_int(12), wrap_int(532), wrap_int(129), wrap_int(9), -wrap_int(12), wrap_int(4), wrap_int(56), wrap_int(90), wrap_int(0)])):
    return [i - wrap_int(1) for i in new_list] == old_list
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_170 Int)) (=> (and (>= list_pos_170 0) (< list_pos_170 (list.length.int x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListInc:0
Too many constants for extrapolation

Solving puzzle 177/732: ListInc:1
sat_func def sat(new_list: List[int], old_list=[18, 29, 40]):
    return [i - 1 for i in new_list] == old_list
modified_func def sat(new_list: List[int], old_list=wrap_list([wrap_int(18), wrap_int(29), wrap_int(40)])):
    return [i - wrap_int(1) for i in new_list] == old_list
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_171 Int)) (=> (and (>= list_pos_171 0) (< list_pos_171 (list.length.int x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListInc:1
Too many constants for extrapolation

Solving puzzle 178/732: ListInc:2
sat_func def sat(new_list: List[int], old_list=[43, 64, 73, 30, 47]):
    return [i - 1 for i in new_list] == old_list
modified_func def sat(new_list: List[int], old_list=wrap_list([wrap_int(43), wrap_int(64), wrap_int(73), wrap_int(30), wrap_int(47)])):
    return [i - wrap_int(1) for i in new_list] == old_list
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_172 Int)) (=> (and (>= list_pos_172 0) (< list_pos_172 (list.length.int x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListInc:2
Too many constants for extrapolation

Solving puzzle 179/732: ListInc:3
sat_func def sat(new_list: List[int], old_list=[43, 9, 49, 93, 36, 47, 48, 38, 12]):
    return [i - 1 for i in new_list] == old_list
modified_func def sat(new_list: List[int], old_list=wrap_list([wrap_int(43), wrap_int(9), wrap_int(49), wrap_int(93), wrap_int(36), wrap_int(47), wrap_int(48), wrap_int(38), wrap_int(12)])):
    return [i - wrap_int(1) for i in new_list] == old_list
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_173 Int)) (=> (and (>= list_pos_173 0) (< list_pos_173 (list.length.int x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListInc:3
Too many constants for extrapolation

Solving puzzle 180/732: ListInc:4
sat_func def sat(new_list: List[int], old_list=[45, 55, 71, 78, 54]):
    return [i - 1 for i in new_list] == old_list
modified_func def sat(new_list: List[int], old_list=wrap_list([wrap_int(45), wrap_int(55), wrap_int(71), wrap_int(78), wrap_int(54)])):
    return [i - wrap_int(1) for i in new_list] == old_list
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_174 Int)) (=> (and (>= list_pos_174 0) (< list_pos_174 (list.length.int x))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListInc:4
Too many constants for extrapolation

Solving puzzle 181/732: PairZeroSum:0
sat_func def sat(inds: List[int], nums=[12, -10452, 18242, 10440, 81, 241, 525, -18242, 91, 20]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
modified_func def sat(inds: List[int], nums=wrap_list([wrap_int(12), -wrap_int(10452), wrap_int(18242), wrap_int(10440), wrap_int(81), wrap_int(241), wrap_int(525), -wrap_int(18242), wrap_int(91), wrap_int(20)])):
    a, b = inds
    return (nums[a] + nums[b] == wrap_int(0)).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0))
Exception -- for puzzle PairZeroSum:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 182/732: PairZeroSum:1
sat_func def sat(inds: List[int], nums=[50, 33, 12, -13, 65, -39, -12, -72, -61, -38, -58, -88, 70, -82, -80, 27, 68, 89, -57, 15, -33, 93, 57, -91, 60, -72, -19, -12, 70, -35, 53, -21, -19, 66, 58, 76, -92, 64, 52, -21, 29, -61, -10, 50, -88, 17, 0, -50, 52, -87, 9, -95, 59, 23, 69, -34, 73, -39, 15, 17, 37, -83, -31, 13, -33, 6, -27, -45, -15, -78, 74, 92, 56, -52, 44, -9, -22, 27, -94, -17, 5, -82, -40, 22, -91, 10, 57, 13, -41, -93, -40, -42, 28, -3, 82]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
modified_func def sat(inds: List[int], nums=wrap_list([wrap_int(50), wrap_int(33), wrap_int(12), -wrap_int(13), wrap_int(65), -wrap_int(39), -wrap_int(12), -wrap_int(72), -wrap_int(61), -wrap_int(38), -wrap_int(58), -wrap_int(88), wrap_int(70), -wrap_int(82), -wrap_int(80), wrap_int(27), wrap_int(68), wrap_int(89), -wrap_int(57), wrap_int(15), -wrap_int(33), wrap_int(93), wrap_int(57), -wrap_int(91), wrap_int(60), -wrap_int(72), -wrap_int(19), -wrap_int(12), wrap_int(70), -wrap_int(35), wrap_int(53), -wrap_int(21), -wrap_int(19), wrap_int(66), wrap_int(58), wrap_int(76), -wrap_int(92), wrap_int(64), wrap_int(52), -wrap_int(21), wrap_int(29), -wrap_int(61), -wrap_int(10), wrap_int(50), -wrap_int(88), wrap_int(17), wrap_int(0), -wrap_int(50), wrap_int(52), -wrap_int(87), wrap_int(9), -wrap_int(95), wrap_int(59), wrap_int(23), wrap_int(69), -wrap_int(34), wrap_int(73), -wrap_int(39), wrap_int(15), wrap_int(17), wrap_int(37), -wrap_int(83), -wrap_int(31), wrap_int(13), -wrap_int(33), wrap_int(6), -wrap_int(27), -wrap_int(45), -wrap_int(15), -wrap_int(78), wrap_int(74), wrap_int(92), wrap_int(56), -wrap_int(52), wrap_int(44), -wrap_int(9), -wrap_int(22), wrap_int(27), -wrap_int(94), -wrap_int(17), wrap_int(5), -wrap_int(82), -wrap_int(40), wrap_int(22), -wrap_int(91), wrap_int(10), wrap_int(57), wrap_int(13), -wrap_int(41), -wrap_int(93), -wrap_int(40), -wrap_int(42), wrap_int(28), -wrap_int(3), wrap_int(82)])):
    a, b = inds
    return (nums[a] + nums[b] == wrap_int(0)).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0))
Exception -- for puzzle PairZeroSum:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 183/732: PairZeroSum:2
sat_func def sat(inds: List[int], nums=[18, -81, 7, -48, -14, 88, -34, 29, 72, 16, 38, -29, 53, -52, 16, 31, 65, 1, -77, 24, -73, 8, 78, -13, -96, 29, -3, 45, -44, 98, 9, -89, -50, 46, -88, 89, -93, 98, -83, -3, -17, 72, 25, 18, 88, -32, -37, -26, 69, -39, 62, 64, 41, 58, 29, 33, -65, -13, 61, 41, -90, -79, -94, -81, 40, 46, -78, -13, -44, 9, 42, -90, 94, -19, 5, -33, 33, -60, 80, -40, -64, 19, -92, 62, -12, -58, 89, -50, -82, -32, 65, 82, -49, 80, -71, 68, -17, 26, 6, -61]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
modified_func def sat(inds: List[int], nums=wrap_list([wrap_int(18), -wrap_int(81), wrap_int(7), -wrap_int(48), -wrap_int(14), wrap_int(88), -wrap_int(34), wrap_int(29), wrap_int(72), wrap_int(16), wrap_int(38), -wrap_int(29), wrap_int(53), -wrap_int(52), wrap_int(16), wrap_int(31), wrap_int(65), wrap_int(1), -wrap_int(77), wrap_int(24), -wrap_int(73), wrap_int(8), wrap_int(78), -wrap_int(13), -wrap_int(96), wrap_int(29), -wrap_int(3), wrap_int(45), -wrap_int(44), wrap_int(98), wrap_int(9), -wrap_int(89), -wrap_int(50), wrap_int(46), -wrap_int(88), wrap_int(89), -wrap_int(93), wrap_int(98), -wrap_int(83), -wrap_int(3), -wrap_int(17), wrap_int(72), wrap_int(25), wrap_int(18), wrap_int(88), -wrap_int(32), -wrap_int(37), -wrap_int(26), wrap_int(69), -wrap_int(39), wrap_int(62), wrap_int(64), wrap_int(41), wrap_int(58), wrap_int(29), wrap_int(33), -wrap_int(65), -wrap_int(13), wrap_int(61), wrap_int(41), -wrap_int(90), -wrap_int(79), -wrap_int(94), -wrap_int(81), wrap_int(40), wrap_int(46), -wrap_int(78), -wrap_int(13), -wrap_int(44), wrap_int(9), wrap_int(42), -wrap_int(90), wrap_int(94), -wrap_int(19), wrap_int(5), -wrap_int(33), wrap_int(33), -wrap_int(60), wrap_int(80), -wrap_int(40), -wrap_int(64), wrap_int(19), -wrap_int(92), wrap_int(62), -wrap_int(12), -wrap_int(58), wrap_int(89), -wrap_int(50), -wrap_int(82), -wrap_int(32), wrap_int(65), wrap_int(82), -wrap_int(49), wrap_int(80), -wrap_int(71), wrap_int(68), -wrap_int(17), wrap_int(26), wrap_int(6), -wrap_int(61)])):
    a, b = inds
    return (nums[a] + nums[b] == wrap_int(0)).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0))
Exception -- for puzzle PairZeroSum:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 184/732: PairZeroSum:3
sat_func def sat(inds: List[int], nums=[61, 13, 32, -67, -29, 6, 65, 82, -36, -90, -3, -53, -80, 52, -20, 14, -58, 1, 14, 88, 90, -76, -83, 47, -20, -26, 5, 71, 29, -51, -6, 38, -42, -48, 9, -74, -37, -86, -31, -63, -45, -74, -40, 23, -16, 24, -6, -93, -46, -42, -4, -85, -91, 71, -72, 11, -33, 33, -82, -67, -34, -60, 89, 60, 26, -12, -92, 42, -92, -58, -37, 9, -38, 54, 34, 25, 85, -65, -79, 33, -52, -72, -80, -76, -39, 24, -2, 40, -53, -14, 8, 21, 7, 46, -88, -67]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
modified_func def sat(inds: List[int], nums=wrap_list([wrap_int(61), wrap_int(13), wrap_int(32), -wrap_int(67), -wrap_int(29), wrap_int(6), wrap_int(65), wrap_int(82), -wrap_int(36), -wrap_int(90), -wrap_int(3), -wrap_int(53), -wrap_int(80), wrap_int(52), -wrap_int(20), wrap_int(14), -wrap_int(58), wrap_int(1), wrap_int(14), wrap_int(88), wrap_int(90), -wrap_int(76), -wrap_int(83), wrap_int(47), -wrap_int(20), -wrap_int(26), wrap_int(5), wrap_int(71), wrap_int(29), -wrap_int(51), -wrap_int(6), wrap_int(38), -wrap_int(42), -wrap_int(48), wrap_int(9), -wrap_int(74), -wrap_int(37), -wrap_int(86), -wrap_int(31), -wrap_int(63), -wrap_int(45), -wrap_int(74), -wrap_int(40), wrap_int(23), -wrap_int(16), wrap_int(24), -wrap_int(6), -wrap_int(93), -wrap_int(46), -wrap_int(42), -wrap_int(4), -wrap_int(85), -wrap_int(91), wrap_int(71), -wrap_int(72), wrap_int(11), -wrap_int(33), wrap_int(33), -wrap_int(82), -wrap_int(67), -wrap_int(34), -wrap_int(60), wrap_int(89), wrap_int(60), wrap_int(26), -wrap_int(12), -wrap_int(92), wrap_int(42), -wrap_int(92), -wrap_int(58), -wrap_int(37), wrap_int(9), -wrap_int(38), wrap_int(54), wrap_int(34), wrap_int(25), wrap_int(85), -wrap_int(65), -wrap_int(79), wrap_int(33), -wrap_int(52), -wrap_int(72), -wrap_int(80), -wrap_int(76), -wrap_int(39), wrap_int(24), -wrap_int(2), wrap_int(40), -wrap_int(53), -wrap_int(14), wrap_int(8), wrap_int(21), wrap_int(7), wrap_int(46), -wrap_int(88), -wrap_int(67)])):
    a, b = inds
    return (nums[a] + nums[b] == wrap_int(0)).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0))
Exception -- for puzzle PairZeroSum:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 185/732: PairZeroSum:4
sat_func def sat(inds: List[int], nums=[4, -4, -4, -3, 3, 1]):
    a, b = inds
    return nums[a] + nums[b] == 0 and a >= 0 and b >= 0
modified_func def sat(inds: List[int], nums=wrap_list([wrap_int(4), -wrap_int(4), -wrap_int(4), -wrap_int(3), wrap_int(3), wrap_int(1)])):
    a, b = inds
    return (nums[a] + nums[b] == wrap_int(0)).__and__(a >= wrap_int(0)).__and__(b >= wrap_int(0))
Exception -- for puzzle PairZeroSum:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 186/732: Fib4:0
sat_func def sat(init: List[int], target=2021):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(2021)):
    a, b, c, d = init
    for i in sym_range(99):
        a, b, c, d = (b, c, d, a + b + c + d)
    return a == target
Exception -- for puzzle Fib4:0 not enough values to unpack (expected 4, got 1)

Solving puzzle 187/732: Fib4:1
sat_func def sat(init: List[int], target=56):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(56)):
    a, b, c, d = init
    for i in sym_range(99):
        a, b, c, d = (b, c, d, a + b + c + d)
    return a == target
Exception -- for puzzle Fib4:1 not enough values to unpack (expected 4, got 1)

Solving puzzle 188/732: Fib4:2
sat_func def sat(init: List[int], target=58965):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(58965)):
    a, b, c, d = init
    for i in sym_range(99):
        a, b, c, d = (b, c, d, a + b + c + d)
    return a == target
Exception -- for puzzle Fib4:2 not enough values to unpack (expected 4, got 1)

Solving puzzle 189/732: Fib4:3
sat_func def sat(init: List[int], target=501192137):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(501192137)):
    a, b, c, d = init
    for i in sym_range(99):
        a, b, c, d = (b, c, d, a + b + c + d)
    return a == target
Exception -- for puzzle Fib4:3 not enough values to unpack (expected 4, got 1)

Solving puzzle 190/732: Fib4:4
sat_func def sat(init: List[int], target=0):
    a, b, c, d = init
    for i in range(99):
        a, b, c, d = b, c, d, (a + b + c + d)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(0)):
    a, b, c, d = init
    for i in sym_range(99):
        a, b, c, d = (b, c, d, a + b + c + d)
    return a == target
Exception -- for puzzle Fib4:4 not enough values to unpack (expected 4, got 1)

Solving puzzle 191/732: LittleFermat:0
sat_func def sat(exp_poly: List[int], d=74152093423, poly=[1, 6, 3, 1, 0, 4, 4]):
    p = len(poly)
    assert p > 2 and all(p % i for i in range(2, p)), "Hint: p is a prime > 2"

    def val(coeffs, n):  # evaluate polynomial mod p
        return sum(c * pow(n, i, p) for i, c in enumerate(coeffs)) % p

    return all(val(exp_poly, n) == pow(val(poly, n), d, p) for n in range(p))
modified_func def sat(exp_poly: List[int], d=wrap_int(74152093423), poly=wrap_list([wrap_int(1), wrap_int(6), wrap_int(3), wrap_int(1), wrap_int(0), wrap_int(4), wrap_int(4)])):
    p = sym_len(poly)
    _assert((p > wrap_int(2)).__and__(all(sym_generator((p % i for i in sym_range(2, p))))), wrap_str('Hint: p is a prime > 2'))

    def val(coeffs, n):
        return sym_sum(sym_generator((c * pow(n, i, p) for i, c in enumerate(coeffs)))) % p
    return all(sym_generator((val(exp_poly, n) == pow(val(poly, n), d, p) for n in sym_range(p))))
Exception -- for puzzle LittleFermat:0 SymbolicInt.__pow__() takes 2 positional arguments but 3 were given

Solving puzzle 192/732: BelowThreshold:0
sat_func def sat(indexes: List[int], nums=[0, 2, 17, 4, 4213, 322, 102, 29, 15, 39, 55], thresh=100):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
modified_func def sat(indexes: List[int], nums=wrap_list([wrap_int(0), wrap_int(2), wrap_int(17), wrap_int(4), wrap_int(4213), wrap_int(322), wrap_int(102), wrap_int(29), wrap_int(15), wrap_int(39), wrap_int(55)]), thresh=wrap_int(100)):
    j = wrap_int(0)
    for i, n in enumerate(nums):
        if n < thresh:
            _assert(indexes[j] == i)
            j += wrap_int(1)
    _assert(j == sym_len(indexes))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.get.int x 0) 0))
(assert (= (list.get.int x 1) 1))
(assert (= (list.get.int x 2) 2))
(assert (= (list.get.int x 3) 3))
(assert (= (list.get.int x 4) 7))
(assert (= (list.get.int x 5) 8))
(assert (= (list.get.int x 6) 9))
(assert (= (list.get.int x 7) 10))
(assert (= 8 (list.length.int x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 1 ((as cons (List Int)) 2 ((as cons (List Int)) 3 ((as cons (List Int)) 7 ((as cons (List Int)) 8 ((as cons (List Int)) 9 ((as cons (List Int)) 10 (as nil (List Int)))))))))))
)

Found solution [0, 1, 2, 3, 7, 8, 9, 10]
Yes! Solved for puzzle  BelowThreshold:0

Solving puzzle 193/732: BelowThreshold:1
sat_func def sat(indexes: List[int], nums=[35, -96, -51, 7, 56, 0], thresh=-30):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
modified_func def sat(indexes: List[int], nums=wrap_list([wrap_int(35), -wrap_int(96), -wrap_int(51), wrap_int(7), wrap_int(56), wrap_int(0)]), thresh=-wrap_int(30)):
    j = wrap_int(0)
    for i, n in enumerate(nums):
        if n < thresh:
            _assert(indexes[j] == i)
            j += wrap_int(1)
    _assert(j == sym_len(indexes))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.get.int x 0) 1))
(assert (= (list.get.int x 1) 2))
(assert (= 2 (list.length.int x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) 2 (as nil (List Int)))))
)

Found solution [1, 2]
Yes! Solved for puzzle  BelowThreshold:1

Solving puzzle 194/732: BelowThreshold:2
sat_func def sat(indexes: List[int], nums=[-20, 45], thresh=91):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
modified_func def sat(indexes: List[int], nums=wrap_list([-wrap_int(20), wrap_int(45)]), thresh=wrap_int(91)):
    j = wrap_int(0)
    for i, n in enumerate(nums):
        if n < thresh:
            _assert(indexes[j] == i)
            j += wrap_int(1)
    _assert(j == sym_len(indexes))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.get.int x 0) 0))
(assert (= (list.get.int x 1) 1))
(assert (= 2 (list.length.int x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [0, 1]
Yes! Solved for puzzle  BelowThreshold:2

Solving puzzle 195/732: BelowThreshold:3
sat_func def sat(indexes: List[int], nums=[84, 56, 13], thresh=-80):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
modified_func def sat(indexes: List[int], nums=wrap_list([wrap_int(84), wrap_int(56), wrap_int(13)]), thresh=-wrap_int(80)):
    j = wrap_int(0)
    for i, n in enumerate(nums):
        if n < thresh:
            _assert(indexes[j] == i)
            j += wrap_int(1)
    _assert(j == sym_len(indexes))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= 0 (list.length.int x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Yes! Solved for puzzle  BelowThreshold:3

Solving puzzle 196/732: BelowThreshold:4
sat_func def sat(indexes: List[int], nums=[3, -70, -88, 38], thresh=95):
    j = 0
    for i, n in enumerate(nums):
        if n < thresh:
            assert indexes[j] == i
            j += 1
    assert j == len(indexes)
    return True
modified_func def sat(indexes: List[int], nums=wrap_list([wrap_int(3), -wrap_int(70), -wrap_int(88), wrap_int(38)]), thresh=wrap_int(95)):
    j = wrap_int(0)
    for i, n in enumerate(nums):
        if n < thresh:
            _assert(indexes[j] == i)
            j += wrap_int(1)
    _assert(j == sym_len(indexes))
    return True
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.get.int x 0) 0))
(assert (= (list.get.int x 1) 1))
(assert (= (list.get.int x 2) 2))
(assert (= (list.get.int x 3) 3))
(assert (= 4 (list.length.int x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 1 ((as cons (List Int)) 2 ((as cons (List Int)) 3 (as nil (List Int)))))))
)

Found solution [0, 1, 2, 3]
Yes! Solved for puzzle  BelowThreshold:4

Solving puzzle 197/732: Fibonacci:0
sat_func def sat(nums: List[int], n=1402):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
modified_func def sat(nums: List[int], n=wrap_int(1402)):
    return (nums[wrap_int(0)] == nums[wrap_int(1)]).__and__(nums[wrap_int(1)] == wrap_int(1)).__and__(all(sym_generator((nums[i + wrap_int(2)] == nums[i + wrap_int(1)] + nums[i] for i in sym_range(n - 2)))))
Exception -- for puzzle Fibonacci:0 maximum recursion depth exceeded

Solving puzzle 198/732: Fibonacci:1
sat_func def sat(nums: List[int], n=537):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
modified_func def sat(nums: List[int], n=wrap_int(537)):
    return (nums[wrap_int(0)] == nums[wrap_int(1)]).__and__(nums[wrap_int(1)] == wrap_int(1)).__and__(all(sym_generator((nums[i + wrap_int(2)] == nums[i + wrap_int(1)] + nums[i] for i in sym_range(n - 2)))))
Exception -- for puzzle Fibonacci:1 maximum recursion depth exceeded

Solving puzzle 199/732: Fibonacci:2
sat_func def sat(nums: List[int], n=6968):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
modified_func def sat(nums: List[int], n=wrap_int(6968)):
    return (nums[wrap_int(0)] == nums[wrap_int(1)]).__and__(nums[wrap_int(1)] == wrap_int(1)).__and__(all(sym_generator((nums[i + wrap_int(2)] == nums[i + wrap_int(1)] + nums[i] for i in sym_range(n - 2)))))
Exception -- for puzzle Fibonacci:2 maximum recursion depth exceeded

Solving puzzle 200/732: Fibonacci:3
sat_func def sat(nums: List[int], n=5585):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
modified_func def sat(nums: List[int], n=wrap_int(5585)):
    return (nums[wrap_int(0)] == nums[wrap_int(1)]).__and__(nums[wrap_int(1)] == wrap_int(1)).__and__(all(sym_generator((nums[i + wrap_int(2)] == nums[i + wrap_int(1)] + nums[i] for i in sym_range(n - 2)))))
Exception -- for puzzle Fibonacci:3 maximum recursion depth exceeded

Solving puzzle 201/732: Fibonacci:4
sat_func def sat(nums: List[int], n=7277):
    return nums[0] == nums[1] == 1 and all(nums[i + 2] == nums[i + 1] + nums[i] for i in range(n - 2))
modified_func def sat(nums: List[int], n=wrap_int(7277)):
    return (nums[wrap_int(0)] == nums[wrap_int(1)]).__and__(nums[wrap_int(1)] == wrap_int(1)).__and__(all(sym_generator((nums[i + wrap_int(2)] == nums[i + wrap_int(1)] + nums[i] for i in sym_range(n - 2)))))
Exception -- for puzzle Fibonacci:4 maximum recursion depth exceeded

Solving puzzle 202/732: MatchBrackets:0
sat_func def sat(matches: List[int], brackets="<<>><<<><>><<>>>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
modified_func def sat(matches: List[int], brackets=wrap_str('<<>><<<><>><<>>>')):
    for i in sym_range(sym_len(brackets)):
        j = matches[i]
        c = brackets[i]
        _assert((brackets[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(brackets)
Exception -- for puzzle MatchBrackets:0 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 203/732: MatchBrackets:1
sat_func def sat(matches: List[int], brackets="<><><><><<>><<<><><<>>>><><><>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
modified_func def sat(matches: List[int], brackets=wrap_str('<><><><><<>><<<><><<>>>><><><>')):
    for i in sym_range(sym_len(brackets)):
        j = matches[i]
        c = brackets[i]
        _assert((brackets[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(brackets)
Exception -- for puzzle MatchBrackets:1 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 204/732: MatchBrackets:2
sat_func def sat(matches: List[int], brackets="<><><<<>><<<<><>>><<>><>>><>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
modified_func def sat(matches: List[int], brackets=wrap_str('<><><<<>><<<<><>>><<>><>>><>')):
    for i in sym_range(sym_len(brackets)):
        j = matches[i]
        c = brackets[i]
        _assert((brackets[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(brackets)
Exception -- for puzzle MatchBrackets:2 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 205/732: MatchBrackets:3
sat_func def sat(matches: List[int], brackets="<><><><><<><><<><>>><><<>><><<>><><><><<<>><>><>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
modified_func def sat(matches: List[int], brackets=wrap_str('<><><><><<><><<><>>><><<>><><<>><><><><<<>><>><>')):
    for i in sym_range(sym_len(brackets)):
        j = matches[i]
        c = brackets[i]
        _assert((brackets[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(brackets)
Exception -- for puzzle MatchBrackets:3 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 206/732: MatchBrackets:4
sat_func def sat(matches: List[int], brackets="<<<<<>>>>><><><<>>"):
    for i in range(len(brackets)):
        j = matches[i]
        c = brackets[i]
        assert brackets[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(brackets)
modified_func def sat(matches: List[int], brackets=wrap_str('<<<<<>>>>><><><<>>')):
    for i in sym_range(sym_len(brackets)):
        j = matches[i]
        c = brackets[i]
        _assert((brackets[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(brackets)
Exception -- for puzzle MatchBrackets:4 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 207/732: CommonNumbers:0
sat_func def sat(common: List[int], a=[2, 416629, 2, 4, 17, 29, 31, 1000], b=[31, 2, 4, 17, 29, 41205]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
modified_func def sat(common: List[int], a=wrap_list([wrap_int(2), wrap_int(416629), wrap_int(2), wrap_int(4), wrap_int(17), wrap_int(29), wrap_int(31), wrap_int(1000)]), b=wrap_list([wrap_int(31), wrap_int(2), wrap_int(4), wrap_int(17), wrap_int(29), wrap_int(41205)])):
    return all(sym_generator((sym_in(i, common) == sym_in(i, a).__and__(sym_in(i, b)) for i in a + b + common)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_186 Int)) (=> (and (>= list_pos_186 0) (< list_pos_186 (list.length.int (list.append.int (cons 2 (cons 416629 (cons 2 (cons 4 (cons 17 (cons 29 (cons 31 (cons 1000 (cons 31 (cons 2 (cons 4 (cons 17 (cons 29 (cons 41205 (as nil (List Int)))))))))))))))) x)))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle CommonNumbers:0
Too many constants for extrapolation

Solving puzzle 208/732: CommonNumbers:1
sat_func def sat(common: List[int], a=[824, 853, 392, 835, 225, 96], b=[73, 534, 705, 376, 376, 965, 404, 976]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
modified_func def sat(common: List[int], a=wrap_list([wrap_int(824), wrap_int(853), wrap_int(392), wrap_int(835), wrap_int(225), wrap_int(96)]), b=wrap_list([wrap_int(73), wrap_int(534), wrap_int(705), wrap_int(376), wrap_int(376), wrap_int(965), wrap_int(404), wrap_int(976)])):
    return all(sym_generator((sym_in(i, common) == sym_in(i, a).__and__(sym_in(i, b)) for i in a + b + common)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_187 Int)) (=> (and (>= list_pos_187 0) (< list_pos_187 (list.length.int (list.append.int (cons 824 (cons 853 (cons 392 (cons 835 (cons 225 (cons 96 (cons 73 (cons 534 (cons 705 (cons 376 (cons 376 (cons 965 (cons 404 (cons 976 (as nil (List Int)))))))))))))))) x)))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle CommonNumbers:1
Too many constants for extrapolation

Solving puzzle 209/732: CommonNumbers:2
sat_func def sat(common: List[int], a=[338, 882, 92, 234], b=[993, 977, 403]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
modified_func def sat(common: List[int], a=wrap_list([wrap_int(338), wrap_int(882), wrap_int(92), wrap_int(234)]), b=wrap_list([wrap_int(993), wrap_int(977), wrap_int(403)])):
    return all(sym_generator((sym_in(i, common) == sym_in(i, a).__and__(sym_in(i, b)) for i in a + b + common)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_188 Int)) (=> (and (>= list_pos_188 0) (< list_pos_188 (list.length.int (list.append.int (cons 338 (cons 882 (cons 92 (cons 234 (cons 993 (cons 977 (cons 403 (as nil (List Int))))))))) x)))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle CommonNumbers:2
Too many constants for extrapolation

Solving puzzle 210/732: CommonNumbers:3
sat_func def sat(common: List[int], a=[950, 299, 581, 222, 490, 758, 58, 76, 808, 814], b=[790, 200, 814, 851, 902, 490, 581, 808, 950, 343, 758]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
modified_func def sat(common: List[int], a=wrap_list([wrap_int(950), wrap_int(299), wrap_int(581), wrap_int(222), wrap_int(490), wrap_int(758), wrap_int(58), wrap_int(76), wrap_int(808), wrap_int(814)]), b=wrap_list([wrap_int(790), wrap_int(200), wrap_int(814), wrap_int(851), wrap_int(902), wrap_int(490), wrap_int(581), wrap_int(808), wrap_int(950), wrap_int(343), wrap_int(758)])):
    return all(sym_generator((sym_in(i, common) == sym_in(i, a).__and__(sym_in(i, b)) for i in a + b + common)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_189 Int)) (=> (and (>= list_pos_189 0) (< list_pos_189 (list.length.int (list.append.int (cons 950 (cons 299 (cons 581 (cons 222 (cons 490 (cons 758 (cons 58 (cons 76 (cons 808 (cons 814 (cons 790 (cons 200 (cons 814 (cons 851 (cons 902 (cons 490 (cons 581 (cons 808 (cons 950 (cons 343 (cons 758 (as nil (List Int))))))))))))))))))))))) x)))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle CommonNumbers:3
Too many constants for extrapolation

Solving puzzle 211/732: CommonNumbers:4
sat_func def sat(common: List[int], a=[452, 318, 348, 995, 733, 874, 699], b=[733, 348, 614, 874, 699, 995, 318, 167, 452]):
    return all((i in common) == (i in a and i in b) for i in a + b + common)
modified_func def sat(common: List[int], a=wrap_list([wrap_int(452), wrap_int(318), wrap_int(348), wrap_int(995), wrap_int(733), wrap_int(874), wrap_int(699)]), b=wrap_list([wrap_int(733), wrap_int(348), wrap_int(614), wrap_int(874), wrap_int(699), wrap_int(995), wrap_int(318), wrap_int(167), wrap_int(452)])):
    return all(sym_generator((sym_in(i, common) == sym_in(i, a).__and__(sym_in(i, b)) for i in a + b + common)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_190 Int)) (=> (and (>= list_pos_190 0) (< list_pos_190 (list.length.int (list.append.int (cons 452 (cons 318 (cons 348 (cons 995 (cons 733 (cons 874 (cons 699 (cons 733 (cons 348 (cons 614 (cons 874 (cons 699 (cons 995 (cons 318 (cons 167 (cons 452 (as nil (List Int)))))))))))))))))) x)))) false)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle CommonNumbers:4
Too many constants for extrapolation

Solving puzzle 212/732: CumulativeSums:0
sat_func def sat(sums: List[int], n=104):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
modified_func def sat(sums: List[int], n=wrap_int(104)):
    return all(sym_generator((sums[i + wrap_int(1)] - sums[i] == i for i in sym_range(n)))).__and__(sums[wrap_int(0)] == wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (- (list.get.int x 1) (list.get.int x 0)) 0) (= (- (list.get.int x 2) (list.get.int x 1)) 1)) (= (- (list.get.int x 3) (list.get.int x 2)) 2)) (= (- (list.get.int x 4) (list.get.int x 3)) 3)) (= (- (list.get.int x 5) (list.get.int x 4)) 4)) (= (- (list.get.int x 6) (list.get.int x 5)) 5)) (= (- (list.get.int x 7) (list.get.int x 6)) 6)) (= (- (list.get.int x 8) (list.get.int x 7)) 7)) (= (- (list.get.int x 9) (list.get.int x 8)) 8)) (= (- (list.get.int x 10) (list....
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle CumulativeSums:0
One large constant for extrapolation
Solving simpler variation replaced 104 with 3
sat_func def sat(sums: List[int], n=3):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
modified_func def sat(sums: List[int], n=wrap_int(3)):
    return all(sym_generator((sums[i + wrap_int(1)] - sums[i] == i for i in sym_range(n)))).__and__(sums[wrap_int(0)] == wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (= (- (list.get.int x 1) (list.get.int x 0)) 0) (= (- (list.get.int x 2) (list.get.int x 1)) 1)) (= (- (list.get.int x 3) (list.get.int x 2)) 2)) (= (list.get.int x 0) 0)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 0 ((as cons (List Int)) 1 ((as cons (List Int)) 3 ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int)))))))))
)

Found solution [0, 0, 1, 3, 0, 0]

Solving puzzle 213/732: CumulativeSums:1
sat_func def sat(sums: List[int], n=19891):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
modified_func def sat(sums: List[int], n=wrap_int(19891)):
    return all(sym_generator((sums[i + wrap_int(1)] - sums[i] == i for i in sym_range(n)))).__and__(sums[wrap_int(0)] == wrap_int(0))
Exception -- for puzzle CumulativeSums:1 maximum recursion depth exceeded

Solving puzzle 214/732: CumulativeSums:2
sat_func def sat(sums: List[int], n=11023):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
modified_func def sat(sums: List[int], n=wrap_int(11023)):
    return all(sym_generator((sums[i + wrap_int(1)] - sums[i] == i for i in sym_range(n)))).__and__(sums[wrap_int(0)] == wrap_int(0))
Exception -- for puzzle CumulativeSums:2 maximum recursion depth exceeded

Solving puzzle 215/732: CumulativeSums:3
sat_func def sat(sums: List[int], n=10840):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
modified_func def sat(sums: List[int], n=wrap_int(10840)):
    return all(sym_generator((sums[i + wrap_int(1)] - sums[i] == i for i in sym_range(n)))).__and__(sums[wrap_int(0)] == wrap_int(0))
Exception -- for puzzle CumulativeSums:3 maximum recursion depth exceeded

Solving puzzle 216/732: CumulativeSums:4
sat_func def sat(sums: List[int], n=14049):
    return all(sums[i + 1] - sums[i] == i for i in range(n)) and sums[0] == 0
modified_func def sat(sums: List[int], n=wrap_int(14049)):
    return all(sym_generator((sums[i + wrap_int(1)] - sums[i] == i for i in sym_range(n)))).__and__(sums[wrap_int(0)] == wrap_int(0))
Exception -- for puzzle CumulativeSums:4 maximum recursion depth exceeded

Solving puzzle 217/732: ParenDepth:0
sat_func def sat(matches: List[int], parens="((())()(()()))(())"):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
modified_func def sat(matches: List[int], parens=wrap_str('((())()(()()))(())')):
    for i, (j, c) in enumerate(sym_zip(matches, parens)):
        _assert((parens[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(parens)
Exception -- for puzzle ParenDepth:0 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 218/732: ParenDepth:1
sat_func def sat(matches: List[int], parens=""):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
modified_func def sat(matches: List[int], parens=wrap_str('')):
    for i, (j, c) in enumerate(sym_zip(matches, parens)):
        _assert((parens[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(parens)
Exception -- for puzzle ParenDepth:1 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 219/732: ParenDepth:2
sat_func def sat(matches: List[int], parens="()"):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
modified_func def sat(matches: List[int], parens=wrap_str('()')):
    for i, (j, c) in enumerate(sym_zip(matches, parens)):
        _assert((parens[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(parens)
Exception -- for puzzle ParenDepth:2 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 220/732: ParenDepth:3
sat_func def sat(matches: List[int], parens="((()(())))"):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
modified_func def sat(matches: List[int], parens=wrap_str('((()(())))')):
    for i, (j, c) in enumerate(sym_zip(matches, parens)):
        _assert((parens[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(parens)
Exception -- for puzzle ParenDepth:3 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 221/732: ParenDepth:4
sat_func def sat(matches: List[int], parens="(())"):
    for i, (j, c) in enumerate(zip(matches, parens)):
        assert parens[j] != c and matches[j] == i and all(i < matches[k] < j for k in range(i + 1, j))
    return len(matches) == len(parens)
modified_func def sat(matches: List[int], parens=wrap_str('(())')):
    for i, (j, c) in enumerate(sym_zip(matches, parens)):
        _assert((parens[j] != c).__and__(matches[j] == i).__and__(all(sym_generator(((i < matches[k]).__and__(matches[k] < j) for k in sym_range(i + 1, j))))))
    return sym_len(matches) == sym_len(parens)
Exception -- for puzzle ParenDepth:4 'NotImplementedType' object has no attribute '__and__'

Solving puzzle 222/732: Derivative:0
sat_func def sat(derivative: List[int], poly=[2, 1, 0, 4, 19, 231, 0, 5]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
modified_func def sat(derivative: List[int], poly=wrap_list([wrap_int(2), wrap_int(1), wrap_int(0), wrap_int(4), wrap_int(19), wrap_int(231), wrap_int(0), wrap_int(5)])):

    def val(poly, x):
        return sym_sum(sym_generator((coeff * x ** i for i, coeff in enumerate(poly))))
    return all(sym_generator((abs(val(poly, x + 1e-08) - val(poly, x) - 1e-08 * val(derivative, x)) < 0.0001 for x in sym_range(sym_len(poly)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_198 Int)) (=> (and (>= list_pos_198 0) (< list_pos_198 (list.length.int x))) (forall ((list_pos_197 Int)) (=> (and (>= list_pos_197 0) (< list_pos_197 (list.length.int x))) (forall ((list_pos_196 Int)) (=> (and (>= list_pos_196 0) (< list_pos_196 (list.length.int x))) (forall ((list_pos_195 Int)) (=> (and (>= list_pos_195 0) (< list_pos_195 (list.length.int x))) (forall ((list_pos_194 Int)) (=> (and (>= list_pos_194 0) (< list_pos_194 (list.length.int x))) (forall ((list_pos_193 Int)) (=> (and (>= list_pos_193 0) (< list_pos_193 (list.length.int x))) (forall ((list_pos_192 Int)) (=> (and (>= list_pos_192 0) (< list_pos_192 (list.length.int x))) (forall ((list_pos_191 Int)) (=> (and (>= list_pos_191 0) (< list_pos_191 (list.length.int x))) (and (and (and (and (and (and (and (< (ite (>= (- (- (+ (+ (+ (+ (+ (+ (+ (+ (* 2 1.0) 0) (* 1 1e-08)) (* 0 1.0000000000000001e-16)) (* 4 1.0000000000000001e-24)) (* 19 1e-32)) (* 231 1.0000000000000001e-40)) (* 0 1.00000000...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.873: Symbol 'e-08' not declared as a variable")

Could not find any solution for puzzle Derivative:0
One large constant for extrapolation
Solving simpler variation replaced 231 with 3
sat_func def sat(derivative: List[int], poly=[2, 1, 0, 4, 19, 3, 0, 5]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
modified_func def sat(derivative: List[int], poly=wrap_list([wrap_int(2), wrap_int(1), wrap_int(0), wrap_int(4), wrap_int(19), wrap_int(3), wrap_int(0), wrap_int(5)])):

    def val(poly, x):
        return sym_sum(sym_generator((coeff * x ** i for i, coeff in enumerate(poly))))
    return all(sym_generator((abs(val(poly, x + 1e-08) - val(poly, x) - 1e-08 * val(derivative, x)) < 0.0001 for x in sym_range(sym_len(poly)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_206 Int)) (=> (and (>= list_pos_206 0) (< list_pos_206 (list.length.int x))) (forall ((list_pos_205 Int)) (=> (and (>= list_pos_205 0) (< list_pos_205 (list.length.int x))) (forall ((list_pos_204 Int)) (=> (and (>= list_pos_204 0) (< list_pos_204 (list.length.int x))) (forall ((list_pos_203 Int)) (=> (and (>= list_pos_203 0) (< list_pos_203 (list.length.int x))) (forall ((list_pos_202 Int)) (=> (and (>= list_pos_202 0) (< list_pos_202 (list.length.int x))) (forall ((list_pos_201 Int)) (=> (and (>= list_pos_201 0) (< list_pos_201 (list.length.int x))) (forall ((list_pos_200 Int)) (=> (and (>= list_pos_200 0) (< list_pos_200 (list.length.int x))) (forall ((list_pos_199 Int)) (=> (and (>= list_pos_199 0) (< list_pos_199 (list.length.int x))) (and (and (and (and (and (and (and (< (ite (>= (- (- (+ (+ (+ (+ (+ (+ (+ (+ (* 2 1.0) 0) (* 1 1e-08)) (* 0 1.0000000000000001e-16)) (* 4 1.0000000000000001e-24)) (* 19 1e-32)) (* 3 1.0000000000000001e-40)) (* 0 1.0000000000...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.873: Symbol 'e-08' not declared as a variable")

Could not find any solution for puzzle Derivative:0

Solving puzzle 223/732: Derivative:1
sat_func def sat(derivative: List[int], poly=[6, -7, -8, 3]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
modified_func def sat(derivative: List[int], poly=wrap_list([wrap_int(6), -wrap_int(7), -wrap_int(8), wrap_int(3)])):

    def val(poly, x):
        return sym_sum(sym_generator((coeff * x ** i for i, coeff in enumerate(poly))))
    return all(sym_generator((abs(val(poly, x + 1e-08) - val(poly, x) - 1e-08 * val(derivative, x)) < 0.0001 for x in sym_range(sym_len(poly)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_210 Int)) (=> (and (>= list_pos_210 0) (< list_pos_210 (list.length.int x))) (forall ((list_pos_209 Int)) (=> (and (>= list_pos_209 0) (< list_pos_209 (list.length.int x))) (forall ((list_pos_208 Int)) (=> (and (>= list_pos_208 0) (< list_pos_208 (list.length.int x))) (forall ((list_pos_207 Int)) (=> (and (>= list_pos_207 0) (< list_pos_207 (list.length.int x))) (and (and (and (< (ite (>= (- (- (+ (+ (+ (+ (* 6 1.0) 0) (* -7 1e-08)) (* -8 1.0000000000000001e-16)) (* 3 1.0000000000000001e-24)) 6) (* (+ (* (list.get.int x list_pos_207) 1) 0) 1e-08)) 0) (- (- (+ (+ (+ (+ (* 6 1.0) 0) (* -7 1e-08)) (* -8 1.0000000000000001e-16)) (* 3 1.0000000000000001e-24)) 6) (* (+ (* (list.get.int x list_pos_207) 1) 0) 1e-08)) (- (- (- (+ (+ (+ (+ (* 6 1.0) 0) (* -7 1e-08)) (* -8 1.0000000000000001e-16)) (* 3 1.0000000000000001e-24)) 6) (* (+ (* (list.get.int x list_pos_207) 1) 0) 1e-08)))) 0.0001) (< (ite (>= (- (- (+ (+ (+ (+ (* 6 1.0) 0) (* -7 1.00000001)) (* -8 1.000000019...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.458: Symbol 'e-08' not declared as a variable")

Could not find any solution for puzzle Derivative:1
Too many constants for extrapolation

Solving puzzle 224/732: Derivative:2
sat_func def sat(derivative: List[int], poly=[-5, 5, -6, 7]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
modified_func def sat(derivative: List[int], poly=wrap_list([-wrap_int(5), wrap_int(5), -wrap_int(6), wrap_int(7)])):

    def val(poly, x):
        return sym_sum(sym_generator((coeff * x ** i for i, coeff in enumerate(poly))))
    return all(sym_generator((abs(val(poly, x + 1e-08) - val(poly, x) - 1e-08 * val(derivative, x)) < 0.0001 for x in sym_range(sym_len(poly)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_214 Int)) (=> (and (>= list_pos_214 0) (< list_pos_214 (list.length.int x))) (forall ((list_pos_213 Int)) (=> (and (>= list_pos_213 0) (< list_pos_213 (list.length.int x))) (forall ((list_pos_212 Int)) (=> (and (>= list_pos_212 0) (< list_pos_212 (list.length.int x))) (forall ((list_pos_211 Int)) (=> (and (>= list_pos_211 0) (< list_pos_211 (list.length.int x))) (and (and (and (< (ite (>= (- (- (+ (+ (+ (+ (* -5 1.0) 0) (* 5 1e-08)) (* -6 1.0000000000000001e-16)) (* 7 1.0000000000000001e-24)) -5) (* (+ (* (list.get.int x list_pos_211) 1) 0) 1e-08)) 0) (- (- (+ (+ (+ (+ (* -5 1.0) 0) (* 5 1e-08)) (* -6 1.0000000000000001e-16)) (* 7 1.0000000000000001e-24)) -5) (* (+ (* (list.get.int x list_pos_211) 1) 0) 1e-08)) (- (- (- (+ (+ (+ (+ (* -5 1.0) 0) (* 5 1e-08)) (* -6 1.0000000000000001e-16)) (* 7 1.0000000000000001e-24)) -5) (* (+ (* (list.get.int x list_pos_211) 1) 0) 1e-08)))) 0.0001) (< (ite (>= (- (- (+ (+ (+ (+ (* -5 1.0) 0) (* 5 1.00000001)) (* -6 1.000000...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.458: Symbol 'e-08' not declared as a variable")

Could not find any solution for puzzle Derivative:2
Too many constants for extrapolation

Solving puzzle 225/732: Derivative:3
sat_func def sat(derivative: List[int], poly=[-8, 2, 1, -8, 9, -10, -2, -7, -10]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
modified_func def sat(derivative: List[int], poly=wrap_list([-wrap_int(8), wrap_int(2), wrap_int(1), -wrap_int(8), wrap_int(9), -wrap_int(10), -wrap_int(2), -wrap_int(7), -wrap_int(10)])):

    def val(poly, x):
        return sym_sum(sym_generator((coeff * x ** i for i, coeff in enumerate(poly))))
    return all(sym_generator((abs(val(poly, x + 1e-08) - val(poly, x) - 1e-08 * val(derivative, x)) < 0.0001 for x in sym_range(sym_len(poly)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_223 Int)) (=> (and (>= list_pos_223 0) (< list_pos_223 (list.length.int x))) (forall ((list_pos_222 Int)) (=> (and (>= list_pos_222 0) (< list_pos_222 (list.length.int x))) (forall ((list_pos_221 Int)) (=> (and (>= list_pos_221 0) (< list_pos_221 (list.length.int x))) (forall ((list_pos_220 Int)) (=> (and (>= list_pos_220 0) (< list_pos_220 (list.length.int x))) (forall ((list_pos_219 Int)) (=> (and (>= list_pos_219 0) (< list_pos_219 (list.length.int x))) (forall ((list_pos_218 Int)) (=> (and (>= list_pos_218 0) (< list_pos_218 (list.length.int x))) (forall ((list_pos_217 Int)) (=> (and (>= list_pos_217 0) (< list_pos_217 (list.length.int x))) (forall ((list_pos_216 Int)) (=> (and (>= list_pos_216 0) (< list_pos_216 (list.length.int x))) (forall ((list_pos_215 Int)) (=> (and (>= list_pos_215 0) (< list_pos_215 (list.length.int x))) (and (and (and (and (and (and (and (and (< (ite (>= (- (- (+ (+ (+ (+ (+ (+ (+ (+ (+ (* -8 1.0) 0) (* 2 1e-08)) (* 1 1.000000000...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.978: Symbol 'e-08' not declared as a variable")

Could not find any solution for puzzle Derivative:3
Too many constants for extrapolation

Solving puzzle 226/732: Derivative:4
sat_func def sat(derivative: List[int], poly=[5, -1, -4, -2, 7, -9, 3, 9]):

    def val(poly, x):
        return sum(coeff * (x ** i) for i, coeff in enumerate(poly))

    return all(abs(val(poly, x + 1e-8) - val(poly, x) - 1e-8 * val(derivative, x)) < 1e-4 for x in range(len(poly)))
modified_func def sat(derivative: List[int], poly=wrap_list([wrap_int(5), -wrap_int(1), -wrap_int(4), -wrap_int(2), wrap_int(7), -wrap_int(9), wrap_int(3), wrap_int(9)])):

    def val(poly, x):
        return sym_sum(sym_generator((coeff * x ** i for i, coeff in enumerate(poly))))
    return all(sym_generator((abs(val(poly, x + 1e-08) - val(poly, x) - 1e-08 * val(derivative, x)) < 0.0001 for x in sym_range(sym_len(poly)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_231 Int)) (=> (and (>= list_pos_231 0) (< list_pos_231 (list.length.int x))) (forall ((list_pos_230 Int)) (=> (and (>= list_pos_230 0) (< list_pos_230 (list.length.int x))) (forall ((list_pos_229 Int)) (=> (and (>= list_pos_229 0) (< list_pos_229 (list.length.int x))) (forall ((list_pos_228 Int)) (=> (and (>= list_pos_228 0) (< list_pos_228 (list.length.int x))) (forall ((list_pos_227 Int)) (=> (and (>= list_pos_227 0) (< list_pos_227 (list.length.int x))) (forall ((list_pos_226 Int)) (=> (and (>= list_pos_226 0) (< list_pos_226 (list.length.int x))) (forall ((list_pos_225 Int)) (=> (and (>= list_pos_225 0) (< list_pos_225 (list.length.int x))) (forall ((list_pos_224 Int)) (=> (and (>= list_pos_224 0) (< list_pos_224 (list.length.int x))) (and (and (and (and (and (and (and (< (ite (>= (- (- (+ (+ (+ (+ (+ (+ (+ (+ (* 5 1.0) 0) (* -1 1e-08)) (* -4 1.0000000000000001e-16)) (* -2 1.0000000000000001e-24)) (* 7 1e-32)) (* -9 1.0000000000000001e-40)) (* 3 1.0000000...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.874: Symbol 'e-08' not declared as a variable")

Could not find any solution for puzzle Derivative:4
Too many constants for extrapolation

Solving puzzle 227/732: Fib3:0
sat_func def sat(init: List[int], target=124156):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(124156)):
    a, b, c = init
    for i in sym_range(16):
        a, b, c = (b, c, a + b + c)
    return a == target
Exception -- for puzzle Fib3:0 not enough values to unpack (expected 3, got 1)

Solving puzzle 228/732: Fib3:1
sat_func def sat(init: List[int], target=4050):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(4050)):
    a, b, c = init
    for i in sym_range(16):
        a, b, c = (b, c, a + b + c)
    return a == target
Exception -- for puzzle Fib3:1 not enough values to unpack (expected 3, got 1)

Solving puzzle 229/732: Fib3:2
sat_func def sat(init: List[int], target=0):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(0)):
    a, b, c = init
    for i in sym_range(16):
        a, b, c = (b, c, a + b + c)
    return a == target
Exception -- for puzzle Fib3:2 not enough values to unpack (expected 3, got 1)

Solving puzzle 230/732: Fib3:3
sat_func def sat(init: List[int], target=4644):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(4644)):
    a, b, c = init
    for i in sym_range(16):
        a, b, c = (b, c, a + b + c)
    return a == target
Exception -- for puzzle Fib3:3 not enough values to unpack (expected 3, got 1)

Solving puzzle 231/732: Fib3:4
sat_func def sat(init: List[int], target=3):
    a, b, c = init
    for i in range(16):
        a, b, c = b, c, (a + b + c)
    return a == target
modified_func def sat(init: List[int], target=wrap_int(3)):
    a, b, c = init
    for i in sym_range(16):
        a, b, c = (b, c, a + b + c)
    return a == target
Exception -- for puzzle Fib3:4 not enough values to unpack (expected 3, got 1)

Solving puzzle 232/732: FindVowels:0
sat_func def sat(vowels: List[str], texts=['Hello, world!', 'Goodbye, world!']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
modified_func def sat(vowels: List[str], texts=wrap_list([wrap_str('Hello, world!'), wrap_str('Goodbye, world!')])):
    for v, t in sym_zip(vowels, texts):
        i = wrap_int(0)
        for j, c in enumerate(t):
            if sym_in(c.lower(), wrap_str('aeiou')).__or__((c.lower() == wrap_str('y')).__and__(j == sym_len(t) - wrap_int(1))):
                _assert(v[i] == c)
                i += wrap_int(1)
        _assert(i == sym_len(v))
    return sym_len(vowels) == sym_len(texts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (< zip_pos_0 2))
(assert (>= zip_pos_0 -2))
(assert (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!") str_pos_7))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!") str_pos_7)) "y") (= (- (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")) 1) 0))) (= (python.str.at (list.get.string x zip_pos_0) 0) (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!") str_pos_7))))))
(assert (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!") str_pos_7))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!") str_pos_7)) "y") (= (- (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")) 1) 0))) (= 1 (str.len (list.get.string x zip_pos_0)))))))
(assert (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!") str_pos_7))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!") str_pos_7)) "y") (= (- (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")) 1) 0))) (= (list.length.string x) 2)))))
(assert (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")))) (< zip_pos_1 2))))
(assert (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")))) (>= zip_pos_1 -2))))
(assert (forall ((str_pos_8 Int)) (=> (and (>= str_pos_8 0) (< str_pos_8 (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hello, world!")))) (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")))) (=> (not (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hello, world!") str_pos_8))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hello, world!") str_pos_8)) "y") (= (- (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hello, world!")) 1) 0)))) (= 0 (str.len (list.get.string x zip_pos_1)))))))))
(assert (forall ((str_pos_8 Int)) (=> (and (>= str_pos_8 0) (< str_pos_8 (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hello, world!")))) (forall ((str_pos_7 Int)) (=> (and (>= str_pos_7 0) (< str_pos_7 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hello, world!")))) (=> (not (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hello, world!") str_pos_8))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hello, world!") str_pos_8)) "y") (= (- (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hello, world!")) 1) 0)))) (= (list.length.string x) 2)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:117.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle FindVowels:0
Solving simpler variation replaced Hello, world! with Hel!
sat_func def sat(vowels: List[str], texts=['Hel!', 'Goodbye, world!']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
modified_func def sat(vowels: List[str], texts=wrap_list([wrap_str('Hel!'), wrap_str('Goodbye, world!')])):
    for v, t in sym_zip(vowels, texts):
        i = wrap_int(0)
        for j, c in enumerate(t):
            if sym_in(c.lower(), wrap_str('aeiou')).__or__((c.lower() == wrap_str('y')).__and__(j == sym_len(t) - wrap_int(1))):
                _assert(v[i] == c)
                i += wrap_int(1)
        _assert(i == sym_len(v))
    return sym_len(vowels) == sym_len(texts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (< zip_pos_0 2))
(assert (>= zip_pos_0 -2))
(assert (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!") str_pos_9))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!") str_pos_9)) "y") (= (- (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")) 1) 0))) (= (python.str.at (list.get.string x zip_pos_0) 0) (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!") str_pos_9))))))
(assert (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!") str_pos_9))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!") str_pos_9)) "y") (= (- (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")) 1) 0))) (= 1 (str.len (list.get.string x zip_pos_0)))))))
(assert (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!") str_pos_9))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!") str_pos_9)) "y") (= (- (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")) 1) 0))) (= (list.length.string x) 2)))))
(assert (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")))) (< zip_pos_1 2))))
(assert (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")))) (>= zip_pos_1 -2))))
(assert (forall ((str_pos_10 Int)) (=> (and (>= str_pos_10 0) (< str_pos_10 (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hel!")))) (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")))) (=> (not (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hel!") str_pos_10))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hel!") str_pos_10)) "y") (= (- (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hel!")) 1) 0)))) (= 0 (str.len (list.get.string x zip_pos_1)))))))))
(assert (forall ((str_pos_10 Int)) (=> (and (>= str_pos_10 0) (< str_pos_10 (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hel!")))) (forall ((str_pos_9 Int)) (=> (and (>= str_pos_9 0) (< str_pos_9 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "Goodbye, world!" "Hel!")))) (=> (not (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hel!") str_pos_10))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hel!") str_pos_10)) "y") (= (- (str.len (ite (or (= zip_pos_1 1) (= zip_pos_1 -1)) "Goodbye, world!" "Hel!")) 1) 0)))) (= (list.length.string x) 2)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:117.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle FindVowels:0

Solving puzzle 233/732: FindVowels:1
sat_func def sat(vowels: List[str], texts=['kelUthI', 'RoRu', 'JuKEBesYtIcHakEQuala', 'TIzEXOtExTyJASiNiKi', 'tEWIFObesY', 'KyxySe', 'kEboWulOfEZEFuMYCH', 'XAPIFYS']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
modified_func def sat(vowels: List[str], texts=wrap_list([wrap_str('kelUthI'), wrap_str('RoRu'), wrap_str('JuKEBesYtIcHakEQuala'), wrap_str('TIzEXOtExTyJASiNiKi'), wrap_str('tEWIFObesY'), wrap_str('KyxySe'), wrap_str('kEboWulOfEZEFuMYCH'), wrap_str('XAPIFYS')])):
    for v, t in sym_zip(vowels, texts):
        i = wrap_int(0)
        for j, c in enumerate(t):
            if sym_in(c.lower(), wrap_str('aeiou')).__or__((c.lower() == wrap_str('y')).__and__(j == sym_len(t) - wrap_int(1))):
                _assert(v[i] == c)
                i += wrap_int(1)
        _assert(i == sym_len(v))
    return sym_len(vowels) == sym_len(texts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (< zip_pos_0 8))
(assert (>= zip_pos_0 -8))
(assert (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUthI")))))))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUthI"))))))) str_pos_11...
(assert (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUthI")))))))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUthI"))))))) str_pos_11...
(assert (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUthI")))))))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUthI"))))))) str_pos_11...
(assert (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUthI")))))))))) (< zip_pos_1 8))))
(assert (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUthI")))))))))) (>= zip_pos_1 -8))))
(assert (forall ((str_pos_12 Int)) (=> (and (>= str_pos_12 0) (< str_pos_12 (str.len (ite (or (= zip_pos_1 7) (= zip_pos_1 -1)) "XAPIFYS" (ite (or (= zip_pos_1 6) (= zip_pos_1 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_1 5) (= zip_pos_1 -3)) "KyxySe" (ite (or (= zip_pos_1 4) (= zip_pos_1 -4)) "tEWIFObesY" (ite (or (= zip_pos_1 3) (= zip_pos_1 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_1 2) (= zip_pos_1 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_1 1) (= zip_pos_1 -7)) "RoRu" "kelUthI")))))))))) (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUt...
(assert (forall ((str_pos_12 Int)) (=> (and (>= str_pos_12 0) (< str_pos_12 (str.len (ite (or (= zip_pos_1 7) (= zip_pos_1 -1)) "XAPIFYS" (ite (or (= zip_pos_1 6) (= zip_pos_1 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_1 5) (= zip_pos_1 -3)) "KyxySe" (ite (or (= zip_pos_1 4) (= zip_pos_1 -4)) "tEWIFObesY" (ite (or (= zip_pos_1 3) (= zip_pos_1 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_1 2) (= zip_pos_1 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_1 1) (= zip_pos_1 -7)) "RoRu" "kelUthI")))))))))) (forall ((str_pos_11 Int)) (=> (and (>= str_pos_11 0) (< str_pos_11 (str.len (ite (or (= zip_pos_0 7) (= zip_pos_0 -1)) "XAPIFYS" (ite (or (= zip_pos_0 6) (= zip_pos_0 -2)) "kEboWulOfEZEFuMYCH" (ite (or (= zip_pos_0 5) (= zip_pos_0 -3)) "KyxySe" (ite (or (= zip_pos_0 4) (= zip_pos_0 -4)) "tEWIFObesY" (ite (or (= zip_pos_0 3) (= zip_pos_0 -5)) "TIzEXOtExTyJASiNiKi" (ite (or (= zip_pos_0 2) (= zip_pos_0 -6)) "JuKEBesYtIcHakEQuala" (ite (or (= zip_pos_0 1) (= zip_pos_0 -7)) "RoRu" "kelUt...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:117.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle FindVowels:1
Too many constants for extrapolation

Solving puzzle 234/732: FindVowels:2
sat_func def sat(vowels: List[str], texts=['sATExtIjopEJOWIvU', 'v', 'teXTOGOzetEX', 'CAMe', 'SApiQuUzISYG', 'NaV']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
modified_func def sat(vowels: List[str], texts=wrap_list([wrap_str('sATExtIjopEJOWIvU'), wrap_str('v'), wrap_str('teXTOGOzetEX'), wrap_str('CAMe'), wrap_str('SApiQuUzISYG'), wrap_str('NaV')])):
    for v, t in sym_zip(vowels, texts):
        i = wrap_int(0)
        for j, c in enumerate(t):
            if sym_in(c.lower(), wrap_str('aeiou')).__or__((c.lower() == wrap_str('y')).__and__(j == sym_len(t) - wrap_int(1))):
                _assert(v[i] == c)
                i += wrap_int(1)
        _assert(i == sym_len(v))
    return sym_len(vowels) == sym_len(texts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (< zip_pos_0 6))
(assert (>= zip_pos_0 -6))
(assert (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU")))))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU"))))) str_pos_13))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos...
(assert (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU")))))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU"))))) str_pos_13))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos...
(assert (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU")))))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU"))))) str_pos_13))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos...
(assert (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU")))))))) (< zip_pos_1 6))))
(assert (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU")))))))) (>= zip_pos_1 -6))))
(assert (forall ((str_pos_14 Int)) (=> (and (>= str_pos_14 0) (< str_pos_14 (str.len (ite (or (= zip_pos_1 5) (= zip_pos_1 -1)) "NaV" (ite (or (= zip_pos_1 4) (= zip_pos_1 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_1 3) (= zip_pos_1 -3)) "CAMe" (ite (or (= zip_pos_1 2) (= zip_pos_1 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_1 1) (= zip_pos_1 -5)) "v" "sATExtIjopEJOWIvU")))))))) (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU")))))))) (=> (not (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_1 5) (= zip_pos_1 -1)) "NaV" (ite (or (= zip_pos_1 4) (= zip_pos_1 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_1 3) (= zip_pos_1 -3)) "CAMe" (ite (or (= zip_pos_1 2) (= zip_pos_1 -4...
(assert (forall ((str_pos_14 Int)) (=> (and (>= str_pos_14 0) (< str_pos_14 (str.len (ite (or (= zip_pos_1 5) (= zip_pos_1 -1)) "NaV" (ite (or (= zip_pos_1 4) (= zip_pos_1 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_1 3) (= zip_pos_1 -3)) "CAMe" (ite (or (= zip_pos_1 2) (= zip_pos_1 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_1 1) (= zip_pos_1 -5)) "v" "sATExtIjopEJOWIvU")))))))) (forall ((str_pos_13 Int)) (=> (and (>= str_pos_13 0) (< str_pos_13 (str.len (ite (or (= zip_pos_0 5) (= zip_pos_0 -1)) "NaV" (ite (or (= zip_pos_0 4) (= zip_pos_0 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_0 3) (= zip_pos_0 -3)) "CAMe" (ite (or (= zip_pos_0 2) (= zip_pos_0 -4)) "teXTOGOzetEX" (ite (or (= zip_pos_0 1) (= zip_pos_0 -5)) "v" "sATExtIjopEJOWIvU")))))))) (=> (not (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_1 5) (= zip_pos_1 -1)) "NaV" (ite (or (= zip_pos_1 4) (= zip_pos_1 -2)) "SApiQuUzISYG" (ite (or (= zip_pos_1 3) (= zip_pos_1 -3)) "CAMe" (ite (or (= zip_pos_1 2) (= zip_pos_1 -4...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:117.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle FindVowels:2
Too many constants for extrapolation

Solving puzzle 235/732: FindVowels:3
sat_func def sat(vowels: List[str], texts=[]):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
modified_func def sat(vowels: List[str], texts=wrap_list([])):
    for v, t in sym_zip(vowels, texts):
        i = wrap_int(0)
        for j, c in enumerate(t):
            if sym_in(c.lower(), wrap_str('aeiou')).__or__((c.lower() == wrap_str('y')).__and__(j == sym_len(t) - wrap_int(1))):
                _assert(v[i] == c)
                i += wrap_int(1)
        _assert(i == sym_len(v))
    return sym_len(vowels) == sym_len(texts)
Exception -- for puzzle FindVowels:3 'NoneType' object is not iterable

Solving puzzle 236/732: FindVowels:4
sat_func def sat(vowels: List[str], texts=['mAloCyBOSAwUg', 'W', 'BEsICHeCeLoNO']):
    for v, t in zip(vowels, texts):
        i = 0
        for j, c in enumerate(t):
            if c.lower() in "aeiou" or c.lower() == 'y' and j == len(t) - 1:
                assert v[i] == c
                i += 1
        assert i == len(v)
    return len(vowels) == len(texts)
modified_func def sat(vowels: List[str], texts=wrap_list([wrap_str('mAloCyBOSAwUg'), wrap_str('W'), wrap_str('BEsICHeCeLoNO')])):
    for v, t in sym_zip(vowels, texts):
        i = wrap_int(0)
        for j, c in enumerate(t):
            if sym_in(c.lower(), wrap_str('aeiou')).__or__((c.lower() == wrap_str('y')).__and__(j == sym_len(t) - wrap_int(1))):
                _assert(v[i] == c)
                i += wrap_int(1)
        _assert(i == sym_len(v))
    return sym_len(vowels) == sym_len(texts)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun-rec str.lower ((s String)) String
  (let ((len (str.len s)))
    (ite (= len 0) 
         ""
         (let ((first (str.at s 0)))
           (str.++ 
             (ite (and (str.< "A" first) (str.< first "Z"))
                  (let ((offset (- (str.to_int first) (str.to_int "A"))))
                    (str.from_int (+ (str.to_int "a") offset)))
                  first)
             (str.lower (str.substr s 1 (- len 1))))))))

(declare-const x (List String))
(assert (< zip_pos_0 3))
(assert (>= zip_pos_0 -3))
(assert (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg")) str_pos_15))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg")) str_pos_15)) "y") (= (- (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))) 1) 0))) (= (python.str.at (list.get.string x zip_pos_0) 0) (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg")) str_pos_15))))))
(assert (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg")) str_pos_15))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg")) str_pos_15)) "y") (= (- (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))) 1) 0))) (= 1 (str.len (list.get.string x zip_pos_0)))))))
(assert (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))))) (=> (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg")) str_pos_15))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg")) str_pos_15)) "y") (= (- (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))) 1) 0))) (= (list.length.string x) 3)))))
(assert (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))))) (< zip_pos_1 3))))
(assert (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))))) (>= zip_pos_1 -3))))
(assert (forall ((str_pos_16 Int)) (=> (and (>= str_pos_16 0) (< str_pos_16 (str.len (ite (or (= zip_pos_1 2) (= zip_pos_1 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_1 1) (= zip_pos_1 -2)) "W" "mAloCyBOSAwUg"))))) (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))))) (=> (not (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_1 2) (= zip_pos_1 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_1 1) (= zip_pos_1 -2)) "W" "mAloCyBOSAwUg")) str_pos_16))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_1 2) (= zip_pos_1 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_1 1) (= zip_pos_1 -2)) "W" "mAloCyBOSAwUg")) str_pos_16)) "y") (= (- (str.len (ite (or (= zip_pos_1 2) (= zip_pos_1 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_1 1) (= zip_pos_1 -2)) "W" "mAloCyBOSAwUg"))) 1) 0)))) (= 0 (str.len (list.get.string x zip_pos_1)))))))))
(assert (forall ((str_pos_16 Int)) (=> (and (>= str_pos_16 0) (< str_pos_16 (str.len (ite (or (= zip_pos_1 2) (= zip_pos_1 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_1 1) (= zip_pos_1 -2)) "W" "mAloCyBOSAwUg"))))) (forall ((str_pos_15 Int)) (=> (and (>= str_pos_15 0) (< str_pos_15 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "W" "mAloCyBOSAwUg"))))) (=> (not (or (str.contains "aeiou" (str.lower (python.str.at (ite (or (= zip_pos_1 2) (= zip_pos_1 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_1 1) (= zip_pos_1 -2)) "W" "mAloCyBOSAwUg")) str_pos_16))) (and (= (str.lower (python.str.at (ite (or (= zip_pos_1 2) (= zip_pos_1 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_1 1) (= zip_pos_1 -2)) "W" "mAloCyBOSAwUg")) str_pos_16)) "y") (= (- (str.len (ite (or (= zip_pos_1 2) (= zip_pos_1 -1)) "BEsICHeCeLoNO" (ite (or (= zip_pos_1 1) (= zip_pos_1 -2)) "W" "mAloCyBOSAwUg"))) 1) 0)))) (= (list.length.string x) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:117.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle FindVowels:4
Too many constants for extrapolation

Solving puzzle 237/732: SmallestEven:0
sat_func def sat(val_index: List[int], nums=[125123, 422323, 141, 5325, 812152, 9, 42145, 5313, 421, 812152]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
modified_func def sat(val_index: List[int], nums=wrap_list([wrap_int(125123), wrap_int(422323), wrap_int(141), wrap_int(5325), wrap_int(812152), wrap_int(9), wrap_int(42145), wrap_int(5313), wrap_int(421), wrap_int(812152)])):
    if val_index == wrap_list([]):
        return all(sym_generator((n % wrap_int(2) == wrap_int(1) for n in nums)))
    v, i = val_index
    _assert((v % wrap_int(2) == wrap_int(0)).__and__(nums[i] == v))
    return all(sym_generator(((n > v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[:i]))).__and__(all(sym_generator(((n >= v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[i:]))))
Exception -- for puzzle SmallestEven:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 238/732: SmallestEven:1
sat_func def sat(val_index: List[int], nums=[38940, 7988, 78915]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
modified_func def sat(val_index: List[int], nums=wrap_list([wrap_int(38940), wrap_int(7988), wrap_int(78915)])):
    if val_index == wrap_list([]):
        return all(sym_generator((n % wrap_int(2) == wrap_int(1) for n in nums)))
    v, i = val_index
    _assert((v % wrap_int(2) == wrap_int(0)).__and__(nums[i] == v))
    return all(sym_generator(((n > v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[:i]))).__and__(all(sym_generator(((n >= v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[i:]))))
Exception -- for puzzle SmallestEven:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 239/732: SmallestEven:2
sat_func def sat(val_index: List[int], nums=[26392632, 33805163]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
modified_func def sat(val_index: List[int], nums=wrap_list([wrap_int(26392632), wrap_int(33805163)])):
    if val_index == wrap_list([]):
        return all(sym_generator((n % wrap_int(2) == wrap_int(1) for n in nums)))
    v, i = val_index
    _assert((v % wrap_int(2) == wrap_int(0)).__and__(nums[i] == v))
    return all(sym_generator(((n > v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[:i]))).__and__(all(sym_generator(((n >= v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[i:]))))
Exception -- for puzzle SmallestEven:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 240/732: SmallestEven:3
sat_func def sat(val_index: List[int], nums=[744557286]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
modified_func def sat(val_index: List[int], nums=wrap_list([wrap_int(744557286)])):
    if val_index == wrap_list([]):
        return all(sym_generator((n % wrap_int(2) == wrap_int(1) for n in nums)))
    v, i = val_index
    _assert((v % wrap_int(2) == wrap_int(0)).__and__(nums[i] == v))
    return all(sym_generator(((n > v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[:i]))).__and__(all(sym_generator(((n >= v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[i:]))))
Exception -- for puzzle SmallestEven:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 241/732: SmallestEven:4
sat_func def sat(val_index: List[int], nums=[4512821, 7022753, 5506558]):
    if val_index == []:
        return all(n % 2 == 1 for n in nums)
    v, i = val_index
    assert v % 2 == 0 and nums[i] == v
    return all(n > v or n % 2 == 1 for n in nums[:i]) and all(n >= v or n % 2 == 1 for n in nums[i:])
modified_func def sat(val_index: List[int], nums=wrap_list([wrap_int(4512821), wrap_int(7022753), wrap_int(5506558)])):
    if val_index == wrap_list([]):
        return all(sym_generator((n % wrap_int(2) == wrap_int(1) for n in nums)))
    v, i = val_index
    _assert((v % wrap_int(2) == wrap_int(0)).__and__(nums[i] == v))
    return all(sym_generator(((n > v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[:i]))).__and__(all(sym_generator(((n >= v).__or__(n % wrap_int(2) == wrap_int(1)) for n in nums[i:]))))
Exception -- for puzzle SmallestEven:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 242/732: WildSort:0
sat_func def sat(strange: List[int], li=[30, 12, 42, 717, 45, 317, 200, -1, 491, 32, 15]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
modified_func def sat(strange: List[int], li=wrap_list([wrap_int(30), wrap_int(12), wrap_int(42), wrap_int(717), wrap_int(45), wrap_int(317), wrap_int(200), -wrap_int(1), wrap_int(491), wrap_int(32), wrap_int(15)])):
    _assert(sym_sorted(strange) == sym_sorted(li), wrap_str('Must be a permutation'))
    return all(sym_generator((n == (min, max)[i % wrap_int(2)](strange[i:]) for i, n in enumerate(strange))))
Exception -- for puzzle WildSort:0 Cannot convert symbolic integer to index

Solving puzzle 243/732: WildSort:1
sat_func def sat(strange: List[int], li=[8, 1, 0, 8, 1, 5, 2, 1, 7, 3, 0, 4, 0, 3, 8, 0, 9, 0, 7]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
modified_func def sat(strange: List[int], li=wrap_list([wrap_int(8), wrap_int(1), wrap_int(0), wrap_int(8), wrap_int(1), wrap_int(5), wrap_int(2), wrap_int(1), wrap_int(7), wrap_int(3), wrap_int(0), wrap_int(4), wrap_int(0), wrap_int(3), wrap_int(8), wrap_int(0), wrap_int(9), wrap_int(0), wrap_int(7)])):
    _assert(sym_sorted(strange) == sym_sorted(li), wrap_str('Must be a permutation'))
    return all(sym_generator((n == (min, max)[i % wrap_int(2)](strange[i:]) for i, n in enumerate(strange))))
Exception -- for puzzle WildSort:1 Cannot convert symbolic integer to index

Solving puzzle 244/732: WildSort:2
sat_func def sat(strange: List[int], li=[2, 0, 2, 4, 7, 6, 9]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
modified_func def sat(strange: List[int], li=wrap_list([wrap_int(2), wrap_int(0), wrap_int(2), wrap_int(4), wrap_int(7), wrap_int(6), wrap_int(9)])):
    _assert(sym_sorted(strange) == sym_sorted(li), wrap_str('Must be a permutation'))
    return all(sym_generator((n == (min, max)[i % wrap_int(2)](strange[i:]) for i, n in enumerate(strange))))
Exception -- for puzzle WildSort:2 Cannot convert symbolic integer to index

Solving puzzle 245/732: WildSort:3
sat_func def sat(strange: List[int], li=[5, 3, 9, 9, 5, 2, 9, 7, 0, 5, 7, 1, 2]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
modified_func def sat(strange: List[int], li=wrap_list([wrap_int(5), wrap_int(3), wrap_int(9), wrap_int(9), wrap_int(5), wrap_int(2), wrap_int(9), wrap_int(7), wrap_int(0), wrap_int(5), wrap_int(7), wrap_int(1), wrap_int(2)])):
    _assert(sym_sorted(strange) == sym_sorted(li), wrap_str('Must be a permutation'))
    return all(sym_generator((n == (min, max)[i % wrap_int(2)](strange[i:]) for i, n in enumerate(strange))))
Exception -- for puzzle WildSort:3 Cannot convert symbolic integer to index

Solving puzzle 246/732: WildSort:4
sat_func def sat(strange: List[int], li=[7, 1, 3]):
    assert sorted(strange) == sorted(li), "Must be a permutation"
    return all(n == (min, max)[i % 2](strange[i:]) for i, n in enumerate(strange))
modified_func def sat(strange: List[int], li=wrap_list([wrap_int(7), wrap_int(1), wrap_int(3)])):
    _assert(sym_sorted(strange) == sym_sorted(li), wrap_str('Must be a permutation'))
    return all(sym_generator((n == (min, max)[i % wrap_int(2)](strange[i:]) for i, n in enumerate(strange))))
Exception -- for puzzle WildSort:4 Cannot convert symbolic integer to index

Solving puzzle 247/732: NarrowerList:0
sat_func def sat(li: List[str], lists=[['this', 'list', 'is', 'narrow'], ['I', 'am', 'shorter but wider']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
modified_func def sat(li: List[str], lists=wrap_list([wrap_list([wrap_str('this'), wrap_str('list'), wrap_str('is'), wrap_str('narrow')]), wrap_list([wrap_str('I'), wrap_str('am'), wrap_str('shorter but wider')])])):
    width = sym_sum(sym_generator((sym_len(s) for s in li)))
    for li2 in lists:
        _assert(width <= sym_sum(sym_generator((sym_len(s) for s in li2))))
    return sym_in(li, lists)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_242 Int)) (=> (and (>= list_pos_242 0) (< list_pos_242 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_242)) 0) 16))))
(assert (forall ((list_pos_242 Int)) (=> (and (>= list_pos_242 0) (< list_pos_242 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_242)) 0) 20))))
(assert (forall ((list_pos_242 Int)) (=> (and (>= list_pos_242 0) (< list_pos_242 (list.length.string x))) (or (= x (cons "this" (cons "list" (cons "is" (cons "narrow" (as nil (List String))))))) (= x (cons "I" (cons "am" (cons "shorter but wider" (as nil (List String))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) ((as cons (List String)) "this" ((as cons (List String)) "list" ((as cons (List String)) "is" ((as cons (List String)) "narrow" (as nil (List String)))))))
)

Could not find any solution for puzzle NarrowerList:0
Too many constants for extrapolation

Solving puzzle 248/732: NarrowerList:1
sat_func def sat(li: List[str], lists=[['gefypo', 'gomecythib'], ['vicowodasyhifeme', 'mojowu', 'poxuchuchacyweth']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
modified_func def sat(li: List[str], lists=wrap_list([wrap_list([wrap_str('gefypo'), wrap_str('gomecythib')]), wrap_list([wrap_str('vicowodasyhifeme'), wrap_str('mojowu'), wrap_str('poxuchuchacyweth')])])):
    width = sym_sum(sym_generator((sym_len(s) for s in li)))
    for li2 in lists:
        _assert(width <= sym_sum(sym_generator((sym_len(s) for s in li2))))
    return sym_in(li, lists)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_243 Int)) (=> (and (>= list_pos_243 0) (< list_pos_243 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_243)) 0) 16))))
(assert (forall ((list_pos_243 Int)) (=> (and (>= list_pos_243 0) (< list_pos_243 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_243)) 0) 38))))
(assert (forall ((list_pos_243 Int)) (=> (and (>= list_pos_243 0) (< list_pos_243 (list.length.string x))) (or (= x (cons "gefypo" (cons "gomecythib" (as nil (List String))))) (= x (cons "vicowodasyhifeme" (cons "mojowu" (cons "poxuchuchacyweth" (as nil (List String))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) ((as cons (List String)) "gefypo" ((as cons (List String)) "gomecythib" (as nil (List String)))))
)

Could not find any solution for puzzle NarrowerList:1
Too many constants for extrapolation

Solving puzzle 249/732: NarrowerList:2
sat_func def sat(li: List[str], lists=[['cil', 'vesic', 'gaquedane'], ['machetyt', 'pumepywotatofo'], ['zatex', 'gilygyxejimagiquav']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
modified_func def sat(li: List[str], lists=wrap_list([wrap_list([wrap_str('cil'), wrap_str('vesic'), wrap_str('gaquedane')]), wrap_list([wrap_str('machetyt'), wrap_str('pumepywotatofo')]), wrap_list([wrap_str('zatex'), wrap_str('gilygyxejimagiquav')])])):
    width = sym_sum(sym_generator((sym_len(s) for s in li)))
    for li2 in lists:
        _assert(width <= sym_sum(sym_generator((sym_len(s) for s in li2))))
    return sym_in(li, lists)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_244 Int)) (=> (and (>= list_pos_244 0) (< list_pos_244 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_244)) 0) 17))))
(assert (forall ((list_pos_244 Int)) (=> (and (>= list_pos_244 0) (< list_pos_244 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_244)) 0) 22))))
(assert (forall ((list_pos_244 Int)) (=> (and (>= list_pos_244 0) (< list_pos_244 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_244)) 0) 23))))
(assert (forall ((list_pos_244 Int)) (=> (and (>= list_pos_244 0) (< list_pos_244 (list.length.string x))) (or (= x (cons "cil" (cons "vesic" (cons "gaquedane" (as nil (List String)))))) (= x (cons "machetyt" (cons "pumepywotatofo" (as nil (List String))))) (= x (cons "zatex" (cons "gilygyxejimagiquav" (as nil (List String)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) ((as cons (List String)) "cil" ((as cons (List String)) "vesic" ((as cons (List String)) "gaquedane" (as nil (List String))))))
)

Could not find any solution for puzzle NarrowerList:2
Too many constants for extrapolation

Solving puzzle 250/732: NarrowerList:3
sat_func def sat(li: List[str], lists=[['hubibexuratezixekyl', 'todot'], ['mochokyhyzylethy', 'we'], ['sygymithajyhu', 'byziruchocetextyram', 'thizupesakocami']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
modified_func def sat(li: List[str], lists=wrap_list([wrap_list([wrap_str('hubibexuratezixekyl'), wrap_str('todot')]), wrap_list([wrap_str('mochokyhyzylethy'), wrap_str('we')]), wrap_list([wrap_str('sygymithajyhu'), wrap_str('byziruchocetextyram'), wrap_str('thizupesakocami')])])):
    width = sym_sum(sym_generator((sym_len(s) for s in li)))
    for li2 in lists:
        _assert(width <= sym_sum(sym_generator((sym_len(s) for s in li2))))
    return sym_in(li, lists)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_245 Int)) (=> (and (>= list_pos_245 0) (< list_pos_245 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_245)) 0) 24))))
(assert (forall ((list_pos_245 Int)) (=> (and (>= list_pos_245 0) (< list_pos_245 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_245)) 0) 18))))
(assert (forall ((list_pos_245 Int)) (=> (and (>= list_pos_245 0) (< list_pos_245 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_245)) 0) 47))))
(assert (forall ((list_pos_245 Int)) (=> (and (>= list_pos_245 0) (< list_pos_245 (list.length.string x))) (or (= x (cons "hubibexuratezixekyl" (cons "todot" (as nil (List String))))) (= x (cons "mochokyhyzylethy" (cons "we" (as nil (List String))))) (= x (cons "sygymithajyhu" (cons "byziruchocetextyram" (cons "thizupesakocami" (as nil (List String))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) ((as cons (List String)) "mochokyhyzylethy" ((as cons (List String)) "we" (as nil (List String)))))
)

Could not find any solution for puzzle NarrowerList:3
Too many constants for extrapolation

Solving puzzle 251/732: NarrowerList:4
sat_func def sat(li: List[str], lists=[['r', 'datucykokegyquazyta', 'gytextevavasochub'], ['faryjav', 'textebyquyho']]):
    width = sum(len(s) for s in li)
    for li2 in lists:
        assert width <= sum(len(s) for s in li2)
    return li in lists
modified_func def sat(li: List[str], lists=wrap_list([wrap_list([wrap_str('r'), wrap_str('datucykokegyquazyta'), wrap_str('gytextevavasochub')]), wrap_list([wrap_str('faryjav'), wrap_str('textebyquyho')])])):
    width = sym_sum(sym_generator((sym_len(s) for s in li)))
    for li2 in lists:
        _assert(width <= sym_sum(sym_generator((sym_len(s) for s in li2))))
    return sym_in(li, lists)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_246 Int)) (=> (and (>= list_pos_246 0) (< list_pos_246 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_246)) 0) 37))))
(assert (forall ((list_pos_246 Int)) (=> (and (>= list_pos_246 0) (< list_pos_246 (list.length.string x))) (<= (+ (str.len (list.get.string x list_pos_246)) 0) 19))))
(assert (forall ((list_pos_246 Int)) (=> (and (>= list_pos_246 0) (< list_pos_246 (list.length.string x))) (or (= x (cons "r" (cons "datucykokegyquazyta" (cons "gytextevavasochub" (as nil (List String)))))) (= x (cons "faryjav" (cons "textebyquyho" (as nil (List String)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) ((as cons (List String)) "r" ((as cons (List String)) "datucykokegyquazyta" ((as cons (List String)) "gytextevavasochub" (as nil (List String))))))
)

Could not find any solution for puzzle NarrowerList:4
Too many constants for extrapolation

Solving puzzle 252/732: NearbyDuplicates:0
sat_func def sat(indices: List[int], s="I am an unhappy string!"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
modified_func def sat(indices: List[int], s=wrap_str('I am an unhappy string!')):
    i, j = indices
    return (s[i] == s[j]).__and__((wrap_int(0) <= i).__and__(i < j).__and__(j < i + wrap_int(3)))
Exception -- for puzzle NearbyDuplicates:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 253/732: NearbyDuplicates:1
sat_func def sat(indices: List[int], s="aeEm%%uIV0imR&xUvQvZf#1z4"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
modified_func def sat(indices: List[int], s=wrap_str('aeEm%%uIV0imR&xUvQvZf#1z4')):
    i, j = indices
    return (s[i] == s[j]).__and__((wrap_int(0) <= i).__and__(i < j).__and__(j < i + wrap_int(3)))
Exception -- for puzzle NearbyDuplicates:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 254/732: NearbyDuplicates:2
sat_func def sat(indices: List[int], s="e&S|C;;b1Nf[mmsQrQY"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
modified_func def sat(indices: List[int], s=wrap_str('e&S|C;;b1Nf[mmsQrQY')):
    i, j = indices
    return (s[i] == s[j]).__and__((wrap_int(0) <= i).__and__(i < j).__and__(j < i + wrap_int(3)))
Exception -- for puzzle NearbyDuplicates:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 255/732: NearbyDuplicates:3
sat_func def sat(indices: List[int], s="?EaEc/oDAm(i gP"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
modified_func def sat(indices: List[int], s=wrap_str('?EaEc/oDAm(i gP')):
    i, j = indices
    return (s[i] == s[j]).__and__((wrap_int(0) <= i).__and__(i < j).__and__(j < i + wrap_int(3)))
Exception -- for puzzle NearbyDuplicates:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 256/732: NearbyDuplicates:4
sat_func def sat(indices: List[int], s="pXw|EEcTKZ;:n[-tBME[[sn%fR37l;bM,t%!"):
    i, j = indices
    return s[i] == s[j] and 0 <= i < j < i + 3
modified_func def sat(indices: List[int], s=wrap_str('pXw|EEcTKZ;:n[-tBME[[sn%fR37l;bM,t%!')):
    i, j = indices
    return (s[i] == s[j]).__and__((wrap_int(0) <= i).__and__(i < j).__and__(j < i + wrap_int(3)))
Exception -- for puzzle NearbyDuplicates:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 257/732: Grader:0
sat_func def sat(grades: List[str], gpas=[2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
modified_func def sat(grades: List[str], gpas=wrap_list([2.8, 3.1, 4.0, 2.2, 3.1, 2.5, 0.9])):
    _assert(sym_len(grades) == sym_len(gpas))
    letters = wrap_list([wrap_str('A+'), wrap_str('A'), wrap_str('A-'), wrap_str('B+'), wrap_str('B'), wrap_str('B-'), wrap_str('C+'), wrap_str('C'), wrap_str('C-'), wrap_str('F')])
    scores = wrap_list([4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0])
    for grade, gpa in sym_zip(grades, gpas):
        i = letters.index(grade)
        _assert(gpa >= scores[i])
        _assert((i == wrap_int(0)).__or__(gpa <= scores[i - wrap_int(1)]))
    return True
Exception -- for puzzle Grader:0 'float' object has no attribute 'z3_expr'

Solving puzzle 258/732: Grader:1
sat_func def sat(grades: List[str], gpas=[3.9759656717898215, 2.532507032264099, 3.695549189812313, 2.492545757546573, 0.9653857771911838, 1.619680869536884]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
modified_func def sat(grades: List[str], gpas=wrap_list([3.9759656717898215, 2.532507032264099, 3.695549189812313, 2.492545757546573, 0.9653857771911838, 1.619680869536884])):
    _assert(sym_len(grades) == sym_len(gpas))
    letters = wrap_list([wrap_str('A+'), wrap_str('A'), wrap_str('A-'), wrap_str('B+'), wrap_str('B'), wrap_str('B-'), wrap_str('C+'), wrap_str('C'), wrap_str('C-'), wrap_str('F')])
    scores = wrap_list([4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0])
    for grade, gpa in sym_zip(grades, gpas):
        i = letters.index(grade)
        _assert(gpa >= scores[i])
        _assert((i == wrap_int(0)).__or__(gpa <= scores[i - wrap_int(1)]))
    return True
Exception -- for puzzle Grader:1 'float' object has no attribute 'z3_expr'

Solving puzzle 259/732: Grader:2
sat_func def sat(grades: List[str], gpas=[1.0670062946539565]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
modified_func def sat(grades: List[str], gpas=wrap_list([1.0670062946539565])):
    _assert(sym_len(grades) == sym_len(gpas))
    letters = wrap_list([wrap_str('A+'), wrap_str('A'), wrap_str('A-'), wrap_str('B+'), wrap_str('B'), wrap_str('B-'), wrap_str('C+'), wrap_str('C'), wrap_str('C-'), wrap_str('F')])
    scores = wrap_list([4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0])
    for grade, gpa in sym_zip(grades, gpas):
        i = letters.index(grade)
        _assert(gpa >= scores[i])
        _assert((i == wrap_int(0)).__or__(gpa <= scores[i - wrap_int(1)]))
    return True
Exception -- for puzzle Grader:2 'float' object has no attribute 'z3_expr'

Solving puzzle 260/732: Grader:3
sat_func def sat(grades: List[str], gpas=[]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
modified_func def sat(grades: List[str], gpas=wrap_list([])):
    _assert(sym_len(grades) == sym_len(gpas))
    letters = wrap_list([wrap_str('A+'), wrap_str('A'), wrap_str('A-'), wrap_str('B+'), wrap_str('B'), wrap_str('B-'), wrap_str('C+'), wrap_str('C'), wrap_str('C-'), wrap_str('F')])
    scores = wrap_list([4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0])
    for grade, gpa in sym_zip(grades, gpas):
        i = letters.index(grade)
        _assert(gpa >= scores[i])
        _assert((i == wrap_int(0)).__or__(gpa <= scores[i - wrap_int(1)]))
    return True
Exception -- for puzzle Grader:3 'float' object has no attribute 'z3_expr'

Solving puzzle 261/732: Grader:4
sat_func def sat(grades: List[str], gpas=[2.7731700871871414, 0.5127907383392896]):
    assert len(grades) == len(gpas)
    letters = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'F']
    scores = [4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0]
    for grade, gpa in zip(grades, gpas):
        i = letters.index(grade)
        assert gpa >= scores[i]
        assert i == 0 or gpa <= scores[i - 1]
    return True
modified_func def sat(grades: List[str], gpas=wrap_list([2.7731700871871414, 0.5127907383392896])):
    _assert(sym_len(grades) == sym_len(gpas))
    letters = wrap_list([wrap_str('A+'), wrap_str('A'), wrap_str('A-'), wrap_str('B+'), wrap_str('B'), wrap_str('B-'), wrap_str('C+'), wrap_str('C'), wrap_str('C-'), wrap_str('F')])
    scores = wrap_list([4.0, 3.7, 3.4, 3.0, 2.7, 2.4, 2.0, 1.7, 1.4, 0.0])
    for grade, gpa in sym_zip(grades, gpas):
        i = letters.index(grade)
        _assert(gpa >= scores[i])
        _assert((i == wrap_int(0)).__or__(gpa <= scores[i - wrap_int(1)]))
    return True
Exception -- for puzzle Grader:4 'float' object has no attribute 'z3_expr'

Solving puzzle 262/732: OneEnded:0
sat_func def sat(nums: List[int], n=5):
    count = 18 * (10 ** (n - 2)) if n > 1 else 1
    strs = {str(n) for n in nums}
    return len(strs) == count and all(s.startswith("1") or s.endswith("1") and len(s) == n for s in strs)
modified_func def sat(nums: List[int], n=wrap_int(5)):
    count = wrap_int(18) * wrap_int(10) ** (n - wrap_int(2)) if n > wrap_int(1) else wrap_int(1)
    strs = {sym_str(n) for n in nums}
    return (sym_len(strs) == count).__and__(all(sym_generator((s.startswith('1').__or__(s.endswith(wrap_str('1')).__and__(sym_len(s) == n)) for s in strs))))
Exception -- for puzzle OneEnded:0 Symbolic hash not yet implemented

Solving puzzle 263/732: UpDownSort:0
sat_func def sat(up_down: List[int], nums=[17, 2, 3, 523, 18, -2, 0, 2, -1]):
    assert all(up_down.count(i) == nums.count(i) for i in set(up_down + nums)), "not a reordering"
    increasing_sign = 1 if ((nums[0] + nums[-1]) % 2 == 1) else -1
    return all((up_down[i + 1] - up_down[i]) * increasing_sign >= 0 for i in range(len(up_down) - 1))
modified_func def sat(up_down: List[int], nums=wrap_list([wrap_int(17), wrap_int(2), wrap_int(3), wrap_int(523), wrap_int(18), -wrap_int(2), wrap_int(0), wrap_int(2), -wrap_int(1)])):
    _assert(all(sym_generator((up_down.count(i) == nums.count(i) for i in set(up_down + nums)))), wrap_str('not a reordering'))
    increasing_sign = wrap_int(1) if (nums[wrap_int(0)] + nums[-wrap_int(1)]) % wrap_int(2) == wrap_int(1) else -wrap_int(1)
    return all(sym_generator(((up_down[i + wrap_int(1)] - up_down[i]) * increasing_sign >= wrap_int(0) for i in sym_range(sym_len(up_down) - 1))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_253 Int)) (=> (and (>= list_pos_253 0) (< list_pos_253 (list.length.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 523 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int))))))))))))))) (= (list.count.int x (list.get.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 523 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int)))))))))))) list_pos_253)) (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 17 (list.get.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 523 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int)))))))))))) list_pos_253)) 1 0) (ite (= 2 (list.get.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 523 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int)))))))))))) list_pos_253)) 1 0)) (ite (= 3 (list.get.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 523 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int)))))))))))) list_pos_253)) 1 0)) (ite (= 523 (list.get.int (list.append.int x (cons 17 ...
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (forall ((list_pos_253 Int)) (=> (and (>= list_pos_253 0) (< list_pos_253 (list.length.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 523 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int))))))))))))))) (>= (* (- (list.get.int x (+ i_0 1)) (list.get.int x i_0)) -1) 0))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) (- 1) (as nil (List Int))))
)

Could not find any solution for puzzle UpDownSort:0
One large constant for extrapolation
Solving simpler variation replaced 523 with 3
sat_func def sat(up_down: List[int], nums=[17, 2, 3, 3, 18, -2, 0, 2, -1]):
    assert all(up_down.count(i) == nums.count(i) for i in set(up_down + nums)), "not a reordering"
    increasing_sign = 1 if ((nums[0] + nums[-1]) % 2 == 1) else -1
    return all((up_down[i + 1] - up_down[i]) * increasing_sign >= 0 for i in range(len(up_down) - 1))
modified_func def sat(up_down: List[int], nums=wrap_list([wrap_int(17), wrap_int(2), wrap_int(3), wrap_int(3), wrap_int(18), -wrap_int(2), wrap_int(0), wrap_int(2), -wrap_int(1)])):
    _assert(all(sym_generator((up_down.count(i) == nums.count(i) for i in set(up_down + nums)))), wrap_str('not a reordering'))
    increasing_sign = wrap_int(1) if (nums[wrap_int(0)] + nums[-wrap_int(1)]) % wrap_int(2) == wrap_int(1) else -wrap_int(1)
    return all(sym_generator(((up_down[i + wrap_int(1)] - up_down[i]) * increasing_sign >= wrap_int(0) for i in sym_range(sym_len(up_down) - 1))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_254 Int)) (=> (and (>= list_pos_254 0) (< list_pos_254 (list.length.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 3 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int))))))))))))))) (= (list.count.int x (list.get.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 3 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int)))))))))))) list_pos_254)) (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 17 (list.get.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 3 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int)))))))))))) list_pos_254)) 1 0) (ite (= 2 (list.get.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 3 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int)))))))))))) list_pos_254)) 1 0)) (ite (= 3 (list.get.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 3 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int)))))))))))) list_pos_254)) 1 0)) (ite (= 3 (list.get.int (list.append.int x (cons 17 (cons 2 (con...
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (forall ((list_pos_254 Int)) (=> (and (>= list_pos_254 0) (< list_pos_254 (list.length.int (list.append.int x (cons 17 (cons 2 (cons 3 (cons 3 (cons 18 (cons -2 (cons 0 (cons 2 (cons -1 (as nil (List Int))))))))))))))) (>= (* (- (list.get.int x (+ i_0 1)) (list.get.int x i_0)) -1) 0))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) (- 1) (as nil (List Int))))
)

Could not find any solution for puzzle UpDownSort:0

Solving puzzle 264/732: FindBored:0
sat_func def sat(boring: List[str], text="This is not boring. I am boring! I am sooo tired."):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
modified_func def sat(boring: List[str], text=wrap_str('This is not boring. I am boring! I am sooo tired.')):
    sentences = text.replace(wrap_str('!'), wrap_str('.')).replace(wrap_str('?'), wrap_str('.')).split(wrap_str('.'))
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != wrap_list([wrap_str('I')])]
    return sym_sorted(boring_and_exciting) == sym_sorted(sentences)
Exception -- for puzzle FindBored:0 'list' object has no attribute 'z3_expr'

Solving puzzle 265/732: FindBored:1
sat_func def sat(boring: List[str], text="dexuzuhyfac lifugerimosiwybot.hesukawycat!hawymemof pa text z.nuquyt weminubadithikanat gejetextipafex vobenekothob.reraxithechaquipapav wexamew lobihus zygijehequesatextacy jucyth?I?I wevymicygequipi cicemyte tha cetexti vuhoxadivelabyduxix?I lanusutho kuzit?nathor sopati myjamygukiwyhuje.I kacuquedewapojedu thulocho?I chezeri.thubitozogukenejugox.cytonoc tex tobaquy wiwithij!vinam rarile sibizytexta notaxithyzu?"):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
modified_func def sat(boring: List[str], text=wrap_str('dexuzuhyfac lifugerimosiwybot.hesukawycat!hawymemof pa text z.nuquyt weminubadithikanat gejetextipafex vobenekothob.reraxithechaquipapav wexamew lobihus zygijehequesatextacy jucyth?I?I wevymicygequipi cicemyte tha cetexti vuhoxadivelabyduxix?I lanusutho kuzit?nathor sopati myjamygukiwyhuje.I kacuquedewapojedu thulocho?I chezeri.thubitozogukenejugox.cytonoc tex tobaquy wiwithij!vinam rarile sibizytexta notaxithyzu?')):
    sentences = text.replace(wrap_str('!'), wrap_str('.')).replace(wrap_str('?'), wrap_str('.')).split(wrap_str('.'))
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != wrap_list([wrap_str('I')])]
    return sym_sorted(boring_and_exciting) == sym_sorted(sentences)
Exception -- for puzzle FindBored:1 'list' object has no attribute 'z3_expr'

Solving puzzle 266/732: FindBored:2
sat_func def sat(boring: List[str], text=""):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
modified_func def sat(boring: List[str], text=wrap_str('')):
    sentences = text.replace(wrap_str('!'), wrap_str('.')).replace(wrap_str('?'), wrap_str('.')).split(wrap_str('.'))
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != wrap_list([wrap_str('I')])]
    return sym_sorted(boring_and_exciting) == sym_sorted(sentences)
Exception -- for puzzle FindBored:2 'list' object has no attribute 'z3_expr'

Solving puzzle 267/732: FindBored:3
sat_func def sat(boring: List[str], text="nysydajywigi vefusivechucirochuw tipeko pogofinifyk.I textovugythecodo ruwatekat dane wachikechanequi matupisofunehac.tubicetofalat colawuhemedexeq lurytext?"):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
modified_func def sat(boring: List[str], text=wrap_str('nysydajywigi vefusivechucirochuw tipeko pogofinifyk.I textovugythecodo ruwatekat dane wachikechanequi matupisofunehac.tubicetofalat colawuhemedexeq lurytext?')):
    sentences = text.replace(wrap_str('!'), wrap_str('.')).replace(wrap_str('?'), wrap_str('.')).split(wrap_str('.'))
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != wrap_list([wrap_str('I')])]
    return sym_sorted(boring_and_exciting) == sym_sorted(sentences)
Exception -- for puzzle FindBored:3 'list' object has no attribute 'z3_expr'

Solving puzzle 268/732: FindBored:4
sat_func def sat(boring: List[str], text="?zihithi ch chithe vuluzuquidawyquo.I?I chypufomiwylojen ziwuwygawyfyg makatex?textidigefoc nyjav.I gujyduvafe gykizubam cofurythoc.coc thohifycepy tex kybiwulatextux."):
    sentences = text.replace("!", ".").replace("?", ".").split(".")
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != ["I"]]
    return sorted(boring_and_exciting) == sorted(sentences)
modified_func def sat(boring: List[str], text=wrap_str('?zihithi ch chithe vuluzuquidawyquo.I?I chypufomiwylojen ziwuwygawyfyg makatex?textidigefoc nyjav.I gujyduvafe gykizubam cofurythoc.coc thohifycepy tex kybiwulatextux.')):
    sentences = text.replace(wrap_str('!'), wrap_str('.')).replace(wrap_str('?'), wrap_str('.')).split(wrap_str('.'))
    boring_and_exciting = boring + [s for s in sentences if s.split()[:1] != wrap_list([wrap_str('I')])]
    return sym_sorted(boring_and_exciting) == sym_sorted(sentences)
Exception -- for puzzle FindBored:4 'list' object has no attribute 'z3_expr'

Solving puzzle 269/732: LargestPrimeDigitSum:0
sat_func def sat(ans: List[int], nums=[23, 17, 201, 14, 10473, 43225, 421, 423, 11, 10, 2022, 342157]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
modified_func def sat(ans: List[int], nums=wrap_list([wrap_int(23), wrap_int(17), wrap_int(201), wrap_int(14), wrap_int(10473), wrap_int(43225), wrap_int(421), wrap_int(423), wrap_int(11), wrap_int(10), wrap_int(2022), wrap_int(342157)])):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    return is_prime(n).__and__(all(sym_generator((m <= n for m in nums if is_prime(m))))).__and__(digit_sum == sym_sum(sym_generator((sym_int(c) for c in sym_str(n)))))
Exception -- for puzzle LargestPrimeDigitSum:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 270/732: LargestPrimeDigitSum:1
sat_func def sat(ans: List[int], nums=[84545, 52, 5755523, 666, 1984, 97315, 7, 3, 789, 427]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
modified_func def sat(ans: List[int], nums=wrap_list([wrap_int(84545), wrap_int(52), wrap_int(5755523), wrap_int(666), wrap_int(1984), wrap_int(97315), wrap_int(7), wrap_int(3), wrap_int(789), wrap_int(427)])):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    return is_prime(n).__and__(all(sym_generator((m <= n for m in nums if is_prime(m))))).__and__(digit_sum == sym_sum(sym_generator((sym_int(c) for c in sym_str(n)))))
Exception -- for puzzle LargestPrimeDigitSum:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 271/732: LargestPrimeDigitSum:2
sat_func def sat(ans: List[int], nums=[5, 7151804, 432154, 5700, 9, 8, 253, 29062, 960, 721]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
modified_func def sat(ans: List[int], nums=wrap_list([wrap_int(5), wrap_int(7151804), wrap_int(432154), wrap_int(5700), wrap_int(9), wrap_int(8), wrap_int(253), wrap_int(29062), wrap_int(960), wrap_int(721)])):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    return is_prime(n).__and__(all(sym_generator((m <= n for m in nums if is_prime(m))))).__and__(digit_sum == sym_sum(sym_generator((sym_int(c) for c in sym_str(n)))))
Exception -- for puzzle LargestPrimeDigitSum:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 272/732: LargestPrimeDigitSum:3
sat_func def sat(ans: List[int], nums=[233804, 41, 6149533, 79, 956, 317909, 8628, 248, 35086, 79]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
modified_func def sat(ans: List[int], nums=wrap_list([wrap_int(233804), wrap_int(41), wrap_int(6149533), wrap_int(79), wrap_int(956), wrap_int(317909), wrap_int(8628), wrap_int(248), wrap_int(35086), wrap_int(79)])):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    return is_prime(n).__and__(all(sym_generator((m <= n for m in nums if is_prime(m))))).__and__(digit_sum == sym_sum(sym_generator((sym_int(c) for c in sym_str(n)))))
Exception -- for puzzle LargestPrimeDigitSum:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 273/732: LargestPrimeDigitSum:4
sat_func def sat(ans: List[int], nums=[87, 2, 2883, 32665, 26115, 32, 77, 97, 717, 674175]):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return n > 1 and all(n % j for j in range(2, int(n ** 0.5) + 1))

    return is_prime(n) and all(m <= n for m in nums if is_prime(m)) and digit_sum == sum(int(c) for c in str(n))
modified_func def sat(ans: List[int], nums=wrap_list([wrap_int(87), wrap_int(2), wrap_int(2883), wrap_int(32665), wrap_int(26115), wrap_int(32), wrap_int(77), wrap_int(97), wrap_int(717), wrap_int(674175)])):
    i, digit_sum = ans
    n = nums[i]

    def is_prime(n):
        return (n > wrap_int(1)).__and__(all(sym_generator((n % j for j in sym_range(2, sym_int(n ** 0.5) + 1)))))
    return is_prime(n).__and__(all(sym_generator((m <= n for m in nums if is_prime(m))))).__and__(digit_sum == sym_sum(sym_generator((sym_int(c) for c in sym_str(n)))))
Exception -- for puzzle LargestPrimeDigitSum:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 274/732: PrimesUpTo:0
sat_func def sat(primes: List[int], n=1234):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
modified_func def sat(primes: List[int], n=wrap_int(1234)):
    _assert(all(sym_generator((wrap_int(1) < p for p in primes))).__and__(all(sym_generator((p % q for p in primes for q in primes if q < p)))))
    return sym_len({i for p in primes for i in sym_range(p, n, p)}) == max(n - wrap_int(2), wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(assert (forall ((list_pos_262 Int)) (=> (and (>= list_pos_262 0) (< list_pos_262 (list.length.int x))) (forall ((list_pos_261 Int)) (=> (and (>= list_pos_261 0) (< list_pos_261 (list.length.int x))) (forall ((list_pos_260 Int)) (=> (and (>= list_pos_260 0) (< list_pos_260 (list.length.int x))) (=> (< (list.get.int x list_pos_262) (list.get.int x list_pos_261)) (and (< 1 (list.get.int x list_pos_260)) (not (= (mod (list.get.int x list_pos_261) (list.get.int x list_pos_262)) 0)))))))))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_263)) (< i_0 1234)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_263) (* k_1 (list.get.int x list_pos_263))))) (< k_1 (div (- 1234 (list.get.int x list_pos_263)) (list.get.int x list_pos_263)))) (forall ((list_pos_263 Int)) (=> (and (>= list_pos_263 0) (< list_pos_263 (list.length.int x))) (forall ((list_pos_262 Int)) (=> (and (>= list_pos_262 0) (< list_pos_262 (list.length.int x))) (forall ((list_pos_261 Int)) (=> (and (>= list_pos_261 0) (< list_pos_261 (list.length.int x))) (forall ((list_pos_260 Int)) (=> (and (>= list_pos_260 0) (< list_pos_260 (list.length.int x))) (=> (and (< (list.get.int x list_pos_262) (list.get.int x list_pos_261)) (not (= (list.get.int x list_pos_263) 1))) false))))))))))))
(assert (forall ((list_pos_266 Int)) (=> (and (>= list_pos_266 0) (< list_pos_266 (list.length.int x))) (forall ((list_pos_265 Int)) (=> (and (>= list_pos_265 0) (< list_pos_265 (list.length.int x))) (forall ((list_pos_264 Int)) (=> (and (>= list_pos_264 0) (< list_pos_264 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_263)) (< i_0 1234)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_263) (* k_1 (list.get.int x list_pos_263))))) (< k_1 (div (- 1234 (list.get.int x list_pos_263)) (list.get.int x list_pos_263)))) (forall ((list_pos_263 Int)) (=> (and (>= list_pos_263 0) (< list_pos_263 (list.length.int x))) (forall ((list_pos_262 Int)) (=> (and (>= list_pos_262 0) (< list_pos_262 (list.length.int x))) (forall ((list_pos_261 Int)) (=> (and (>= list_pos_261 0) (< list_pos_261 (list.length.int x))) (forall ((list_pos_260 Int)) (=> (and (>= list_pos_260 0) (< list_pos_260 (list.length.int x))) (=> (not (< (list.get.int x list_pos_266) (lis...
(assert (forall ((i_2 Int)) (=> (and (>= i_2 (list.get.int x list_pos_267)) (< i_2 1234)) (forall ((list_pos_267 Int)) (=> (and (>= list_pos_267 0) (< list_pos_267 (list.length.int x))) (forall ((list_pos_266 Int)) (=> (and (>= list_pos_266 0) (< list_pos_266 (list.length.int x))) (forall ((list_pos_265 Int)) (=> (and (>= list_pos_265 0) (< list_pos_265 (list.length.int x))) (forall ((list_pos_264 Int)) (=> (and (>= list_pos_264 0) (< list_pos_264 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_263)) (< i_0 1234)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_263) (* k_1 (list.get.int x list_pos_263))))) (< k_1 (div (- 1234 (list.get.int x list_pos_263)) (list.get.int x list_pos_263)))) (forall ((list_pos_263 Int)) (=> (and (>= list_pos_263 0) (< list_pos_263 (list.length.int x))) (forall ((list_pos_262 Int)) (=> (and (>= list_pos_262 0) (< list_pos_262 (list.length.int x))) (forall ((list_pos_261 Int)) (=> (and (>= list_pos_261 0) (<...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:101.77: Symbol 'list_pos_263' not declared as a variable")

Could not find any solution for puzzle PrimesUpTo:0
One large constant for extrapolation
Solving simpler variation replaced 1234 with 3
sat_func def sat(primes: List[int], n=3):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
modified_func def sat(primes: List[int], n=wrap_int(3)):
    _assert(all(sym_generator((wrap_int(1) < p for p in primes))).__and__(all(sym_generator((p % q for p in primes for q in primes if q < p)))))
    return sym_len({i for p in primes for i in sym_range(p, n, p)}) == max(n - wrap_int(2), wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(assert (forall ((list_pos_270 Int)) (=> (and (>= list_pos_270 0) (< list_pos_270 (list.length.int x))) (forall ((list_pos_269 Int)) (=> (and (>= list_pos_269 0) (< list_pos_269 (list.length.int x))) (forall ((list_pos_268 Int)) (=> (and (>= list_pos_268 0) (< list_pos_268 (list.length.int x))) (=> (< (list.get.int x list_pos_270) (list.get.int x list_pos_269)) (and (< 1 (list.get.int x list_pos_268)) (not (= (mod (list.get.int x list_pos_269) (list.get.int x list_pos_270)) 0)))))))))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_271)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_271) (* k_1 (list.get.int x list_pos_271))))) (< k_1 (div (- 3 (list.get.int x list_pos_271)) (list.get.int x list_pos_271)))) (forall ((list_pos_271 Int)) (=> (and (>= list_pos_271 0) (< list_pos_271 (list.length.int x))) (forall ((list_pos_270 Int)) (=> (and (>= list_pos_270 0) (< list_pos_270 (list.length.int x))) (forall ((list_pos_269 Int)) (=> (and (>= list_pos_269 0) (< list_pos_269 (list.length.int x))) (forall ((list_pos_268 Int)) (=> (and (>= list_pos_268 0) (< list_pos_268 (list.length.int x))) (=> (and (< (list.get.int x list_pos_270) (list.get.int x list_pos_269)) (not (= (list.get.int x list_pos_271) 1))) true))))))))))))
(assert (forall ((list_pos_274 Int)) (=> (and (>= list_pos_274 0) (< list_pos_274 (list.length.int x))) (forall ((list_pos_273 Int)) (=> (and (>= list_pos_273 0) (< list_pos_273 (list.length.int x))) (forall ((list_pos_272 Int)) (=> (and (>= list_pos_272 0) (< list_pos_272 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_271)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_271) (* k_1 (list.get.int x list_pos_271))))) (< k_1 (div (- 3 (list.get.int x list_pos_271)) (list.get.int x list_pos_271)))) (forall ((list_pos_271 Int)) (=> (and (>= list_pos_271 0) (< list_pos_271 (list.length.int x))) (forall ((list_pos_270 Int)) (=> (and (>= list_pos_270 0) (< list_pos_270 (list.length.int x))) (forall ((list_pos_269 Int)) (=> (and (>= list_pos_269 0) (< list_pos_269 (list.length.int x))) (forall ((list_pos_268 Int)) (=> (and (>= list_pos_268 0) (< list_pos_268 (list.length.int x))) (=> (not (< (list.get.int x list_pos_274) (list.get....
(assert (forall ((i_2 Int)) (=> (and (>= i_2 (list.get.int x list_pos_275)) (< i_2 3)) (forall ((list_pos_275 Int)) (=> (and (>= list_pos_275 0) (< list_pos_275 (list.length.int x))) (forall ((list_pos_274 Int)) (=> (and (>= list_pos_274 0) (< list_pos_274 (list.length.int x))) (forall ((list_pos_273 Int)) (=> (and (>= list_pos_273 0) (< list_pos_273 (list.length.int x))) (forall ((list_pos_272 Int)) (=> (and (>= list_pos_272 0) (< list_pos_272 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_271)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_271) (* k_1 (list.get.int x list_pos_271))))) (< k_1 (div (- 3 (list.get.int x list_pos_271)) (list.get.int x list_pos_271)))) (forall ((list_pos_271 Int)) (=> (and (>= list_pos_271 0) (< list_pos_271 (list.length.int x))) (forall ((list_pos_270 Int)) (=> (and (>= list_pos_270 0) (< list_pos_270 (list.length.int x))) (forall ((list_pos_269 Int)) (=> (and (>= list_pos_269 0) (< list_pos...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:101.77: Symbol 'list_pos_271' not declared as a variable")

Could not find any solution for puzzle PrimesUpTo:0

Solving puzzle 275/732: PrimesUpTo:1
sat_func def sat(primes: List[int], n=10):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
modified_func def sat(primes: List[int], n=wrap_int(10)):
    _assert(all(sym_generator((wrap_int(1) < p for p in primes))).__and__(all(sym_generator((p % q for p in primes for q in primes if q < p)))))
    return sym_len({i for p in primes for i in sym_range(p, n, p)}) == max(n - wrap_int(2), wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(assert (forall ((list_pos_278 Int)) (=> (and (>= list_pos_278 0) (< list_pos_278 (list.length.int x))) (forall ((list_pos_277 Int)) (=> (and (>= list_pos_277 0) (< list_pos_277 (list.length.int x))) (forall ((list_pos_276 Int)) (=> (and (>= list_pos_276 0) (< list_pos_276 (list.length.int x))) (=> (< (list.get.int x list_pos_278) (list.get.int x list_pos_277)) (and (< 1 (list.get.int x list_pos_276)) (not (= (mod (list.get.int x list_pos_277) (list.get.int x list_pos_278)) 0)))))))))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_279)) (< i_0 10)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_279) (* k_1 (list.get.int x list_pos_279))))) (< k_1 (div (- 10 (list.get.int x list_pos_279)) (list.get.int x list_pos_279)))) (forall ((list_pos_279 Int)) (=> (and (>= list_pos_279 0) (< list_pos_279 (list.length.int x))) (forall ((list_pos_278 Int)) (=> (and (>= list_pos_278 0) (< list_pos_278 (list.length.int x))) (forall ((list_pos_277 Int)) (=> (and (>= list_pos_277 0) (< list_pos_277 (list.length.int x))) (forall ((list_pos_276 Int)) (=> (and (>= list_pos_276 0) (< list_pos_276 (list.length.int x))) (=> (and (< (list.get.int x list_pos_278) (list.get.int x list_pos_277)) (not (= (list.get.int x list_pos_279) 1))) false))))))))))))
(assert (forall ((list_pos_282 Int)) (=> (and (>= list_pos_282 0) (< list_pos_282 (list.length.int x))) (forall ((list_pos_281 Int)) (=> (and (>= list_pos_281 0) (< list_pos_281 (list.length.int x))) (forall ((list_pos_280 Int)) (=> (and (>= list_pos_280 0) (< list_pos_280 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_279)) (< i_0 10)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_279) (* k_1 (list.get.int x list_pos_279))))) (< k_1 (div (- 10 (list.get.int x list_pos_279)) (list.get.int x list_pos_279)))) (forall ((list_pos_279 Int)) (=> (and (>= list_pos_279 0) (< list_pos_279 (list.length.int x))) (forall ((list_pos_278 Int)) (=> (and (>= list_pos_278 0) (< list_pos_278 (list.length.int x))) (forall ((list_pos_277 Int)) (=> (and (>= list_pos_277 0) (< list_pos_277 (list.length.int x))) (forall ((list_pos_276 Int)) (=> (and (>= list_pos_276 0) (< list_pos_276 (list.length.int x))) (=> (not (< (list.get.int x list_pos_282) (list.ge...
(assert (forall ((i_2 Int)) (=> (and (>= i_2 (list.get.int x list_pos_283)) (< i_2 10)) (forall ((list_pos_283 Int)) (=> (and (>= list_pos_283 0) (< list_pos_283 (list.length.int x))) (forall ((list_pos_282 Int)) (=> (and (>= list_pos_282 0) (< list_pos_282 (list.length.int x))) (forall ((list_pos_281 Int)) (=> (and (>= list_pos_281 0) (< list_pos_281 (list.length.int x))) (forall ((list_pos_280 Int)) (=> (and (>= list_pos_280 0) (< list_pos_280 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_279)) (< i_0 10)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_279) (* k_1 (list.get.int x list_pos_279))))) (< k_1 (div (- 10 (list.get.int x list_pos_279)) (list.get.int x list_pos_279)))) (forall ((list_pos_279 Int)) (=> (and (>= list_pos_279 0) (< list_pos_279 (list.length.int x))) (forall ((list_pos_278 Int)) (=> (and (>= list_pos_278 0) (< list_pos_278 (list.length.int x))) (forall ((list_pos_277 Int)) (=> (and (>= list_pos_277 0) (< list_...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:101.77: Symbol 'list_pos_279' not declared as a variable")

Could not find any solution for puzzle PrimesUpTo:1
Too many constants for extrapolation

Solving puzzle 276/732: PrimesUpTo:2
sat_func def sat(primes: List[int], n=1000):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
modified_func def sat(primes: List[int], n=wrap_int(1000)):
    _assert(all(sym_generator((wrap_int(1) < p for p in primes))).__and__(all(sym_generator((p % q for p in primes for q in primes if q < p)))))
    return sym_len({i for p in primes for i in sym_range(p, n, p)}) == max(n - wrap_int(2), wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(assert (forall ((list_pos_286 Int)) (=> (and (>= list_pos_286 0) (< list_pos_286 (list.length.int x))) (forall ((list_pos_285 Int)) (=> (and (>= list_pos_285 0) (< list_pos_285 (list.length.int x))) (forall ((list_pos_284 Int)) (=> (and (>= list_pos_284 0) (< list_pos_284 (list.length.int x))) (=> (< (list.get.int x list_pos_286) (list.get.int x list_pos_285)) (and (< 1 (list.get.int x list_pos_284)) (not (= (mod (list.get.int x list_pos_285) (list.get.int x list_pos_286)) 0)))))))))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_287)) (< i_0 1000)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_287) (* k_1 (list.get.int x list_pos_287))))) (< k_1 (div (- 1000 (list.get.int x list_pos_287)) (list.get.int x list_pos_287)))) (forall ((list_pos_287 Int)) (=> (and (>= list_pos_287 0) (< list_pos_287 (list.length.int x))) (forall ((list_pos_286 Int)) (=> (and (>= list_pos_286 0) (< list_pos_286 (list.length.int x))) (forall ((list_pos_285 Int)) (=> (and (>= list_pos_285 0) (< list_pos_285 (list.length.int x))) (forall ((list_pos_284 Int)) (=> (and (>= list_pos_284 0) (< list_pos_284 (list.length.int x))) (=> (and (< (list.get.int x list_pos_286) (list.get.int x list_pos_285)) (not (= (list.get.int x list_pos_287) 1))) false))))))))))))
(assert (forall ((list_pos_290 Int)) (=> (and (>= list_pos_290 0) (< list_pos_290 (list.length.int x))) (forall ((list_pos_289 Int)) (=> (and (>= list_pos_289 0) (< list_pos_289 (list.length.int x))) (forall ((list_pos_288 Int)) (=> (and (>= list_pos_288 0) (< list_pos_288 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_287)) (< i_0 1000)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_287) (* k_1 (list.get.int x list_pos_287))))) (< k_1 (div (- 1000 (list.get.int x list_pos_287)) (list.get.int x list_pos_287)))) (forall ((list_pos_287 Int)) (=> (and (>= list_pos_287 0) (< list_pos_287 (list.length.int x))) (forall ((list_pos_286 Int)) (=> (and (>= list_pos_286 0) (< list_pos_286 (list.length.int x))) (forall ((list_pos_285 Int)) (=> (and (>= list_pos_285 0) (< list_pos_285 (list.length.int x))) (forall ((list_pos_284 Int)) (=> (and (>= list_pos_284 0) (< list_pos_284 (list.length.int x))) (=> (not (< (list.get.int x list_pos_290) (lis...
(assert (forall ((i_2 Int)) (=> (and (>= i_2 (list.get.int x list_pos_291)) (< i_2 1000)) (forall ((list_pos_291 Int)) (=> (and (>= list_pos_291 0) (< list_pos_291 (list.length.int x))) (forall ((list_pos_290 Int)) (=> (and (>= list_pos_290 0) (< list_pos_290 (list.length.int x))) (forall ((list_pos_289 Int)) (=> (and (>= list_pos_289 0) (< list_pos_289 (list.length.int x))) (forall ((list_pos_288 Int)) (=> (and (>= list_pos_288 0) (< list_pos_288 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_287)) (< i_0 1000)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_287) (* k_1 (list.get.int x list_pos_287))))) (< k_1 (div (- 1000 (list.get.int x list_pos_287)) (list.get.int x list_pos_287)))) (forall ((list_pos_287 Int)) (=> (and (>= list_pos_287 0) (< list_pos_287 (list.length.int x))) (forall ((list_pos_286 Int)) (=> (and (>= list_pos_286 0) (< list_pos_286 (list.length.int x))) (forall ((list_pos_285 Int)) (=> (and (>= list_pos_285 0) (<...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:101.77: Symbol 'list_pos_287' not declared as a variable")

Could not find any solution for puzzle PrimesUpTo:2
One large constant for extrapolation
Solving simpler variation replaced 1000 with 3
sat_func def sat(primes: List[int], n=3):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
modified_func def sat(primes: List[int], n=wrap_int(3)):
    _assert(all(sym_generator((wrap_int(1) < p for p in primes))).__and__(all(sym_generator((p % q for p in primes for q in primes if q < p)))))
    return sym_len({i for p in primes for i in sym_range(p, n, p)}) == max(n - wrap_int(2), wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(assert (forall ((list_pos_294 Int)) (=> (and (>= list_pos_294 0) (< list_pos_294 (list.length.int x))) (forall ((list_pos_293 Int)) (=> (and (>= list_pos_293 0) (< list_pos_293 (list.length.int x))) (forall ((list_pos_292 Int)) (=> (and (>= list_pos_292 0) (< list_pos_292 (list.length.int x))) (=> (< (list.get.int x list_pos_294) (list.get.int x list_pos_293)) (and (< 1 (list.get.int x list_pos_292)) (not (= (mod (list.get.int x list_pos_293) (list.get.int x list_pos_294)) 0)))))))))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_295)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_295) (* k_1 (list.get.int x list_pos_295))))) (< k_1 (div (- 3 (list.get.int x list_pos_295)) (list.get.int x list_pos_295)))) (forall ((list_pos_295 Int)) (=> (and (>= list_pos_295 0) (< list_pos_295 (list.length.int x))) (forall ((list_pos_294 Int)) (=> (and (>= list_pos_294 0) (< list_pos_294 (list.length.int x))) (forall ((list_pos_293 Int)) (=> (and (>= list_pos_293 0) (< list_pos_293 (list.length.int x))) (forall ((list_pos_292 Int)) (=> (and (>= list_pos_292 0) (< list_pos_292 (list.length.int x))) (=> (and (< (list.get.int x list_pos_294) (list.get.int x list_pos_293)) (not (= (list.get.int x list_pos_295) 1))) true))))))))))))
(assert (forall ((list_pos_298 Int)) (=> (and (>= list_pos_298 0) (< list_pos_298 (list.length.int x))) (forall ((list_pos_297 Int)) (=> (and (>= list_pos_297 0) (< list_pos_297 (list.length.int x))) (forall ((list_pos_296 Int)) (=> (and (>= list_pos_296 0) (< list_pos_296 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_295)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_295) (* k_1 (list.get.int x list_pos_295))))) (< k_1 (div (- 3 (list.get.int x list_pos_295)) (list.get.int x list_pos_295)))) (forall ((list_pos_295 Int)) (=> (and (>= list_pos_295 0) (< list_pos_295 (list.length.int x))) (forall ((list_pos_294 Int)) (=> (and (>= list_pos_294 0) (< list_pos_294 (list.length.int x))) (forall ((list_pos_293 Int)) (=> (and (>= list_pos_293 0) (< list_pos_293 (list.length.int x))) (forall ((list_pos_292 Int)) (=> (and (>= list_pos_292 0) (< list_pos_292 (list.length.int x))) (=> (not (< (list.get.int x list_pos_298) (list.get....
(assert (forall ((i_2 Int)) (=> (and (>= i_2 (list.get.int x list_pos_299)) (< i_2 3)) (forall ((list_pos_299 Int)) (=> (and (>= list_pos_299 0) (< list_pos_299 (list.length.int x))) (forall ((list_pos_298 Int)) (=> (and (>= list_pos_298 0) (< list_pos_298 (list.length.int x))) (forall ((list_pos_297 Int)) (=> (and (>= list_pos_297 0) (< list_pos_297 (list.length.int x))) (forall ((list_pos_296 Int)) (=> (and (>= list_pos_296 0) (< list_pos_296 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_295)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_295) (* k_1 (list.get.int x list_pos_295))))) (< k_1 (div (- 3 (list.get.int x list_pos_295)) (list.get.int x list_pos_295)))) (forall ((list_pos_295 Int)) (=> (and (>= list_pos_295 0) (< list_pos_295 (list.length.int x))) (forall ((list_pos_294 Int)) (=> (and (>= list_pos_294 0) (< list_pos_294 (list.length.int x))) (forall ((list_pos_293 Int)) (=> (and (>= list_pos_293 0) (< list_pos...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:101.77: Symbol 'list_pos_295' not declared as a variable")

Could not find any solution for puzzle PrimesUpTo:2

Solving puzzle 277/732: PrimesUpTo:3
sat_func def sat(primes: List[int], n=-1):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
modified_func def sat(primes: List[int], n=-wrap_int(1)):
    _assert(all(sym_generator((wrap_int(1) < p for p in primes))).__and__(all(sym_generator((p % q for p in primes for q in primes if q < p)))))
    return sym_len({i for p in primes for i in sym_range(p, n, p)}) == max(n - wrap_int(2), wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(assert (forall ((list_pos_302 Int)) (=> (and (>= list_pos_302 0) (< list_pos_302 (list.length.int x))) (forall ((list_pos_301 Int)) (=> (and (>= list_pos_301 0) (< list_pos_301 (list.length.int x))) (forall ((list_pos_300 Int)) (=> (and (>= list_pos_300 0) (< list_pos_300 (list.length.int x))) (=> (< (list.get.int x list_pos_302) (list.get.int x list_pos_301)) (and (< 1 (list.get.int x list_pos_300)) (not (= (mod (list.get.int x list_pos_301) (list.get.int x list_pos_302)) 0)))))))))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_303)) (< i_0 -1)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_303) (* k_1 (list.get.int x list_pos_303))))) (< k_1 (div (- -1 (list.get.int x list_pos_303)) (list.get.int x list_pos_303)))) (forall ((list_pos_303 Int)) (=> (and (>= list_pos_303 0) (< list_pos_303 (list.length.int x))) (forall ((list_pos_302 Int)) (=> (and (>= list_pos_302 0) (< list_pos_302 (list.length.int x))) (forall ((list_pos_301 Int)) (=> (and (>= list_pos_301 0) (< list_pos_301 (list.length.int x))) (forall ((list_pos_300 Int)) (=> (and (>= list_pos_300 0) (< list_pos_300 (list.length.int x))) (=> (and (< (list.get.int x list_pos_302) (list.get.int x list_pos_301)) (not (= (list.get.int x list_pos_303) 1))) false))))))))))))
(assert (forall ((list_pos_306 Int)) (=> (and (>= list_pos_306 0) (< list_pos_306 (list.length.int x))) (forall ((list_pos_305 Int)) (=> (and (>= list_pos_305 0) (< list_pos_305 (list.length.int x))) (forall ((list_pos_304 Int)) (=> (and (>= list_pos_304 0) (< list_pos_304 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_303)) (< i_0 -1)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_303) (* k_1 (list.get.int x list_pos_303))))) (< k_1 (div (- -1 (list.get.int x list_pos_303)) (list.get.int x list_pos_303)))) (forall ((list_pos_303 Int)) (=> (and (>= list_pos_303 0) (< list_pos_303 (list.length.int x))) (forall ((list_pos_302 Int)) (=> (and (>= list_pos_302 0) (< list_pos_302 (list.length.int x))) (forall ((list_pos_301 Int)) (=> (and (>= list_pos_301 0) (< list_pos_301 (list.length.int x))) (forall ((list_pos_300 Int)) (=> (and (>= list_pos_300 0) (< list_pos_300 (list.length.int x))) (=> (not (< (list.get.int x list_pos_306) (list.ge...
(assert (forall ((i_2 Int)) (=> (and (>= i_2 (list.get.int x list_pos_307)) (< i_2 -1)) (forall ((list_pos_307 Int)) (=> (and (>= list_pos_307 0) (< list_pos_307 (list.length.int x))) (forall ((list_pos_306 Int)) (=> (and (>= list_pos_306 0) (< list_pos_306 (list.length.int x))) (forall ((list_pos_305 Int)) (=> (and (>= list_pos_305 0) (< list_pos_305 (list.length.int x))) (forall ((list_pos_304 Int)) (=> (and (>= list_pos_304 0) (< list_pos_304 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_303)) (< i_0 -1)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_303) (* k_1 (list.get.int x list_pos_303))))) (< k_1 (div (- -1 (list.get.int x list_pos_303)) (list.get.int x list_pos_303)))) (forall ((list_pos_303 Int)) (=> (and (>= list_pos_303 0) (< list_pos_303 (list.length.int x))) (forall ((list_pos_302 Int)) (=> (and (>= list_pos_302 0) (< list_pos_302 (list.length.int x))) (forall ((list_pos_301 Int)) (=> (and (>= list_pos_301 0) (< list_...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:101.77: Symbol 'list_pos_303' not declared as a variable")

Could not find any solution for puzzle PrimesUpTo:3
Too many constants for extrapolation

Solving puzzle 278/732: PrimesUpTo:4
sat_func def sat(primes: List[int], n=10000):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
modified_func def sat(primes: List[int], n=wrap_int(10000)):
    _assert(all(sym_generator((wrap_int(1) < p for p in primes))).__and__(all(sym_generator((p % q for p in primes for q in primes if q < p)))))
    return sym_len({i for p in primes for i in sym_range(p, n, p)}) == max(n - wrap_int(2), wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(assert (forall ((list_pos_310 Int)) (=> (and (>= list_pos_310 0) (< list_pos_310 (list.length.int x))) (forall ((list_pos_309 Int)) (=> (and (>= list_pos_309 0) (< list_pos_309 (list.length.int x))) (forall ((list_pos_308 Int)) (=> (and (>= list_pos_308 0) (< list_pos_308 (list.length.int x))) (=> (< (list.get.int x list_pos_310) (list.get.int x list_pos_309)) (and (< 1 (list.get.int x list_pos_308)) (not (= (mod (list.get.int x list_pos_309) (list.get.int x list_pos_310)) 0)))))))))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_311)) (< i_0 10000)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_311) (* k_1 (list.get.int x list_pos_311))))) (< k_1 (div (- 10000 (list.get.int x list_pos_311)) (list.get.int x list_pos_311)))) (forall ((list_pos_311 Int)) (=> (and (>= list_pos_311 0) (< list_pos_311 (list.length.int x))) (forall ((list_pos_310 Int)) (=> (and (>= list_pos_310 0) (< list_pos_310 (list.length.int x))) (forall ((list_pos_309 Int)) (=> (and (>= list_pos_309 0) (< list_pos_309 (list.length.int x))) (forall ((list_pos_308 Int)) (=> (and (>= list_pos_308 0) (< list_pos_308 (list.length.int x))) (=> (and (< (list.get.int x list_pos_310) (list.get.int x list_pos_309)) (not (= (list.get.int x list_pos_311) 1))) false))))))))))))
(assert (forall ((list_pos_314 Int)) (=> (and (>= list_pos_314 0) (< list_pos_314 (list.length.int x))) (forall ((list_pos_313 Int)) (=> (and (>= list_pos_313 0) (< list_pos_313 (list.length.int x))) (forall ((list_pos_312 Int)) (=> (and (>= list_pos_312 0) (< list_pos_312 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_311)) (< i_0 10000)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_311) (* k_1 (list.get.int x list_pos_311))))) (< k_1 (div (- 10000 (list.get.int x list_pos_311)) (list.get.int x list_pos_311)))) (forall ((list_pos_311 Int)) (=> (and (>= list_pos_311 0) (< list_pos_311 (list.length.int x))) (forall ((list_pos_310 Int)) (=> (and (>= list_pos_310 0) (< list_pos_310 (list.length.int x))) (forall ((list_pos_309 Int)) (=> (and (>= list_pos_309 0) (< list_pos_309 (list.length.int x))) (forall ((list_pos_308 Int)) (=> (and (>= list_pos_308 0) (< list_pos_308 (list.length.int x))) (=> (not (< (list.get.int x list_pos_314) (l...
(assert (forall ((i_2 Int)) (=> (and (>= i_2 (list.get.int x list_pos_315)) (< i_2 10000)) (forall ((list_pos_315 Int)) (=> (and (>= list_pos_315 0) (< list_pos_315 (list.length.int x))) (forall ((list_pos_314 Int)) (=> (and (>= list_pos_314 0) (< list_pos_314 (list.length.int x))) (forall ((list_pos_313 Int)) (=> (and (>= list_pos_313 0) (< list_pos_313 (list.length.int x))) (forall ((list_pos_312 Int)) (=> (and (>= list_pos_312 0) (< list_pos_312 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_311)) (< i_0 10000)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_311) (* k_1 (list.get.int x list_pos_311))))) (< k_1 (div (- 10000 (list.get.int x list_pos_311)) (list.get.int x list_pos_311)))) (forall ((list_pos_311 Int)) (=> (and (>= list_pos_311 0) (< list_pos_311 (list.length.int x))) (forall ((list_pos_310 Int)) (=> (and (>= list_pos_310 0) (< list_pos_310 (list.length.int x))) (forall ((list_pos_309 Int)) (=> (and (>= list_pos_309 0)...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:101.77: Symbol 'list_pos_311' not declared as a variable")

Could not find any solution for puzzle PrimesUpTo:4
One large constant for extrapolation
Solving simpler variation replaced 10000 with 3
sat_func def sat(primes: List[int], n=3):
    assert all(1 < p for p in primes) and all(p % q for p in primes for q in primes if q < p)
    return len({i for p in primes for i in range(p, n, p)}) == max(n - 2, 0)
modified_func def sat(primes: List[int], n=wrap_int(3)):
    _assert(all(sym_generator((wrap_int(1) < p for p in primes))).__and__(all(sym_generator((p % q for p in primes for q in primes if q < p)))))
    return sym_len({i for p in primes for i in sym_range(p, n, p)}) == max(n - wrap_int(2), wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(assert (forall ((list_pos_318 Int)) (=> (and (>= list_pos_318 0) (< list_pos_318 (list.length.int x))) (forall ((list_pos_317 Int)) (=> (and (>= list_pos_317 0) (< list_pos_317 (list.length.int x))) (forall ((list_pos_316 Int)) (=> (and (>= list_pos_316 0) (< list_pos_316 (list.length.int x))) (=> (< (list.get.int x list_pos_318) (list.get.int x list_pos_317)) (and (< 1 (list.get.int x list_pos_316)) (not (= (mod (list.get.int x list_pos_317) (list.get.int x list_pos_318)) 0)))))))))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_319)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_319) (* k_1 (list.get.int x list_pos_319))))) (< k_1 (div (- 3 (list.get.int x list_pos_319)) (list.get.int x list_pos_319)))) (forall ((list_pos_319 Int)) (=> (and (>= list_pos_319 0) (< list_pos_319 (list.length.int x))) (forall ((list_pos_318 Int)) (=> (and (>= list_pos_318 0) (< list_pos_318 (list.length.int x))) (forall ((list_pos_317 Int)) (=> (and (>= list_pos_317 0) (< list_pos_317 (list.length.int x))) (forall ((list_pos_316 Int)) (=> (and (>= list_pos_316 0) (< list_pos_316 (list.length.int x))) (=> (and (< (list.get.int x list_pos_318) (list.get.int x list_pos_317)) (not (= (list.get.int x list_pos_319) 1))) true))))))))))))
(assert (forall ((list_pos_322 Int)) (=> (and (>= list_pos_322 0) (< list_pos_322 (list.length.int x))) (forall ((list_pos_321 Int)) (=> (and (>= list_pos_321 0) (< list_pos_321 (list.length.int x))) (forall ((list_pos_320 Int)) (=> (and (>= list_pos_320 0) (< list_pos_320 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_319)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_319) (* k_1 (list.get.int x list_pos_319))))) (< k_1 (div (- 3 (list.get.int x list_pos_319)) (list.get.int x list_pos_319)))) (forall ((list_pos_319 Int)) (=> (and (>= list_pos_319 0) (< list_pos_319 (list.length.int x))) (forall ((list_pos_318 Int)) (=> (and (>= list_pos_318 0) (< list_pos_318 (list.length.int x))) (forall ((list_pos_317 Int)) (=> (and (>= list_pos_317 0) (< list_pos_317 (list.length.int x))) (forall ((list_pos_316 Int)) (=> (and (>= list_pos_316 0) (< list_pos_316 (list.length.int x))) (=> (not (< (list.get.int x list_pos_322) (list.get....
(assert (forall ((i_2 Int)) (=> (and (>= i_2 (list.get.int x list_pos_323)) (< i_2 3)) (forall ((list_pos_323 Int)) (=> (and (>= list_pos_323 0) (< list_pos_323 (list.length.int x))) (forall ((list_pos_322 Int)) (=> (and (>= list_pos_322 0) (< list_pos_322 (list.length.int x))) (forall ((list_pos_321 Int)) (=> (and (>= list_pos_321 0) (< list_pos_321 (list.length.int x))) (forall ((list_pos_320 Int)) (=> (and (>= list_pos_320 0) (< list_pos_320 (list.length.int x))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x list_pos_319)) (< i_0 3)) (>= k_1 0)) (= i_0 (+ (list.get.int x list_pos_319) (* k_1 (list.get.int x list_pos_319))))) (< k_1 (div (- 3 (list.get.int x list_pos_319)) (list.get.int x list_pos_319)))) (forall ((list_pos_319 Int)) (=> (and (>= list_pos_319 0) (< list_pos_319 (list.length.int x))) (forall ((list_pos_318 Int)) (=> (and (>= list_pos_318 0) (< list_pos_318 (list.length.int x))) (forall ((list_pos_317 Int)) (=> (and (>= list_pos_317 0) (< list_pos...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:101.77: Symbol 'list_pos_319' not declared as a variable")

Could not find any solution for puzzle PrimesUpTo:4

Solving puzzle 279/732: UppercaseEven:0
sat_func def sat(positions: List[int], s="ThIs is A tEsT, Or *IS* iT?"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
modified_func def sat(positions: List[int], s=wrap_str('ThIs is A tEsT, Or *IS* iT?')):
    _assert(all(sym_generator((sym_in(s[i], wrap_str('AEIOU')) for i in positions))))
    return all(sym_generator((sym_in(i, positions).__or__(c not in wrap_str('AEIOU')).__or__(i % wrap_int(2) == wrap_int(1)) for i, c in enumerate(s))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_324 Int)) (=> (and (>= list_pos_324 0) (< list_pos_324 (list.length.int x))) (str.contains "AEIOU" (str.substr "ThIs is A tEsT, Or *IS* iT?" (list.get.int x list_pos_324) (- (+ (list.get.int x list_pos_324) 1) (list.get.int x list_pos_324)))))))
(assert (forall ((list_pos_324 Int)) (=> (and (>= list_pos_324 0) (< list_pos_324 (list.length.int x))) (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (or (or (list.contains.int x 0) true) false) (or (or (list.contains.int x 1) true) true)) (or (or (list.contains.int x 2) false) false)) (or (or (list.contains.int x 3) true) true)) (or (or (list.contains.int x 4) true) false)) (or (or (list.contains.int x 5) true) true)) (or (or (list.contains.int x 6) true) false)) (or (or (list.contains.int x 7) true) true)) (or (or (list.contains.int x 8) false) false)) (or (or (list.contains.int x 9) true) true)) (or (or (list.contains.int x 10) true) false)) (or (or (list.contains.int x 11) false) true)) (or (or (list.contains.int x 12) true) false)) (or (or (list.contains.int x 13) true) true)) (or (or (list.contains.int x 14) true) false)) (or (or (list.contains.int x 15) true) true)) (or (or (list.contains.int x 1...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UppercaseEven:0
Too many constants for extrapolation

Solving puzzle 280/732: UppercaseEven:1
sat_func def sat(positions: List[int], s="j"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
modified_func def sat(positions: List[int], s=wrap_str('j')):
    _assert(all(sym_generator((sym_in(s[i], wrap_str('AEIOU')) for i in positions))))
    return all(sym_generator((sym_in(i, positions).__or__(c not in wrap_str('AEIOU')).__or__(i % wrap_int(2) == wrap_int(1)) for i, c in enumerate(s))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_325 Int)) (=> (and (>= list_pos_325 0) (< list_pos_325 (list.length.int x))) (str.contains "AEIOU" (str.substr "j" (list.get.int x list_pos_325) (- (+ (list.get.int x list_pos_325) 1) (list.get.int x list_pos_325)))))))
(assert (forall ((list_pos_325 Int)) (=> (and (>= list_pos_325 0) (< list_pos_325 (list.length.int x))) (or (or (list.contains.int x 0) true) false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UppercaseEven:1
Too many constants for extrapolation

Solving puzzle 281/732: UppercaseEven:2
sat_func def sat(positions: List[int], s="FYZuLOLYcoduHUSA"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
modified_func def sat(positions: List[int], s=wrap_str('FYZuLOLYcoduHUSA')):
    _assert(all(sym_generator((sym_in(s[i], wrap_str('AEIOU')) for i in positions))))
    return all(sym_generator((sym_in(i, positions).__or__(c not in wrap_str('AEIOU')).__or__(i % wrap_int(2) == wrap_int(1)) for i, c in enumerate(s))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_326 Int)) (=> (and (>= list_pos_326 0) (< list_pos_326 (list.length.int x))) (str.contains "AEIOU" (str.substr "FYZuLOLYcoduHUSA" (list.get.int x list_pos_326) (- (+ (list.get.int x list_pos_326) 1) (list.get.int x list_pos_326)))))))
(assert (forall ((list_pos_326 Int)) (=> (and (>= list_pos_326 0) (< list_pos_326 (list.length.int x))) (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (or (or (list.contains.int x 0) true) false) (or (or (list.contains.int x 1) true) true)) (or (or (list.contains.int x 2) true) false)) (or (or (list.contains.int x 3) true) true)) (or (or (list.contains.int x 4) true) false)) (or (or (list.contains.int x 5) false) true)) (or (or (list.contains.int x 6) true) false)) (or (or (list.contains.int x 7) true) true)) (or (or (list.contains.int x 8) true) false)) (or (or (list.contains.int x 9) true) true)) (or (or (list.contains.int x 10) true) false)) (or (or (list.contains.int x 11) true) true)) (or (or (list.contains.int x 12) true) false)) (or (or (list.contains.int x 13) false) true)) (or (or (list.contains.int x 14) true) false)) (or (or (list.contains.int x 15) false) true)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UppercaseEven:2
Too many constants for extrapolation

Solving puzzle 282/732: UppercaseEven:3
sat_func def sat(positions: List[int], s="vEWUquyCo"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
modified_func def sat(positions: List[int], s=wrap_str('vEWUquyCo')):
    _assert(all(sym_generator((sym_in(s[i], wrap_str('AEIOU')) for i in positions))))
    return all(sym_generator((sym_in(i, positions).__or__(c not in wrap_str('AEIOU')).__or__(i % wrap_int(2) == wrap_int(1)) for i, c in enumerate(s))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_327 Int)) (=> (and (>= list_pos_327 0) (< list_pos_327 (list.length.int x))) (str.contains "AEIOU" (str.substr "vEWUquyCo" (list.get.int x list_pos_327) (- (+ (list.get.int x list_pos_327) 1) (list.get.int x list_pos_327)))))))
(assert (forall ((list_pos_327 Int)) (=> (and (>= list_pos_327 0) (< list_pos_327 (list.length.int x))) (and (and (and (and (and (and (and (and (or (or (list.contains.int x 0) true) false) (or (or (list.contains.int x 1) false) true)) (or (or (list.contains.int x 2) true) false)) (or (or (list.contains.int x 3) false) true)) (or (or (list.contains.int x 4) true) false)) (or (or (list.contains.int x 5) true) true)) (or (or (list.contains.int x 6) true) false)) (or (or (list.contains.int x 7) true) true)) (or (or (list.contains.int x 8) true) false)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UppercaseEven:3
Too many constants for extrapolation

Solving puzzle 283/732: UppercaseEven:4
sat_func def sat(positions: List[int], s="JUtARefAzeVyruJEvAKy"):
    assert all(s[i] in "AEIOU" for i in positions)
    return all(i in positions or c not in "AEIOU" or i % 2 == 1 for i, c in enumerate(s))
modified_func def sat(positions: List[int], s=wrap_str('JUtARefAzeVyruJEvAKy')):
    _assert(all(sym_generator((sym_in(s[i], wrap_str('AEIOU')) for i in positions))))
    return all(sym_generator((sym_in(i, positions).__or__(c not in wrap_str('AEIOU')).__or__(i % wrap_int(2) == wrap_int(1)) for i, c in enumerate(s))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_328 Int)) (=> (and (>= list_pos_328 0) (< list_pos_328 (list.length.int x))) (str.contains "AEIOU" (str.substr "JUtARefAzeVyruJEvAKy" (list.get.int x list_pos_328) (- (+ (list.get.int x list_pos_328) 1) (list.get.int x list_pos_328)))))))
(assert (forall ((list_pos_328 Int)) (=> (and (>= list_pos_328 0) (< list_pos_328 (list.length.int x))) (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (or (or (list.contains.int x 0) true) false) (or (or (list.contains.int x 1) false) true)) (or (or (list.contains.int x 2) true) false)) (or (or (list.contains.int x 3) false) true)) (or (or (list.contains.int x 4) true) false)) (or (or (list.contains.int x 5) true) true)) (or (or (list.contains.int x 6) true) false)) (or (or (list.contains.int x 7) false) true)) (or (or (list.contains.int x 8) true) false)) (or (or (list.contains.int x 9) true) true)) (or (or (list.contains.int x 10) true) false)) (or (or (list.contains.int x 11) true) true)) (or (or (list.contains.int x 12) true) false)) (or (or (list.contains.int x 13) true) true)) (or (or (list.contains.int x 14) true) false)) (or (or (list.contains.int x 15) false) true)) (or (or (list.contains.int x 16) true) false)) (or (or (list.con...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle UppercaseEven:4
Too many constants for extrapolation

Solving puzzle 284/732: StonePiles:0
sat_func def sat(li: List[int], n=909):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(909)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 909) (= (list.length.int x) 909)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StonePiles:0
One large constant for extrapolation
Solving simpler variation replaced 909 with 3
sat_func def sat(li: List[int], n=3):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(3)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 3) (= (list.length.int x) 3)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) 4 ((as cons (List Int)) (- 4) (as nil (List Int))))))
)

Found solution [3, 4, -4]
WARNING: Solution verification failed for puzzle StonePiles:0

Solving puzzle 285/732: StonePiles:1
sat_func def sat(li: List[int], n=28694):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(28694)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 28694) (= (list.length.int x) 28694)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StonePiles:1
One large constant for extrapolation
Solving simpler variation replaced 28694 with 3
sat_func def sat(li: List[int], n=3):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(3)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 3) (= (list.length.int x) 3)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) 4 ((as cons (List Int)) (- 4) (as nil (List Int))))))
)

Found solution [3, 4, -4]
WARNING: Solution verification failed for puzzle StonePiles:1

Solving puzzle 286/732: StonePiles:2
sat_func def sat(li: List[int], n=97916):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(97916)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 97916) (= (list.length.int x) 97916)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StonePiles:2
One large constant for extrapolation
Solving simpler variation replaced 97916 with 3
sat_func def sat(li: List[int], n=3):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(3)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 3) (= (list.length.int x) 3)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) 4 ((as cons (List Int)) (- 4) (as nil (List Int))))))
)

Found solution [3, 4, -4]
WARNING: Solution verification failed for puzzle StonePiles:2

Solving puzzle 287/732: StonePiles:3
sat_func def sat(li: List[int], n=57991):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(57991)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 57991) (= (list.length.int x) 57991)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StonePiles:3
One large constant for extrapolation
Solving simpler variation replaced 57991 with 3
sat_func def sat(li: List[int], n=3):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(3)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 3) (= (list.length.int x) 3)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) 4 ((as cons (List Int)) (- 4) (as nil (List Int))))))
)

Found solution [3, 4, -4]
WARNING: Solution verification failed for puzzle StonePiles:3

Solving puzzle 288/732: StonePiles:4
sat_func def sat(li: List[int], n=24997):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(24997)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 24997) (= (list.length.int x) 24997)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StonePiles:4
One large constant for extrapolation
Solving simpler variation replaced 24997 with 3
sat_func def sat(li: List[int], n=3):
    return li[0] == n and len(li) == n and all(b - a == 2 for a, b in zip(li, li[1:]))
modified_func def sat(li: List[int], n=wrap_int(3)):
    return (li[wrap_int(0)] == n).__and__(sym_len(li) == n).__and__(all(sym_generator((b - a == wrap_int(2) for a, b in sym_zip(li, li[1:])))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 3) (= (list.length.int x) 3)) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) 4 ((as cons (List Int)) (- 4) (as nil (List Int))))))
)

Found solution [3, 4, -4]
WARNING: Solution verification failed for puzzle StonePiles:4

Solving puzzle 289/732: SortedOdds:0
sat_func def sat(sub: List[int], nums=[17, 20, -100, 101, 423258, 19949, 0, 20174, 9351773, -11]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
modified_func def sat(sub: List[int], nums=wrap_list([wrap_int(17), wrap_int(20), -wrap_int(100), wrap_int(101), wrap_int(423258), wrap_int(19949), wrap_int(0), wrap_int(20174), wrap_int(9351773), -wrap_int(11)])):
    for i in sym_range(sym_len(sub)):
        n = sub[i]
        _assert(n == min(sub[i:]))
        _assert(all(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(abs(n))))))
        _assert(sub.count(n) == nums.count(n))
    for n in nums:
        if n not in sub:
            _assert(any(sym_generator((sym_int(c) % wrap_int(2) == wrap_int(0) for c in sym_str(abs(n))))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_0) (list.get.int (list.slice.int x i_0 -1 1) list_pos_329)))))))
(assert (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_17)) 0))))))))
(assert (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_17) 10) 2) 0)))))))))
(assert (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_0)) (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 17 (list.get.int x i_0)) 1 0) (ite (= 20 (list.get.int x i_0)) 1 0)) (ite (= -100 (list.get.int x i_0)) 1 0)) (ite (= 101 (list.get.int x i_0)) 1 0)) (ite (= 423258 (list.get.int x i_0)) 1 0)) (ite (= 19949 (list.get.int x i_0)) 1 0)) (ite (= 0 (list.get.int x i_0)) 1 0)) (ite (= 20174 (list.get.int x i_0)) 1 0)) (ite (= 9351773 (list.get.int x i_0)) 1 0)) (ite (= -11 (list.get.int x i_0)) 1 0))))))))))
(assert (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (list.contains.int x 17) (list.contains.int x 20) (list.contains.int x -100) (list.contains.int x 101) (list.contains.int x 423258) (list.contains.int x 19949) (list.contains.int x 0) (list.contains.int x 20174) (list.contains.int x 9351773) (list.contains.int x -11)) true))))))))
(assert (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_1) (list.get.int (list.slice.int x i_1 -1 1) list_pos_330)))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1)))) str_pos_18)) 0))))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1)))) str_pos_18) 10) 2) 0)))))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_1)) (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 17 (list.get.int x i_1)) 1 0) (ite (= 20 (list.get.int x i_1)) 1 0)) (ite (= -100 (list.get.int x i_1)) 1 0)) (ite (= 101 (list.get.int x i_1)) 1 0)) (ite (= 423258 (list.get.int x i...
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (not (list.contains.int x 17)) (or false false)))))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20))) (or true true)))))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100))) (or (or false true) true)))))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100)) (not (list.contains.int x 101))) (or (or false true) false)))))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100)) (not (list.contains.int x 101)) (not (list.contains.int x 423258))) (or (or (or (or (or true true) false) true) false) true)))))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100)) (not (list.contains.int x 101)) (not (list.contains.int x 423258)) (not (list.contains.int x 19949))) (or (or (or (or false false) false) true) false)))))))...
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100)) (not (list.contains.int x 101)) (not (list.contains.int x 423258)) (not (list.contains.int x 19949)) (not (list.contains.int x 0))) true))))))))))))))
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100)) (not (list.contains.int x 101)) (not (list.contains.int x 423258)) (not (list.contains.int x 19949)) (not (list.contains.int x 0)) (not (list.contains.int x...
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100)) (not (list.contains.int x 101)) (not (list.contains.int x 423258)) (not (list.contains.int x 19949)) (not (list.contains.int x 0)) (not (list.contains.int x...
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100)) (not (list.contains.int x 101)) (not (list.contains.int x 423258)) (not (list.contains.int x 19949)) (not (list.contains.int x 0)) (not (list.contains.int x...
(assert (forall ((str_pos_18 Int)) (=> (and (>= str_pos_18 0) (< str_pos_18 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_330 Int)) (=> (and (>= list_pos_330 0) (< list_pos_330 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_17 Int)) (=> (and (>= str_pos_17 0) (< str_pos_17 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_329 Int)) (=> (and (>= list_pos_329 0) (< list_pos_329 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 17)) (not (list.contains.int x 20)) (not (list.contains.int x -100)) (not (list.contains.int x 101)) (not (list.contains.int x 423258)) (not (list.contains.int x 19949)) (not (list.contains.int x 0)) (not (list.contains.int x...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:164.118: Symbol 'i_0' not declared as a variable")

Could not find any solution for puzzle SortedOdds:0
Too many constants for extrapolation

Solving puzzle 290/732: SortedOdds:1
sat_func def sat(sub: List[int], nums=[57463, -919281, 3293, 346, 319386, 14840, -423, 8892, 4689075, -4526385, 5889, 1226706, -5422, 7630106, 74198, 7835, 1050438, 602897]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
modified_func def sat(sub: List[int], nums=wrap_list([wrap_int(57463), -wrap_int(919281), wrap_int(3293), wrap_int(346), wrap_int(319386), wrap_int(14840), -wrap_int(423), wrap_int(8892), wrap_int(4689075), -wrap_int(4526385), wrap_int(5889), wrap_int(1226706), -wrap_int(5422), wrap_int(7630106), wrap_int(74198), wrap_int(7835), wrap_int(1050438), wrap_int(602897)])):
    for i in sym_range(sym_len(sub)):
        n = sub[i]
        _assert(n == min(sub[i:]))
        _assert(all(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(abs(n))))))
        _assert(sub.count(n) == nums.count(n))
    for n in nums:
        if n not in sub:
            _assert(any(sym_generator((sym_int(c) % wrap_int(2) == wrap_int(0) for c in sym_str(abs(n))))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_0) (list.get.int (list.slice.int x i_0 -1 1) list_pos_331)))))))
(assert (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_19)) 0))))))))
(assert (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_19) 10) 2) 0)))))))))
(assert (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_0)) (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 57463 (list.get.int x i_0)) 1 0) (ite (= -919281 (list.get.int x i_0)) 1 0)) (ite (= 3293 (list.get.int x i_0)) 1 0)) (ite (= 346 (list.get.int x i_0)) 1 0)) (ite (= 319386 (list.get.int x i_0)) 1 0)) (ite (= 14840 (list.get.int x i_0)) 1 0)) (ite (= -423 (list.get.int x i_0)) 1 0)) (ite (= 8892 (list.get.int x i_0)) 1 0)) (ite (= 4689075 (list.get.int x i_0)) 1 0)) (ite (= -4526385 (list.get.int x i_0)) 1 0)) (ite (= 5889 (list.get.int x i_0)) 1 0)) (ite (= 1226706 (list.get.int x i_0)) 1 0)) (ite (= -5422 (list.get.i...
(assert (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (list.contains.int x 57463) (list.contains.int x -919281) (list.contains.int x 3293) (list.contains.int x 346) (list.contains.int x 319386) (list.contains.int x 14840) (list.contains.int x -423) (list.contains.int x 8892) (list.contains.int x 4689075) (list.contains.int x -4526385) (list.contains.int x 5889) (list.contains.int x 1226706) (list.contains.int x -5422) (list.contains.int x 7630106) (list.contains.int x 74198) (list.contains.int x 7835) (list.contains.int x 1050438) (list.contains.int x 602897)) true))))))))
(assert (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_1) (list.get.int (list.slice.int x i_1 -1 1) list_pos_332)))))))))))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1)))) str_pos_20)) 0))))))))))))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1)))) str_pos_20) 10) 2) 0)))))))))))))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_1)) (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 57463 (list.get.int x i_1)) 1 0) (ite (= -919281 (list.get.int x i_1)) 1 0)) (ite (= 3293 (list.get.int x i_1)) 1 0)) (ite (= 346 (list.get.int x i_1)) 1 0)) ...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (not (list.contains.int x 57463)) (or (or (or (or false false) true) true) false)))))))))))))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281))) (or (or (or (or (or false false) false) true) true) false)))))))))))))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293))) (or (or (or false true) false) false)))))))))))))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346))) (or (or false true) true)))))))))))))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386))) (or (or (or (or (or false false) false) false) true) true)))))))))))))))
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840))) (or (or (or (or false true) true) true) true))...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423))) (or (or true ...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(assert (forall ((str_pos_20 Int)) (=> (and (>= str_pos_20 0) (< str_pos_20 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_332 Int)) (=> (and (>= list_pos_332 0) (< list_pos_332 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_19 Int)) (=> (and (>= str_pos_19 0) (< str_pos_19 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_331 Int)) (=> (and (>= list_pos_331 0) (< list_pos_331 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 57463)) (not (list.contains.int x -919281)) (not (list.contains.int x 3293)) (not (list.contains.int x 346)) (not (list.contains.int x 319386)) (not (list.contains.int x 14840)) (not (list.contains.int x -423)) (not (list.con...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:164.118: Symbol 'i_0' not declared as a variable")

Could not find any solution for puzzle SortedOdds:1
Too many constants for extrapolation

Solving puzzle 291/732: SortedOdds:2
sat_func def sat(sub: List[int], nums=[0, 7888, -1156983, 67, -304732, 128, -5391, 0, 468568]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
modified_func def sat(sub: List[int], nums=wrap_list([wrap_int(0), wrap_int(7888), -wrap_int(1156983), wrap_int(67), -wrap_int(304732), wrap_int(128), -wrap_int(5391), wrap_int(0), wrap_int(468568)])):
    for i in sym_range(sym_len(sub)):
        n = sub[i]
        _assert(n == min(sub[i:]))
        _assert(all(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(abs(n))))))
        _assert(sub.count(n) == nums.count(n))
    for n in nums:
        if n not in sub:
            _assert(any(sym_generator((sym_int(c) % wrap_int(2) == wrap_int(0) for c in sym_str(abs(n))))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_0) (list.get.int (list.slice.int x i_0 -1 1) list_pos_333)))))))
(assert (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_21)) 0))))))))
(assert (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_21) 10) 2) 0)))))))))
(assert (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_0)) (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 0 (list.get.int x i_0)) 1 0) (ite (= 7888 (list.get.int x i_0)) 1 0)) (ite (= -1156983 (list.get.int x i_0)) 1 0)) (ite (= 67 (list.get.int x i_0)) 1 0)) (ite (= -304732 (list.get.int x i_0)) 1 0)) (ite (= 128 (list.get.int x i_0)) 1 0)) (ite (= -5391 (list.get.int x i_0)) 1 0)) (ite (= 0 (list.get.int x i_0)) 1 0)) (ite (= 468568 (list.get.int x i_0)) 1 0))))))))))
(assert (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (list.contains.int x 0) (list.contains.int x 7888) (list.contains.int x -1156983) (list.contains.int x 67) (list.contains.int x -304732) (list.contains.int x 128) (list.contains.int x -5391) (list.contains.int x 0) (list.contains.int x 468568)) true))))))))
(assert (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_1) (list.get.int (list.slice.int x i_1 -1 1) list_pos_334)))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1)))) str_pos_22)) 0))))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1)))) str_pos_22) 10) 2) 0)))))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_1)) (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 0 (list.get.int x i_1)) 1 0) (ite (= 7888 (list.get.int x i_1)) 1 0)) (ite (= -1156983 (list.get.int x i_1)) 1 0)) (ite (= 67 (list.get.int x i_1)) 1 0)) (ite (= -304732 (list.get.int x...
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (not (list.contains.int x 0)) true))))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888))) (or (or (or false true) true) true)))))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888)) (not (list.contains.int x -1156983))) (or (or (or (or (or (or false false) false) true) false) true) false)))))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888)) (not (list.contains.int x -1156983)) (not (list.contains.int x 67))) (or true false)))))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888)) (not (list.contains.int x -1156983)) (not (list.contains.int x 67)) (not (list.contains.int x -304732))) (or (or (or (or (or false true) true) false) false) true)))))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888)) (not (list.contains.int x -1156983)) (not (list.contains.int x 67)) (not (list.contains.int x -304732)) (not (list.contains.int x 128))) (or (or false true) true)))))))))))))))
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888)) (not (list.contains.int x -1156983)) (not (list.contains.int x 67)) (not (list.contains.int x -304732)) (not (list.contains.int x 128)) (not (list.contains.int x -5391))) (or (or (or false...
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888)) (not (list.contains.int x -1156983)) (not (list.contains.int x 67)) (not (list.contains.int x -304732)) (not (list.contains.int x 128)) (not (list.contains.int x -5391)) (not (list.contain...
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888)) (not (list.contains.int x -1156983)) (not (list.contains.int x 67)) (not (list.contains.int x -304732)) (not (list.contains.int x 128)) (not (list.contains.int x -5391)) (not (list.contain...
(assert (forall ((str_pos_22 Int)) (=> (and (>= str_pos_22 0) (< str_pos_22 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_334 Int)) (=> (and (>= list_pos_334 0) (< list_pos_334 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_21 Int)) (=> (and (>= str_pos_21 0) (< str_pos_21 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_333 Int)) (=> (and (>= list_pos_333 0) (< list_pos_333 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 0)) (not (list.contains.int x 7888)) (not (list.contains.int x -1156983)) (not (list.contains.int x 67)) (not (list.contains.int x -304732)) (not (list.contains.int x 128)) (not (list.contains.int x -5391)) (not (list.contain...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:164.118: Symbol 'i_0' not declared as a variable")

Could not find any solution for puzzle SortedOdds:2
Too many constants for extrapolation

Solving puzzle 292/732: SortedOdds:3
sat_func def sat(sub: List[int], nums=[630253, -40, -8050056, -18536, 5847702, -90469, 290800, 0, -1431502, -5837, -945, 97582, 8673, 2729]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
modified_func def sat(sub: List[int], nums=wrap_list([wrap_int(630253), -wrap_int(40), -wrap_int(8050056), -wrap_int(18536), wrap_int(5847702), -wrap_int(90469), wrap_int(290800), wrap_int(0), -wrap_int(1431502), -wrap_int(5837), -wrap_int(945), wrap_int(97582), wrap_int(8673), wrap_int(2729)])):
    for i in sym_range(sym_len(sub)):
        n = sub[i]
        _assert(n == min(sub[i:]))
        _assert(all(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(abs(n))))))
        _assert(sub.count(n) == nums.count(n))
    for n in nums:
        if n not in sub:
            _assert(any(sym_generator((sym_int(c) % wrap_int(2) == wrap_int(0) for c in sym_str(abs(n))))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_0) (list.get.int (list.slice.int x i_0 -1 1) list_pos_335)))))))
(assert (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_23)) 0))))))))
(assert (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_23) 10) 2) 0)))))))))
(assert (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_0)) (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 630253 (list.get.int x i_0)) 1 0) (ite (= -40 (list.get.int x i_0)) 1 0)) (ite (= -8050056 (list.get.int x i_0)) 1 0)) (ite (= -18536 (list.get.int x i_0)) 1 0)) (ite (= 5847702 (list.get.int x i_0)) 1 0)) (ite (= -90469 (list.get.int x i_0)) 1 0)) (ite (= 290800 (list.get.int x i_0)) 1 0)) (ite (= 0 (list.get.int x i_0)) 1 0)) (ite (= -1431502 (list.get.int x i_0)) 1 0)) (ite (= -5837 (list.get.int x i_0)) 1 0)) (ite (= -945 (list.get.int x i_0)) 1 0)) (ite (= 97582 (list.get.int x i_0)) 1 0)) (ite (= 8673 (list.get.int x i_0)) 1...
(assert (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (list.contains.int x 630253) (list.contains.int x -40) (list.contains.int x -8050056) (list.contains.int x -18536) (list.contains.int x 5847702) (list.contains.int x -90469) (list.contains.int x 290800) (list.contains.int x 0) (list.contains.int x -1431502) (list.contains.int x -5837) (list.contains.int x -945) (list.contains.int x 97582) (list.contains.int x 8673) (list.contains.int x 2729)) true))))))))
(assert (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_1) (list.get.int (list.slice.int x i_1 -1 1) list_pos_336)))))))))))))
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1)))) str_pos_24)) 0))))))))))))))
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1)))) str_pos_24) 10) 2) 0)))))))))))))))
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_1)) (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (+ (ite (= 630253 (list.get.int x i_1)) 1 0) (ite (= -40 (list.get.int x i_1)) 1 0)) (ite (= -8050056 (list.get.int x i_1)) 1 0)) (ite (= -18536 (list.get.int x i_1)) 1 0)) (ite (= ...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (not (list.contains.int x 630253)) (or (or (or (or (or true false) true) true) false) false)))))))))))))))
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40))) (or true true)))))))))))))))
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056))) (or (or (or (or (or (or true true) false) true) true) false) true)))))))))))))))
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536))) (or (or (or (or false true) false) false) true)))))))))))))))
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702))) (or (or (or (or (or (or false true) true) false) false) true) true)))))))))...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469))) (or (or (or (or false true) true) true) ...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800))) (or (...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800)) (not (...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800)) (not (...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800)) (not (...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800)) (not (...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800)) (not (...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800)) (not (...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800)) (not (...
(assert (forall ((str_pos_24 Int)) (=> (and (>= str_pos_24 0) (< str_pos_24 (str.len (str.from_int (ite (>= (list.get.int x i_1) 0) (list.get.int x i_1) (- (list.get.int x i_1))))))) (forall ((list_pos_336 Int)) (=> (and (>= list_pos_336 0) (< list_pos_336 (list.length.int (list.slice.int x i_1 -1 1)))) (forall ((i_1 Int)) (=> (and (>= i_1 0) (< i_1 (list.length.int x))) (forall ((str_pos_23 Int)) (=> (and (>= str_pos_23 0) (< str_pos_23 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_335 Int)) (=> (and (>= list_pos_335 0) (< list_pos_335 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (=> (and (not (list.contains.int x 630253)) (not (list.contains.int x -40)) (not (list.contains.int x -8050056)) (not (list.contains.int x -18536)) (not (list.contains.int x 5847702)) (not (list.contains.int x -90469)) (not (list.contains.int x 290800)) (not (...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:164.118: Symbol 'i_0' not declared as a variable")

Could not find any solution for puzzle SortedOdds:3
Too many constants for extrapolation

Solving puzzle 293/732: SortedOdds:4
sat_func def sat(sub: List[int], nums=[]):
    for i in range(len(sub)):
        n = sub[i]
        assert n == min(sub[i:])
        assert all(int(c) % 2 for c in str(abs(n)))  # all odd digits
        assert sub.count(n) == nums.count(n)

    for n in nums:
        if n not in sub:
            assert any(int(c) % 2 == 0 for c in str(abs(n)))

    return True
modified_func def sat(sub: List[int], nums=wrap_list([])):
    for i in sym_range(sym_len(sub)):
        n = sub[i]
        _assert(n == min(sub[i:]))
        _assert(all(sym_generator((sym_int(c) % wrap_int(2) for c in sym_str(abs(n))))))
        _assert(sub.count(n) == nums.count(n))
    for n in nums:
        if n not in sub:
            _assert(any(sym_generator((sym_int(c) % wrap_int(2) == wrap_int(0) for c in sym_str(abs(n))))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (forall ((list_pos_337 Int)) (=> (and (>= list_pos_337 0) (< list_pos_337 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.get.int x i_0) (list.get.int (list.slice.int x i_0 -1 1) list_pos_337)))))))
(assert (forall ((str_pos_25 Int)) (=> (and (>= str_pos_25 0) (< str_pos_25 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_337 Int)) (=> (and (>= list_pos_337 0) (< list_pos_337 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (> (str.len (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_25)) 0))))))))
(assert (forall ((str_pos_25 Int)) (=> (and (>= str_pos_25 0) (< str_pos_25 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_337 Int)) (=> (and (>= list_pos_337 0) (< list_pos_337 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (not (= (mod (python.int (python.str.at (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0)))) str_pos_25) 10) 2) 0)))))))))
(assert (forall ((str_pos_25 Int)) (=> (and (>= str_pos_25 0) (< str_pos_25 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_337 Int)) (=> (and (>= list_pos_337 0) (< list_pos_337 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) (= (list.count.int x (list.get.int x i_0)) 0))))))))
(assert (forall ((str_pos_25 Int)) (=> (and (>= str_pos_25 0) (< str_pos_25 (str.len (str.from_int (ite (>= (list.get.int x i_0) 0) (list.get.int x i_0) (- (list.get.int x i_0))))))) (forall ((list_pos_337 Int)) (=> (and (>= list_pos_337 0) (< list_pos_337 (list.length.int (list.slice.int x i_0 -1 1)))) (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (list.length.int x))) true)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:164.118: Symbol 'i_0' not declared as a variable")

Could not find any solution for puzzle SortedOdds:4
Too many constants for extrapolation

Solving puzzle 294/732: BackwardsDigits:0
sat_func def sat(backwards_digits: List[str], nums=[0, 2, 14, -2, 3, 8, 4, 5, 5, 7, 21, 101, 41, 2, 9, 6]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
modified_func def sat(backwards_digits: List[str], nums=wrap_list([wrap_int(0), wrap_int(2), wrap_int(14), -wrap_int(2), wrap_int(3), wrap_int(8), wrap_int(4), wrap_int(5), wrap_int(5), wrap_int(7), wrap_int(21), wrap_int(101), wrap_int(41), wrap_int(2), wrap_int(9), wrap_int(6)])):
    digits = {wrap_str('one'): wrap_int(1), wrap_str('two'): wrap_int(2), wrap_str('three'): wrap_int(3), wrap_str('four'): wrap_int(4), wrap_str('five'): wrap_int(5), wrap_str('six'): wrap_int(6), wrap_str('seven'): wrap_int(7), wrap_str('eight'): wrap_int(8), wrap_str('nine'): wrap_int(9)}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        _assert(n == max(li[i:i + 2]))
        _assert(nums.count(n) == li.count(n))
    return all(sym_generator(((n not in sym_range(1, 10)).__or__(sym_in(n, li)) for n in nums)))
Exception -- for puzzle BackwardsDigits:0 Symbolic hash not yet implemented

Solving puzzle 295/732: BackwardsDigits:1
sat_func def sat(backwards_digits: List[str], nums=[98, -3]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
modified_func def sat(backwards_digits: List[str], nums=wrap_list([wrap_int(98), -wrap_int(3)])):
    digits = {wrap_str('one'): wrap_int(1), wrap_str('two'): wrap_int(2), wrap_str('three'): wrap_int(3), wrap_str('four'): wrap_int(4), wrap_str('five'): wrap_int(5), wrap_str('six'): wrap_int(6), wrap_str('seven'): wrap_int(7), wrap_str('eight'): wrap_int(8), wrap_str('nine'): wrap_int(9)}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        _assert(n == max(li[i:i + 2]))
        _assert(nums.count(n) == li.count(n))
    return all(sym_generator(((n not in sym_range(1, 10)).__or__(sym_in(n, li)) for n in nums)))
Exception -- for puzzle BackwardsDigits:1 Symbolic hash not yet implemented

Solving puzzle 296/732: BackwardsDigits:2
sat_func def sat(backwards_digits: List[str], nums=[22, 5, 27, 10, 70, 9, 82, -5, 30, 51, 10, 0, 48]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
modified_func def sat(backwards_digits: List[str], nums=wrap_list([wrap_int(22), wrap_int(5), wrap_int(27), wrap_int(10), wrap_int(70), wrap_int(9), wrap_int(82), -wrap_int(5), wrap_int(30), wrap_int(51), wrap_int(10), wrap_int(0), wrap_int(48)])):
    digits = {wrap_str('one'): wrap_int(1), wrap_str('two'): wrap_int(2), wrap_str('three'): wrap_int(3), wrap_str('four'): wrap_int(4), wrap_str('five'): wrap_int(5), wrap_str('six'): wrap_int(6), wrap_str('seven'): wrap_int(7), wrap_str('eight'): wrap_int(8), wrap_str('nine'): wrap_int(9)}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        _assert(n == max(li[i:i + 2]))
        _assert(nums.count(n) == li.count(n))
    return all(sym_generator(((n not in sym_range(1, 10)).__or__(sym_in(n, li)) for n in nums)))
Exception -- for puzzle BackwardsDigits:2 Symbolic hash not yet implemented

Solving puzzle 297/732: BackwardsDigits:3
sat_func def sat(backwards_digits: List[str], nums=[-5, -3, 9, 1, 93, -1, 4]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
modified_func def sat(backwards_digits: List[str], nums=wrap_list([-wrap_int(5), -wrap_int(3), wrap_int(9), wrap_int(1), wrap_int(93), -wrap_int(1), wrap_int(4)])):
    digits = {wrap_str('one'): wrap_int(1), wrap_str('two'): wrap_int(2), wrap_str('three'): wrap_int(3), wrap_str('four'): wrap_int(4), wrap_str('five'): wrap_int(5), wrap_str('six'): wrap_int(6), wrap_str('seven'): wrap_int(7), wrap_str('eight'): wrap_int(8), wrap_str('nine'): wrap_int(9)}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        _assert(n == max(li[i:i + 2]))
        _assert(nums.count(n) == li.count(n))
    return all(sym_generator(((n not in sym_range(1, 10)).__or__(sym_in(n, li)) for n in nums)))
Exception -- for puzzle BackwardsDigits:3 Symbolic hash not yet implemented

Solving puzzle 298/732: BackwardsDigits:4
sat_func def sat(backwards_digits: List[str], nums=[-1, 3, 75, 86, 70, -5, 31, 5, 62, 6, 92, 60, 29, 5, 7, 3]):
    digits = {"one": 1, "two": 2, "three": 3, "four": 4, "five": 5, "six": 6, "seven": 7, "eight": 8, "nine": 9}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        assert n == max(li[i: i + 2])
        assert nums.count(n) == li.count(n)

    return all(n not in range(1, 10) or n in li for n in nums)
modified_func def sat(backwards_digits: List[str], nums=wrap_list([-wrap_int(1), wrap_int(3), wrap_int(75), wrap_int(86), wrap_int(70), -wrap_int(5), wrap_int(31), wrap_int(5), wrap_int(62), wrap_int(6), wrap_int(92), wrap_int(60), wrap_int(29), wrap_int(5), wrap_int(7), wrap_int(3)])):
    digits = {wrap_str('one'): wrap_int(1), wrap_str('two'): wrap_int(2), wrap_str('three'): wrap_int(3), wrap_str('four'): wrap_int(4), wrap_str('five'): wrap_int(5), wrap_str('six'): wrap_int(6), wrap_str('seven'): wrap_int(7), wrap_str('eight'): wrap_int(8), wrap_str('nine'): wrap_int(9)}
    li = [digits[s] for s in backwards_digits]
    for i, n in enumerate(li):
        _assert(n == max(li[i:i + 2]))
        _assert(nums.count(n) == li.count(n))
    return all(sym_generator(((n not in sym_range(1, 10)).__or__(sym_in(n, li)) for n in nums)))
Exception -- for puzzle BackwardsDigits:4 Symbolic hash not yet implemented

Solving puzzle 299/732: AlternatingFactorials:0
sat_func def sat(li: List[int], n=100):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(100)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 100))
(assert (forall ((list_pos_343 Int)) (=> (and (>= list_pos_343 0) (< list_pos_343 (list.length.int x))) (= (list.get.int x list_pos_343) 1))))
(assert (forall ((list_pos_343 Int)) (=> (and (>= list_pos_343 0) (< list_pos_343 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle AlternatingFactorials:0
One large constant for extrapolation
Solving simpler variation replaced 100 with 3
sat_func def sat(li: List[int], n=3):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(3)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(assert (forall ((list_pos_344 Int)) (=> (and (>= list_pos_344 0) (< list_pos_344 (list.length.int x))) (= (list.get.int x list_pos_344) 1))))
(assert (forall ((list_pos_344 Int)) (=> (and (>= list_pos_344 0) (< list_pos_344 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 (as nil (List Int))))))
)

Could not find any solution for puzzle AlternatingFactorials:0

Solving puzzle 300/732: AlternatingFactorials:1
sat_func def sat(li: List[int], n=997):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(997)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 997))
(assert (forall ((list_pos_345 Int)) (=> (and (>= list_pos_345 0) (< list_pos_345 (list.length.int x))) (= (list.get.int x list_pos_345) 1))))
(assert (forall ((list_pos_345 Int)) (=> (and (>= list_pos_345 0) (< list_pos_345 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle AlternatingFactorials:1
One large constant for extrapolation
Solving simpler variation replaced 997 with 3
sat_func def sat(li: List[int], n=3):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(3)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(assert (forall ((list_pos_346 Int)) (=> (and (>= list_pos_346 0) (< list_pos_346 (list.length.int x))) (= (list.get.int x list_pos_346) 1))))
(assert (forall ((list_pos_346 Int)) (=> (and (>= list_pos_346 0) (< list_pos_346 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 (as nil (List Int))))))
)

Could not find any solution for puzzle AlternatingFactorials:1

Solving puzzle 301/732: AlternatingFactorials:2
sat_func def sat(li: List[int], n=825):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(825)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 825))
(assert (forall ((list_pos_347 Int)) (=> (and (>= list_pos_347 0) (< list_pos_347 (list.length.int x))) (= (list.get.int x list_pos_347) 1))))
(assert (forall ((list_pos_347 Int)) (=> (and (>= list_pos_347 0) (< list_pos_347 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle AlternatingFactorials:2
One large constant for extrapolation
Solving simpler variation replaced 825 with 3
sat_func def sat(li: List[int], n=3):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(3)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(assert (forall ((list_pos_348 Int)) (=> (and (>= list_pos_348 0) (< list_pos_348 (list.length.int x))) (= (list.get.int x list_pos_348) 1))))
(assert (forall ((list_pos_348 Int)) (=> (and (>= list_pos_348 0) (< list_pos_348 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 (as nil (List Int))))))
)

Could not find any solution for puzzle AlternatingFactorials:2

Solving puzzle 302/732: AlternatingFactorials:3
sat_func def sat(li: List[int], n=267):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(267)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 267))
(assert (forall ((list_pos_349 Int)) (=> (and (>= list_pos_349 0) (< list_pos_349 (list.length.int x))) (= (list.get.int x list_pos_349) 1))))
(assert (forall ((list_pos_349 Int)) (=> (and (>= list_pos_349 0) (< list_pos_349 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle AlternatingFactorials:3
One large constant for extrapolation
Solving simpler variation replaced 267 with 3
sat_func def sat(li: List[int], n=3):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(3)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(assert (forall ((list_pos_350 Int)) (=> (and (>= list_pos_350 0) (< list_pos_350 (list.length.int x))) (= (list.get.int x list_pos_350) 1))))
(assert (forall ((list_pos_350 Int)) (=> (and (>= list_pos_350 0) (< list_pos_350 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 (as nil (List Int))))))
)

Could not find any solution for puzzle AlternatingFactorials:3

Solving puzzle 303/732: AlternatingFactorials:4
sat_func def sat(li: List[int], n=576):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(576)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 576))
(assert (forall ((list_pos_351 Int)) (=> (and (>= list_pos_351 0) (< list_pos_351 (list.length.int x))) (= (list.get.int x list_pos_351) 1))))
(assert (forall ((list_pos_351 Int)) (=> (and (>= list_pos_351 0) (< list_pos_351 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle AlternatingFactorials:4
One large constant for extrapolation
Solving simpler variation replaced 576 with 3
sat_func def sat(li: List[int], n=3):
    assert len(li) == n
    for i, m in enumerate(li):
        if i < 2:
            assert m == i + 1
        elif i % 2 == 1:
            assert m == li[i - 2] + i + (i + 1)
        else:
            assert m == li[i - 2] * i * (i + 1)
    return True
modified_func def sat(li: List[int], n=wrap_int(3)):
    _assert(sym_len(li) == n)
    for i, m in enumerate(li):
        if i < wrap_int(2):
            _assert(m == i + wrap_int(1))
        elif i % wrap_int(2) == wrap_int(1):
            _assert(m == li[i - wrap_int(2)] + i + (i + wrap_int(1)))
        else:
            _assert(m == li[i - wrap_int(2)] * i * (i + wrap_int(1)))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(assert (forall ((list_pos_352 Int)) (=> (and (>= list_pos_352 0) (< list_pos_352 (list.length.int x))) (= (list.get.int x list_pos_352) 1))))
(assert (forall ((list_pos_352 Int)) (=> (and (>= list_pos_352 0) (< list_pos_352 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 (as nil (List Int))))))
)

Could not find any solution for puzzle AlternatingFactorials:4

Solving puzzle 304/732: EvenPalindromeNumbers:0
sat_func def sat(pals: List[int], n=1099, count=49):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(1099), count=wrap_int(49)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_354 Int)) (=> (and (>= list_pos_354 0) (< list_pos_354 (list.length.int x))) (forall ((list_pos_353 Int)) (=> (and (>= list_pos_353 0) (< list_pos_353 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_353)) (<= (list.get.int x list_pos_353) 1099)) (= (str.from_int (list.get.int x list_pos_353)) (str.reverse (str.from_int (list.get.int x list_pos_353))))) (= (mod (list.get.int x list_pos_353) 2) 0)) (<= 49 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:0
One large constant for extrapolation
Solving simpler variation replaced 1099 with 3
sat_func def sat(pals: List[int], n=3, count=49):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(3), count=wrap_int(49)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_356 Int)) (=> (and (>= list_pos_356 0) (< list_pos_356 (list.length.int x))) (forall ((list_pos_355 Int)) (=> (and (>= list_pos_355 0) (< list_pos_355 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_355)) (<= (list.get.int x list_pos_355) 3)) (= (str.from_int (list.get.int x list_pos_355)) (str.reverse (str.from_int (list.get.int x list_pos_355))))) (= (mod (list.get.int x list_pos_355) 2) 0)) (<= 49 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:0

Solving puzzle 305/732: EvenPalindromeNumbers:1
sat_func def sat(pals: List[int], n=2737, count=56):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(2737), count=wrap_int(56)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_358 Int)) (=> (and (>= list_pos_358 0) (< list_pos_358 (list.length.int x))) (forall ((list_pos_357 Int)) (=> (and (>= list_pos_357 0) (< list_pos_357 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_357)) (<= (list.get.int x list_pos_357) 2737)) (= (str.from_int (list.get.int x list_pos_357)) (str.reverse (str.from_int (list.get.int x list_pos_357))))) (= (mod (list.get.int x list_pos_357) 2) 0)) (<= 56 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:1
One large constant for extrapolation
Solving simpler variation replaced 2737 with 3
sat_func def sat(pals: List[int], n=3, count=56):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(3), count=wrap_int(56)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_360 Int)) (=> (and (>= list_pos_360 0) (< list_pos_360 (list.length.int x))) (forall ((list_pos_359 Int)) (=> (and (>= list_pos_359 0) (< list_pos_359 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_359)) (<= (list.get.int x list_pos_359) 3)) (= (str.from_int (list.get.int x list_pos_359)) (str.reverse (str.from_int (list.get.int x list_pos_359))))) (= (mod (list.get.int x list_pos_359) 2) 0)) (<= 56 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:1

Solving puzzle 306/732: EvenPalindromeNumbers:2
sat_func def sat(pals: List[int], n=7895, count=79):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(7895), count=wrap_int(79)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_362 Int)) (=> (and (>= list_pos_362 0) (< list_pos_362 (list.length.int x))) (forall ((list_pos_361 Int)) (=> (and (>= list_pos_361 0) (< list_pos_361 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_361)) (<= (list.get.int x list_pos_361) 7895)) (= (str.from_int (list.get.int x list_pos_361)) (str.reverse (str.from_int (list.get.int x list_pos_361))))) (= (mod (list.get.int x list_pos_361) 2) 0)) (<= 79 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:2
One large constant for extrapolation
Solving simpler variation replaced 7895 with 3
sat_func def sat(pals: List[int], n=3, count=79):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(3), count=wrap_int(79)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_364 Int)) (=> (and (>= list_pos_364 0) (< list_pos_364 (list.length.int x))) (forall ((list_pos_363 Int)) (=> (and (>= list_pos_363 0) (< list_pos_363 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_363)) (<= (list.get.int x list_pos_363) 3)) (= (str.from_int (list.get.int x list_pos_363)) (str.reverse (str.from_int (list.get.int x list_pos_363))))) (= (mod (list.get.int x list_pos_363) 2) 0)) (<= 79 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:2

Solving puzzle 307/732: EvenPalindromeNumbers:3
sat_func def sat(pals: List[int], n=2645, count=55):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(2645), count=wrap_int(55)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_366 Int)) (=> (and (>= list_pos_366 0) (< list_pos_366 (list.length.int x))) (forall ((list_pos_365 Int)) (=> (and (>= list_pos_365 0) (< list_pos_365 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_365)) (<= (list.get.int x list_pos_365) 2645)) (= (str.from_int (list.get.int x list_pos_365)) (str.reverse (str.from_int (list.get.int x list_pos_365))))) (= (mod (list.get.int x list_pos_365) 2) 0)) (<= 55 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:3
One large constant for extrapolation
Solving simpler variation replaced 2645 with 3
sat_func def sat(pals: List[int], n=3, count=55):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(3), count=wrap_int(55)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_368 Int)) (=> (and (>= list_pos_368 0) (< list_pos_368 (list.length.int x))) (forall ((list_pos_367 Int)) (=> (and (>= list_pos_367 0) (< list_pos_367 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_367)) (<= (list.get.int x list_pos_367) 3)) (= (str.from_int (list.get.int x list_pos_367)) (str.reverse (str.from_int (list.get.int x list_pos_367))))) (= (mod (list.get.int x list_pos_367) 2) 0)) (<= 55 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:3

Solving puzzle 308/732: EvenPalindromeNumbers:4
sat_func def sat(pals: List[int], n=3173, count=59):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(3173), count=wrap_int(59)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_370 Int)) (=> (and (>= list_pos_370 0) (< list_pos_370 (list.length.int x))) (forall ((list_pos_369 Int)) (=> (and (>= list_pos_369 0) (< list_pos_369 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_369)) (<= (list.get.int x list_pos_369) 3173)) (= (str.from_int (list.get.int x list_pos_369)) (str.reverse (str.from_int (list.get.int x list_pos_369))))) (= (mod (list.get.int x list_pos_369) 2) 0)) (<= 59 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:4
One large constant for extrapolation
Solving simpler variation replaced 3173 with 3
sat_func def sat(pals: List[int], n=3, count=59):
    return all(0 <= i <= n and str(i) == str(i)[::-1] and i % 2 == 0 for i in pals) and len(set(pals)) >= count
modified_func def sat(pals: List[int], n=wrap_int(3), count=wrap_int(59)):
    return all(sym_generator(((wrap_int(0) <= i).__and__(i <= n).__and__(sym_str(i) == sym_str(i)[::-1]).__and__(i % wrap_int(2) == wrap_int(0)) for i in pals))).__and__(sym_len(set(pals)) >= count)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str.reverse ((s String)) String
  (ite (= s "")
       ""
       (str.++ (str.substr s (- (str.len s) 1) 1)
               (str.reverse (str.substr s 0 (- (str.len s) 1))))))

(declare-const x (List Int))
(assert (forall ((list_pos_372 Int)) (=> (and (>= list_pos_372 0) (< list_pos_372 (list.length.int x))) (forall ((list_pos_371 Int)) (=> (and (>= list_pos_371 0) (< list_pos_371 (list.length.int x))) (and (and (and (and (<= 0 (list.get.int x list_pos_371)) (<= (list.get.int x list_pos_371) 3)) (= (str.from_int (list.get.int x list_pos_371)) (str.reverse (str.from_int (list.get.int x list_pos_371))))) (= (mod (list.get.int x list_pos_371) 2) 0)) (<= 59 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle EvenPalindromeNumbers:4

Solving puzzle 309/732: PositiveDigitSums:0
sat_func def sat(pos: List[int], nums=[-804, 9124, -945, 2410, 0, 21, -123]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
modified_func def sat(pos: List[int], nums=wrap_list([-wrap_int(804), wrap_int(9124), -wrap_int(945), wrap_int(2410), wrap_int(0), wrap_int(21), -wrap_int(123)])):
    for n in pos + nums:
        s = sym_str(n)
        if sym_int(s[:2]) + sym_sum(sym_generator((sym_int(c) for c in s[2:]))) <= wrap_int(0):
            _assert(n not in pos)
        else:
            _assert(pos.count(n) == nums.count(n))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x (List Int))
(assert (forall ((list_pos_373 Int)) (=> (and (>= list_pos_373 0) (< list_pos_373 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 0 2)) 0))))
(assert (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373))))))) (forall ((list_pos_373 Int)) (=> (and (>= list_pos_373 0) (< list_pos_373 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (> (str.len (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as n...
(assert (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373))))))) (forall ((list_pos_373 Int)) (=> (and (>= list_pos_373 0) (< list_pos_373 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -...
(assert (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373))))))) (forall ((list_pos_373 Int)) (=> (and (>= list_pos_373 0) (< list_pos_373 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -...
(assert (forall ((list_pos_374 Int)) (=> (and (>= list_pos_374 0) (< list_pos_374 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373))))))) (forall ((list_pos_373 Int)) (=> (and (>= list_pos_373 0) (< list_pos_373 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 ...
(assert (forall ((str_pos_27 Int)) (=> (and (>= str_pos_27 0) (< str_pos_27 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_374)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_374))))))) (forall ((list_pos_374 Int)) (=> (and (>= list_pos_374 0) (< list_pos_374 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons...
(assert (forall ((str_pos_27 Int)) (=> (and (>= str_pos_27 0) (< str_pos_27 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_374)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_374))))))) (forall ((list_pos_374 Int)) (=> (and (>= list_pos_374 0) (< list_pos_374 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons...
(assert (forall ((str_pos_27 Int)) (=> (and (>= str_pos_27 0) (< str_pos_27 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_374)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_374))))))) (forall ((list_pos_374 Int)) (=> (and (>= list_pos_374 0) (< list_pos_374 (list.length.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int))))))))))))) (forall ((str_pos_26 Int)) (=> (and (>= str_pos_26 0) (< str_pos_26 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons -945 (cons 2410 (cons 0 (cons 21 (cons -123 (as nil (List Int)))))))))) list_pos_373)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons -804 (cons 9124 (cons...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:132.252: Symbol 'list_pos_373' not declared as a variable")

Could not find any solution for puzzle PositiveDigitSums:0
Too many constants for extrapolation

Solving puzzle 310/732: PositiveDigitSums:1
sat_func def sat(pos: List[int], nums=[3885, -46840, -82208, 35161, -84028]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
modified_func def sat(pos: List[int], nums=wrap_list([wrap_int(3885), -wrap_int(46840), -wrap_int(82208), wrap_int(35161), -wrap_int(84028)])):
    for n in pos + nums:
        s = sym_str(n)
        if sym_int(s[:2]) + sym_sum(sym_generator((sym_int(c) for c in s[2:]))) <= wrap_int(0):
            _assert(n not in pos)
        else:
            _assert(pos.count(n) == nums.count(n))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x (List Int))
(assert (forall ((list_pos_375 Int)) (=> (and (>= list_pos_375 0) (< list_pos_375 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 0 2)) 0))))
(assert (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375))))))) (forall ((list_pos_375 Int)) (=> (and (>= list_pos_375 0) (< list_pos_375 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (> (str.len (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)))) str_pos_28)) 0))))))
(assert (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375))))))) (forall ((list_pos_375 Int)) (=> (and (>= list_pos_375 0) (< list_pos_375 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List I...
(assert (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375))))))) (forall ((list_pos_375 Int)) (=> (and (>= list_pos_375 0) (< list_pos_375 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List I...
(assert (forall ((list_pos_376 Int)) (=> (and (>= list_pos_376 0) (< list_pos_376 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375))))))) (forall ((list_pos_375 Int)) (=> (and (>= list_pos_375 0) (< list_pos_375 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_376...
(assert (forall ((str_pos_29 Int)) (=> (and (>= str_pos_29 0) (< str_pos_29 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_376)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_376))))))) (forall ((list_pos_376 Int)) (=> (and (>= list_pos_376 0) (< list_pos_376 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List...
(assert (forall ((str_pos_29 Int)) (=> (and (>= str_pos_29 0) (< str_pos_29 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_376)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_376))))))) (forall ((list_pos_376 Int)) (=> (and (>= list_pos_376 0) (< list_pos_376 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List...
(assert (forall ((str_pos_29 Int)) (=> (and (>= str_pos_29 0) (< str_pos_29 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_376)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_376))))))) (forall ((list_pos_376 Int)) (=> (and (>= list_pos_376 0) (< list_pos_376 (list.length.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int))))))))))) (forall ((str_pos_28 Int)) (=> (and (>= str_pos_28 0) (< str_pos_28 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List Int)))))))) list_pos_375)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 3885 (cons -46840 (cons -82208 (cons 35161 (cons -84028 (as nil (List...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:132.240: Symbol 'list_pos_375' not declared as a variable")

Could not find any solution for puzzle PositiveDigitSums:1
Too many constants for extrapolation

Solving puzzle 311/732: PositiveDigitSums:2
sat_func def sat(pos: List[int], nums=[42550, -7024, -90058]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
modified_func def sat(pos: List[int], nums=wrap_list([wrap_int(42550), -wrap_int(7024), -wrap_int(90058)])):
    for n in pos + nums:
        s = sym_str(n)
        if sym_int(s[:2]) + sym_sum(sym_generator((sym_int(c) for c in s[2:]))) <= wrap_int(0):
            _assert(n not in pos)
        else:
            _assert(pos.count(n) == nums.count(n))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x (List Int))
(assert (forall ((list_pos_377 Int)) (=> (and (>= list_pos_377 0) (< list_pos_377 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 0 2)) 0))))
(assert (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377))))))) (forall ((list_pos_377 Int)) (=> (and (>= list_pos_377 0) (< list_pos_377 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (> (str.len (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)))) str_pos_30)) 0))))))
(assert (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377))))))) (forall ((list_pos_377 Int)) (=> (and (>= list_pos_377 0) (< list_pos_377 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List ...
(assert (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377))))))) (forall ((list_pos_377 Int)) (=> (and (>= list_pos_377 0) (< list_pos_377 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List ...
(assert (forall ((list_pos_378 Int)) (=> (and (>= list_pos_378 0) (< list_pos_378 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377))))))) (forall ((list_pos_377 Int)) (=> (and (>= list_pos_377 0) (< list_pos_377 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_378)) 0 2)) 0))))))))
(assert (forall ((str_pos_31 Int)) (=> (and (>= str_pos_31 0) (< str_pos_31 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_378)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_378))))))) (forall ((list_pos_378 Int)) (=> (and (>= list_pos_378 0) (< list_pos_378 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377))))))) (forall ((list_pos_377 Int)) (=> (and (>= list_pos_377 0) (< list_pos_377 (list.length.int (list.appen...
(assert (forall ((str_pos_31 Int)) (=> (and (>= str_pos_31 0) (< str_pos_31 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_378)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_378))))))) (forall ((list_pos_378 Int)) (=> (and (>= list_pos_378 0) (< list_pos_378 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377))))))) (forall ((list_pos_377 Int)) (=> (and (>= list_pos_377 0) (< list_pos_377 (list.length.int (list.appen...
(assert (forall ((str_pos_31 Int)) (=> (and (>= str_pos_31 0) (< str_pos_31 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_378)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_378))))))) (forall ((list_pos_378 Int)) (=> (and (>= list_pos_378 0) (< list_pos_378 (list.length.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int))))))))) (forall ((str_pos_30 Int)) (=> (and (>= str_pos_30 0) (< str_pos_30 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 42550 (cons -7024 (cons -90058 (as nil (List Int)))))) list_pos_377))))))) (forall ((list_pos_377 Int)) (=> (and (>= list_pos_377 0) (< list_pos_377 (list.length.int (list.appen...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:132.213: Symbol 'list_pos_377' not declared as a variable")

Could not find any solution for puzzle PositiveDigitSums:2
Too many constants for extrapolation

Solving puzzle 312/732: PositiveDigitSums:3
sat_func def sat(pos: List[int], nums=[39739, -37931, -68285, -32414]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
modified_func def sat(pos: List[int], nums=wrap_list([wrap_int(39739), -wrap_int(37931), -wrap_int(68285), -wrap_int(32414)])):
    for n in pos + nums:
        s = sym_str(n)
        if sym_int(s[:2]) + sym_sum(sym_generator((sym_int(c) for c in s[2:]))) <= wrap_int(0):
            _assert(n not in pos)
        else:
            _assert(pos.count(n) == nums.count(n))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x (List Int))
(assert (forall ((list_pos_379 Int)) (=> (and (>= list_pos_379 0) (< list_pos_379 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 0 2)) 0))))
(assert (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379))))))) (forall ((list_pos_379 Int)) (=> (and (>= list_pos_379 0) (< list_pos_379 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (> (str.len (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)))) str_pos_32)) 0))))))
(assert (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379))))))) (forall ((list_pos_379 Int)) (=> (and (>= list_pos_379 0) (< list_pos_379 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get...
(assert (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379))))))) (forall ((list_pos_379 Int)) (=> (and (>= list_pos_379 0) (< list_pos_379 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get...
(assert (forall ((list_pos_380 Int)) (=> (and (>= list_pos_380 0) (< list_pos_380 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379))))))) (forall ((list_pos_379 Int)) (=> (and (>= list_pos_379 0) (< list_pos_379 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_380)) 0 2)) 0))))))))
(assert (forall ((str_pos_33 Int)) (=> (and (>= str_pos_33 0) (< str_pos_33 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_380)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_380))))))) (forall ((list_pos_380 Int)) (=> (and (>= list_pos_380 0) (< list_pos_380 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379))))))) (forall ((list_pos_379 Int)...
(assert (forall ((str_pos_33 Int)) (=> (and (>= str_pos_33 0) (< str_pos_33 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_380)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_380))))))) (forall ((list_pos_380 Int)) (=> (and (>= list_pos_380 0) (< list_pos_380 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379))))))) (forall ((list_pos_379 Int)...
(assert (forall ((str_pos_33 Int)) (=> (and (>= str_pos_33 0) (< str_pos_33 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_380)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_380))))))) (forall ((list_pos_380 Int)) (=> (and (>= list_pos_380 0) (< list_pos_380 (list.length.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int)))))))))) (forall ((str_pos_32 Int)) (=> (and (>= str_pos_32 0) (< str_pos_32 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 39739 (cons -37931 (cons -68285 (cons -32414 (as nil (List Int))))))) list_pos_379))))))) (forall ((list_pos_379 Int)...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:132.228: Symbol 'list_pos_379' not declared as a variable")

Could not find any solution for puzzle PositiveDigitSums:3
Too many constants for extrapolation

Solving puzzle 313/732: PositiveDigitSums:4
sat_func def sat(pos: List[int], nums=[26162, -47643, -37426]):
    for n in pos + nums:
        s = str(n)
        if int(s[:2]) + sum(int(c) for c in s[2:]) <= 0:
            assert n not in pos
        else:
            assert pos.count(n) == nums.count(n)
    return True
modified_func def sat(pos: List[int], nums=wrap_list([wrap_int(26162), -wrap_int(47643), -wrap_int(37426)])):
    for n in pos + nums:
        s = sym_str(n)
        if sym_int(s[:2]) + sym_sum(sym_generator((sym_int(c) for c in s[2:]))) <= wrap_int(0):
            _assert(n not in pos)
        else:
            _assert(pos.count(n) == nums.count(n))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))


(define-fun python.str.substr ((s String) (start Int) (end Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start))
        (end (ite (< end 0) (+ (str.len s) end) end)))
    (str.substr s start (- end start))))

(declare-const x (List Int))
(assert (forall ((list_pos_381 Int)) (=> (and (>= list_pos_381 0) (< list_pos_381 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 0 2)) 0))))
(assert (forall ((str_pos_34 Int)) (=> (and (>= str_pos_34 0) (< str_pos_34 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381))))))) (forall ((list_pos_381 Int)) (=> (and (>= list_pos_381 0) (< list_pos_381 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (> (str.len (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)))) str_pos_34)) 0))))))
(assert (forall ((str_pos_34 Int)) (=> (and (>= str_pos_34 0) (< str_pos_34 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381))))))) (forall ((list_pos_381 Int)) (=> (and (>= list_pos_381 0) (< list_pos_381 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil ...
(assert (forall ((str_pos_34 Int)) (=> (and (>= str_pos_34 0) (< str_pos_34 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381))))))) (forall ((list_pos_381 Int)) (=> (and (>= list_pos_381 0) (< list_pos_381 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (=> (and (<= (+ (python.int (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 0 2) 10) (+ (python.int (python.str.at (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil ...
(assert (forall ((list_pos_382 Int)) (=> (and (>= list_pos_382 0) (< list_pos_382 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (forall ((str_pos_34 Int)) (=> (and (>= str_pos_34 0) (< str_pos_34 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381))))))) (forall ((list_pos_381 Int)) (=> (and (>= list_pos_381 0) (< list_pos_381 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (> (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_382)) 0 2)) 0))))))))
(assert (forall ((str_pos_35 Int)) (=> (and (>= str_pos_35 0) (< str_pos_35 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_382)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_382))))))) (forall ((list_pos_382 Int)) (=> (and (>= list_pos_382 0) (< list_pos_382 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (forall ((str_pos_34 Int)) (=> (and (>= str_pos_34 0) (< str_pos_34 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381))))))) (forall ((list_pos_381 Int)) (=> (and (>= list_pos_381 0) (< list_pos_381 (list.length.int (list....
(assert (forall ((str_pos_35 Int)) (=> (and (>= str_pos_35 0) (< str_pos_35 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_382)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_382))))))) (forall ((list_pos_382 Int)) (=> (and (>= list_pos_382 0) (< list_pos_382 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (forall ((str_pos_34 Int)) (=> (and (>= str_pos_34 0) (< str_pos_34 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381))))))) (forall ((list_pos_381 Int)) (=> (and (>= list_pos_381 0) (< list_pos_381 (list.length.int (list....
(assert (forall ((str_pos_35 Int)) (=> (and (>= str_pos_35 0) (< str_pos_35 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_382)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_382))))))) (forall ((list_pos_382 Int)) (=> (and (>= list_pos_382 0) (< list_pos_382 (list.length.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int))))))))) (forall ((str_pos_34 Int)) (=> (and (>= str_pos_34 0) (< str_pos_34 (str.len (python.str.substr (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381)) 2 (str.len (str.from_int (list.get.int (list.append.int x (cons 26162 (cons -47643 (cons -37426 (as nil (List Int)))))) list_pos_381))))))) (forall ((list_pos_381 Int)) (=> (and (>= list_pos_381 0) (< list_pos_381 (list.length.int (list....
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:132.214: Symbol 'list_pos_381' not declared as a variable")

Could not find any solution for puzzle PositiveDigitSums:4
Too many constants for extrapolation

Solving puzzle 314/732: RotateSort:0
sat_func def sat(original: List[int], arr=[2, 3, -1, -1, 0, 1, 1]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
modified_func def sat(original: List[int], arr=wrap_list([wrap_int(2), wrap_int(3), -wrap_int(1), -wrap_int(1), wrap_int(0), wrap_int(1), wrap_int(1)])):
    _assert(sym_in(sym_str(original)[1:-1], sym_str(sym_sorted(original) * wrap_int(2))), wrap_str('Not ring sorted'))
    return any(sym_generator((original == arr[:i] + arr[i + 1:] for i in sym_range(sym_len(arr) + 1))))
Exception -- for puzzle RotateSort:0 Cannot convert symbolic integer to index

Solving puzzle 315/732: RotateSort:1
sat_func def sat(original: List[int], arr=[2, 3, 3, 5, 6, 0]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
modified_func def sat(original: List[int], arr=wrap_list([wrap_int(2), wrap_int(3), wrap_int(3), wrap_int(5), wrap_int(6), wrap_int(0)])):
    _assert(sym_in(sym_str(original)[1:-1], sym_str(sym_sorted(original) * wrap_int(2))), wrap_str('Not ring sorted'))
    return any(sym_generator((original == arr[:i] + arr[i + 1:] for i in sym_range(sym_len(arr) + 1))))
Exception -- for puzzle RotateSort:1 Cannot convert symbolic integer to index

Solving puzzle 316/732: RotateSort:2
sat_func def sat(original: List[int], arr=[3, 5]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
modified_func def sat(original: List[int], arr=wrap_list([wrap_int(3), wrap_int(5)])):
    _assert(sym_in(sym_str(original)[1:-1], sym_str(sym_sorted(original) * wrap_int(2))), wrap_str('Not ring sorted'))
    return any(sym_generator((original == arr[:i] + arr[i + 1:] for i in sym_range(sym_len(arr) + 1))))
Exception -- for puzzle RotateSort:2 Cannot convert symbolic integer to index

Solving puzzle 317/732: RotateSort:3
sat_func def sat(original: List[int], arr=[3, 7, 3, 6, 6, 8, 9, 0, 0, 1]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
modified_func def sat(original: List[int], arr=wrap_list([wrap_int(3), wrap_int(7), wrap_int(3), wrap_int(6), wrap_int(6), wrap_int(8), wrap_int(9), wrap_int(0), wrap_int(0), wrap_int(1)])):
    _assert(sym_in(sym_str(original)[1:-1], sym_str(sym_sorted(original) * wrap_int(2))), wrap_str('Not ring sorted'))
    return any(sym_generator((original == arr[:i] + arr[i + 1:] for i in sym_range(sym_len(arr) + 1))))
Exception -- for puzzle RotateSort:3 Cannot convert symbolic integer to index

Solving puzzle 318/732: RotateSort:4
sat_func def sat(original: List[int], arr=[3, 2, 6, 7, 7, 8, 3]):
    assert str(original)[1:-1] in str(sorted(original) * 2), "Not ring sorted"
    return any(original == arr[:i] + arr[i + 1:] for i in range(len(arr) + 1))
modified_func def sat(original: List[int], arr=wrap_list([wrap_int(3), wrap_int(2), wrap_int(6), wrap_int(7), wrap_int(7), wrap_int(8), wrap_int(3)])):
    _assert(sym_in(sym_str(original)[1:-1], sym_str(sym_sorted(original) * wrap_int(2))), wrap_str('Not ring sorted'))
    return any(sym_generator((original == arr[:i] + arr[i + 1:] for i in sym_range(sym_len(arr) + 1))))
Exception -- for puzzle RotateSort:4 Cannot convert symbolic integer to index

Solving puzzle 319/732: DelPalindrome:0
sat_func def sat(strings: List[str], a="this is a test", b="cat"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
modified_func def sat(strings: List[str], a=wrap_str('this is a test'), b=wrap_str('cat')):
    s, is_palindrome = strings
    i = wrap_int(0)
    for c in a:
        if c not in b:
            _assert(s[i] == c)
            i += wrap_int(1)
    _assert(i == sym_len(s))
    return is_palindrome == sym_str(s == s[::-1])
Exception -- for puzzle DelPalindrome:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 320/732: DelPalindrome:1
sat_func def sat(strings: List[str], a="vochemogogajesuxujefobemenepejyquizys", b="te"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
modified_func def sat(strings: List[str], a=wrap_str('vochemogogajesuxujefobemenepejyquizys'), b=wrap_str('te')):
    s, is_palindrome = strings
    i = wrap_int(0)
    for c in a:
        if c not in b:
            _assert(s[i] == c)
            i += wrap_int(1)
    _assert(i == sym_len(s))
    return is_palindrome == sym_str(s == s[::-1])
Exception -- for puzzle DelPalindrome:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 321/732: DelPalindrome:2
sat_func def sat(strings: List[str], a="tagodecequyzafiwathegothatymuzabegelelathe", b="wululizokiwa"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
modified_func def sat(strings: List[str], a=wrap_str('tagodecequyzafiwathegothatymuzabegelelathe'), b=wrap_str('wululizokiwa')):
    s, is_palindrome = strings
    i = wrap_int(0)
    for c in a:
        if c not in b:
            _assert(s[i] == c)
            i += wrap_int(1)
    _assert(i == sym_len(s))
    return is_palindrome == sym_str(s == s[::-1])
Exception -- for puzzle DelPalindrome:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 322/732: DelPalindrome:3
sat_func def sat(strings: List[str], a="sipylovegubequagujete", b="doh"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
modified_func def sat(strings: List[str], a=wrap_str('sipylovegubequagujete'), b=wrap_str('doh')):
    s, is_palindrome = strings
    i = wrap_int(0)
    for c in a:
        if c not in b:
            _assert(s[i] == c)
            i += wrap_int(1)
    _assert(i == sym_len(s))
    return is_palindrome == sym_str(s == s[::-1])
Exception -- for puzzle DelPalindrome:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 323/732: DelPalindrome:4
sat_func def sat(strings: List[str], a="fodivahug", b="ne"):
    s, is_palindrome = strings
    i = 0
    for c in a:
        if c not in b:
            assert s[i] == c
            i += 1
    assert i == len(s)
    return is_palindrome == str(s == s[::-1])
modified_func def sat(strings: List[str], a=wrap_str('fodivahug'), b=wrap_str('ne')):
    s, is_palindrome = strings
    i = wrap_int(0)
    for c in a:
        if c not in b:
            _assert(s[i] == c)
            i += wrap_int(1)
    _assert(i == sym_len(s))
    return is_palindrome == sym_str(s == s[::-1])
Exception -- for puzzle DelPalindrome:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 324/732: ReplaceMe:0
sat_func def sat(answers: List[str], lst=['234515', '21503', '2506236943']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
modified_func def sat(answers: List[str], lst=wrap_list([wrap_str('234515'), wrap_str('21503'), wrap_str('2506236943')])):
    if sym_len(answers) != sym_len(lst):
        return False
    for a, s in sym_zip(answers, lst):
        if sym_in(wrap_str('t'), a):
            return False
        num_odds = sym_sum(sym_generator((sym_int(i) % wrap_int(2) for i in s)))
        if a.replace(sym_str(num_odds), wrap_str('t')) != wrap_str('this is a test'):
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (=> (not (= (list.length.string x) 3)) false))
(assert (=> (not (not (= (list.length.string x) 3))) (< zip_pos_0 3)))
(assert (=> (not (not (= (list.length.string x) 3))) (>= zip_pos_0 -3)))
(assert (forall ((str_pos_36 Int)) (=> (and (>= str_pos_36 0) (< str_pos_36 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "2506236943" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "21503" "234515"))))) (=> (and (not (not (= (list.length.string x) 3))) (not (str.contains (list.get.string x zip_pos_0) "t"))) (> (str.len (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "2506236943" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "21503" "234515")) str_pos_36)) 0)))))
(assert (forall ((str_pos_36 Int)) (=> (and (>= str_pos_36 0) (< str_pos_36 (str.len (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "2506236943" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "21503" "234515"))))) (=> (and (not (not (= (list.length.string x) 3))) (not (str.contains (list.get.string x zip_pos_0) "t")) (not (not (= (str.replace (list.get.string x zip_pos_0) (str.from_int (+ (mod (python.int (python.str.at (ite (or (= zip_pos_0 2) (= zip_pos_0 -1)) "2506236943" (ite (or (= zip_pos_0 1) (= zip_pos_0 -2)) "21503" "234515")) str_pos_36) 10) 2) 0)) "t") "this is a test")))) true))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:126.57: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReplaceMe:0
Too many constants for extrapolation

Solving puzzle 325/732: ReplaceMe:1
sat_func def sat(answers: List[str], lst=['56', '0']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
modified_func def sat(answers: List[str], lst=wrap_list([wrap_str('56'), wrap_str('0')])):
    if sym_len(answers) != sym_len(lst):
        return False
    for a, s in sym_zip(answers, lst):
        if sym_in(wrap_str('t'), a):
            return False
        num_odds = sym_sum(sym_generator((sym_int(i) % wrap_int(2) for i in s)))
        if a.replace(sym_str(num_odds), wrap_str('t')) != wrap_str('this is a test'):
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (=> (not (= (list.length.string x) 2)) false))
(assert (=> (not (not (= (list.length.string x) 2))) (< zip_pos_0 2)))
(assert (=> (not (not (= (list.length.string x) 2))) (>= zip_pos_0 -2)))
(assert (forall ((str_pos_37 Int)) (=> (and (>= str_pos_37 0) (< str_pos_37 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "0" "56")))) (=> (and (not (not (= (list.length.string x) 2))) (not (str.contains (list.get.string x zip_pos_0) "t"))) (> (str.len (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "0" "56") str_pos_37)) 0)))))
(assert (forall ((str_pos_37 Int)) (=> (and (>= str_pos_37 0) (< str_pos_37 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "0" "56")))) (=> (and (not (not (= (list.length.string x) 2))) (not (str.contains (list.get.string x zip_pos_0) "t")) (not (not (= (str.replace (list.get.string x zip_pos_0) (str.from_int (+ (mod (python.int (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "0" "56") str_pos_37) 10) 2) 0)) "t") "this is a test")))) true))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:126.57: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReplaceMe:1
Too many constants for extrapolation

Solving puzzle 326/732: ReplaceMe:2
sat_func def sat(answers: List[str], lst=[]):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
modified_func def sat(answers: List[str], lst=wrap_list([])):
    if sym_len(answers) != sym_len(lst):
        return False
    for a, s in sym_zip(answers, lst):
        if sym_in(wrap_str('t'), a):
            return False
        num_odds = sym_sum(sym_generator((sym_int(i) % wrap_int(2) for i in s)))
        if a.replace(sym_str(num_odds), wrap_str('t')) != wrap_str('this is a test'):
            return False
    return True
Exception -- for puzzle ReplaceMe:2 'NoneType' object is not iterable

Solving puzzle 327/732: ReplaceMe:3
sat_func def sat(answers: List[str], lst=['767', '5707']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
modified_func def sat(answers: List[str], lst=wrap_list([wrap_str('767'), wrap_str('5707')])):
    if sym_len(answers) != sym_len(lst):
        return False
    for a, s in sym_zip(answers, lst):
        if sym_in(wrap_str('t'), a):
            return False
        num_odds = sym_sum(sym_generator((sym_int(i) % wrap_int(2) for i in s)))
        if a.replace(sym_str(num_odds), wrap_str('t')) != wrap_str('this is a test'):
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (=> (not (= (list.length.string x) 2)) false))
(assert (=> (not (not (= (list.length.string x) 2))) (< zip_pos_0 2)))
(assert (=> (not (not (= (list.length.string x) 2))) (>= zip_pos_0 -2)))
(assert (forall ((str_pos_38 Int)) (=> (and (>= str_pos_38 0) (< str_pos_38 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "5707" "767")))) (=> (and (not (not (= (list.length.string x) 2))) (not (str.contains (list.get.string x zip_pos_0) "t"))) (> (str.len (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "5707" "767") str_pos_38)) 0)))))
(assert (forall ((str_pos_38 Int)) (=> (and (>= str_pos_38 0) (< str_pos_38 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "5707" "767")))) (=> (and (not (not (= (list.length.string x) 2))) (not (str.contains (list.get.string x zip_pos_0) "t")) (not (not (= (str.replace (list.get.string x zip_pos_0) (str.from_int (+ (mod (python.int (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "5707" "767") str_pos_38) 10) 2) 0)) "t") "this is a test")))) true))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:126.57: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReplaceMe:3
Two large constants for extrapolation
Solving simpler variation replaced 5707 with 3 and 767 with 5
sat_func def sat(answers: List[str], lst=['5', '3']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
modified_func def sat(answers: List[str], lst=wrap_list([wrap_str('5'), wrap_str('3')])):
    if sym_len(answers) != sym_len(lst):
        return False
    for a, s in sym_zip(answers, lst):
        if sym_in(wrap_str('t'), a):
            return False
        num_odds = sym_sum(sym_generator((sym_int(i) % wrap_int(2) for i in s)))
        if a.replace(sym_str(num_odds), wrap_str('t')) != wrap_str('this is a test'):
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (=> (not (= (list.length.string x) 2)) false))
(assert (=> (not (not (= (list.length.string x) 2))) (< zip_pos_0 2)))
(assert (=> (not (not (= (list.length.string x) 2))) (>= zip_pos_0 -2)))
(assert (forall ((str_pos_39 Int)) (=> (and (>= str_pos_39 0) (< str_pos_39 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "3" "5")))) (=> (and (not (not (= (list.length.string x) 2))) (not (str.contains (list.get.string x zip_pos_0) "t"))) (> (str.len (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "3" "5") str_pos_39)) 0)))))
(assert (forall ((str_pos_39 Int)) (=> (and (>= str_pos_39 0) (< str_pos_39 (str.len (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "3" "5")))) (=> (and (not (not (= (list.length.string x) 2))) (not (str.contains (list.get.string x zip_pos_0) "t")) (not (not (= (str.replace (list.get.string x zip_pos_0) (str.from_int (+ (mod (python.int (python.str.at (ite (or (= zip_pos_0 1) (= zip_pos_0 -1)) "3" "5") str_pos_39) 10) 2) 0)) "t") "this is a test")))) true))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:126.57: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReplaceMe:3

Solving puzzle 328/732: ReplaceMe:4
sat_func def sat(answers: List[str], lst=['856']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
modified_func def sat(answers: List[str], lst=wrap_list([wrap_str('856')])):
    if sym_len(answers) != sym_len(lst):
        return False
    for a, s in sym_zip(answers, lst):
        if sym_in(wrap_str('t'), a):
            return False
        num_odds = sym_sum(sym_generator((sym_int(i) % wrap_int(2) for i in s)))
        if a.replace(sym_str(num_odds), wrap_str('t')) != wrap_str('this is a test'):
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (not (= (list.length.string x) 1)) false))
(assert (=> (not (not (= (list.length.string x) 1))) (< zip_pos_0 1)))
(assert (=> (not (not (= (list.length.string x) 1))) (>= zip_pos_0 -1)))
(assert (=> (and (not (not (= (list.length.string x) 1))) (not (str.contains (list.get.string x zip_pos_0) "t")) (not (not (= (str.replace (list.get.string x zip_pos_0) "1" "t") "this is a test")))) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:100.57: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReplaceMe:4
One large constant for extrapolation
Solving simpler variation replaced 856 with 3
sat_func def sat(answers: List[str], lst=['3']):
    if len(answers) != len(lst):
        return False
    for a, s in zip(answers, lst):
        if "t" in a:
            return False
        num_odds = sum(int(i) % 2 for i in s)
        if a.replace(str(num_odds), "t") != "this is a test":
            return False
    return True
modified_func def sat(answers: List[str], lst=wrap_list([wrap_str('3')])):
    if sym_len(answers) != sym_len(lst):
        return False
    for a, s in sym_zip(answers, lst):
        if sym_in(wrap_str('t'), a):
            return False
        num_odds = sym_sum(sym_generator((sym_int(i) % wrap_int(2) for i in s)))
        if a.replace(sym_str(num_odds), wrap_str('t')) != wrap_str('this is a test'):
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (not (= (list.length.string x) 1)) false))
(assert (=> (not (not (= (list.length.string x) 1))) (< zip_pos_0 1)))
(assert (=> (not (not (= (list.length.string x) 1))) (>= zip_pos_0 -1)))
(assert (=> (and (not (not (= (list.length.string x) 1))) (not (str.contains (list.get.string x zip_pos_0) "t")) (not (not (= (str.replace (list.get.string x zip_pos_0) "1" "t") "this is a test")))) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:100.57: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReplaceMe:4

Solving puzzle 329/732: MinSubArraySum:0
sat_func def sat(start_end: List[int], base=7, p=50741, upper=-4897754):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
modified_func def sat(start_end: List[int], base=wrap_int(7), p=wrap_int(50741), upper=-wrap_int(4897754)):
    start, end = start_end
    return sym_sum(sym_generator((pow(base, i, p) - p // wrap_int(2) for i in sym_range(start, end)))) <= upper
Exception -- for puzzle MinSubArraySum:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 330/732: MinSubArraySum:1
sat_func def sat(start_end: List[int], base=1706, p=2004, upper=-14268):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
modified_func def sat(start_end: List[int], base=wrap_int(1706), p=wrap_int(2004), upper=-wrap_int(14268)):
    start, end = start_end
    return sym_sum(sym_generator((pow(base, i, p) - p // wrap_int(2) for i in sym_range(start, end)))) <= upper
Exception -- for puzzle MinSubArraySum:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 331/732: MinSubArraySum:2
sat_func def sat(start_end: List[int], base=4595, p=7106, upper=-193758):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
modified_func def sat(start_end: List[int], base=wrap_int(4595), p=wrap_int(7106), upper=-wrap_int(193758)):
    start, end = start_end
    return sym_sum(sym_generator((pow(base, i, p) - p // wrap_int(2) for i in sym_range(start, end)))) <= upper
Exception -- for puzzle MinSubArraySum:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 332/732: MinSubArraySum:3
sat_func def sat(start_end: List[int], base=1181, p=2664, upper=-102305):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
modified_func def sat(start_end: List[int], base=wrap_int(1181), p=wrap_int(2664), upper=-wrap_int(102305)):
    start, end = start_end
    return sym_sum(sym_generator((pow(base, i, p) - p // wrap_int(2) for i in sym_range(start, end)))) <= upper
Exception -- for puzzle MinSubArraySum:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 333/732: MinSubArraySum:4
sat_func def sat(start_end: List[int], base=7160, p=7736, upper=-35852):
    start, end = start_end
    return sum(pow(base, i, p) - p // 2 for i in range(start, end)) <= upper
modified_func def sat(start_end: List[int], base=wrap_int(7160), p=wrap_int(7736), upper=-wrap_int(35852)):
    start, end = start_end
    return sym_sum(sym_generator((pow(base, i, p) - p // wrap_int(2) for i in sym_range(start, end)))) <= upper
Exception -- for puzzle MinSubArraySum:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 334/732: BinarySort:0
sat_func def sat(ordered: List[int], arr=[4, 2, 3, -1, 15, 2, 6, 9, 5, 16, 1048576]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
modified_func def sat(ordered: List[int], arr=wrap_list([wrap_int(4), wrap_int(2), wrap_int(3), -wrap_int(1), wrap_int(15), wrap_int(2), wrap_int(6), wrap_int(9), wrap_int(5), wrap_int(16), wrap_int(1048576)])):
    if sym_sorted(ordered) != sym_sorted(arr):
        return False
    return all(sym_generator((sym_bin(a).count('1') <= sym_bin(b).count('1') for a, b in sym_zip(ordered, ordered[1:]))))
Exception -- for puzzle BinarySort:0 Cannot convert symbolic integer to index

Solving puzzle 335/732: BinarySort:1
sat_func def sat(ordered: List[int], arr=[19, 47, -51, 40, 6, 0, 41, 57, 13, 16, -27, 7]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
modified_func def sat(ordered: List[int], arr=wrap_list([wrap_int(19), wrap_int(47), -wrap_int(51), wrap_int(40), wrap_int(6), wrap_int(0), wrap_int(41), wrap_int(57), wrap_int(13), wrap_int(16), -wrap_int(27), wrap_int(7)])):
    if sym_sorted(ordered) != sym_sorted(arr):
        return False
    return all(sym_generator((sym_bin(a).count('1') <= sym_bin(b).count('1') for a, b in sym_zip(ordered, ordered[1:]))))
Exception -- for puzzle BinarySort:1 Cannot convert symbolic integer to index

Solving puzzle 336/732: BinarySort:2
sat_func def sat(ordered: List[int], arr=[62, 63, 1]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
modified_func def sat(ordered: List[int], arr=wrap_list([wrap_int(62), wrap_int(63), wrap_int(1)])):
    if sym_sorted(ordered) != sym_sorted(arr):
        return False
    return all(sym_generator((sym_bin(a).count('1') <= sym_bin(b).count('1') for a, b in sym_zip(ordered, ordered[1:]))))
Exception -- for puzzle BinarySort:2 Cannot convert symbolic integer to index

Solving puzzle 337/732: BinarySort:3
sat_func def sat(ordered: List[int], arr=[-9, -78, -17, 42, 85, 79, 61]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
modified_func def sat(ordered: List[int], arr=wrap_list([-wrap_int(9), -wrap_int(78), -wrap_int(17), wrap_int(42), wrap_int(85), wrap_int(79), wrap_int(61)])):
    if sym_sorted(ordered) != sym_sorted(arr):
        return False
    return all(sym_generator((sym_bin(a).count('1') <= sym_bin(b).count('1') for a, b in sym_zip(ordered, ordered[1:]))))
Exception -- for puzzle BinarySort:3 Cannot convert symbolic integer to index

Solving puzzle 338/732: BinarySort:4
sat_func def sat(ordered: List[int], arr=[-65, -6, 82, -85, -84, 97, 55, 54]):
    if sorted(ordered) != sorted(arr):
        return False  # not even a permutation
    return all(bin(a).count("1") <= bin(b).count("1") for a, b in zip(ordered, ordered[1:]))
modified_func def sat(ordered: List[int], arr=wrap_list([-wrap_int(65), -wrap_int(6), wrap_int(82), -wrap_int(85), -wrap_int(84), wrap_int(97), wrap_int(55), wrap_int(54)])):
    if sym_sorted(ordered) != sym_sorted(arr):
        return False
    return all(sym_generator((sym_bin(a).count('1') <= sym_bin(b).count('1') for a, b in sym_zip(ordered, ordered[1:]))))
Exception -- for puzzle BinarySort:4 Cannot convert symbolic integer to index

Solving puzzle 339/732: ConsonantFilter:0
sat_func def sat(words: List[str], s="This is not a very hard puzzle", n=3):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
modified_func def sat(words: List[str], s=wrap_str('This is not a very hard puzzle'), n=wrap_int(3)):
    i = wrap_int(0)
    for w in s.split():
        num_consonants = wrap_int(0)
        for c in w.lower():
            if c not in wrap_str('aeiou'):
                num_consonants += wrap_int(1)
        if num_consonants == n:
            if words[i] != w:
                return False
            i += wrap_int(1)
    return i == sym_len(words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (not (= (list.get.string x 0) "This")) false))
(assert (=> (and (not (not (= (list.get.string x 0) "This"))) (not (not (= (list.get.string x 1) "very"))) (not (not (= (list.get.string x 2) "hard")))) (= 3 (list.length.string x))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) (as nil (List String)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle ConsonantFilter:0
Too many constants for extrapolation

Solving puzzle 340/732: ConsonantFilter:1
sat_func def sat(words: List[str], s="xopike tha textufuzowapa xaxiweborite dutextequuch metojylucazasysebi wy", n=5):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
modified_func def sat(words: List[str], s=wrap_str('xopike tha textufuzowapa xaxiweborite dutextequuch metojylucazasysebi wy'), n=wrap_int(5)):
    i = wrap_int(0)
    for w in s.split():
        num_consonants = wrap_int(0)
        for c in w.lower():
            if c not in wrap_str('aeiou'):
                num_consonants += wrap_int(1)
        if num_consonants == n:
            if words[i] != w:
                return False
            i += wrap_int(1)
    return i == sym_len(words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= 0 (list.length.string x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) (as nil (List String)))
)

Found solution []
Yes! Solved for puzzle  ConsonantFilter:1

Solving puzzle 341/732: ConsonantFilter:2
sat_func def sat(words: List[str], s="tihyc pydykosisaroquicoc text", n=6):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
modified_func def sat(words: List[str], s=wrap_str('tihyc pydykosisaroquicoc text'), n=wrap_int(6)):
    i = wrap_int(0)
    for w in s.split():
        num_consonants = wrap_int(0)
        for c in w.lower():
            if c not in wrap_str('aeiou'):
                num_consonants += wrap_int(1)
        if num_consonants == n:
            if words[i] != w:
                return False
            i += wrap_int(1)
    return i == sym_len(words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= 0 (list.length.string x)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) (as nil (List String)))
)

Found solution []
Yes! Solved for puzzle  ConsonantFilter:2

Solving puzzle 342/732: ConsonantFilter:3
sat_func def sat(words: List[str], s="chalejugedijypiq jypityvekifate mobekolupumymikana quaxizot vurikojithokasatuka teragusaculi vyceth dachaci wu", n=1):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
modified_func def sat(words: List[str], s=wrap_str('chalejugedijypiq jypityvekifate mobekolupumymikana quaxizot vurikojithokasatuka teragusaculi vyceth dachaci wu'), n=wrap_int(1)):
    i = wrap_int(0)
    for w in s.split():
        num_consonants = wrap_int(0)
        for c in w.lower():
            if c not in wrap_str('aeiou'):
                num_consonants += wrap_int(1)
        if num_consonants == n:
            if words[i] != w:
                return False
            i += wrap_int(1)
    return i == sym_len(words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (not (= (list.get.string x 0) "wu")) false))
(assert (=> (not (not (= (list.get.string x 0) "wu"))) (= 1 (list.length.string x))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "wu" (as nil (List String))))
)

Found solution ['wu']
Yes! Solved for puzzle  ConsonantFilter:3

Solving puzzle 343/732: ConsonantFilter:4
sat_func def sat(words: List[str], s="thigafamyhuchykikoxe limyb wy textitextomyc regolathagychiby pep", n=2):
    i = 0
    for w in s.split():
        num_consonants = 0
        for c in w.lower():
            if c not in "aeiou":
                num_consonants += 1
        if num_consonants == n:
            if words[i] != w:
                return False
            i += 1
    return i == len(words)
modified_func def sat(words: List[str], s=wrap_str('thigafamyhuchykikoxe limyb wy textitextomyc regolathagychiby pep'), n=wrap_int(2)):
    i = wrap_int(0)
    for w in s.split():
        num_consonants = wrap_int(0)
        for c in w.lower():
            if c not in wrap_str('aeiou'):
                num_consonants += wrap_int(1)
        if num_consonants == n:
            if words[i] != w:
                return False
            i += wrap_int(1)
    return i == sym_len(words)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (=> (not (= (list.get.string x 0) "wy")) false))
(assert (=> (and (not (not (= (list.get.string x 0) "wy"))) (not (not (= (list.get.string x 1) "pep")))) (= 2 (list.length.string x))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) (as nil (List String)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle ConsonantFilter:4
Too many constants for extrapolation

Solving puzzle 344/732: BiggestK:0
sat_func def sat(biggest: List[int], k=7, nums=[31, 1, 2, -10, -2, 4, 17, 18, 20, 14, 20, 21, 18, 0]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
modified_func def sat(biggest: List[int], k=wrap_int(7), nums=wrap_list([wrap_int(31), wrap_int(1), wrap_int(2), -wrap_int(10), -wrap_int(2), wrap_int(4), wrap_int(17), wrap_int(18), wrap_int(20), wrap_int(14), wrap_int(20), wrap_int(21), wrap_int(18), wrap_int(0)])):
    if sym_len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return (k == wrap_int(0)).__or__(k == sym_len(nums)).__or__(max(smallest) <= min(biggest))
Exception -- for puzzle BiggestK:0 'SymbolicList' object has no attribute 'remove'

Solving puzzle 345/732: BiggestK:1
sat_func def sat(biggest: List[int], k=3, nums=[-5, 30, 31, 32, 30, 93, 97]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
modified_func def sat(biggest: List[int], k=wrap_int(3), nums=wrap_list([-wrap_int(5), wrap_int(30), wrap_int(31), wrap_int(32), wrap_int(30), wrap_int(93), wrap_int(97)])):
    if sym_len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return (k == wrap_int(0)).__or__(k == sym_len(nums)).__or__(max(smallest) <= min(biggest))
Exception -- for puzzle BiggestK:1 'SymbolicList' object has no attribute 'remove'

Solving puzzle 346/732: BiggestK:2
sat_func def sat(biggest: List[int], k=2, nums=[75, 30, 53, 25, 14]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
modified_func def sat(biggest: List[int], k=wrap_int(2), nums=wrap_list([wrap_int(75), wrap_int(30), wrap_int(53), wrap_int(25), wrap_int(14)])):
    if sym_len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return (k == wrap_int(0)).__or__(k == sym_len(nums)).__or__(max(smallest) <= min(biggest))
Exception -- for puzzle BiggestK:2 'SymbolicList' object has no attribute 'remove'

Solving puzzle 347/732: BiggestK:3
sat_func def sat(biggest: List[int], k=1, nums=[-6, 9, 36, 36, 99, 66, 41, 38, 11, 61]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
modified_func def sat(biggest: List[int], k=wrap_int(1), nums=wrap_list([-wrap_int(6), wrap_int(9), wrap_int(36), wrap_int(36), wrap_int(99), wrap_int(66), wrap_int(41), wrap_int(38), wrap_int(11), wrap_int(61)])):
    if sym_len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return (k == wrap_int(0)).__or__(k == sym_len(nums)).__or__(max(smallest) <= min(biggest))
Exception -- for puzzle BiggestK:3 'SymbolicList' object has no attribute 'remove'

Solving puzzle 348/732: BiggestK:4
sat_func def sat(biggest: List[int], k=2, nums=[4, 65, 52, 41, 21, 0, 45, 71]):
    if len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return k == 0 or k == len(nums) or max(smallest) <= min(biggest)
modified_func def sat(biggest: List[int], k=wrap_int(2), nums=wrap_list([wrap_int(4), wrap_int(65), wrap_int(52), wrap_int(41), wrap_int(21), wrap_int(0), wrap_int(45), wrap_int(71)])):
    if sym_len(biggest) != k:
        return False
    smallest = nums[:]
    for n in biggest:
        smallest.remove(n)
    return (k == wrap_int(0)).__or__(k == sym_len(nums)).__or__(max(smallest) <= min(biggest))
Exception -- for puzzle BiggestK:4 'SymbolicList' object has no attribute 'remove'

Solving puzzle 349/732: OddCollatz:0
sat_func def sat(odds: List[int], n=1243272912731):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
modified_func def sat(odds: List[int], n=wrap_int(1243272912731)):
    num_odds = wrap_int(0)
    while True:
        if n % wrap_int(2) == wrap_int(1):
            num_odds += wrap_int(1)
            if n not in odds:
                return False
        if n <= wrap_int(1):
            return num_odds == sym_len(odds)
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) == wrap_int(1) else n // wrap_int(2)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (and (list.contains.int x 1243272912731) (<= 1243272912731 1)) (= 1 (list.length.int x))))
(assert (=> (not (list.contains.int x 1243272912731)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 1243272912731 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [1243272912731, 1]
WARNING: Solution verification failed for puzzle OddCollatz:0
One large constant for extrapolation
Solving simpler variation replaced 1243272912731 with 3
sat_func def sat(odds: List[int], n=3):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
modified_func def sat(odds: List[int], n=wrap_int(3)):
    num_odds = wrap_int(0)
    while True:
        if n % wrap_int(2) == wrap_int(1):
            num_odds += wrap_int(1)
            if n not in odds:
                return False
        if n <= wrap_int(1):
            return num_odds == sym_len(odds)
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) == wrap_int(1) else n // wrap_int(2)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (and (list.contains.int x 3) (<= 3 1)) (= 1 (list.length.int x))))
(assert (=> (not (list.contains.int x 3)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [3, 1]
WARNING: Solution verification failed for puzzle OddCollatz:0

Solving puzzle 350/732: OddCollatz:1
sat_func def sat(odds: List[int], n=6969429614):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
modified_func def sat(odds: List[int], n=wrap_int(6969429614)):
    num_odds = wrap_int(0)
    while True:
        if n % wrap_int(2) == wrap_int(1):
            num_odds += wrap_int(1)
            if n not in odds:
                return False
        if n <= wrap_int(1):
            return num_odds == sym_len(odds)
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) == wrap_int(1) else n // wrap_int(2)
Exception -- for puzzle OddCollatz:1 maximum recursion depth exceeded

Solving puzzle 351/732: OddCollatz:2
sat_func def sat(odds: List[int], n=529):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
modified_func def sat(odds: List[int], n=wrap_int(529)):
    num_odds = wrap_int(0)
    while True:
        if n % wrap_int(2) == wrap_int(1):
            num_odds += wrap_int(1)
            if n not in odds:
                return False
        if n <= wrap_int(1):
            return num_odds == sym_len(odds)
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) == wrap_int(1) else n // wrap_int(2)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (and (list.contains.int x 529) (<= 529 1)) (= 1 (list.length.int x))))
(assert (=> (not (list.contains.int x 529)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 529 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [529, 1]
WARNING: Solution verification failed for puzzle OddCollatz:2
One large constant for extrapolation
Solving simpler variation replaced 529 with 3
sat_func def sat(odds: List[int], n=3):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
modified_func def sat(odds: List[int], n=wrap_int(3)):
    num_odds = wrap_int(0)
    while True:
        if n % wrap_int(2) == wrap_int(1):
            num_odds += wrap_int(1)
            if n not in odds:
                return False
        if n <= wrap_int(1):
            return num_odds == sym_len(odds)
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) == wrap_int(1) else n // wrap_int(2)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (and (list.contains.int x 3) (<= 3 1)) (= 1 (list.length.int x))))
(assert (=> (not (list.contains.int x 3)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 3 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [3, 1]
WARNING: Solution verification failed for puzzle OddCollatz:2

Solving puzzle 352/732: OddCollatz:3
sat_func def sat(odds: List[int], n=37):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
modified_func def sat(odds: List[int], n=wrap_int(37)):
    num_odds = wrap_int(0)
    while True:
        if n % wrap_int(2) == wrap_int(1):
            num_odds += wrap_int(1)
            if n not in odds:
                return False
        if n <= wrap_int(1):
            return num_odds == sym_len(odds)
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) == wrap_int(1) else n // wrap_int(2)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (and (list.contains.int x 37) (<= 37 1)) (= 1 (list.length.int x))))
(assert (=> (not (list.contains.int x 37)) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 37 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [37, 1]
WARNING: Solution verification failed for puzzle OddCollatz:3
Too many constants for extrapolation

Solving puzzle 353/732: OddCollatz:4
sat_func def sat(odds: List[int], n=95119584):
    num_odds = 0
    while True:
        if n % 2 == 1:
            num_odds += 1
            if n not in odds:
                return False
        if n <= 1:
            return num_odds == len(odds)
        n = (3 * n + 1) if n % 2 == 1 else n // 2
modified_func def sat(odds: List[int], n=wrap_int(95119584)):
    num_odds = wrap_int(0)
    while True:
        if n % wrap_int(2) == wrap_int(1):
            num_odds += wrap_int(1)
            if n not in odds:
                return False
        if n <= wrap_int(1):
            return num_odds == sym_len(odds)
        n = wrap_int(3) * n + wrap_int(1) if n % wrap_int(2) == wrap_int(1) else n // wrap_int(2)
Exception -- for puzzle OddCollatz:4 maximum recursion depth exceeded

Solving puzzle 354/732: StrangeSplit:0
sat_func def sat(lst: List[str], s="Hello, world!"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
modified_func def sat(lst: List[str], s=wrap_str('Hello, world!')):
    if sym_in(wrap_str(' '), s):
        return wrap_str(' ').join(lst) == s
    if sym_in(wrap_str(','), s):
        return wrap_str(',').join(lst) == s
    return wrap_str('').join(lst) == wrap_str('').join(sym_generator((c for c in s if c.islower().__and__(sym_ord(c) % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (= (python.join x " ") "Hello, world!"))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "Hello, world!" (as nil (List String))))
)

Found solution ['Hello, world!']
Yes! Solved for puzzle  StrangeSplit:0

Solving puzzle 355/732: StrangeSplit:1
sat_func def sat(lst: List[str], s="Goodbye,spaces!"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
modified_func def sat(lst: List[str], s=wrap_str('Goodbye,spaces!')):
    if sym_in(wrap_str(' '), s):
        return wrap_str(' ').join(lst) == s
    if sym_in(wrap_str(','), s):
        return wrap_str(',').join(lst) == s
    return wrap_str('').join(lst) == wrap_str('').join(sym_generator((c for c in s if c.islower().__and__(sym_ord(c) % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (= (python.join x ",") "Goodbye,spaces!"))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "Goodbye,spaces!" (as nil (List String))))
)

Found solution ['Goodbye,spaces!']
Yes! Solved for puzzle  StrangeSplit:1

Solving puzzle 356/732: StrangeSplit:2
sat_func def sat(lst: List[str], s="abcbcbbedfsgfakbfjghskbne[pewte"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
modified_func def sat(lst: List[str], s=wrap_str('abcbcbbedfsgfakbfjghskbne[pewte')):
    if sym_in(wrap_str(' '), s):
        return wrap_str(' ').join(lst) == s
    if sym_in(wrap_str(','), s):
        return wrap_str(',').join(lst) == s
    return wrap_str('').join(lst) == wrap_str('').join(sym_generator((c for c in s if c.islower().__and__(sym_ord(c) % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (= (python.join x "") (python.join (cons "a" (cons "b" (cons "c" (cons "b" (cons "c" (cons "b" (cons "b" (cons "e" (cons "d" (cons "f" (cons "s" (cons "g" (cons "f" (cons "a" (cons "k" (cons "b" (cons "f" (cons "j" (cons "g" (cons "h" (cons "s" (cons "k" (cons "b" (cons "n" (cons "e" (cons "[" (cons "p" (cons "e" (cons "w" (cons "t" (cons "e" (as nil (List String))))))))))))))))))))))))))))))))) "")))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle StrangeSplit:2
Too many constants for extrapolation

Solving puzzle 357/732: StrangeSplit:3
sat_func def sat(lst: List[str], s="wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
modified_func def sat(lst: List[str], s=wrap_str('wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc')):
    if sym_in(wrap_str(' '), s):
        return wrap_str(' ').join(lst) == s
    if sym_in(wrap_str(','), s):
        return wrap_str(',').join(lst) == s
    return wrap_str('').join(lst) == wrap_str('').join(sym_generator((c for c in s if c.islower().__and__(sym_ord(c) % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (= (python.join x ",") "wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc"))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc" (as nil (List String))))
)

Found solution ['wotekitex,textarinequo,do,machoki,balecethotuwy,jarynutextopimud,dethexifythuthyc']
Yes! Solved for puzzle  StrangeSplit:3

Solving puzzle 358/732: StrangeSplit:4
sat_func def sat(lst: List[str], s="jitys py sepocedynechuhegu lekinihiluwefax"):
    if " " in s:
        return " ".join(lst) == s
    if "," in s:
        return ",".join(lst) == s
    return "".join(lst) == "".join(c for c in s if c.islower() and ord(c) % 2 == 0)
modified_func def sat(lst: List[str], s=wrap_str('jitys py sepocedynechuhegu lekinihiluwefax')):
    if sym_in(wrap_str(' '), s):
        return wrap_str(' ').join(lst) == s
    if sym_in(wrap_str(','), s):
        return wrap_str(',').join(lst) == s
    return wrap_str('').join(lst) == wrap_str('').join(sym_generator((c for c in s if c.islower().__and__(sym_ord(c) % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (= (python.join x " ") "jitys py sepocedynechuhegu lekinihiluwefax"))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List String) ((as cons (List String)) "jitys py sepocedynechuhegu lekinihiluwefax" (as nil (List String))))
)

Found solution ['jitys py sepocedynechuhegu lekinihiluwefax']
Yes! Solved for puzzle  StrangeSplit:4

Solving puzzle 359/732: IncreasingViolation:0
sat_func def sat(violation: List[int], nums=[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 17, 17, 18, 19, 20, 22, 24]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
modified_func def sat(violation: List[int], nums=wrap_list([wrap_int(1), wrap_int(2), wrap_int(3), wrap_int(4), wrap_int(6), wrap_int(7), wrap_int(8), wrap_int(9), wrap_int(10), wrap_int(11), wrap_int(17), wrap_int(17), wrap_int(18), wrap_int(19), wrap_int(20), wrap_int(22), wrap_int(24)])):
    if sym_not(violation):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    i, j = violation
    return (wrap_int(0) <= i).__and__(i < j).__and__(nums[i] >= nums[j])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) true) true) false) true) true) true) true) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle IncreasingViolation:0
Too many constants for extrapolation

Solving puzzle 360/732: IncreasingViolation:1
sat_func def sat(violation: List[int], nums=[10, 16, 19, 23, 25, 27, 27, 39, 39, 44, 52, 60, 64, 1, 92, 96]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
modified_func def sat(violation: List[int], nums=wrap_list([wrap_int(10), wrap_int(16), wrap_int(19), wrap_int(23), wrap_int(25), wrap_int(27), wrap_int(27), wrap_int(39), wrap_int(39), wrap_int(44), wrap_int(52), wrap_int(60), wrap_int(64), wrap_int(1), wrap_int(92), wrap_int(96)])):
    if sym_not(violation):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    i, j = violation
    return (wrap_int(0) <= i).__and__(i < j).__and__(nums[i] >= nums[j])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and true true) true) true) true) false) true) false) true) true) true) true) false) true) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle IncreasingViolation:1
Too many constants for extrapolation

Solving puzzle 361/732: IncreasingViolation:2
sat_func def sat(violation: List[int], nums=[10, 10, 10, 11, 17, 22, 31, 35, 42, 48, 61, 75, 90, 92]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
modified_func def sat(violation: List[int], nums=wrap_list([wrap_int(10), wrap_int(10), wrap_int(10), wrap_int(11), wrap_int(17), wrap_int(22), wrap_int(31), wrap_int(35), wrap_int(42), wrap_int(48), wrap_int(61), wrap_int(75), wrap_int(90), wrap_int(92)])):
    if sym_not(violation):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    i, j = violation
    return (wrap_int(0) <= i).__and__(i < j).__and__(nums[i] >= nums[j])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and (and false false) true) true) true) true) true) true) true) true) true) true) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle IncreasingViolation:2
Too many constants for extrapolation

Solving puzzle 362/732: IncreasingViolation:3
sat_func def sat(violation: List[int], nums=[5, 5, 84]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
modified_func def sat(violation: List[int], nums=wrap_list([wrap_int(5), wrap_int(5), wrap_int(84)])):
    if sym_not(violation):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    i, j = violation
    return (wrap_int(0) <= i).__and__(i < j).__and__(nums[i] >= nums[j])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and false true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle IncreasingViolation:3
Too many constants for extrapolation

Solving puzzle 363/732: IncreasingViolation:4
sat_func def sat(violation: List[int], nums=[2, 5, 12, 40, 41, 47, 52, 53, 60, 46, 64, 66, 71]):
    if not violation:
        return all(nums[i] < nums[i + 1] for i in range(len(nums) - 1))
    i, j = violation
    return 0 <= i < j and nums[i] >= nums[j]
modified_func def sat(violation: List[int], nums=wrap_list([wrap_int(2), wrap_int(5), wrap_int(12), wrap_int(40), wrap_int(41), wrap_int(47), wrap_int(52), wrap_int(53), wrap_int(60), wrap_int(46), wrap_int(64), wrap_int(66), wrap_int(71)])):
    if sym_not(violation):
        return all(sym_generator((nums[i] < nums[i + wrap_int(1)] for i in sym_range(sym_len(nums) - 1))))
    i, j = violation
    return (wrap_int(0) <= i).__and__(i < j).__and__(nums[i] >= nums[j])
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and true true) true) true) true) true) true) true) false) true) true) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle IncreasingViolation:4
Too many constants for extrapolation

Solving puzzle 364/732: PrimeIntervalIntersection:0
sat_func def sat(interval2: List[int], interval1=[32157, 93210127]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
modified_func def sat(interval2: List[int], interval1=wrap_list([wrap_int(32157), wrap_int(93210127)])):
    intersection_width = min(interval1[wrap_int(1)], interval2[wrap_int(1)]) - max(interval1[wrap_int(0)], interval2[wrap_int(0)])
    return (intersection_width > wrap_int(1)).__and__(all(sym_generator((intersection_width % i for i in sym_range(2, intersection_width)))))
Timed out for puzzle PrimeIntervalIntersection:0

Solving puzzle 365/732: PrimeIntervalIntersection:1
sat_func def sat(interval2: List[int], interval1=[-3367, 4628]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
modified_func def sat(interval2: List[int], interval1=wrap_list([-wrap_int(3367), wrap_int(4628)])):
    intersection_width = min(interval1[wrap_int(1)], interval2[wrap_int(1)]) - max(interval1[wrap_int(0)], interval2[wrap_int(0)])
    return (intersection_width > wrap_int(1)).__and__(all(sym_generator((intersection_width % i for i in sym_range(2, intersection_width)))))
Exception -- for puzzle PrimeIntervalIntersection:1 maximum recursion depth exceeded

Solving puzzle 366/732: PrimeIntervalIntersection:2
sat_func def sat(interval2: List[int], interval1=[0, 2381571]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
modified_func def sat(interval2: List[int], interval1=wrap_list([wrap_int(0), wrap_int(2381571)])):
    intersection_width = min(interval1[wrap_int(1)], interval2[wrap_int(1)]) - max(interval1[wrap_int(0)], interval2[wrap_int(0)])
    return (intersection_width > wrap_int(1)).__and__(all(sym_generator((intersection_width % i for i in sym_range(2, intersection_width)))))
Timed out for puzzle PrimeIntervalIntersection:2

Solving puzzle 367/732: PrimeIntervalIntersection:3
sat_func def sat(interval2: List[int], interval1=[0, 1867]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
modified_func def sat(interval2: List[int], interval1=wrap_list([wrap_int(0), wrap_int(1867)])):
    intersection_width = min(interval1[wrap_int(1)], interval2[wrap_int(1)]) - max(interval1[wrap_int(0)], interval2[wrap_int(0)])
    return (intersection_width > wrap_int(1)).__and__(all(sym_generator((intersection_width % i for i in sym_range(2, intersection_width)))))
Exception -- for puzzle PrimeIntervalIntersection:3 maximum recursion depth exceeded

Solving puzzle 368/732: PrimeIntervalIntersection:4
sat_func def sat(interval2: List[int], interval1=[-9017, 9358096]):
    intersection_width = min(interval1[1], interval2[1]) - max(interval1[0], interval2[0])
    return intersection_width > 1 and all(intersection_width % i for i in range(2, intersection_width))
modified_func def sat(interval2: List[int], interval1=wrap_list([-wrap_int(9017), wrap_int(9358096)])):
    intersection_width = min(interval1[wrap_int(1)], interval2[wrap_int(1)]) - max(interval1[wrap_int(0)], interval2[wrap_int(0)])
    return (intersection_width > wrap_int(1)).__and__(all(sym_generator((intersection_width % i for i in sym_range(2, intersection_width)))))
Timed out for puzzle PrimeIntervalIntersection:4

Solving puzzle 369/732: LexPath:0
sat_func def sat(path: List[int], k=10, edges=[[2, 4], [3], [4, 1], [4], [0]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
modified_func def sat(path: List[int], k=wrap_int(10), edges=wrap_list([wrap_list([wrap_int(2), wrap_int(4)]), wrap_list([wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(1)]), wrap_list([wrap_int(4)]), wrap_list([wrap_int(0)])])):

    def check(prefix):
        for i, j in sym_zip(path, prefix):
            if i != j:
                return i < j
        return (sym_len(prefix) >= k).__or__(all(sym_generator((check(prefix + wrap_list([i])) for i in edges[prefix[-wrap_int(1)]]))))
    return all(sym_generator((sym_in(path[i], edges[path[i - wrap_int(1)]]) for i in sym_range(1, k)))).__and__(all(sym_generator((check(wrap_list([i])) for i in sym_range(sym_len(edges))))))
Exception -- for puzzle LexPath:0 'SymbolicInt' object has no attribute 'contains'

Solving puzzle 370/732: LexPath:1
sat_func def sat(path: List[int], k=12, edges=[[2, 1], [0], [1, 3, 0], [1, 0, 3]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
modified_func def sat(path: List[int], k=wrap_int(12), edges=wrap_list([wrap_list([wrap_int(2), wrap_int(1)]), wrap_list([wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(3), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(0), wrap_int(3)])])):

    def check(prefix):
        for i, j in sym_zip(path, prefix):
            if i != j:
                return i < j
        return (sym_len(prefix) >= k).__or__(all(sym_generator((check(prefix + wrap_list([i])) for i in edges[prefix[-wrap_int(1)]]))))
    return all(sym_generator((sym_in(path[i], edges[path[i - wrap_int(1)]]) for i in sym_range(1, k)))).__and__(all(sym_generator((check(wrap_list([i])) for i in sym_range(sym_len(edges))))))
Exception -- for puzzle LexPath:1 'SymbolicInt' object has no attribute 'contains'

Solving puzzle 371/732: LexPath:2
sat_func def sat(path: List[int], k=0, edges=[[2, 0], [0, 3, 1, 2], [3, 0, 1, 2], [1, 2]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
modified_func def sat(path: List[int], k=wrap_int(0), edges=wrap_list([wrap_list([wrap_int(2), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(3), wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(3), wrap_int(0), wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(2)])])):

    def check(prefix):
        for i, j in sym_zip(path, prefix):
            if i != j:
                return i < j
        return (sym_len(prefix) >= k).__or__(all(sym_generator((check(prefix + wrap_list([i])) for i in edges[prefix[-wrap_int(1)]]))))
    return all(sym_generator((sym_in(path[i], edges[path[i - wrap_int(1)]]) for i in sym_range(1, k)))).__and__(all(sym_generator((check(wrap_list([i])) for i in sym_range(sym_len(edges))))))
Exception -- for puzzle LexPath:2 'int' object has no attribute 'z3_expr'

Solving puzzle 372/732: LexPath:3
sat_func def sat(path: List[int], k=14, edges=[[2], [2, 1, 0], [2, 1, 0]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
modified_func def sat(path: List[int], k=wrap_int(14), edges=wrap_list([wrap_list([wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(1), wrap_int(0)])])):

    def check(prefix):
        for i, j in sym_zip(path, prefix):
            if i != j:
                return i < j
        return (sym_len(prefix) >= k).__or__(all(sym_generator((check(prefix + wrap_list([i])) for i in edges[prefix[-wrap_int(1)]]))))
    return all(sym_generator((sym_in(path[i], edges[path[i - wrap_int(1)]]) for i in sym_range(1, k)))).__and__(all(sym_generator((check(wrap_list([i])) for i in sym_range(sym_len(edges))))))
Exception -- for puzzle LexPath:3 'SymbolicInt' object has no attribute 'contains'

Solving puzzle 373/732: LexPath:4
sat_func def sat(path: List[int], k=1, edges=[[2, 0, 3, 1], [3, 1], [2, 0, 1], [0]]):

    def check(prefix):
        for i, j in zip(path, prefix):
            if i != j:
                return i < j
        return len(prefix) >= k or all(check(prefix + [i]) for i in edges[prefix[-1]])

    return all(path[i] in edges[path[i - 1]] for i in range(1, k)) and all(check([i]) for i in range(len(edges)))
modified_func def sat(path: List[int], k=wrap_int(1), edges=wrap_list([wrap_list([wrap_int(2), wrap_int(0), wrap_int(3), wrap_int(1)]), wrap_list([wrap_int(3), wrap_int(1)]), wrap_list([wrap_int(2), wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(0)])])):

    def check(prefix):
        for i, j in sym_zip(path, prefix):
            if i != j:
                return i < j
        return (sym_len(prefix) >= k).__or__(all(sym_generator((check(prefix + wrap_list([i])) for i in edges[prefix[-wrap_int(1)]]))))
    return all(sym_generator((sym_in(path[i], edges[path[i - wrap_int(1)]]) for i in sym_range(1, k)))).__and__(all(sym_generator((check(wrap_list([i])) for i in sym_range(sym_len(edges))))))
Exception -- for puzzle LexPath:4 'int' object has no attribute 'z3_expr'

Solving puzzle 374/732: Tribonacci:0
sat_func def sat(seq: List[int], length=181):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
modified_func def sat(seq: List[int], length=wrap_int(181)):
    return all(sym_generator((seq[n] == (seq[n - wrap_int(1)] + seq[n - wrap_int(2)] + seq[n + wrap_int(1)] if n % wrap_int(2) else wrap_int(1) + n // wrap_int(2)) for n in sym_range(length))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (list.get.int x 0) (+ (+ (list.get.int x (- 0 1)) (list.get.int x (- 0 2))) (list.get.int...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Tribonacci:0
One large constant for extrapolation
Solving simpler variation replaced 181 with 3
sat_func def sat(seq: List[int], length=3):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
modified_func def sat(seq: List[int], length=wrap_int(3)):
    return all(sym_generator((seq[n] == (seq[n - wrap_int(1)] + seq[n - wrap_int(2)] + seq[n + wrap_int(1)] if n % wrap_int(2) else wrap_int(1) + n // wrap_int(2)) for n in sym_range(length))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) (+ (+ (list.get.int x (- 0 1)) (list.get.int x (- 0 2))) (list.get.int x 1))) (= (list.get.int x 1) (+ (+ (list.get.int x (- 1 1)) (list.get.int x (- 1 2))) (list.get.int x 2)))) (= (list.get.int x 2) (+ (+ (list.get.int x (- 2 1)) (list.get.int x (- 2 2))) (list.get.int x 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle Tribonacci:0

Solving puzzle 375/732: Tribonacci:1
sat_func def sat(seq: List[int], length=412):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
modified_func def sat(seq: List[int], length=wrap_int(412)):
    return all(sym_generator((seq[n] == (seq[n - wrap_int(1)] + seq[n - wrap_int(2)] + seq[n + wrap_int(1)] if n % wrap_int(2) else wrap_int(1) + n // wrap_int(2)) for n in sym_range(length))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (a...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Tribonacci:1
One large constant for extrapolation
Solving simpler variation replaced 412 with 3
sat_func def sat(seq: List[int], length=3):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
modified_func def sat(seq: List[int], length=wrap_int(3)):
    return all(sym_generator((seq[n] == (seq[n - wrap_int(1)] + seq[n - wrap_int(2)] + seq[n + wrap_int(1)] if n % wrap_int(2) else wrap_int(1) + n // wrap_int(2)) for n in sym_range(length))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) (+ (+ (list.get.int x (- 0 1)) (list.get.int x (- 0 2))) (list.get.int x 1))) (= (list.get.int x 1) (+ (+ (list.get.int x (- 1 1)) (list.get.int x (- 1 2))) (list.get.int x 2)))) (= (list.get.int x 2) (+ (+ (list.get.int x (- 2 1)) (list.get.int x (- 2 2))) (list.get.int x 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle Tribonacci:1

Solving puzzle 376/732: Tribonacci:2
sat_func def sat(seq: List[int], length=482):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
modified_func def sat(seq: List[int], length=wrap_int(482)):
    return all(sym_generator((seq[n] == (seq[n - wrap_int(1)] + seq[n - wrap_int(2)] + seq[n + wrap_int(1)] if n % wrap_int(2) else wrap_int(1) + n // wrap_int(2)) for n in sym_range(length))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (a...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Tribonacci:2
One large constant for extrapolation
Solving simpler variation replaced 482 with 3
sat_func def sat(seq: List[int], length=3):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
modified_func def sat(seq: List[int], length=wrap_int(3)):
    return all(sym_generator((seq[n] == (seq[n - wrap_int(1)] + seq[n - wrap_int(2)] + seq[n + wrap_int(1)] if n % wrap_int(2) else wrap_int(1) + n // wrap_int(2)) for n in sym_range(length))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) (+ (+ (list.get.int x (- 0 1)) (list.get.int x (- 0 2))) (list.get.int x 1))) (= (list.get.int x 1) (+ (+ (list.get.int x (- 1 1)) (list.get.int x (- 1 2))) (list.get.int x 2)))) (= (list.get.int x 2) (+ (+ (list.get.int x (- 2 1)) (list.get.int x (- 2 2))) (list.get.int x 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle Tribonacci:2

Solving puzzle 377/732: Tribonacci:3
sat_func def sat(seq: List[int], length=50):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
modified_func def sat(seq: List[int], length=wrap_int(50)):
    return all(sym_generator((seq[n] == (seq[n - wrap_int(1)] + seq[n - wrap_int(2)] + seq[n + wrap_int(1)] if n % wrap_int(2) else wrap_int(1) + n // wrap_int(2)) for n in sym_range(length))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (list.get.int x 0) (+ (+ (list.get.int x (- 0 1)) (list.get.int x (- 0 2))) (list.get.int x 1))) (= (list.get.int x 1) (+ (+ (list.get.int x (- 1 1)) (list.get.int x (- 1 2))) (list.get.int x 2)))) (= (list.get.int x 2) (+ (+ (list.get.int x (- 2 1)) (list.get.int x (- 2 2))) (list.get.int x 3)))) (= (list.get.int x 3) (+ (+ (list.get.int x (- 3 1)) (list.get.int x (- 3 2))) (list.get.int x 4)))) (= (list.get.int x 4) (+ (+ (list.get.int x (- 4 1)) (list.get.int x (- 4 2))) (list.get.int x 5)))) (= (list.get.int x 5) (+ (+ (list.get.int x (- 5 1)) (list.get.int x (- 5 2))) (list.get.int x 6)))) (= (list.get.int x 6) (+ (+ (list.get.int x (- 6 1)) (list.get.int x (- 6 2))) (list.get.int x 7)))) (= (list.get.int x 7) (+ (+ (list.get.int...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle Tribonacci:3
Too many constants for extrapolation

Solving puzzle 378/732: Tribonacci:4
sat_func def sat(seq: List[int], length=761):
    return all(seq[n] == (seq[n - 1] + seq[n - 2] + seq[n + 1] if n % 2 else 1 + n // 2) for n in range(length))
modified_func def sat(seq: List[int], length=wrap_int(761)):
    return all(sym_generator((seq[n] == (seq[n - wrap_int(1)] + seq[n - wrap_int(2)] + seq[n + wrap_int(1)] if n % wrap_int(2) else wrap_int(1) + n // wrap_int(2)) for n in sym_range(length))))
Exception -- for puzzle Tribonacci:4 maximum recursion depth exceeded

Solving puzzle 379/732: CeilingSquares:0
sat_func def sat(running_squares: List[int], x=[201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
modified_func def sat(running_squares: List[int], x=wrap_list([201.1, 301.4, -18.1, 1244122.0, 10101.0101, 10000000.0])):
    for i, v in enumerate(x):
        ceiling = sym_int(v) + (v > wrap_int(0)).__and__(sym_not(v.is_integer()))
        square = ceiling ** wrap_int(2)
        if running_squares[i] != square + (i > wrap_int(0)).__and__(running_squares[i - wrap_int(1)]):
            return False
    return sym_len(running_squares) == sym_len(x)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (not (= (list.get.int x 0) (+ (^ (+ (ite (and true true) 1 0) 201) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0)))) false))
(assert (=> (and (not (not (= (list.get.int x 0) (+ (^ (+ (ite (and true true) 1 0) 201) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0))))) (not (not (= (list.get.int x 1) (+ (^ (+ (ite (and true true) 1 0) 301) 2) (ite (and true (not (= (list.get.int x (- 1 1)) 0))) 1 0))))) (not (not (= (list.get.int x 2) (+ (^ (+ (ite (and false true) 1 0) -18) 2) (ite (and true (not (= (list.get.int x (- 2 1)) 0))) 1 0))))) (not (not (= (list.get.int x 3) (+ (^ (+ (ite (and true false) 1 0) 1244122) 2) (ite (and true (not (= (list.get.int x (- 3 1)) 0))) 1 0))))) (not (not (= (list.get.int x 4) (+ (^ (+ (ite (and true true) 1 0) 10101) 2) (ite (and true (not (= (list.get.int x (- 4 1)) 0))) 1 0))))) (not (not (= (list.get.int x 5) (+ (^ (+ (ite (and true false) 1 0) 10000000) 2) (ite (and true (not (= (list.get.int x (- 5 1)) 0))) 1 0)))))) (= (list.length.int x) 6)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle CeilingSquares:0
Too many constants for extrapolation

Solving puzzle 380/732: CeilingSquares:1
sat_func def sat(running_squares: List[int], x=[9.650000588598111, -8.077324515062926, 2.649836251190308, 0.7153951297675469, -1.9181388431489204, 2.7112675102232675, -6.813543009125667, 7.029917456417941, -2.821293215347511]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
modified_func def sat(running_squares: List[int], x=wrap_list([9.650000588598111, -8.077324515062926, 2.649836251190308, 0.7153951297675469, -1.9181388431489204, 2.7112675102232675, -6.813543009125667, 7.029917456417941, -2.821293215347511])):
    for i, v in enumerate(x):
        ceiling = sym_int(v) + (v > wrap_int(0)).__and__(sym_not(v.is_integer()))
        square = ceiling ** wrap_int(2)
        if running_squares[i] != square + (i > wrap_int(0)).__and__(running_squares[i - wrap_int(1)]):
            return False
    return sym_len(running_squares) == sym_len(x)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (not (= (list.get.int x 0) (+ (^ (+ (ite (and true true) 1 0) 9) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0)))) false))
(assert (=> (and (not (not (= (list.get.int x 0) (+ (^ (+ (ite (and true true) 1 0) 9) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0))))) (not (not (= (list.get.int x 1) (+ (^ (+ (ite (and false true) 1 0) -8) 2) (ite (and true (not (= (list.get.int x (- 1 1)) 0))) 1 0))))) (not (not (= (list.get.int x 2) (+ (^ (+ (ite (and true true) 1 0) 2) 2) (ite (and true (not (= (list.get.int x (- 2 1)) 0))) 1 0))))) (not (not (= (list.get.int x 3) (+ (^ (+ (ite (and true true) 1 0) 0) 2) (ite (and true (not (= (list.get.int x (- 3 1)) 0))) 1 0))))) (not (not (= (list.get.int x 4) (+ (^ (+ (ite (and false true) 1 0) -1) 2) (ite (and true (not (= (list.get.int x (- 4 1)) 0))) 1 0))))) (not (not (= (list.get.int x 5) (+ (^ (+ (ite (and true true) 1 0) 2) 2) (ite (and true (not (= (list.get.int x (- 5 1)) 0))) 1 0))))) (not (not (= (list.get.int x 6) (+ (^ (+ (ite (and false true) 1 0) -6) 2) (ite (and true (not (= (list.get.int x (- 6 1)) 0))) 1 0))))) (not (not (= (list.get.int x 7)...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle CeilingSquares:1
Too many constants for extrapolation

Solving puzzle 381/732: CeilingSquares:2
sat_func def sat(running_squares: List[int], x=[-2.6340066467560996, 4.322176523433114, -1.5079841130054472, -8.985060763252859, -9.074227436202381]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
modified_func def sat(running_squares: List[int], x=wrap_list([-2.6340066467560996, 4.322176523433114, -1.5079841130054472, -8.985060763252859, -9.074227436202381])):
    for i, v in enumerate(x):
        ceiling = sym_int(v) + (v > wrap_int(0)).__and__(sym_not(v.is_integer()))
        square = ceiling ** wrap_int(2)
        if running_squares[i] != square + (i > wrap_int(0)).__and__(running_squares[i - wrap_int(1)]):
            return False
    return sym_len(running_squares) == sym_len(x)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (not (= (list.get.int x 0) (+ (^ (+ (ite (and false true) 1 0) -2) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0)))) false))
(assert (=> (and (not (not (= (list.get.int x 0) (+ (^ (+ (ite (and false true) 1 0) -2) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0))))) (not (not (= (list.get.int x 1) (+ (^ (+ (ite (and true true) 1 0) 4) 2) (ite (and true (not (= (list.get.int x (- 1 1)) 0))) 1 0))))) (not (not (= (list.get.int x 2) (+ (^ (+ (ite (and false true) 1 0) -1) 2) (ite (and true (not (= (list.get.int x (- 2 1)) 0))) 1 0))))) (not (not (= (list.get.int x 3) (+ (^ (+ (ite (and false true) 1 0) -8) 2) (ite (and true (not (= (list.get.int x (- 3 1)) 0))) 1 0))))) (not (not (= (list.get.int x 4) (+ (^ (+ (ite (and false true) 1 0) -9) 2) (ite (and true (not (= (list.get.int x (- 4 1)) 0))) 1 0)))))) (= (list.length.int x) 5)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle CeilingSquares:2
Too many constants for extrapolation

Solving puzzle 382/732: CeilingSquares:3
sat_func def sat(running_squares: List[int], x=[8.257528417306844, -3.7315204726521944, 9.856438333047798, -7.228652980051451, -6.343263566703614, -2.5469735103334834, -3.2923884429492762, -2.991171802818804]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
modified_func def sat(running_squares: List[int], x=wrap_list([8.257528417306844, -3.7315204726521944, 9.856438333047798, -7.228652980051451, -6.343263566703614, -2.5469735103334834, -3.2923884429492762, -2.991171802818804])):
    for i, v in enumerate(x):
        ceiling = sym_int(v) + (v > wrap_int(0)).__and__(sym_not(v.is_integer()))
        square = ceiling ** wrap_int(2)
        if running_squares[i] != square + (i > wrap_int(0)).__and__(running_squares[i - wrap_int(1)]):
            return False
    return sym_len(running_squares) == sym_len(x)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (not (= (list.get.int x 0) (+ (^ (+ (ite (and true true) 1 0) 8) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0)))) false))
(assert (=> (and (not (not (= (list.get.int x 0) (+ (^ (+ (ite (and true true) 1 0) 8) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0))))) (not (not (= (list.get.int x 1) (+ (^ (+ (ite (and false true) 1 0) -3) 2) (ite (and true (not (= (list.get.int x (- 1 1)) 0))) 1 0))))) (not (not (= (list.get.int x 2) (+ (^ (+ (ite (and true true) 1 0) 9) 2) (ite (and true (not (= (list.get.int x (- 2 1)) 0))) 1 0))))) (not (not (= (list.get.int x 3) (+ (^ (+ (ite (and false true) 1 0) -7) 2) (ite (and true (not (= (list.get.int x (- 3 1)) 0))) 1 0))))) (not (not (= (list.get.int x 4) (+ (^ (+ (ite (and false true) 1 0) -6) 2) (ite (and true (not (= (list.get.int x (- 4 1)) 0))) 1 0))))) (not (not (= (list.get.int x 5) (+ (^ (+ (ite (and false true) 1 0) -2) 2) (ite (and true (not (= (list.get.int x (- 5 1)) 0))) 1 0))))) (not (not (= (list.get.int x 6) (+ (^ (+ (ite (and false true) 1 0) -3) 2) (ite (and true (not (= (list.get.int x (- 6 1)) 0))) 1 0))))) (not (not (= (list.get.int ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle CeilingSquares:3
Too many constants for extrapolation

Solving puzzle 383/732: CeilingSquares:4
sat_func def sat(running_squares: List[int], x=[6.608264692857215, -2.204391758043112, 3.8328091843913974, 4.122558586426074, 6.79452673601816, -1.8532801154281735, 6.207567645800566]):
    for i, v in enumerate(x):
        ceiling = int(v) + (v > 0 and not v.is_integer())
        square = ceiling ** 2
        if running_squares[i] != square + (i > 0 and running_squares[i - 1]):
            return False

    return len(running_squares) == len(x)
modified_func def sat(running_squares: List[int], x=wrap_list([6.608264692857215, -2.204391758043112, 3.8328091843913974, 4.122558586426074, 6.79452673601816, -1.8532801154281735, 6.207567645800566])):
    for i, v in enumerate(x):
        ceiling = sym_int(v) + (v > wrap_int(0)).__and__(sym_not(v.is_integer()))
        square = ceiling ** wrap_int(2)
        if running_squares[i] != square + (i > wrap_int(0)).__and__(running_squares[i - wrap_int(1)]):
            return False
    return sym_len(running_squares) == sym_len(x)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (=> (not (= (list.get.int x 0) (+ (^ (+ (ite (and true true) 1 0) 6) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0)))) false))
(assert (=> (and (not (not (= (list.get.int x 0) (+ (^ (+ (ite (and true true) 1 0) 6) 2) (ite (and false (not (= (list.get.int x (- 0 1)) 0))) 1 0))))) (not (not (= (list.get.int x 1) (+ (^ (+ (ite (and false true) 1 0) -2) 2) (ite (and true (not (= (list.get.int x (- 1 1)) 0))) 1 0))))) (not (not (= (list.get.int x 2) (+ (^ (+ (ite (and true true) 1 0) 3) 2) (ite (and true (not (= (list.get.int x (- 2 1)) 0))) 1 0))))) (not (not (= (list.get.int x 3) (+ (^ (+ (ite (and true true) 1 0) 4) 2) (ite (and true (not (= (list.get.int x (- 3 1)) 0))) 1 0))))) (not (not (= (list.get.int x 4) (+ (^ (+ (ite (and true true) 1 0) 6) 2) (ite (and true (not (= (list.get.int x (- 4 1)) 0))) 1 0))))) (not (not (= (list.get.int x 5) (+ (^ (+ (ite (and false true) 1 0) -1) 2) (ite (and true (not (= (list.get.int x (- 5 1)) 0))) 1 0))))) (not (not (= (list.get.int x 6) (+ (^ (+ (ite (and true true) 1 0) 6) 2) (ite (and true (not (= (list.get.int x (- 6 1)) 0))) 1 0)))))) (= (list.length.int x) 7)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle CeilingSquares:4
Too many constants for extrapolation

Solving puzzle 384/732: Drops:0
sat_func def sat(drop_indexes: List[int], nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -100, 1000, 18, 4, -2, -3, -3, 1, 0]):
    d = 0
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            assert drop_indexes[d] == i
            d += 1
    return d == len(drop_indexes)
modified_func def sat(drop_indexes: List[int], nums=wrap_list([wrap_int(2), -wrap_int(1), wrap_int(14), wrap_int(8), wrap_int(9), wrap_int(9), wrap_int(8), wrap_int(4), wrap_int(2), wrap_int(4), wrap_int(3), -wrap_int(100), wrap_int(1000), wrap_int(18), wrap_int(4), -wrap_int(2), -wrap_int(3), -wrap_int(3), wrap_int(1), wrap_int(0)])):
    d = wrap_int(0)
    for i in sym_range(1, sym_len(nums)):
        if nums[i] < nums[i - wrap_int(1)]:
            _assert(drop_indexes[d] == i)
            d += wrap_int(1)
    return d == sym_len(drop_indexes)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (- 1 1) 20))
(assert (>= (- 1 1) -20))
(assert (=> (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (= (list.get.int x 0) 1)))
(assert (=> (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< (- 2 1) 20)))
(assert (=> (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (>= (- 2 1) -20)))
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (=...
(assert (< (- 1 1) 20))
(assert (>= (- 1 1) -20))
(assert (=> (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (< (- 2 1) 20)))
(assert (=> (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (>= (- 2 1) -20)))
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 1000 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -100 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [1, 1]
Exception in checking result: 
WARNING: Solution verification failed for puzzle Drops:0
Two large constants for extrapolation
Solving simpler variation replaced 100 with 3 and 1000 with 5
sat_func def sat(drop_indexes: List[int], nums=[2, -1, 14, 8, 9, 9, 8, 4, 2, 4, 3, -3, 5, 18, 4, -2, -3, -3, 1, 0]):
    d = 0
    for i in range(1, len(nums)):
        if nums[i] < nums[i - 1]:
            assert drop_indexes[d] == i
            d += 1
    return d == len(drop_indexes)
modified_func def sat(drop_indexes: List[int], nums=wrap_list([wrap_int(2), -wrap_int(1), wrap_int(14), wrap_int(8), wrap_int(9), wrap_int(9), wrap_int(8), wrap_int(4), wrap_int(2), wrap_int(4), wrap_int(3), -wrap_int(3), wrap_int(5), wrap_int(18), wrap_int(4), -wrap_int(2), -wrap_int(3), -wrap_int(3), wrap_int(1), wrap_int(0)])):
    d = wrap_int(0)
    for i in sym_range(1, sym_len(nums)):
        if nums[i] < nums[i - wrap_int(1)]:
            _assert(drop_indexes[d] == i)
            d += wrap_int(1)
    return d == sym_len(drop_indexes)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (- 1 1) 20))
(assert (>= (- 1 1) -20))
(assert (=> (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (= (list.get.int x 0) 1)))
(assert (=> (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< (- 2 1) 20)))
(assert (=> (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (>= (- 2 1) -20)))
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (=> (and (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2)))))))))))))))))))) (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite (or (= (- 2...
(assert (< (- 1 1) 20))
(assert (>= (- 1 1) -20))
(assert (=> (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (< (- 2 1) 20)))
(assert (=> (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (>= (- 2 1) -20)))
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(assert (=> (and (not (< -1 (ite (or (= (- 1 1) 19) (= (- 1 1) -1)) 0 (ite (or (= (- 1 1) 18) (= (- 1 1) -2)) 1 (ite (or (= (- 1 1) 17) (= (- 1 1) -3)) -3 (ite (or (= (- 1 1) 16) (= (- 1 1) -4)) -3 (ite (or (= (- 1 1) 15) (= (- 1 1) -5)) -2 (ite (or (= (- 1 1) 14) (= (- 1 1) -6)) 4 (ite (or (= (- 1 1) 13) (= (- 1 1) -7)) 18 (ite (or (= (- 1 1) 12) (= (- 1 1) -8)) 5 (ite (or (= (- 1 1) 11) (= (- 1 1) -9)) -3 (ite (or (= (- 1 1) 10) (= (- 1 1) -10)) 3 (ite (or (= (- 1 1) 9) (= (- 1 1) -11)) 4 (ite (or (= (- 1 1) 8) (= (- 1 1) -12)) 2 (ite (or (= (- 1 1) 7) (= (- 1 1) -13)) 4 (ite (or (= (- 1 1) 6) (= (- 1 1) -14)) 8 (ite (or (= (- 1 1) 5) (= (- 1 1) -15)) 9 (ite (or (= (- 1 1) 4) (= (- 1 1) -16)) 9 (ite (or (= (- 1 1) 3) (= (- 1 1) -17)) 8 (ite (or (= (- 1 1) 2) (= (- 1 1) -18)) 14 (ite (or (= (- 1 1) 1) (= (- 1 1) -19)) -1 2))))))))))))))))))))) (not (< 14 (ite (or (= (- 2 1) 19) (= (- 2 1) -1)) 0 (ite (or (= (- 2 1) 18) (= (- 2 1) -2)) 1 (ite (or (= (- 2 1) 17) (= (- 2 1) -3)) -3 (ite ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [1, 1]
Exception in checking result: 
WARNING: Solution verification failed for puzzle Drops:0

Solving puzzle 385/732: LargestNegSmallestPos:0
sat_func def sat(extremes: List[int], nums=[-10, -4, 100, -40, 2, 2, 3, 17, -50, -25, 18, 41, 9, 11, 15]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
modified_func def sat(extremes: List[int], nums=wrap_list([-wrap_int(10), -wrap_int(4), wrap_int(100), -wrap_int(40), wrap_int(2), wrap_int(2), wrap_int(3), wrap_int(17), -wrap_int(50), -wrap_int(25), wrap_int(18), wrap_int(41), wrap_int(9), wrap_int(11), wrap_int(15)])):
    neg, pos = extremes
    if neg == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(min(nums) >= wrap_int(0)))
    else:
        _assert((neg < wrap_int(0)).__and__(sym_in(neg, nums)).__and__(all(sym_generator(((n >= wrap_int(0)).__or__(n <= neg) for n in nums)))))
    if pos == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(max(nums) <= wrap_int(0)))
    else:
        _assert((pos > wrap_int(0)).__and__(sym_in(pos, nums)).__and__(all(sym_generator(((n <= wrap_int(0)).__or__(n >= pos) for n in nums)))))
    return True
Exception -- for puzzle LargestNegSmallestPos:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 386/732: LargestNegSmallestPos:1
sat_func def sat(extremes: List[int], nums=[-566, -114, -971]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
modified_func def sat(extremes: List[int], nums=wrap_list([-wrap_int(566), -wrap_int(114), -wrap_int(971)])):
    neg, pos = extremes
    if neg == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(min(nums) >= wrap_int(0)))
    else:
        _assert((neg < wrap_int(0)).__and__(sym_in(neg, nums)).__and__(all(sym_generator(((n >= wrap_int(0)).__or__(n <= neg) for n in nums)))))
    if pos == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(max(nums) <= wrap_int(0)))
    else:
        _assert((pos > wrap_int(0)).__and__(sym_in(pos, nums)).__and__(all(sym_generator(((n <= wrap_int(0)).__or__(n >= pos) for n in nums)))))
    return True
Exception -- for puzzle LargestNegSmallestPos:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 387/732: LargestNegSmallestPos:2
sat_func def sat(extremes: List[int], nums=[-90, -123, 227, 905, 613, 735, 988, -215, -190, 272, -920, 581, 212, 317]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
modified_func def sat(extremes: List[int], nums=wrap_list([-wrap_int(90), -wrap_int(123), wrap_int(227), wrap_int(905), wrap_int(613), wrap_int(735), wrap_int(988), -wrap_int(215), -wrap_int(190), wrap_int(272), -wrap_int(920), wrap_int(581), wrap_int(212), wrap_int(317)])):
    neg, pos = extremes
    if neg == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(min(nums) >= wrap_int(0)))
    else:
        _assert((neg < wrap_int(0)).__and__(sym_in(neg, nums)).__and__(all(sym_generator(((n >= wrap_int(0)).__or__(n <= neg) for n in nums)))))
    if pos == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(max(nums) <= wrap_int(0)))
    else:
        _assert((pos > wrap_int(0)).__and__(sym_in(pos, nums)).__and__(all(sym_generator(((n <= wrap_int(0)).__or__(n >= pos) for n in nums)))))
    return True
Exception -- for puzzle LargestNegSmallestPos:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 388/732: LargestNegSmallestPos:3
sat_func def sat(extremes: List[int], nums=[]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
modified_func def sat(extremes: List[int], nums=wrap_list([])):
    neg, pos = extremes
    if neg == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(min(nums) >= wrap_int(0)))
    else:
        _assert((neg < wrap_int(0)).__and__(sym_in(neg, nums)).__and__(all(sym_generator(((n >= wrap_int(0)).__or__(n <= neg) for n in nums)))))
    if pos == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(max(nums) <= wrap_int(0)))
    else:
        _assert((pos > wrap_int(0)).__and__(sym_in(pos, nums)).__and__(all(sym_generator(((n <= wrap_int(0)).__or__(n >= pos) for n in nums)))))
    return True
Exception -- for puzzle LargestNegSmallestPos:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 389/732: LargestNegSmallestPos:4
sat_func def sat(extremes: List[int], nums=[-719, 922, 52, -861, 495, 327, -955, -301, -542, -257, -712]):
    neg, pos = extremes
    if neg == 0:
        assert nums == [] or min(nums) >= 0
    else:
        assert neg < 0 and neg in nums and all(n >= 0 or n <= neg for n in nums)
    if pos == 0:
        assert nums == [] or max(nums) <= 0
    else:
        assert pos > 0 and pos in nums and all(n <= 0 or n >= pos for n in nums)
    return True
modified_func def sat(extremes: List[int], nums=wrap_list([-wrap_int(719), wrap_int(922), wrap_int(52), -wrap_int(861), wrap_int(495), wrap_int(327), -wrap_int(955), -wrap_int(301), -wrap_int(542), -wrap_int(257), -wrap_int(712)])):
    neg, pos = extremes
    if neg == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(min(nums) >= wrap_int(0)))
    else:
        _assert((neg < wrap_int(0)).__and__(sym_in(neg, nums)).__and__(all(sym_generator(((n >= wrap_int(0)).__or__(n <= neg) for n in nums)))))
    if pos == wrap_int(0):
        _assert((nums == wrap_list([])).__or__(max(nums) <= wrap_int(0)))
    else:
        _assert((pos > wrap_int(0)).__and__(sym_in(pos, nums)).__and__(all(sym_generator(((n <= wrap_int(0)).__or__(n >= pos) for n in nums)))))
    return True
Exception -- for puzzle LargestNegSmallestPos:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 390/732: Even4Sum:0
sat_func def sat(summands: List[int], n=1234567890):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
modified_func def sat(summands: List[int], n=wrap_int(1234567890)):
    return (sym_sum(summands) == n).__and__(min(summands) > wrap_int(0)).__and__(sym_len(summands) == wrap_int(4)).__and__(all(sym_generator((s % wrap_int(2) == wrap_int(0) for s in summands))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_405 Int)) (=> (and (>= list_pos_405 0) (< list_pos_405 (list.length.int x))) (forall ((list_pos_404 Int)) (=> (and (>= list_pos_404 0) (< list_pos_404 (list.length.int x))) (forall ((list_pos_403 Int)) (=> (and (>= list_pos_403 0) (< list_pos_403 (list.length.int x))) (and (and (and (= (+ (list.get.int x list_pos_403) 0) 1234567890) (> (list.get.int x list_pos_404) 0)) (= (list.length.int x) 4)) (= (mod (list.get.int x list_pos_405) 2) 0)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Even4Sum:0
One large constant for extrapolation
Solving simpler variation replaced 1234567890 with 3
sat_func def sat(summands: List[int], n=3):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
modified_func def sat(summands: List[int], n=wrap_int(3)):
    return (sym_sum(summands) == n).__and__(min(summands) > wrap_int(0)).__and__(sym_len(summands) == wrap_int(4)).__and__(all(sym_generator((s % wrap_int(2) == wrap_int(0) for s in summands))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_408 Int)) (=> (and (>= list_pos_408 0) (< list_pos_408 (list.length.int x))) (forall ((list_pos_407 Int)) (=> (and (>= list_pos_407 0) (< list_pos_407 (list.length.int x))) (forall ((list_pos_406 Int)) (=> (and (>= list_pos_406 0) (< list_pos_406 (list.length.int x))) (and (and (and (= (+ (list.get.int x list_pos_406) 0) 3) (> (list.get.int x list_pos_407) 0)) (= (list.length.int x) 4)) (= (mod (list.get.int x list_pos_408) 2) 0)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Even4Sum:0

Solving puzzle 391/732: Even4Sum:1
sat_func def sat(summands: List[int], n=8):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
modified_func def sat(summands: List[int], n=wrap_int(8)):
    return (sym_sum(summands) == n).__and__(min(summands) > wrap_int(0)).__and__(sym_len(summands) == wrap_int(4)).__and__(all(sym_generator((s % wrap_int(2) == wrap_int(0) for s in summands))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_411 Int)) (=> (and (>= list_pos_411 0) (< list_pos_411 (list.length.int x))) (forall ((list_pos_410 Int)) (=> (and (>= list_pos_410 0) (< list_pos_410 (list.length.int x))) (forall ((list_pos_409 Int)) (=> (and (>= list_pos_409 0) (< list_pos_409 (list.length.int x))) (and (and (and (= (+ (list.get.int x list_pos_409) 0) 8) (> (list.get.int x list_pos_410) 0)) (= (list.length.int x) 4)) (= (mod (list.get.int x list_pos_411) 2) 0)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Even4Sum:1
Too many constants for extrapolation

Solving puzzle 392/732: Even4Sum:2
sat_func def sat(summands: List[int], n=10):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
modified_func def sat(summands: List[int], n=wrap_int(10)):
    return (sym_sum(summands) == n).__and__(min(summands) > wrap_int(0)).__and__(sym_len(summands) == wrap_int(4)).__and__(all(sym_generator((s % wrap_int(2) == wrap_int(0) for s in summands))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_414 Int)) (=> (and (>= list_pos_414 0) (< list_pos_414 (list.length.int x))) (forall ((list_pos_413 Int)) (=> (and (>= list_pos_413 0) (< list_pos_413 (list.length.int x))) (forall ((list_pos_412 Int)) (=> (and (>= list_pos_412 0) (< list_pos_412 (list.length.int x))) (and (and (and (= (+ (list.get.int x list_pos_412) 0) 10) (> (list.get.int x list_pos_413) 0)) (= (list.length.int x) 4)) (= (mod (list.get.int x list_pos_414) 2) 0)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Even4Sum:2
Too many constants for extrapolation

Solving puzzle 393/732: Even4Sum:3
sat_func def sat(summands: List[int], n=12):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
modified_func def sat(summands: List[int], n=wrap_int(12)):
    return (sym_sum(summands) == n).__and__(min(summands) > wrap_int(0)).__and__(sym_len(summands) == wrap_int(4)).__and__(all(sym_generator((s % wrap_int(2) == wrap_int(0) for s in summands))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_417 Int)) (=> (and (>= list_pos_417 0) (< list_pos_417 (list.length.int x))) (forall ((list_pos_416 Int)) (=> (and (>= list_pos_416 0) (< list_pos_416 (list.length.int x))) (forall ((list_pos_415 Int)) (=> (and (>= list_pos_415 0) (< list_pos_415 (list.length.int x))) (and (and (and (= (+ (list.get.int x list_pos_415) 0) 12) (> (list.get.int x list_pos_416) 0)) (= (list.length.int x) 4)) (= (mod (list.get.int x list_pos_417) 2) 0)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Even4Sum:3
Too many constants for extrapolation

Solving puzzle 394/732: Even4Sum:4
sat_func def sat(summands: List[int], n=465665808):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
modified_func def sat(summands: List[int], n=wrap_int(465665808)):
    return (sym_sum(summands) == n).__and__(min(summands) > wrap_int(0)).__and__(sym_len(summands) == wrap_int(4)).__and__(all(sym_generator((s % wrap_int(2) == wrap_int(0) for s in summands))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_420 Int)) (=> (and (>= list_pos_420 0) (< list_pos_420 (list.length.int x))) (forall ((list_pos_419 Int)) (=> (and (>= list_pos_419 0) (< list_pos_419 (list.length.int x))) (forall ((list_pos_418 Int)) (=> (and (>= list_pos_418 0) (< list_pos_418 (list.length.int x))) (and (and (and (= (+ (list.get.int x list_pos_418) 0) 465665808) (> (list.get.int x list_pos_419) 0)) (= (list.length.int x) 4)) (= (mod (list.get.int x list_pos_420) 2) 0)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Even4Sum:4
One large constant for extrapolation
Solving simpler variation replaced 465665808 with 3
sat_func def sat(summands: List[int], n=3):
    return sum(summands) == n and min(summands) > 0 and len(summands) == 4 and all(s % 2 == 0 for s in summands)
modified_func def sat(summands: List[int], n=wrap_int(3)):
    return (sym_sum(summands) == n).__and__(min(summands) > wrap_int(0)).__and__(sym_len(summands) == wrap_int(4)).__and__(all(sym_generator((s % wrap_int(2) == wrap_int(0) for s in summands))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_423 Int)) (=> (and (>= list_pos_423 0) (< list_pos_423 (list.length.int x))) (forall ((list_pos_422 Int)) (=> (and (>= list_pos_422 0) (< list_pos_422 (list.length.int x))) (forall ((list_pos_421 Int)) (=> (and (>= list_pos_421 0) (< list_pos_421 (list.length.int x))) (and (and (and (= (+ (list.get.int x list_pos_421) 0) 3) (> (list.get.int x list_pos_422) 0)) (= (list.length.int x) 4)) (= (mod (list.get.int x list_pos_423) 2) 0)))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Even4Sum:4

Solving puzzle 395/732: InverseSuperFactorial:0
sat_func def sat(nums: List[int], super_factorials=[1, 2, 1]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
modified_func def sat(nums: List[int], super_factorials=wrap_list([wrap_int(1), wrap_int(2), wrap_int(1)])):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in sym_range(n, 0, -1):
            k = j ** (n - j + wrap_int(1))
            _assert(sf % k == wrap_int(0), sym_str(i) + wrap_str(' ') + sym_str(sf) + wrap_str(' ') + sym_str(j) + wrap_str(' ') + sym_str(n))
            sf //= k
        _assert(sf == wrap_int(1))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(declare-const k_3 Int)
(declare-const k_5 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 1 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 1 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 1))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 0))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 1))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 1 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 0))))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 1 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 1))))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) true)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (+ (* (- 1) k_1) (list.get.int x 0)) (+ 1 k_1))")

Could not find any solution for puzzle InverseSuperFactorial:0
Too many constants for extrapolation

Solving puzzle 396/732: InverseSuperFactorial:1
sat_func def sat(nums: List[int], super_factorials=[24883200, 288, 24883200, 1834933472251084800000, 125411328000, 5056584744960000, 2, 125411328000, 34560, 1834933472251084800000, 34560]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
modified_func def sat(nums: List[int], super_factorials=wrap_list([wrap_int(24883200), wrap_int(288), wrap_int(24883200), wrap_int(1834933472251084800000), wrap_int(125411328000), wrap_int(5056584744960000), wrap_int(2), wrap_int(125411328000), wrap_int(34560), wrap_int(1834933472251084800000), wrap_int(34560)])):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in sym_range(n, 0, -1):
            k = j ** (n - j + wrap_int(1))
            _assert(sf % k == wrap_int(0), sym_str(i) + wrap_str(' ') + sym_str(sf) + wrap_str(' ') + sym_str(j) + wrap_str(' ') + sym_str(n))
            sf //= k
        _assert(sf == wrap_int(1))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(declare-const k_3 Int)
(declare-const k_5 Int)
(declare-const k_7 Int)
(declare-const k_9 Int)
(declare-const k_11 Int)
(declare-const k_13 Int)
(declare-const k_15 Int)
(declare-const k_17 Int)
(declare-const k_19 Int)
(declare-const k_21 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 24883200 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 24883200 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 1))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 288 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 0))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 288 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 1))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 24883200 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 0))))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 24883200 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 1))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 1834933472251084800000 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 0))))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 1834933472251084800000 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 1))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 125411328000 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 0))))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 125411328000 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 1))))))))))))
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (+ (* (- 1) k_1) (list.get.int x 0)) (+ 1 k_1))")

Could not find any solution for puzzle InverseSuperFactorial:1
Too many constants for extrapolation

Solving puzzle 397/732: InverseSuperFactorial:2
sat_func def sat(nums: List[int], super_factorials=[2, 2, 12, 2, 2, 1, 1834933472251084800000, 1, 24883200, 24883200, 1834933472251084800000]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
modified_func def sat(nums: List[int], super_factorials=wrap_list([wrap_int(2), wrap_int(2), wrap_int(12), wrap_int(2), wrap_int(2), wrap_int(1), wrap_int(1834933472251084800000), wrap_int(1), wrap_int(24883200), wrap_int(24883200), wrap_int(1834933472251084800000)])):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in sym_range(n, 0, -1):
            k = j ** (n - j + wrap_int(1))
            _assert(sf % k == wrap_int(0), sym_str(i) + wrap_str(' ') + sym_str(sf) + wrap_str(' ') + sym_str(j) + wrap_str(' ') + sym_str(n))
            sf //= k
        _assert(sf == wrap_int(1))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(declare-const k_3 Int)
(declare-const k_5 Int)
(declare-const k_7 Int)
(declare-const k_9 Int)
(declare-const k_11 Int)
(declare-const k_13 Int)
(declare-const k_15 Int)
(declare-const k_17 Int)
(declare-const k_19 Int)
(declare-const k_21 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 1))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 0))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 1))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 12 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 0))))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 12 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 1))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 0))))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 1))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 0))))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 1))))))))))))
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (+ (* (- 1) k_1) (list.get.int x 0)) (+ 1 k_1))")

Could not find any solution for puzzle InverseSuperFactorial:2
Two large constants for extrapolation
Solving simpler variation replaced 1834933472251084800000 with 3 and 24883200 with 5
sat_func def sat(nums: List[int], super_factorials=[2, 2, 12, 2, 2, 1, 3, 1, 5, 5, 3]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
modified_func def sat(nums: List[int], super_factorials=wrap_list([wrap_int(2), wrap_int(2), wrap_int(12), wrap_int(2), wrap_int(2), wrap_int(1), wrap_int(3), wrap_int(1), wrap_int(5), wrap_int(5), wrap_int(3)])):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in sym_range(n, 0, -1):
            k = j ** (n - j + wrap_int(1))
            _assert(sf % k == wrap_int(0), sym_str(i) + wrap_str(' ') + sym_str(sf) + wrap_str(' ') + sym_str(j) + wrap_str(' ') + sym_str(n))
            sf //= k
        _assert(sf == wrap_int(1))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(declare-const k_3 Int)
(declare-const k_5 Int)
(declare-const k_7 Int)
(declare-const k_9 Int)
(declare-const k_11 Int)
(declare-const k_13 Int)
(declare-const k_15 Int)
(declare-const k_17 Int)
(declare-const k_19 Int)
(declare-const k_21 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 1))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 0))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 1))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 12 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 0))))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 12 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 1))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 0))))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 1))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 0))))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 1))))))))))))
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (+ (* (- 1) k_1) (list.get.int x 0)) (+ 1 k_1))")

Could not find any solution for puzzle InverseSuperFactorial:2

Solving puzzle 398/732: InverseSuperFactorial:3
sat_func def sat(nums: List[int], super_factorials=[1, 1, 12, 2, 12, 12, 2, 2, 12, 2, 24883200]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
modified_func def sat(nums: List[int], super_factorials=wrap_list([wrap_int(1), wrap_int(1), wrap_int(12), wrap_int(2), wrap_int(12), wrap_int(12), wrap_int(2), wrap_int(2), wrap_int(12), wrap_int(2), wrap_int(24883200)])):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in sym_range(n, 0, -1):
            k = j ** (n - j + wrap_int(1))
            _assert(sf % k == wrap_int(0), sym_str(i) + wrap_str(' ') + sym_str(sf) + wrap_str(' ') + sym_str(j) + wrap_str(' ') + sym_str(n))
            sf //= k
        _assert(sf == wrap_int(1))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(declare-const k_3 Int)
(declare-const k_5 Int)
(declare-const k_7 Int)
(declare-const k_9 Int)
(declare-const k_11 Int)
(declare-const k_13 Int)
(declare-const k_15 Int)
(declare-const k_17 Int)
(declare-const k_19 Int)
(declare-const k_21 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 1 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 1 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 1))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 1 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 0))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 1 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 1))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 12 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 0))))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 12 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 1))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 0))))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 1))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 12 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 0))))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 12 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 1))))))))))))
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (+ (* (- 1) k_1) (list.get.int x 0)) (+ 1 k_1))")

Could not find any solution for puzzle InverseSuperFactorial:3
One large constant for extrapolation
Solving simpler variation replaced 24883200 with 3
sat_func def sat(nums: List[int], super_factorials=[1, 1, 12, 2, 12, 12, 2, 2, 12, 2, 3]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
modified_func def sat(nums: List[int], super_factorials=wrap_list([wrap_int(1), wrap_int(1), wrap_int(12), wrap_int(2), wrap_int(12), wrap_int(12), wrap_int(2), wrap_int(2), wrap_int(12), wrap_int(2), wrap_int(3)])):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in sym_range(n, 0, -1):
            k = j ** (n - j + wrap_int(1))
            _assert(sf % k == wrap_int(0), sym_str(i) + wrap_str(' ') + sym_str(sf) + wrap_str(' ') + sym_str(j) + wrap_str(' ') + sym_str(n))
            sf //= k
        _assert(sf == wrap_int(1))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(declare-const k_3 Int)
(declare-const k_5 Int)
(declare-const k_7 Int)
(declare-const k_9 Int)
(declare-const k_11 Int)
(declare-const k_13 Int)
(declare-const k_15 Int)
(declare-const k_17 Int)
(declare-const k_19 Int)
(declare-const k_21 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 1 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 1 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 1))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 1 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 0))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 1 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 1))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 12 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 0))))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 12 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 1))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 2 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 0))))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 2 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 1))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 12 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 0))))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 12 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 1))))))))))))
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (+ (* (- 1) k_1) (list.get.int x 0)) (+ 1 k_1))")

Could not find any solution for puzzle InverseSuperFactorial:3

Solving puzzle 399/732: InverseSuperFactorial:4
sat_func def sat(nums: List[int], super_factorials=[1, 125411328000, 34560, 288, 24883200, 1, 12, 2, 5056584744960000, 1834933472251084800000, 125411328000]):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in range(n, 0, -1):
            k = j ** (n - j + 1)
            assert sf % k == 0, f"{i} {sf} {j} {n}"
            sf //= k
        assert sf == 1
    return True
modified_func def sat(nums: List[int], super_factorials=wrap_list([wrap_int(1), wrap_int(125411328000), wrap_int(34560), wrap_int(288), wrap_int(24883200), wrap_int(1), wrap_int(12), wrap_int(2), wrap_int(5056584744960000), wrap_int(1834933472251084800000), wrap_int(125411328000)])):
    for i, sf in enumerate(super_factorials):
        n = nums[i]
        for j in sym_range(n, 0, -1):
            k = j ** (n - j + wrap_int(1))
            _assert(sf % k == wrap_int(0), sym_str(i) + wrap_str(' ') + sym_str(sf) + wrap_str(' ') + sym_str(j) + wrap_str(' ') + sym_str(n))
            sf //= k
        _assert(sf == wrap_int(1))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(declare-const k_1 Int)
(declare-const k_3 Int)
(declare-const k_5 Int)
(declare-const k_7 Int)
(declare-const k_9 Int)
(declare-const k_11 Int)
(declare-const k_13 Int)
(declare-const k_15 Int)
(declare-const k_17 Int)
(declare-const k_19 Int)
(declare-const k_21 Int)
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 1 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 0))))
(assert (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 1 (^ i_0 (+ (- (list.get.int x 0) i_0) 1))) 1))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 125411328000 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 0))))))
(assert (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 125411328000 (^ i_2 (+ (- (list.get.int x 1) i_2) 1))) 1))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 34560 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 0))))))))
(assert (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 34560 (^ i_4 (+ (- (list.get.int x 2) i_4) 1))) 1))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 288 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 0))))))))))
(assert (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 288 (^ i_6 (+ (- (list.get.int x 3) i_6) 1))) 1))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (mod 24883200 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 0))))))))))))
(assert (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0)) (>= k_1 0)) (= i_0 (+ (list.get.int x 0) (* k_1 -1)))) (< k_1 (div (- 0 (list.get.int x 0)) -1))) (= (div 24883200 (^ i_8 (+ (- (list.get.int x 4) i_8) 1))) 1))))))))))))
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (< i_2 0)) (>= k_3 0)) (= i_2 (+ (list.get.int x 1) (* k_3 -1)))) (< k_3 (div (- 0 (list.get.int x 1)) -1))) (forall ((i_0 Int)) (=> (and (and (and (and (>= i_0 (list.get.int x 0)) (< i_0 0...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int x 2)) (< i_4 0)) (>= k_5 0)) (= i_4 (+ (list.get.int x 2) (* k_5 -1)))) (< k_5 (div (- 0 (list.get.int x 2)) -1))) (forall ((i_2 Int)) (=> (and (and (and (and (>= i_2 (list.get.int x 1)) (...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.get.int x 3)) (< i_6 0)) (>= k_7 0)) (= i_6 (+ (list.get.int x 3) (* k_7 -1)))) (< k_7 (div (- 0 (list.get.int x 3)) -1))) (forall ((i_4 Int)) (=> (and (and (and (and (>= i_4 (list.get.int ...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 (list.get.int x 4)) (< i_8 0)) (>= k_9 0)) (= i_8 (+ (list.get.int x 4) (* k_9 -1)))) (< k_9 (div (- 0 (list.get.int x 4)) -1))) (forall ((i_6 Int)) (=> (and (and (and (and (>= i_6 (list.g...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= i_10 (list.get.int x 5)) (< i_10 0)) (>= k_11 0)) (= i_10 (+ (list.get.int x 5) (* k_11 -1)))) (< k_11 (div (- 0 (list.get.int x 5)) -1))) (forall ((i_8 Int)) (=> (and (and (and (and (>= i_8 ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(assert (forall ((i_20 Int)) (=> (and (and (and (and (>= i_20 (list.get.int x 10)) (< i_20 0)) (>= k_21 0)) (= i_20 (+ (list.get.int x 10) (* k_21 -1)))) (< k_21 (div (- 0 (list.get.int x 10)) -1))) (forall ((i_18 Int)) (=> (and (and (and (and (>= i_18 (list.get.int x 9)) (< i_18 0)) (>= k_19 0)) (= i_18 (+ (list.get.int x 9) (* k_19 -1)))) (< k_19 (div (- 0 (list.get.int x 9)) -1))) (forall ((i_16 Int)) (=> (and (and (and (and (>= i_16 (list.get.int x 8)) (< i_16 0)) (>= k_17 0)) (= i_16 (+ (list.get.int x 8) (* k_17 -1)))) (< k_17 (div (- 0 (list.get.int x 8)) -1))) (forall ((i_14 Int)) (=> (and (and (and (and (>= i_14 (list.get.int x 7)) (< i_14 0)) (>= k_15 0)) (= i_14 (+ (list.get.int x 7) (* k_15 -1)))) (< k_15 (div (- 0 (list.get.int x 7)) -1))) (forall ((i_12 Int)) (=> (and (and (and (and (>= i_12 (list.get.int x 6)) (< i_12 0)) (>= k_13 0)) (= i_12 (+ (list.get.int x 6) (* k_13 -1)))) (< k_13 (div (- 0 (list.get.int x 6)) -1))) (forall ((i_10 Int)) (=> (and (and (and (and (>= ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "The exponent of the POW(^) operator can only be a positive integral constant below 67108864. Exception occurred in:
  (^ (+ (* (- 1) k_1) (list.get.int x 0)) (+ 1 k_1))")

Could not find any solution for puzzle InverseSuperFactorial:4
Too many constants for extrapolation

Solving puzzle 400/732: FilenameOK:0
sat_func def sat(valids: List[str], filenames=['cat.txt', '!jog.dll', '31F9.html', 'Is this okay?.txt', '.exe', '']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
modified_func def sat(valids: List[str], filenames=wrap_list([wrap_str('cat.txt'), wrap_str('!jog.dll'), wrap_str('31F9.html'), wrap_str('Is this okay?.txt'), wrap_str('.exe'), wrap_str('')])):
    _assert(sym_len(valids) == sym_len(filenames))
    for v, f in sym_zip(valids, filenames):
        n_digits = sym_sum(sym_generator((c.isdigit() for c in f)))
        if v == wrap_str('Yes'):
            prefix, ext = f.split(wrap_str('.'))
            _assert(sym_in(ext, wrap_list([wrap_str('txt'), wrap_str('dll'), wrap_str('exe')])).__and__(prefix[wrap_int(0)].isalpha()).__and__(n_digits < wrap_int(4)))
        else:
            _assert(v == wrap_str('No'))
            _assert((f.split(wrap_str('.'))[1:] not in wrap_list([wrap_list([wrap_str('txt')]), wrap_list([wrap_str('dll')]), wrap_list([wrap_str('exe')])])).__or__(sym_not(f[wrap_int(0)].isalpha())).__or__(n_digits > wrap_int(3)))
    return True
Exception -- for puzzle FilenameOK:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 401/732: FilenameOK:1
sat_func def sat(valids: List[str], filenames=['mtherylP.exe', 'Qbatw.mp4', 'DtextadusypykagusakoA.exe', 'Bmigusocycyth].mp4', ')kutextulelucezyQ.tar.zip', 'nchelycozitixiM.exe', 'wrichevyxi.exe', 'Nvew0.txt', 'dnochofazehaxaharop!.dll', '8mefasechuxacyxg.txt', 'isijufotextydycifu3.mp4', 'vmithujydet[.mp4']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
modified_func def sat(valids: List[str], filenames=wrap_list([wrap_str('mtherylP.exe'), wrap_str('Qbatw.mp4'), wrap_str('DtextadusypykagusakoA.exe'), wrap_str('Bmigusocycyth].mp4'), wrap_str(')kutextulelucezyQ.tar.zip'), wrap_str('nchelycozitixiM.exe'), wrap_str('wrichevyxi.exe'), wrap_str('Nvew0.txt'), wrap_str('dnochofazehaxaharop!.dll'), wrap_str('8mefasechuxacyxg.txt'), wrap_str('isijufotextydycifu3.mp4'), wrap_str('vmithujydet[.mp4')])):
    _assert(sym_len(valids) == sym_len(filenames))
    for v, f in sym_zip(valids, filenames):
        n_digits = sym_sum(sym_generator((c.isdigit() for c in f)))
        if v == wrap_str('Yes'):
            prefix, ext = f.split(wrap_str('.'))
            _assert(sym_in(ext, wrap_list([wrap_str('txt'), wrap_str('dll'), wrap_str('exe')])).__and__(prefix[wrap_int(0)].isalpha()).__and__(n_digits < wrap_int(4)))
        else:
            _assert(v == wrap_str('No'))
            _assert((f.split(wrap_str('.'))[1:] not in wrap_list([wrap_list([wrap_str('txt')]), wrap_list([wrap_str('dll')]), wrap_list([wrap_str('exe')])])).__or__(sym_not(f[wrap_int(0)].isalpha())).__or__(n_digits > wrap_int(3)))
    return True
Exception -- for puzzle FilenameOK:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 402/732: FilenameOK:2
sat_func def sat(valids: List[str], filenames=['WbytyjachuquithX.tar.zip', 'Pzuzuvetextr.mp4', 'Xcymem[.tar.zip', 'AhypagacheJ.dll', 'JbubefichiwyryzydochC.exe', '8te;.dll', 'wtextoL.mp4', 'mthowexezixexuqd.exe', '^nehapu4.txt', 'Hsovap].txt', 'Cchoxe>.tar.zip', '1quobejugichewabechek#.dll']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
modified_func def sat(valids: List[str], filenames=wrap_list([wrap_str('WbytyjachuquithX.tar.zip'), wrap_str('Pzuzuvetextr.mp4'), wrap_str('Xcymem[.tar.zip'), wrap_str('AhypagacheJ.dll'), wrap_str('JbubefichiwyryzydochC.exe'), wrap_str('8te;.dll'), wrap_str('wtextoL.mp4'), wrap_str('mthowexezixexuqd.exe'), wrap_str('^nehapu4.txt'), wrap_str('Hsovap].txt'), wrap_str('Cchoxe>.tar.zip'), wrap_str('1quobejugichewabechek#.dll')])):
    _assert(sym_len(valids) == sym_len(filenames))
    for v, f in sym_zip(valids, filenames):
        n_digits = sym_sum(sym_generator((c.isdigit() for c in f)))
        if v == wrap_str('Yes'):
            prefix, ext = f.split(wrap_str('.'))
            _assert(sym_in(ext, wrap_list([wrap_str('txt'), wrap_str('dll'), wrap_str('exe')])).__and__(prefix[wrap_int(0)].isalpha()).__and__(n_digits < wrap_int(4)))
        else:
            _assert(v == wrap_str('No'))
            _assert((f.split(wrap_str('.'))[1:] not in wrap_list([wrap_list([wrap_str('txt')]), wrap_list([wrap_str('dll')]), wrap_list([wrap_str('exe')])])).__or__(sym_not(f[wrap_int(0)].isalpha())).__or__(n_digits > wrap_int(3)))
    return True
Exception -- for puzzle FilenameOK:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 403/732: FilenameOK:3
sat_func def sat(valids: List[str], filenames=['+thunidothytextofi..txt', 'Onithytemolysefel$.mp4', 'Clychifopozesuxijuvo.mp4']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
modified_func def sat(valids: List[str], filenames=wrap_list([wrap_str('+thunidothytextofi..txt'), wrap_str('Onithytemolysefel$.mp4'), wrap_str('Clychifopozesuxijuvo.mp4')])):
    _assert(sym_len(valids) == sym_len(filenames))
    for v, f in sym_zip(valids, filenames):
        n_digits = sym_sum(sym_generator((c.isdigit() for c in f)))
        if v == wrap_str('Yes'):
            prefix, ext = f.split(wrap_str('.'))
            _assert(sym_in(ext, wrap_list([wrap_str('txt'), wrap_str('dll'), wrap_str('exe')])).__and__(prefix[wrap_int(0)].isalpha()).__and__(n_digits < wrap_int(4)))
        else:
            _assert(v == wrap_str('No'))
            _assert((f.split(wrap_str('.'))[1:] not in wrap_list([wrap_list([wrap_str('txt')]), wrap_list([wrap_str('dll')]), wrap_list([wrap_str('exe')])])).__or__(sym_not(f[wrap_int(0)].isalpha())).__or__(n_digits > wrap_int(3)))
    return True
Exception -- for puzzle FilenameOK:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 404/732: FilenameOK:4
sat_func def sat(valids: List[str], filenames=['XsiwemunarytextatecY.exe', 'Dfanachofegerevojyv].dll', ')pethymula0.exe', '4dihurudyjahatextov.exe', '0hyxZ.tar.zip', 'WbywithachoxenomeW.mp4', 'rniworatuzepatapuy.txt', '6quypucocj.exe', 'Zmavifolulitek.txt', 'ywue.exe', 'QhI.txt', ')vugu^.mp4', 'ygihycogaduhalyfyzen.tar.zip', 'icubonaguchegupejuha(.exe', ']gothusodawinuwidinexD.mp4', ' wyw(.exe']):
    assert len(valids) == len(filenames)
    for v, f in zip(valids, filenames):
        n_digits = sum(c.isdigit() for c in f)
        if v == "Yes":
            prefix, ext = f.split(".")
            assert ext in ["txt", "dll", "exe"] and prefix[0].isalpha() and n_digits < 4
        else:
            assert v == "No"
            assert f.split(".")[1:] not in [['txt'], ['dll'], ['exe']] or not f[0].isalpha() or n_digits > 3
    return True
modified_func def sat(valids: List[str], filenames=wrap_list([wrap_str('XsiwemunarytextatecY.exe'), wrap_str('Dfanachofegerevojyv].dll'), wrap_str(')pethymula0.exe'), wrap_str('4dihurudyjahatextov.exe'), wrap_str('0hyxZ.tar.zip'), wrap_str('WbywithachoxenomeW.mp4'), wrap_str('rniworatuzepatapuy.txt'), wrap_str('6quypucocj.exe'), wrap_str('Zmavifolulitek.txt'), wrap_str('ywue.exe'), wrap_str('QhI.txt'), wrap_str(')vugu^.mp4'), wrap_str('ygihycogaduhalyfyzen.tar.zip'), wrap_str('icubonaguchegupejuha(.exe'), wrap_str(']gothusodawinuwidinexD.mp4'), wrap_str(' wyw(.exe')])):
    _assert(sym_len(valids) == sym_len(filenames))
    for v, f in sym_zip(valids, filenames):
        n_digits = sym_sum(sym_generator((c.isdigit() for c in f)))
        if v == wrap_str('Yes'):
            prefix, ext = f.split(wrap_str('.'))
            _assert(sym_in(ext, wrap_list([wrap_str('txt'), wrap_str('dll'), wrap_str('exe')])).__and__(prefix[wrap_int(0)].isalpha()).__and__(n_digits < wrap_int(4)))
        else:
            _assert(v == wrap_str('No'))
            _assert((f.split(wrap_str('.'))[1:] not in wrap_list([wrap_list([wrap_str('txt')]), wrap_list([wrap_str('dll')]), wrap_list([wrap_str('exe')])])).__or__(sym_not(f[wrap_int(0)].isalpha())).__or__(n_digits > wrap_int(3)))
    return True
Exception -- for puzzle FilenameOK:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 405/732: FindStrangeSum:0
sat_func def sat(lst: List[int], tot=1125181293221):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=wrap_int(1125181293221)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_429 Int)) (=> (and (>= list_pos_429 0) (< list_pos_429 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_429) 3) 0) (= (+ (^ (list.get.int x list_pos_429) 2) 0) 1125181293221)))))
(assert (forall ((list_pos_430 Int)) (=> (and (>= list_pos_430 0) (< list_pos_430 (list.length.int x))) (forall ((list_pos_429 Int)) (=> (and (>= list_pos_429 0) (< list_pos_429 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_430) 3) 0)) (not (= (mod (list.get.int x list_pos_430) 4) 0))) (= (+ (list.get.int x list_pos_430) 0) 1125181293221)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:0
One large constant for extrapolation
Solving simpler variation replaced 1125181293221 with 3
sat_func def sat(lst: List[int], tot=3):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=wrap_int(3)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_431 Int)) (=> (and (>= list_pos_431 0) (< list_pos_431 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_431) 3) 0) (= (+ (^ (list.get.int x list_pos_431) 2) 0) 3)))))
(assert (forall ((list_pos_432 Int)) (=> (and (>= list_pos_432 0) (< list_pos_432 (list.length.int x))) (forall ((list_pos_431 Int)) (=> (and (>= list_pos_431 0) (< list_pos_431 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_432) 3) 0)) (not (= (mod (list.get.int x list_pos_432) 4) 0))) (= (+ (list.get.int x list_pos_432) 0) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:0

Solving puzzle 406/732: FindStrangeSum:1
sat_func def sat(lst: List[int], tot=704):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=wrap_int(704)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_433 Int)) (=> (and (>= list_pos_433 0) (< list_pos_433 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_433) 3) 0) (= (+ (^ (list.get.int x list_pos_433) 2) 0) 704)))))
(assert (forall ((list_pos_434 Int)) (=> (and (>= list_pos_434 0) (< list_pos_434 (list.length.int x))) (forall ((list_pos_433 Int)) (=> (and (>= list_pos_433 0) (< list_pos_433 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_434) 3) 0)) (not (= (mod (list.get.int x list_pos_434) 4) 0))) (= (+ (list.get.int x list_pos_434) 0) 704)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:1
One large constant for extrapolation
Solving simpler variation replaced 704 with 3
sat_func def sat(lst: List[int], tot=3):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=wrap_int(3)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_435 Int)) (=> (and (>= list_pos_435 0) (< list_pos_435 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_435) 3) 0) (= (+ (^ (list.get.int x list_pos_435) 2) 0) 3)))))
(assert (forall ((list_pos_436 Int)) (=> (and (>= list_pos_436 0) (< list_pos_436 (list.length.int x))) (forall ((list_pos_435 Int)) (=> (and (>= list_pos_435 0) (< list_pos_435 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_436) 3) 0)) (not (= (mod (list.get.int x list_pos_436) 4) 0))) (= (+ (list.get.int x list_pos_436) 0) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:1

Solving puzzle 407/732: FindStrangeSum:2
sat_func def sat(lst: List[int], tot=8849):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=wrap_int(8849)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_437 Int)) (=> (and (>= list_pos_437 0) (< list_pos_437 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_437) 3) 0) (= (+ (^ (list.get.int x list_pos_437) 2) 0) 8849)))))
(assert (forall ((list_pos_438 Int)) (=> (and (>= list_pos_438 0) (< list_pos_438 (list.length.int x))) (forall ((list_pos_437 Int)) (=> (and (>= list_pos_437 0) (< list_pos_437 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_438) 3) 0)) (not (= (mod (list.get.int x list_pos_438) 4) 0))) (= (+ (list.get.int x list_pos_438) 0) 8849)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:2
One large constant for extrapolation
Solving simpler variation replaced 8849 with 3
sat_func def sat(lst: List[int], tot=3):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=wrap_int(3)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_439 Int)) (=> (and (>= list_pos_439 0) (< list_pos_439 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_439) 3) 0) (= (+ (^ (list.get.int x list_pos_439) 2) 0) 3)))))
(assert (forall ((list_pos_440 Int)) (=> (and (>= list_pos_440 0) (< list_pos_440 (list.length.int x))) (forall ((list_pos_439 Int)) (=> (and (>= list_pos_439 0) (< list_pos_439 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_440) 3) 0)) (not (= (mod (list.get.int x list_pos_440) 4) 0))) (= (+ (list.get.int x list_pos_440) 0) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:2

Solving puzzle 408/732: FindStrangeSum:3
sat_func def sat(lst: List[int], tot=-516784):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=-wrap_int(516784)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_441 Int)) (=> (and (>= list_pos_441 0) (< list_pos_441 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_441) 3) 0) (= (+ (^ (list.get.int x list_pos_441) 2) 0) -516784)))))
(assert (forall ((list_pos_442 Int)) (=> (and (>= list_pos_442 0) (< list_pos_442 (list.length.int x))) (forall ((list_pos_441 Int)) (=> (and (>= list_pos_441 0) (< list_pos_441 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_442) 3) 0)) (not (= (mod (list.get.int x list_pos_442) 4) 0))) (= (+ (list.get.int x list_pos_442) 0) -516784)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:3
One large constant for extrapolation
Solving simpler variation replaced 516784 with 3
sat_func def sat(lst: List[int], tot=-3):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=-wrap_int(3)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_443 Int)) (=> (and (>= list_pos_443 0) (< list_pos_443 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_443) 3) 0) (= (+ (^ (list.get.int x list_pos_443) 2) 0) -3)))))
(assert (forall ((list_pos_444 Int)) (=> (and (>= list_pos_444 0) (< list_pos_444 (list.length.int x))) (forall ((list_pos_443 Int)) (=> (and (>= list_pos_443 0) (< list_pos_443 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_444) 3) 0)) (not (= (mod (list.get.int x list_pos_444) 4) 0))) (= (+ (list.get.int x list_pos_444) 0) -3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:3

Solving puzzle 409/732: FindStrangeSum:4
sat_func def sat(lst: List[int], tot=976643993):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=wrap_int(976643993)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_445 Int)) (=> (and (>= list_pos_445 0) (< list_pos_445 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_445) 3) 0) (= (+ (^ (list.get.int x list_pos_445) 2) 0) 976643993)))))
(assert (forall ((list_pos_446 Int)) (=> (and (>= list_pos_446 0) (< list_pos_446 (list.length.int x))) (forall ((list_pos_445 Int)) (=> (and (>= list_pos_445 0) (< list_pos_445 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_446) 3) 0)) (not (= (mod (list.get.int x list_pos_446) 4) 0))) (= (+ (list.get.int x list_pos_446) 0) 976643993)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:4
One large constant for extrapolation
Solving simpler variation replaced 976643993 with 3
sat_func def sat(lst: List[int], tot=3):
    return sum(n ** 2 if n % 3 == 0 else n ** 3 if n % 4 == 0 else n for n in lst) == tot
modified_func def sat(lst: List[int], tot=wrap_int(3)):
    return sym_sum(sym_generator((n ** wrap_int(2) if n % wrap_int(3) == wrap_int(0) else n ** wrap_int(3) if n % wrap_int(4) == wrap_int(0) else n for n in lst))) == tot
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_447 Int)) (=> (and (>= list_pos_447 0) (< list_pos_447 (list.length.int x))) (=> (= (mod (list.get.int x list_pos_447) 3) 0) (= (+ (^ (list.get.int x list_pos_447) 2) 0) 3)))))
(assert (forall ((list_pos_448 Int)) (=> (and (>= list_pos_448 0) (< list_pos_448 (list.length.int x))) (forall ((list_pos_447 Int)) (=> (and (>= list_pos_447 0) (< list_pos_447 (list.length.int x))) (=> (and (not (= (mod (list.get.int x list_pos_448) 3) 0)) (not (= (mod (list.get.int x list_pos_448) 4) 0))) (= (+ (list.get.int x list_pos_448) 0) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FindStrangeSum:4

Solving puzzle 410/732: SortByDigitSum:0
sat_func def sat(ordered: List[int], nums=[1, 0, -1, -100, 10, 14, 235251, 11, 10000, 2000001, -155]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
modified_func def sat(ordered: List[int], nums=wrap_list([wrap_int(1), wrap_int(0), -wrap_int(1), -wrap_int(100), wrap_int(10), wrap_int(14), wrap_int(235251), wrap_int(11), wrap_int(10000), wrap_int(2000001), -wrap_int(155)])):
    digit_sums = [sym_sum(sym_generator((sym_int(c) for c in sym_str(n) if c != wrap_str('-')))) for n in ordered]
    return (sym_sorted(ordered) == sym_sorted(nums)).__and__(digit_sums == sym_sorted(digit_sums))
Exception -- for puzzle SortByDigitSum:0 Cannot convert symbolic integer to index

Solving puzzle 411/732: SortByDigitSum:1
sat_func def sat(ordered: List[int], nums=[-222, -896, 914, 817]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
modified_func def sat(ordered: List[int], nums=wrap_list([-wrap_int(222), -wrap_int(896), wrap_int(914), wrap_int(817)])):
    digit_sums = [sym_sum(sym_generator((sym_int(c) for c in sym_str(n) if c != wrap_str('-')))) for n in ordered]
    return (sym_sorted(ordered) == sym_sorted(nums)).__and__(digit_sums == sym_sorted(digit_sums))
Exception -- for puzzle SortByDigitSum:1 Cannot convert symbolic integer to index

Solving puzzle 412/732: SortByDigitSum:2
sat_func def sat(ordered: List[int], nums=[208]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
modified_func def sat(ordered: List[int], nums=wrap_list([wrap_int(208)])):
    digit_sums = [sym_sum(sym_generator((sym_int(c) for c in sym_str(n) if c != wrap_str('-')))) for n in ordered]
    return (sym_sorted(ordered) == sym_sorted(nums)).__and__(digit_sums == sym_sorted(digit_sums))
Exception -- for puzzle SortByDigitSum:2 Cannot convert symbolic integer to index

Solving puzzle 413/732: SortByDigitSum:3
sat_func def sat(ordered: List[int], nums=[]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
modified_func def sat(ordered: List[int], nums=wrap_list([])):
    digit_sums = [sym_sum(sym_generator((sym_int(c) for c in sym_str(n) if c != wrap_str('-')))) for n in ordered]
    return (sym_sorted(ordered) == sym_sorted(nums)).__and__(digit_sums == sym_sorted(digit_sums))
Exception -- for puzzle SortByDigitSum:3 Cannot convert symbolic integer to index

Solving puzzle 414/732: SortByDigitSum:4
sat_func def sat(ordered: List[int], nums=[232, -710]):
    digit_sums = [sum(int(c) for c in str(n) if c != "-") for n in ordered]
    return sorted(ordered) == sorted(nums) and digit_sums == sorted(digit_sums)
modified_func def sat(ordered: List[int], nums=wrap_list([wrap_int(232), -wrap_int(710)])):
    digit_sums = [sym_sum(sym_generator((sym_int(c) for c in sym_str(n) if c != wrap_str('-')))) for n in ordered]
    return (sym_sorted(ordered) == sym_sorted(nums)).__and__(digit_sums == sym_sorted(digit_sums))
Exception -- for puzzle SortByDigitSum:4 Cannot convert symbolic integer to index

Solving puzzle 415/732: BigOdds:0
sat_func def sat(odds: List[int], nums=[204, 109, 203, 17, 45, 11, 21, 99, 909, 16, -33, 3, 17]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
modified_func def sat(odds: List[int], nums=wrap_list([wrap_int(204), wrap_int(109), wrap_int(203), wrap_int(17), wrap_int(45), wrap_int(11), wrap_int(21), wrap_int(99), wrap_int(909), wrap_int(16), -wrap_int(33), wrap_int(3), wrap_int(17)])):
    _assert(all(sym_generator(((o > wrap_int(10)).__and__(odds.count(o) == nums.count(o)).__and__(sym_int(sym_str(o)[i]) % wrap_int(2)) for o in odds for i in wrap_list([-wrap_int(1), wrap_int(0)])))))
    return all(sym_generator((sym_in(n, odds).__or__(n <= wrap_int(10)).__or__(sym_int(sym_str(n)[wrap_int(0)]) % wrap_int(2) == wrap_int(0)).__or__(sym_int(sym_str(n)[-wrap_int(1)]) % wrap_int(2) == wrap_int(0)) for n in nums)))
Exception -- for puzzle BigOdds:0 int() argument must be a string, a bytes-like object or a real number, not 'SymbolicSlice'

Solving puzzle 416/732: BigOdds:1
sat_func def sat(odds: List[int], nums=[13559]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
modified_func def sat(odds: List[int], nums=wrap_list([wrap_int(13559)])):
    _assert(all(sym_generator(((o > wrap_int(10)).__and__(odds.count(o) == nums.count(o)).__and__(sym_int(sym_str(o)[i]) % wrap_int(2)) for o in odds for i in wrap_list([-wrap_int(1), wrap_int(0)])))))
    return all(sym_generator((sym_in(n, odds).__or__(n <= wrap_int(10)).__or__(sym_int(sym_str(n)[wrap_int(0)]) % wrap_int(2) == wrap_int(0)).__or__(sym_int(sym_str(n)[-wrap_int(1)]) % wrap_int(2) == wrap_int(0)) for n in nums)))
Exception -- for puzzle BigOdds:1 int() argument must be a string, a bytes-like object or a real number, not 'SymbolicSlice'

Solving puzzle 417/732: BigOdds:2
sat_func def sat(odds: List[int], nums=[12320, 771, 11224, 17261]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
modified_func def sat(odds: List[int], nums=wrap_list([wrap_int(12320), wrap_int(771), wrap_int(11224), wrap_int(17261)])):
    _assert(all(sym_generator(((o > wrap_int(10)).__and__(odds.count(o) == nums.count(o)).__and__(sym_int(sym_str(o)[i]) % wrap_int(2)) for o in odds for i in wrap_list([-wrap_int(1), wrap_int(0)])))))
    return all(sym_generator((sym_in(n, odds).__or__(n <= wrap_int(10)).__or__(sym_int(sym_str(n)[wrap_int(0)]) % wrap_int(2) == wrap_int(0)).__or__(sym_int(sym_str(n)[-wrap_int(1)]) % wrap_int(2) == wrap_int(0)) for n in nums)))
Exception -- for puzzle BigOdds:2 int() argument must be a string, a bytes-like object or a real number, not 'SymbolicSlice'

Solving puzzle 418/732: BigOdds:3
sat_func def sat(odds: List[int], nums=[13251, 8503, 5595, 19712, 10196, 16271]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
modified_func def sat(odds: List[int], nums=wrap_list([wrap_int(13251), wrap_int(8503), wrap_int(5595), wrap_int(19712), wrap_int(10196), wrap_int(16271)])):
    _assert(all(sym_generator(((o > wrap_int(10)).__and__(odds.count(o) == nums.count(o)).__and__(sym_int(sym_str(o)[i]) % wrap_int(2)) for o in odds for i in wrap_list([-wrap_int(1), wrap_int(0)])))))
    return all(sym_generator((sym_in(n, odds).__or__(n <= wrap_int(10)).__or__(sym_int(sym_str(n)[wrap_int(0)]) % wrap_int(2) == wrap_int(0)).__or__(sym_int(sym_str(n)[-wrap_int(1)]) % wrap_int(2) == wrap_int(0)) for n in nums)))
Exception -- for puzzle BigOdds:3 int() argument must be a string, a bytes-like object or a real number, not 'SymbolicSlice'

Solving puzzle 419/732: BigOdds:4
sat_func def sat(odds: List[int], nums=[]):
    assert all(o > 10 and odds.count(o) == nums.count(o) and int(str(o)[i]) % 2 for o in odds for i in [-1, 0])
    return all(n in odds or n <= 10 or int(str(n)[0]) % 2 == 0 or int(str(n)[-1]) % 2 == 0 for n in nums)
modified_func def sat(odds: List[int], nums=wrap_list([])):
    _assert(all(sym_generator(((o > wrap_int(10)).__and__(odds.count(o) == nums.count(o)).__and__(sym_int(sym_str(o)[i]) % wrap_int(2)) for o in odds for i in wrap_list([-wrap_int(1), wrap_int(0)])))))
    return all(sym_generator((sym_in(n, odds).__or__(n <= wrap_int(10)).__or__(sym_int(sym_str(n)[wrap_int(0)]) % wrap_int(2) == wrap_int(0)).__or__(sym_int(sym_str(n)[-wrap_int(1)]) % wrap_int(2) == wrap_int(0)) for n in nums)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec str-to-int ((s String) (base Int)) Int
  (let ((len (str.len s)))
    (to_int 
      (ite (<= len 0) 
           0.0
           (+ (* (to_real (- (str.to_code (str.substr s (- len 1) 1)) 48))
                 (^ (to_real base) (to_real (- len 1))))
              (to_real (str-to-int (str.substr s 0 (- len 1)) base)))))))

(define-fun-rec bin-to-int ((s String)) Int
  (let ((len (str.len s)))
    (ite (<= len 0) 
         0
         (+ (* (ite (= (str.substr s (- len 1) 1) "1") 1 0)
               (to_int (^ 2.0 (to_real (- len 1)))))
            (bin-to-int (str.substr s 0 (- len 1)))))))

(define-fun python.int ((s String) (base Int)) Int
  (ite (= base 10) (str.to_int s) (ite (= base 2) (bin-to-int s) (str-to-int s base))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (forall ((list_pos_458 Int)) (=> (and (>= list_pos_458 0) (< list_pos_458 (list.length.int x))) (> (str.len (python.str.at (str.from_int (list.get.int x list_pos_458)) -1)) 0))))
(assert (forall ((list_pos_458 Int)) (=> (and (>= list_pos_458 0) (< list_pos_458 (list.length.int x))) (> (str.len (python.str.at (str.from_int (list.get.int x list_pos_458)) 0)) 0))))
(assert (forall ((list_pos_458 Int)) (=> (and (>= list_pos_458 0) (< list_pos_458 (list.length.int x))) (and (and (and (> (list.get.int x list_pos_458) 10) (= (list.count.int x (list.get.int x list_pos_458)) 0)) (not (= (mod (python.int (python.str.at (str.from_int (list.get.int x list_pos_458)) -1) 10) 2) 0))) (and (and (> (list.get.int x list_pos_458) 10) (= (list.count.int x (list.get.int x list_pos_458)) 0)) (not (= (mod (python.int (python.str.at (str.from_int (list.get.int x list_pos_458)) 0) 10) 2) 0)))))))
(assert (forall ((list_pos_458 Int)) (=> (and (>= list_pos_458 0) (< list_pos_458 (list.length.int x))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BigOdds:4
Too many constants for extrapolation

Solving puzzle 420/732: PlanetRange:0
sat_func def sat(planets_between: List[str], a="Mars", b="Neptune"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
modified_func def sat(planets_between: List[str], a=wrap_str('Mars'), b=wrap_str('Neptune')):
    _assert(wrap_str(' ') not in wrap_str('').join(planets_between))
    return sym_in(wrap_str(' ').join(wrap_list([a]) + planets_between + wrap_list([b])), wrap_str('Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto'))
Exception -- for puzzle PlanetRange:0 found bad constraint False of type <class 'bool'>

Solving puzzle 421/732: PlanetRange:1
sat_func def sat(planets_between: List[str], a="Venus", b="Neptune"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
modified_func def sat(planets_between: List[str], a=wrap_str('Venus'), b=wrap_str('Neptune')):
    _assert(wrap_str(' ') not in wrap_str('').join(planets_between))
    return sym_in(wrap_str(' ').join(wrap_list([a]) + planets_between + wrap_list([b])), wrap_str('Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto'))
Exception -- for puzzle PlanetRange:1 found bad constraint False of type <class 'bool'>

Solving puzzle 422/732: PlanetRange:2
sat_func def sat(planets_between: List[str], a="Venus", b="Earth"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
modified_func def sat(planets_between: List[str], a=wrap_str('Venus'), b=wrap_str('Earth')):
    _assert(wrap_str(' ') not in wrap_str('').join(planets_between))
    return sym_in(wrap_str(' ').join(wrap_list([a]) + planets_between + wrap_list([b])), wrap_str('Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto'))
Exception -- for puzzle PlanetRange:2 found bad constraint False of type <class 'bool'>

Solving puzzle 423/732: PlanetRange:3
sat_func def sat(planets_between: List[str], a="Earth", b="Jupiter"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
modified_func def sat(planets_between: List[str], a=wrap_str('Earth'), b=wrap_str('Jupiter')):
    _assert(wrap_str(' ') not in wrap_str('').join(planets_between))
    return sym_in(wrap_str(' ').join(wrap_list([a]) + planets_between + wrap_list([b])), wrap_str('Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto'))
Exception -- for puzzle PlanetRange:3 found bad constraint False of type <class 'bool'>

Solving puzzle 424/732: PlanetRange:4
sat_func def sat(planets_between: List[str], a="Earth", b="Uranus"):
    assert " " not in "".join(planets_between)
    return " ".join([a] + planets_between + [b]) in "Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
modified_func def sat(planets_between: List[str], a=wrap_str('Earth'), b=wrap_str('Uranus')):
    _assert(wrap_str(' ') not in wrap_str('').join(planets_between))
    return sym_in(wrap_str(' ').join(wrap_list([a]) + planets_between + wrap_list([b])), wrap_str('Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto'))
Exception -- for puzzle PlanetRange:4 found bad constraint False of type <class 'bool'>

Solving puzzle 425/732: EvenWords:0
sat_func def sat(evens: List[str], words=['The', 'worm', 'ate', 'a', 'bird', 'imagine', 'that', '!', 'Absurd', '!!']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
modified_func def sat(evens: List[str], words=wrap_list([wrap_str('The'), wrap_str('worm'), wrap_str('ate'), wrap_str('a'), wrap_str('bird'), wrap_str('imagine'), wrap_str('that'), wrap_str('!'), wrap_str('Absurd'), wrap_str('!!')])):
    lens = [sym_len(w) for w in evens]
    _assert(all(sym_generator(((lens[i] % wrap_int(2) == wrap_int(0)).__and__(lens[i] == max(lens[:i + 1])).__and__(sym_in(w, words)) for i, w in enumerate(evens)))))
    return all(sym_generator(((sym_len(w) % wrap_int(2) == wrap_int(1)).__or__(sym_in(w, evens)) for w in words)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_460 Int)) (=> (and (>= list_pos_460 0) (< list_pos_460 (list.length.string x))) (forall ((list_pos_459 Int)) (=> (and (>= list_pos_459 0) (< list_pos_459 (list.length.string x))) (and (and (= (mod (str.len (list.get.string x list_pos_459)) 2) 0) (= (str.len (list.get.string x list_pos_459)) (str.len (list.get.string x list_pos_459)))) (or (= (list.get.string x list_pos_460) "The") (= (list.get.string x list_pos_460) "worm") (= (list.get.string x list_pos_460) "ate") (= (list.get.string x list_pos_460) "a") (= (list.get.string x list_pos_460) "bird") (= (list.get.string x list_pos_460) "imagine") (= (list.get.string x list_pos_460) "that") (= (list.get.string x list_pos_460) "!") (= (list.get.string x list_pos_460) "Absurd") (= (list.get.string x list_pos_460) "!!"))))))))
(assert (forall ((list_pos_460 Int)) (=> (and (>= list_pos_460 0) (< list_pos_460 (list.length.string x))) (forall ((list_pos_459 Int)) (=> (and (>= list_pos_459 0) (< list_pos_459 (list.length.string x))) (and (and (and (and (and (and (and (and (and (or true (list.contains.string x "The")) (or false (list.contains.string x "worm"))) (or true (list.contains.string x "ate"))) (or true (list.contains.string x "a"))) (or false (list.contains.string x "bird"))) (or true (list.contains.string x "imagine"))) (or false (list.contains.string x "that"))) (or true (list.contains.string x "!"))) (or false (list.contains.string x "Absurd"))) (or false (list.contains.string x "!!"))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle EvenWords:0
Too many constants for extrapolation

Solving puzzle 426/732: EvenWords:1
sat_func def sat(evens: List[str], words=['valafytextulu', 'quyjylixyvy', 'mavusegojysaquo']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
modified_func def sat(evens: List[str], words=wrap_list([wrap_str('valafytextulu'), wrap_str('quyjylixyvy'), wrap_str('mavusegojysaquo')])):
    lens = [sym_len(w) for w in evens]
    _assert(all(sym_generator(((lens[i] % wrap_int(2) == wrap_int(0)).__and__(lens[i] == max(lens[:i + 1])).__and__(sym_in(w, words)) for i, w in enumerate(evens)))))
    return all(sym_generator(((sym_len(w) % wrap_int(2) == wrap_int(1)).__or__(sym_in(w, evens)) for w in words)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_462 Int)) (=> (and (>= list_pos_462 0) (< list_pos_462 (list.length.string x))) (forall ((list_pos_461 Int)) (=> (and (>= list_pos_461 0) (< list_pos_461 (list.length.string x))) (and (and (= (mod (str.len (list.get.string x list_pos_461)) 2) 0) (= (str.len (list.get.string x list_pos_461)) (str.len (list.get.string x list_pos_461)))) (or (= (list.get.string x list_pos_462) "valafytextulu") (= (list.get.string x list_pos_462) "quyjylixyvy") (= (list.get.string x list_pos_462) "mavusegojysaquo"))))))))
(assert (forall ((list_pos_462 Int)) (=> (and (>= list_pos_462 0) (< list_pos_462 (list.length.string x))) (forall ((list_pos_461 Int)) (=> (and (>= list_pos_461 0) (< list_pos_461 (list.length.string x))) (and (and (or true (list.contains.string x "valafytextulu")) (or true (list.contains.string x "quyjylixyvy"))) (or true (list.contains.string x "mavusegojysaquo"))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle EvenWords:1
Too many constants for extrapolation

Solving puzzle 427/732: EvenWords:2
sat_func def sat(evens: List[str], words=['pemathubolyrav', 'mucyxavofolajig', 'm', 'zyzagynorusybef']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
modified_func def sat(evens: List[str], words=wrap_list([wrap_str('pemathubolyrav'), wrap_str('mucyxavofolajig'), wrap_str('m'), wrap_str('zyzagynorusybef')])):
    lens = [sym_len(w) for w in evens]
    _assert(all(sym_generator(((lens[i] % wrap_int(2) == wrap_int(0)).__and__(lens[i] == max(lens[:i + 1])).__and__(sym_in(w, words)) for i, w in enumerate(evens)))))
    return all(sym_generator(((sym_len(w) % wrap_int(2) == wrap_int(1)).__or__(sym_in(w, evens)) for w in words)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_464 Int)) (=> (and (>= list_pos_464 0) (< list_pos_464 (list.length.string x))) (forall ((list_pos_463 Int)) (=> (and (>= list_pos_463 0) (< list_pos_463 (list.length.string x))) (and (and (= (mod (str.len (list.get.string x list_pos_463)) 2) 0) (= (str.len (list.get.string x list_pos_463)) (str.len (list.get.string x list_pos_463)))) (or (= (list.get.string x list_pos_464) "pemathubolyrav") (= (list.get.string x list_pos_464) "mucyxavofolajig") (= (list.get.string x list_pos_464) "m") (= (list.get.string x list_pos_464) "zyzagynorusybef"))))))))
(assert (forall ((list_pos_464 Int)) (=> (and (>= list_pos_464 0) (< list_pos_464 (list.length.string x))) (forall ((list_pos_463 Int)) (=> (and (>= list_pos_463 0) (< list_pos_463 (list.length.string x))) (and (and (and (or false (list.contains.string x "pemathubolyrav")) (or true (list.contains.string x "mucyxavofolajig"))) (or true (list.contains.string x "m"))) (or true (list.contains.string x "zyzagynorusybef"))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) ((as cons (List String)) "pemathubolyrav" ((as cons (List String)) "" (as nil (List String)))))
)

Could not find any solution for puzzle EvenWords:2
Too many constants for extrapolation

Solving puzzle 428/732: EvenWords:3
sat_func def sat(evens: List[str], words=['bozachogawykon', 'kywicij', 'tylegykivysequ']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
modified_func def sat(evens: List[str], words=wrap_list([wrap_str('bozachogawykon'), wrap_str('kywicij'), wrap_str('tylegykivysequ')])):
    lens = [sym_len(w) for w in evens]
    _assert(all(sym_generator(((lens[i] % wrap_int(2) == wrap_int(0)).__and__(lens[i] == max(lens[:i + 1])).__and__(sym_in(w, words)) for i, w in enumerate(evens)))))
    return all(sym_generator(((sym_len(w) % wrap_int(2) == wrap_int(1)).__or__(sym_in(w, evens)) for w in words)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_466 Int)) (=> (and (>= list_pos_466 0) (< list_pos_466 (list.length.string x))) (forall ((list_pos_465 Int)) (=> (and (>= list_pos_465 0) (< list_pos_465 (list.length.string x))) (and (and (= (mod (str.len (list.get.string x list_pos_465)) 2) 0) (= (str.len (list.get.string x list_pos_465)) (str.len (list.get.string x list_pos_465)))) (or (= (list.get.string x list_pos_466) "bozachogawykon") (= (list.get.string x list_pos_466) "kywicij") (= (list.get.string x list_pos_466) "tylegykivysequ"))))))))
(assert (forall ((list_pos_466 Int)) (=> (and (>= list_pos_466 0) (< list_pos_466 (list.length.string x))) (forall ((list_pos_465 Int)) (=> (and (>= list_pos_465 0) (< list_pos_465 (list.length.string x))) (and (and (or false (list.contains.string x "bozachogawykon")) (or true (list.contains.string x "kywicij"))) (or false (list.contains.string x "tylegykivysequ"))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle EvenWords:3
Too many constants for extrapolation

Solving puzzle 429/732: EvenWords:4
sat_func def sat(evens: List[str], words=['vanafegyfog', 'vipugohuvychu']):
    lens = [len(w) for w in evens]
    assert all(lens[i] % 2 == 0 and lens[i] == max(lens[:i + 1]) and w in words for i, w in enumerate(evens))
    return all((len(w) % 2 == 1 or w in evens) for w in words)
modified_func def sat(evens: List[str], words=wrap_list([wrap_str('vanafegyfog'), wrap_str('vipugohuvychu')])):
    lens = [sym_len(w) for w in evens]
    _assert(all(sym_generator(((lens[i] % wrap_int(2) == wrap_int(0)).__and__(lens[i] == max(lens[:i + 1])).__and__(sym_in(w, words)) for i, w in enumerate(evens)))))
    return all(sym_generator(((sym_len(w) % wrap_int(2) == wrap_int(1)).__or__(sym_in(w, evens)) for w in words)))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (forall ((list_pos_468 Int)) (=> (and (>= list_pos_468 0) (< list_pos_468 (list.length.string x))) (forall ((list_pos_467 Int)) (=> (and (>= list_pos_467 0) (< list_pos_467 (list.length.string x))) (and (and (= (mod (str.len (list.get.string x list_pos_467)) 2) 0) (= (str.len (list.get.string x list_pos_467)) (str.len (list.get.string x list_pos_467)))) (or (= (list.get.string x list_pos_468) "vanafegyfog") (= (list.get.string x list_pos_468) "vipugohuvychu"))))))))
(assert (forall ((list_pos_468 Int)) (=> (and (>= list_pos_468 0) (< list_pos_468 (list.length.string x))) (forall ((list_pos_467 Int)) (=> (and (>= list_pos_467 0) (< list_pos_467 (list.length.string x))) (and (or true (list.contains.string x "vanafegyfog")) (or true (list.contains.string x "vipugohuvychu"))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle EvenWords:4
Too many constants for extrapolation

Solving puzzle 430/732: PrimeSel:0
sat_func def sat(neighbors: List[int], nums=[14, 7, 11, 13, 7, 4, 19, 2, 55, 13, 31, 14, 2, 9, -7, 0, 88, 13, 13]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
modified_func def sat(neighbors: List[int], nums=wrap_list([wrap_int(14), wrap_int(7), wrap_int(11), wrap_int(13), wrap_int(7), wrap_int(4), wrap_int(19), wrap_int(2), wrap_int(55), wrap_int(13), wrap_int(31), wrap_int(14), wrap_int(2), wrap_int(9), -wrap_int(7), wrap_int(0), wrap_int(88), wrap_int(13), wrap_int(13)])):

    def prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    goods = set()
    for i, n in enumerate(nums):
        if (i > wrap_int(0)).__and__(prime(nums[i - wrap_int(1)])).__or__((i < sym_len(nums) - wrap_int(1)).__and__(prime(nums[i + wrap_int(1)]))):
            goods.add(n)
    return (set(neighbors) == goods).__and__(all(sym_generator((n == min(neighbors[i:]) for i, n in enumerate(neighbors)))))
Exception -- for puzzle PrimeSel:0 list index out of range

Solving puzzle 431/732: PrimeSel:1
sat_func def sat(neighbors: List[int], nums=[15, 1, 1, 11, 12, 12, 3, 3, 2, 5, 12, 0, 16, 0, 4, 14, 11, 7, 8]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
modified_func def sat(neighbors: List[int], nums=wrap_list([wrap_int(15), wrap_int(1), wrap_int(1), wrap_int(11), wrap_int(12), wrap_int(12), wrap_int(3), wrap_int(3), wrap_int(2), wrap_int(5), wrap_int(12), wrap_int(0), wrap_int(16), wrap_int(0), wrap_int(4), wrap_int(14), wrap_int(11), wrap_int(7), wrap_int(8)])):

    def prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    goods = set()
    for i, n in enumerate(nums):
        if (i > wrap_int(0)).__and__(prime(nums[i - wrap_int(1)])).__or__((i < sym_len(nums) - wrap_int(1)).__and__(prime(nums[i + wrap_int(1)]))):
            goods.add(n)
    return (set(neighbors) == goods).__and__(all(sym_generator((n == min(neighbors[i:]) for i, n in enumerate(neighbors)))))
Exception -- for puzzle PrimeSel:1 list index out of range

Solving puzzle 432/732: PrimeSel:2
sat_func def sat(neighbors: List[int], nums=[1, 15, 19]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
modified_func def sat(neighbors: List[int], nums=wrap_list([wrap_int(1), wrap_int(15), wrap_int(19)])):

    def prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    goods = set()
    for i, n in enumerate(nums):
        if (i > wrap_int(0)).__and__(prime(nums[i - wrap_int(1)])).__or__((i < sym_len(nums) - wrap_int(1)).__and__(prime(nums[i + wrap_int(1)]))):
            goods.add(n)
    return (set(neighbors) == goods).__and__(all(sym_generator((n == min(neighbors[i:]) for i, n in enumerate(neighbors)))))
Exception -- for puzzle PrimeSel:2 list index out of range

Solving puzzle 433/732: PrimeSel:3
sat_func def sat(neighbors: List[int], nums=[9, 9, 0, 2, 7, 14, 14, 2, 6, 4, -1, 7, 2, 2, 14, 8, 7, 19, 5, 9, 4, 18, 14, 8, 9, 2, -1]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
modified_func def sat(neighbors: List[int], nums=wrap_list([wrap_int(9), wrap_int(9), wrap_int(0), wrap_int(2), wrap_int(7), wrap_int(14), wrap_int(14), wrap_int(2), wrap_int(6), wrap_int(4), -wrap_int(1), wrap_int(7), wrap_int(2), wrap_int(2), wrap_int(14), wrap_int(8), wrap_int(7), wrap_int(19), wrap_int(5), wrap_int(9), wrap_int(4), wrap_int(18), wrap_int(14), wrap_int(8), wrap_int(9), wrap_int(2), -wrap_int(1)])):

    def prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    goods = set()
    for i, n in enumerate(nums):
        if (i > wrap_int(0)).__and__(prime(nums[i - wrap_int(1)])).__or__((i < sym_len(nums) - wrap_int(1)).__and__(prime(nums[i + wrap_int(1)]))):
            goods.add(n)
    return (set(neighbors) == goods).__and__(all(sym_generator((n == min(neighbors[i:]) for i, n in enumerate(neighbors)))))
Exception -- for puzzle PrimeSel:3 list index out of range

Solving puzzle 434/732: PrimeSel:4
sat_func def sat(neighbors: List[int], nums=[4, 2, 4, 7, -1, 10, 0, 10, 1, 3, 8, 3, 5, 3, 0, -1, 11, 18, 15, 2, 4, 10, 8, 14, 6, 1, 12, 14, 5]):

    def prime(m):
        return all(m % i for i in range(2, m - 1))

    goods = set()
    for i, n in enumerate(nums):
        if (i > 0 and prime(nums[i - 1])) or (i < len(nums) - 1 and prime(nums[i + 1])):
            goods.add(n)

    return set(neighbors) == goods and all(n == min(neighbors[i:]) for i, n in enumerate(neighbors))
modified_func def sat(neighbors: List[int], nums=wrap_list([wrap_int(4), wrap_int(2), wrap_int(4), wrap_int(7), -wrap_int(1), wrap_int(10), wrap_int(0), wrap_int(10), wrap_int(1), wrap_int(3), wrap_int(8), wrap_int(3), wrap_int(5), wrap_int(3), wrap_int(0), -wrap_int(1), wrap_int(11), wrap_int(18), wrap_int(15), wrap_int(2), wrap_int(4), wrap_int(10), wrap_int(8), wrap_int(14), wrap_int(6), wrap_int(1), wrap_int(12), wrap_int(14), wrap_int(5)])):

    def prime(m):
        return all(sym_generator((m % i for i in sym_range(2, m - 1))))
    goods = set()
    for i, n in enumerate(nums):
        if (i > wrap_int(0)).__and__(prime(nums[i - wrap_int(1)])).__or__((i < sym_len(nums) - wrap_int(1)).__and__(prime(nums[i + wrap_int(1)]))):
            goods.add(n)
    return (set(neighbors) == goods).__and__(all(sym_generator((n == min(neighbors[i:]) for i, n in enumerate(neighbors)))))
Exception -- for puzzle PrimeSel:4 list index out of range

Solving puzzle 435/732: ArrayDiff:0
sat_func def sat(b: List[int], a=[1, 2, 3, 0, 4, 17, 2, 4, 5, 9, 8, 4], c=[1, 2, 3, 4, 0, 16, 2, 3, 5, 9, 8, 4]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
modified_func def sat(b: List[int], a=wrap_list([wrap_int(1), wrap_int(2), wrap_int(3), wrap_int(0), wrap_int(4), wrap_int(17), wrap_int(2), wrap_int(4), wrap_int(5), wrap_int(9), wrap_int(8), wrap_int(4)]), c=wrap_list([wrap_int(1), wrap_int(2), wrap_int(3), wrap_int(4), wrap_int(0), wrap_int(16), wrap_int(2), wrap_int(3), wrap_int(5), wrap_int(9), wrap_int(8), wrap_int(4)])):
    return (sym_len(b) == sym_len(a)).__and__(all(sym_generator((i + j == k for i, j, k in sym_zip(a, b, c)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< zip_pos_0 12))
(assert (>= zip_pos_0 -12))
(assert (< zip_pos_0 12))
(assert (>= zip_pos_0 -12))
(assert (and (= (list.length.int x) 12) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ArrayDiff:0
Too many constants for extrapolation

Solving puzzle 436/732: ArrayDiff:1
sat_func def sat(b: List[int], a=[14, -1, 12, 11, 3, -1, 18, 5, 8, 5, 6, 1], c=[15, 19, 15, 19, 4, 1, 7, 12, -1, 16, 11, 5]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
modified_func def sat(b: List[int], a=wrap_list([wrap_int(14), -wrap_int(1), wrap_int(12), wrap_int(11), wrap_int(3), -wrap_int(1), wrap_int(18), wrap_int(5), wrap_int(8), wrap_int(5), wrap_int(6), wrap_int(1)]), c=wrap_list([wrap_int(15), wrap_int(19), wrap_int(15), wrap_int(19), wrap_int(4), wrap_int(1), wrap_int(7), wrap_int(12), -wrap_int(1), wrap_int(16), wrap_int(11), wrap_int(5)])):
    return (sym_len(b) == sym_len(a)).__and__(all(sym_generator((i + j == k for i, j, k in sym_zip(a, b, c)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< zip_pos_0 12))
(assert (>= zip_pos_0 -12))
(assert (< zip_pos_0 12))
(assert (>= zip_pos_0 -12))
(assert (and (= (list.length.int x) 12) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ArrayDiff:1
Too many constants for extrapolation

Solving puzzle 437/732: ArrayDiff:2
sat_func def sat(b: List[int], a=[14, 14, 2, 1, 11, 10, 15, 11, 9, 10, 4, 1, 7, 10, 16, 12], c=[5, 11, 16, 8, 19, 12, 19, 9, 10, 11, 14, 18, 2, 2, 0, 17]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
modified_func def sat(b: List[int], a=wrap_list([wrap_int(14), wrap_int(14), wrap_int(2), wrap_int(1), wrap_int(11), wrap_int(10), wrap_int(15), wrap_int(11), wrap_int(9), wrap_int(10), wrap_int(4), wrap_int(1), wrap_int(7), wrap_int(10), wrap_int(16), wrap_int(12)]), c=wrap_list([wrap_int(5), wrap_int(11), wrap_int(16), wrap_int(8), wrap_int(19), wrap_int(12), wrap_int(19), wrap_int(9), wrap_int(10), wrap_int(11), wrap_int(14), wrap_int(18), wrap_int(2), wrap_int(2), wrap_int(0), wrap_int(17)])):
    return (sym_len(b) == sym_len(a)).__and__(all(sym_generator((i + j == k for i, j, k in sym_zip(a, b, c)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< zip_pos_0 16))
(assert (>= zip_pos_0 -16))
(assert (< zip_pos_0 16))
(assert (>= zip_pos_0 -16))
(assert (and (= (list.length.int x) 16) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ArrayDiff:2
Too many constants for extrapolation

Solving puzzle 438/732: ArrayDiff:3
sat_func def sat(b: List[int], a=[4, 8, 14, 17, 15, -1, 17, 8, -1, 4, 3, 10, 2, 13, 1], c=[13, 14, 11, 18, 16, 8, 14, 3, 0, 9, 7, 19, 11, 15, 9]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
modified_func def sat(b: List[int], a=wrap_list([wrap_int(4), wrap_int(8), wrap_int(14), wrap_int(17), wrap_int(15), -wrap_int(1), wrap_int(17), wrap_int(8), -wrap_int(1), wrap_int(4), wrap_int(3), wrap_int(10), wrap_int(2), wrap_int(13), wrap_int(1)]), c=wrap_list([wrap_int(13), wrap_int(14), wrap_int(11), wrap_int(18), wrap_int(16), wrap_int(8), wrap_int(14), wrap_int(3), wrap_int(0), wrap_int(9), wrap_int(7), wrap_int(19), wrap_int(11), wrap_int(15), wrap_int(9)])):
    return (sym_len(b) == sym_len(a)).__and__(all(sym_generator((i + j == k for i, j, k in sym_zip(a, b, c)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< zip_pos_0 15))
(assert (>= zip_pos_0 -15))
(assert (< zip_pos_0 15))
(assert (>= zip_pos_0 -15))
(assert (and (= (list.length.int x) 15) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ArrayDiff:3
Too many constants for extrapolation

Solving puzzle 439/732: ArrayDiff:4
sat_func def sat(b: List[int], a=[13, 10, 7, 7, 1, 10, 0, 17, 5, 14, 10, 14], c=[13, 13, 17, 4, 18, 17, 12, 16, 0, 3, 12, 14]):
    return len(b) == len(a) and all(i + j == k for i, j, k in zip(a, b, c))
modified_func def sat(b: List[int], a=wrap_list([wrap_int(13), wrap_int(10), wrap_int(7), wrap_int(7), wrap_int(1), wrap_int(10), wrap_int(0), wrap_int(17), wrap_int(5), wrap_int(14), wrap_int(10), wrap_int(14)]), c=wrap_list([wrap_int(13), wrap_int(13), wrap_int(17), wrap_int(4), wrap_int(18), wrap_int(17), wrap_int(12), wrap_int(16), wrap_int(0), wrap_int(3), wrap_int(12), wrap_int(14)])):
    return (sym_len(b) == sym_len(a)).__and__(all(sym_generator((i + j == k for i, j, k in sym_zip(a, b, c)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< zip_pos_0 12))
(assert (>= zip_pos_0 -12))
(assert (< zip_pos_0 12))
(assert (>= zip_pos_0 -12))
(assert (and (= (list.length.int x) 12) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ArrayDiff:4
Too many constants for extrapolation

Solving puzzle 440/732: EvaluateOperators:0
sat_func def sat(ops: List[str], target=2021, nums=[4, 6, 2, 1, 1, 3, 9]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
modified_func def sat(ops: List[str], target=wrap_int(2021), nums=wrap_list([wrap_int(4), wrap_int(6), wrap_int(2), wrap_int(1), wrap_int(1), wrap_int(3), wrap_int(9)])):
    _assert((sym_len(ops) == sym_len(set(ops))).__and__(set(ops) == {wrap_str('**'), wrap_str('*'), wrap_str('+'), wrap_str('-'), wrap_str('//'), wrap_str('%')}))
    expr = sym_str(nums[wrap_int(0)])
    for n, op in sym_zip(nums[1:], ops):
        expr += op + sym_str(n)
    return eval(expr) == target
Exception -- for puzzle EvaluateOperators:0 Symbolic hash not yet implemented

Solving puzzle 441/732: EvaluateOperators:1
sat_func def sat(ops: List[str], target=4, nums=[5, 4, 8, 9, 3, 6, 2]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
modified_func def sat(ops: List[str], target=wrap_int(4), nums=wrap_list([wrap_int(5), wrap_int(4), wrap_int(8), wrap_int(9), wrap_int(3), wrap_int(6), wrap_int(2)])):
    _assert((sym_len(ops) == sym_len(set(ops))).__and__(set(ops) == {wrap_str('**'), wrap_str('*'), wrap_str('+'), wrap_str('-'), wrap_str('//'), wrap_str('%')}))
    expr = sym_str(nums[wrap_int(0)])
    for n, op in sym_zip(nums[1:], ops):
        expr += op + sym_str(n)
    return eval(expr) == target
Exception -- for puzzle EvaluateOperators:1 Symbolic hash not yet implemented

Solving puzzle 442/732: EvaluateOperators:2
sat_func def sat(ops: List[str], target=-24995, nums=[1, 8, 5, 8, 5, 5, 5]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
modified_func def sat(ops: List[str], target=-wrap_int(24995), nums=wrap_list([wrap_int(1), wrap_int(8), wrap_int(5), wrap_int(8), wrap_int(5), wrap_int(5), wrap_int(5)])):
    _assert((sym_len(ops) == sym_len(set(ops))).__and__(set(ops) == {wrap_str('**'), wrap_str('*'), wrap_str('+'), wrap_str('-'), wrap_str('//'), wrap_str('%')}))
    expr = sym_str(nums[wrap_int(0)])
    for n, op in sym_zip(nums[1:], ops):
        expr += op + sym_str(n)
    return eval(expr) == target
Exception -- for puzzle EvaluateOperators:2 Symbolic hash not yet implemented

Solving puzzle 443/732: EvaluateOperators:3
sat_func def sat(ops: List[str], target=6, nums=[7, 4, 4, 2, 4, 1, 6]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
modified_func def sat(ops: List[str], target=wrap_int(6), nums=wrap_list([wrap_int(7), wrap_int(4), wrap_int(4), wrap_int(2), wrap_int(4), wrap_int(1), wrap_int(6)])):
    _assert((sym_len(ops) == sym_len(set(ops))).__and__(set(ops) == {wrap_str('**'), wrap_str('*'), wrap_str('+'), wrap_str('-'), wrap_str('//'), wrap_str('%')}))
    expr = sym_str(nums[wrap_int(0)])
    for n, op in sym_zip(nums[1:], ops):
        expr += op + sym_str(n)
    return eval(expr) == target
Exception -- for puzzle EvaluateOperators:3 Symbolic hash not yet implemented

Solving puzzle 444/732: EvaluateOperators:4
sat_func def sat(ops: List[str], target=38, nums=[6, 2, 1, 7, 1, 3, 1]):
    assert len(ops) == len(set(ops)) and set(ops) == {"**", "*", "+", "-", "//", "%"}
    expr = str(nums[0])
    for n, op in zip(nums[1:], ops):
        expr += op + str(n)
    return eval(expr) == target
modified_func def sat(ops: List[str], target=wrap_int(38), nums=wrap_list([wrap_int(6), wrap_int(2), wrap_int(1), wrap_int(7), wrap_int(1), wrap_int(3), wrap_int(1)])):
    _assert((sym_len(ops) == sym_len(set(ops))).__and__(set(ops) == {wrap_str('**'), wrap_str('*'), wrap_str('+'), wrap_str('-'), wrap_str('//'), wrap_str('%')}))
    expr = sym_str(nums[wrap_int(0)])
    for n, op in sym_zip(nums[1:], ops):
        expr += op + sym_str(n)
    return eval(expr) == target
Exception -- for puzzle EvaluateOperators:4 Symbolic hash not yet implemented

Solving puzzle 445/732: ReverseCase:0
sat_func def sat(rev: List[str], strs=['cat', 'u8u', '12532', '', '191', '4tUn8', 'ewrWQTEW', 'i', 'IoU']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
modified_func def sat(rev: List[str], strs=wrap_list([wrap_str('cat'), wrap_str('u8u'), wrap_str('12532'), wrap_str(''), wrap_str('191'), wrap_str('4tUn8'), wrap_str('ewrWQTEW'), wrap_str('i'), wrap_str('IoU')])):
    _assert(sym_len(rev) == sym_len(strs))
    return all(sym_generator(((r.swapcase() == s).__and__(s != r).__or__((r[::-1] == s).__and__(s == s.swapcase())) for r, s in sym_zip(rev, strs))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.length.string x) 9))
(assert (< zip_pos_0 9))
(assert (>= zip_pos_0 -9))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:100.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReverseCase:0
Two large constants for extrapolation
Solving simpler variation replaced 12532 with 3 and 191 with 5
sat_func def sat(rev: List[str], strs=['cat', 'u8u', '3', '', '5', '4tUn8', 'ewrWQTEW', 'i', 'IoU']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
modified_func def sat(rev: List[str], strs=wrap_list([wrap_str('cat'), wrap_str('u8u'), wrap_str('3'), wrap_str(''), wrap_str('5'), wrap_str('4tUn8'), wrap_str('ewrWQTEW'), wrap_str('i'), wrap_str('IoU')])):
    _assert(sym_len(rev) == sym_len(strs))
    return all(sym_generator(((r.swapcase() == s).__and__(s != r).__or__((r[::-1] == s).__and__(s == s.swapcase())) for r, s in sym_zip(rev, strs))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.length.string x) 9))
(assert (< zip_pos_0 9))
(assert (>= zip_pos_0 -9))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:100.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReverseCase:0

Solving puzzle 446/732: ReverseCase:1
sat_func def sat(rev: List[str], strs=['vYWakiFoWElEnYjOfA', 'RO', '575', '943', '403', '-292', 'textY']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
modified_func def sat(rev: List[str], strs=wrap_list([wrap_str('vYWakiFoWElEnYjOfA'), wrap_str('RO'), wrap_str('575'), wrap_str('943'), wrap_str('403'), wrap_str('-292'), wrap_str('textY')])):
    _assert(sym_len(rev) == sym_len(strs))
    return all(sym_generator(((r.swapcase() == s).__and__(s != r).__or__((r[::-1] == s).__and__(s == s.swapcase())) for r, s in sym_zip(rev, strs))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.length.string x) 7))
(assert (< zip_pos_0 7))
(assert (>= zip_pos_0 -7))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:100.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReverseCase:1
Too many constants for extrapolation

Solving puzzle 447/732: ReverseCase:2
sat_func def sat(rev: List[str], strs=['223', '990', '-603', 'Ma', '-963', 'kO', 'REThoFOhuVAnUCyMyhIC', '711', '-874']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
modified_func def sat(rev: List[str], strs=wrap_list([wrap_str('223'), wrap_str('990'), wrap_str('-603'), wrap_str('Ma'), wrap_str('-963'), wrap_str('kO'), wrap_str('REThoFOhuVAnUCyMyhIC'), wrap_str('711'), wrap_str('-874')])):
    _assert(sym_len(rev) == sym_len(strs))
    return all(sym_generator(((r.swapcase() == s).__and__(s != r).__or__((r[::-1] == s).__and__(s == s.swapcase())) for r, s in sym_zip(rev, strs))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.length.string x) 9))
(assert (< zip_pos_0 9))
(assert (>= zip_pos_0 -9))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:100.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReverseCase:2
Too many constants for extrapolation

Solving puzzle 448/732: ReverseCase:3
sat_func def sat(rev: List[str], strs=['-352', 'wi', '-787', '706', 'fYchUc', '542', 'JeJuzichUnaHugAc', '963']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
modified_func def sat(rev: List[str], strs=wrap_list([wrap_str('-352'), wrap_str('wi'), wrap_str('-787'), wrap_str('706'), wrap_str('fYchUc'), wrap_str('542'), wrap_str('JeJuzichUnaHugAc'), wrap_str('963')])):
    _assert(sym_len(rev) == sym_len(strs))
    return all(sym_generator(((r.swapcase() == s).__and__(s != r).__or__((r[::-1] == s).__and__(s == s.swapcase())) for r, s in sym_zip(rev, strs))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.length.string x) 8))
(assert (< zip_pos_0 8))
(assert (>= zip_pos_0 -8))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:100.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReverseCase:3
Too many constants for extrapolation

Solving puzzle 449/732: ReverseCase:4
sat_func def sat(rev: List[str], strs=['234', '-828', '330', 'NateXt', '-524', '-196', 'siciNUCewOCePUdiN']):
    assert len(rev) == len(strs)
    return all(r.swapcase() == s != r or r[::-1] == s == s.swapcase() for r, s in zip(rev, strs))
modified_func def sat(rev: List[str], strs=wrap_list([wrap_str('234'), wrap_str('-828'), wrap_str('330'), wrap_str('NateXt'), wrap_str('-524'), wrap_str('-196'), wrap_str('siciNUCewOCePUdiN')])):
    _assert(sym_len(rev) == sym_len(strs))
    return all(sym_generator(((r.swapcase() == s).__and__(s != r).__or__((r[::-1] == s).__and__(s == s.swapcase())) for r, s in sym_zip(rev, strs))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List String))
(assert (= (list.length.string x) 7))
(assert (< zip_pos_0 7))
(assert (>= zip_pos_0 -7))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:100.12: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle ReverseCase:4
Too many constants for extrapolation

Solving puzzle 450/732: EvenBetween:0
sat_func def sat(ab: List[int], s="3298832990329923299432996329983300033002"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('3298832990329923299432996329983300033002')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_474)) (< i_0 (+ (list.get.int x list_pos_475) 1))) (forall ((list_pos_475 Int)) (=> (and (>= list_pos_475 0) (< list_pos_475 (list.length.int x))) (forall ((list_pos_474 Int)) (=> (and (>= list_pos_474 0) (< list_pos_474 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3298832990329923299432996329983300033002" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_476)) (< i_1 (+ (list.get.int x list_pos_477) 1))) (forall ((list_pos_477 Int)) (=> (and (>= list_pos_477 0) (< list_pos_477 (list.length.int x))) (forall ((list_pos_476 Int)) (=> (and (>= list_pos_476 0) (< list_pos_476 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_474)) (< i_0 (+ (list.get.int x list_pos_475) 1))) (forall ((list_pos_475 Int)) (=> (and (>= list_pos_475 0) (< list_pos_475 (list.length.int x))) (forall ((list_pos_474 Int)) (=> (and (>= list_pos_474 0) (< list_pos_474 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3298832990329923299432996329983300033002" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_474' not declared as a variable")

Could not find any solution for puzzle EvenBetween:0
One large constant for extrapolation
Solving simpler variation replaced 3298832990329923299432996329983300033002 with 3
sat_func def sat(ab: List[int], s="3"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('3')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_478)) (< i_0 (+ (list.get.int x list_pos_479) 1))) (forall ((list_pos_479 Int)) (=> (and (>= list_pos_479 0) (< list_pos_479 (list.length.int x))) (forall ((list_pos_478 Int)) (=> (and (>= list_pos_478 0) (< list_pos_478 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_480)) (< i_1 (+ (list.get.int x list_pos_481) 1))) (forall ((list_pos_481 Int)) (=> (and (>= list_pos_481 0) (< list_pos_481 (list.length.int x))) (forall ((list_pos_480 Int)) (=> (and (>= list_pos_480 0) (< list_pos_480 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_478)) (< i_0 (+ (list.get.int x list_pos_479) 1))) (forall ((list_pos_479 Int)) (=> (and (>= list_pos_479 0) (< list_pos_479 (list.length.int x))) (forall ((list_pos_478 Int)) (=> (and (>= list_pos_478 0) (< list_pos_478 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_478' not declared as a variable")

Could not find any solution for puzzle EvenBetween:0

Solving puzzle 451/732: EvenBetween:1
sat_func def sat(ab: List[int], s="38600386023860438606"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('38600386023860438606')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_482)) (< i_0 (+ (list.get.int x list_pos_483) 1))) (forall ((list_pos_483 Int)) (=> (and (>= list_pos_483 0) (< list_pos_483 (list.length.int x))) (forall ((list_pos_482 Int)) (=> (and (>= list_pos_482 0) (< list_pos_482 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "38600386023860438606" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_484)) (< i_1 (+ (list.get.int x list_pos_485) 1))) (forall ((list_pos_485 Int)) (=> (and (>= list_pos_485 0) (< list_pos_485 (list.length.int x))) (forall ((list_pos_484 Int)) (=> (and (>= list_pos_484 0) (< list_pos_484 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_482)) (< i_0 (+ (list.get.int x list_pos_483) 1))) (forall ((list_pos_483 Int)) (=> (and (>= list_pos_483 0) (< list_pos_483 (list.length.int x))) (forall ((list_pos_482 Int)) (=> (and (>= list_pos_482 0) (< list_pos_482 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "38600386023860438606" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_482' not declared as a variable")

Could not find any solution for puzzle EvenBetween:1
One large constant for extrapolation
Solving simpler variation replaced 38600386023860438606 with 3
sat_func def sat(ab: List[int], s="3"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('3')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_486)) (< i_0 (+ (list.get.int x list_pos_487) 1))) (forall ((list_pos_487 Int)) (=> (and (>= list_pos_487 0) (< list_pos_487 (list.length.int x))) (forall ((list_pos_486 Int)) (=> (and (>= list_pos_486 0) (< list_pos_486 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_488)) (< i_1 (+ (list.get.int x list_pos_489) 1))) (forall ((list_pos_489 Int)) (=> (and (>= list_pos_489 0) (< list_pos_489 (list.length.int x))) (forall ((list_pos_488 Int)) (=> (and (>= list_pos_488 0) (< list_pos_488 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_486)) (< i_0 (+ (list.get.int x list_pos_487) 1))) (forall ((list_pos_487 Int)) (=> (and (>= list_pos_487 0) (< list_pos_487 (list.length.int x))) (forall ((list_pos_486 Int)) (=> (and (>= list_pos_486 0) (< list_pos_486 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_486' not declared as a variable")

Could not find any solution for puzzle EvenBetween:1

Solving puzzle 452/732: EvenBetween:2
sat_func def sat(ab: List[int], s="254042540625408"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('254042540625408')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_490)) (< i_0 (+ (list.get.int x list_pos_491) 1))) (forall ((list_pos_491 Int)) (=> (and (>= list_pos_491 0) (< list_pos_491 (list.length.int x))) (forall ((list_pos_490 Int)) (=> (and (>= list_pos_490 0) (< list_pos_490 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "254042540625408" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_492)) (< i_1 (+ (list.get.int x list_pos_493) 1))) (forall ((list_pos_493 Int)) (=> (and (>= list_pos_493 0) (< list_pos_493 (list.length.int x))) (forall ((list_pos_492 Int)) (=> (and (>= list_pos_492 0) (< list_pos_492 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_490)) (< i_0 (+ (list.get.int x list_pos_491) 1))) (forall ((list_pos_491 Int)) (=> (and (>= list_pos_491 0) (< list_pos_491 (list.length.int x))) (forall ((list_pos_490 Int)) (=> (and (>= list_pos_490 0) (< list_pos_490 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "254042540625408" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_490' not declared as a variable")

Could not find any solution for puzzle EvenBetween:2
One large constant for extrapolation
Solving simpler variation replaced 254042540625408 with 3
sat_func def sat(ab: List[int], s="3"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('3')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_494)) (< i_0 (+ (list.get.int x list_pos_495) 1))) (forall ((list_pos_495 Int)) (=> (and (>= list_pos_495 0) (< list_pos_495 (list.length.int x))) (forall ((list_pos_494 Int)) (=> (and (>= list_pos_494 0) (< list_pos_494 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_496)) (< i_1 (+ (list.get.int x list_pos_497) 1))) (forall ((list_pos_497 Int)) (=> (and (>= list_pos_497 0) (< list_pos_497 (list.length.int x))) (forall ((list_pos_496 Int)) (=> (and (>= list_pos_496 0) (< list_pos_496 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_494)) (< i_0 (+ (list.get.int x list_pos_495) 1))) (forall ((list_pos_495 Int)) (=> (and (>= list_pos_495 0) (< list_pos_495 (list.length.int x))) (forall ((list_pos_494 Int)) (=> (and (>= list_pos_494 0) (< list_pos_494 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_494' not declared as a variable")

Could not find any solution for puzzle EvenBetween:2

Solving puzzle 453/732: EvenBetween:3
sat_func def sat(ab: List[int], s="32880328823288432886"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('32880328823288432886')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_498)) (< i_0 (+ (list.get.int x list_pos_499) 1))) (forall ((list_pos_499 Int)) (=> (and (>= list_pos_499 0) (< list_pos_499 (list.length.int x))) (forall ((list_pos_498 Int)) (=> (and (>= list_pos_498 0) (< list_pos_498 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "32880328823288432886" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_500)) (< i_1 (+ (list.get.int x list_pos_501) 1))) (forall ((list_pos_501 Int)) (=> (and (>= list_pos_501 0) (< list_pos_501 (list.length.int x))) (forall ((list_pos_500 Int)) (=> (and (>= list_pos_500 0) (< list_pos_500 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_498)) (< i_0 (+ (list.get.int x list_pos_499) 1))) (forall ((list_pos_499 Int)) (=> (and (>= list_pos_499 0) (< list_pos_499 (list.length.int x))) (forall ((list_pos_498 Int)) (=> (and (>= list_pos_498 0) (< list_pos_498 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "32880328823288432886" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_498' not declared as a variable")

Could not find any solution for puzzle EvenBetween:3
One large constant for extrapolation
Solving simpler variation replaced 32880328823288432886 with 3
sat_func def sat(ab: List[int], s="3"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('3')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_502)) (< i_0 (+ (list.get.int x list_pos_503) 1))) (forall ((list_pos_503 Int)) (=> (and (>= list_pos_503 0) (< list_pos_503 (list.length.int x))) (forall ((list_pos_502 Int)) (=> (and (>= list_pos_502 0) (< list_pos_502 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_504)) (< i_1 (+ (list.get.int x list_pos_505) 1))) (forall ((list_pos_505 Int)) (=> (and (>= list_pos_505 0) (< list_pos_505 (list.length.int x))) (forall ((list_pos_504 Int)) (=> (and (>= list_pos_504 0) (< list_pos_504 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_502)) (< i_0 (+ (list.get.int x list_pos_503) 1))) (forall ((list_pos_503 Int)) (=> (and (>= list_pos_503 0) (< list_pos_503 (list.length.int x))) (forall ((list_pos_502 Int)) (=> (and (>= list_pos_502 0) (< list_pos_502 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_502' not declared as a variable")

Could not find any solution for puzzle EvenBetween:3

Solving puzzle 454/732: EvenBetween:4
sat_func def sat(ab: List[int], s="6062860630606326063460636"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('6062860630606326063460636')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_506)) (< i_0 (+ (list.get.int x list_pos_507) 1))) (forall ((list_pos_507 Int)) (=> (and (>= list_pos_507 0) (< list_pos_507 (list.length.int x))) (forall ((list_pos_506 Int)) (=> (and (>= list_pos_506 0) (< list_pos_506 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "6062860630606326063460636" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_508)) (< i_1 (+ (list.get.int x list_pos_509) 1))) (forall ((list_pos_509 Int)) (=> (and (>= list_pos_509 0) (< list_pos_509 (list.length.int x))) (forall ((list_pos_508 Int)) (=> (and (>= list_pos_508 0) (< list_pos_508 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_506)) (< i_0 (+ (list.get.int x list_pos_507) 1))) (forall ((list_pos_507 Int)) (=> (and (>= list_pos_507 0) (< list_pos_507 (list.length.int x))) (forall ((list_pos_506 Int)) (=> (and (>= list_pos_506 0) (< list_pos_506 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "6062860630606326063460636" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_506' not declared as a variable")

Could not find any solution for puzzle EvenBetween:4
One large constant for extrapolation
Solving simpler variation replaced 6062860630606326063460636 with 3
sat_func def sat(ab: List[int], s="3"):
    return abs(ab[0] - ab[1]) > 4 and s == "".join(str(i) for i in range(min(ab), max(ab) + 1) if i % 2 == 0)
modified_func def sat(ab: List[int], s=wrap_str('3')):
    return (abs(ab[wrap_int(0)] - ab[wrap_int(1)]) > wrap_int(4)).__and__(s == wrap_str('').join(sym_generator((sym_str(i) for i in sym_range(min(ab), max(ab) + 1) if i % wrap_int(2) == wrap_int(0)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_510)) (< i_0 (+ (list.get.int x list_pos_511) 1))) (forall ((list_pos_511 Int)) (=> (and (>= list_pos_511 0) (< list_pos_511 (list.length.int x))) (forall ((list_pos_510 Int)) (=> (and (>= list_pos_510 0) (< list_pos_510 (list.length.int x))) (=> (= (mod i_0 2) 0) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (cons (str.from_int i_0) (as nil (List String))) "")))))))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (list.get.int x list_pos_512)) (< i_1 (+ (list.get.int x list_pos_513) 1))) (forall ((list_pos_513 Int)) (=> (and (>= list_pos_513 0) (< list_pos_513 (list.length.int x))) (forall ((list_pos_512 Int)) (=> (and (>= list_pos_512 0) (< list_pos_512 (list.length.int x))) (forall ((i_0 Int)) (=> (and (>= i_0 (list.get.int x list_pos_510)) (< i_0 (+ (list.get.int x list_pos_511) 1))) (forall ((list_pos_511 Int)) (=> (and (>= list_pos_511 0) (< list_pos_511 (list.length.int x))) (forall ((list_pos_510 Int)) (=> (and (>= list_pos_510 0) (< list_pos_510 (list.length.int x))) (=> (not (= (mod i_1 2) 0)) (and (> (ite (>= (- (list.get.int x 0) (list.get.int x 1)) 0) (- (list.get.int x 0) (list.get.int x 1)) (- (- (list.get.int x 0) (list.get.int x 1)))) 4) (= "3" (python.join (as nil (List String)) "")))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:109.62: Symbol 'list_pos_510' not declared as a variable")

Could not find any solution for puzzle EvenBetween:4

Solving puzzle 455/732: Triple0:0
sat_func def sat(delta: List[int], nums=[[1, 2, 3], [9, -2, 8], [17, 2, 50]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
modified_func def sat(delta: List[int], nums=wrap_list([wrap_list([wrap_int(1), wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(9), -wrap_int(2), wrap_int(8)]), wrap_list([wrap_int(17), wrap_int(2), wrap_int(50)])])):
    return all(sym_generator((sym_sum(sym_generator((vec[i] for vec in nums))) + delta[i] == wrap_int(0) for i in sym_range(3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (+ 27 (list.get.int x 0)) 0) (= (+ 2 (list.get.int x 1)) 0)) (= (+ 61 (list.get.int x 2)) 0)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 27) ((as cons (List Int)) (- 2) ((as cons (List Int)) (- 61) ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))
)

Found solution [-27, -2, -61, 0, 0]
Yes! Solved for puzzle  Triple0:0

Solving puzzle 456/732: Triple0:1
sat_func def sat(delta: List[int], nums=[[-48, -64, 10], [-6, 46, 95], [89, 95, 20], [-96, 45, 74], [-78, 19, 47], [-6, -69, 55]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
modified_func def sat(delta: List[int], nums=wrap_list([wrap_list([-wrap_int(48), -wrap_int(64), wrap_int(10)]), wrap_list([-wrap_int(6), wrap_int(46), wrap_int(95)]), wrap_list([wrap_int(89), wrap_int(95), wrap_int(20)]), wrap_list([-wrap_int(96), wrap_int(45), wrap_int(74)]), wrap_list([-wrap_int(78), wrap_int(19), wrap_int(47)]), wrap_list([-wrap_int(6), -wrap_int(69), wrap_int(55)])])):
    return all(sym_generator((sym_sum(sym_generator((vec[i] for vec in nums))) + delta[i] == wrap_int(0) for i in sym_range(3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (+ -145 (list.get.int x 0)) 0) (= (+ 72 (list.get.int x 1)) 0)) (= (+ 301 (list.get.int x 2)) 0)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 145 ((as cons (List Int)) (- 72) ((as cons (List Int)) (- 301) ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))
)

Found solution [145, -72, -301, 0, 0]
Yes! Solved for puzzle  Triple0:1

Solving puzzle 457/732: Triple0:2
sat_func def sat(delta: List[int], nums=[[-17, -87, 34], [-8, -47, -68], [92, -14, -18], [18, 89, 85], [52, 89, -56], [-38, -19, -53], [-78, -25, -34]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
modified_func def sat(delta: List[int], nums=wrap_list([wrap_list([-wrap_int(17), -wrap_int(87), wrap_int(34)]), wrap_list([-wrap_int(8), -wrap_int(47), -wrap_int(68)]), wrap_list([wrap_int(92), -wrap_int(14), -wrap_int(18)]), wrap_list([wrap_int(18), wrap_int(89), wrap_int(85)]), wrap_list([wrap_int(52), wrap_int(89), -wrap_int(56)]), wrap_list([-wrap_int(38), -wrap_int(19), -wrap_int(53)]), wrap_list([-wrap_int(78), -wrap_int(25), -wrap_int(34)])])):
    return all(sym_generator((sym_sum(sym_generator((vec[i] for vec in nums))) + delta[i] == wrap_int(0) for i in sym_range(3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (+ 21 (list.get.int x 0)) 0) (= (+ -14 (list.get.int x 1)) 0)) (= (+ -110 (list.get.int x 2)) 0)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 21) ((as cons (List Int)) 14 ((as cons (List Int)) 110 ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))
)

Found solution [-21, 14, 110, 0, 0]
Yes! Solved for puzzle  Triple0:2

Solving puzzle 458/732: Triple0:3
sat_func def sat(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
modified_func def sat(delta: List[int], nums=wrap_list([wrap_list([wrap_int(35), -wrap_int(53), wrap_int(59)]), wrap_list([wrap_int(78), -wrap_int(51), wrap_int(93)]), wrap_list([-wrap_int(20), -wrap_int(17), -wrap_int(17)]), wrap_list([wrap_int(64), wrap_int(46), -wrap_int(24)]), wrap_list([-wrap_int(81), -wrap_int(100), wrap_int(47)]), wrap_list([-wrap_int(98), -wrap_int(21), wrap_int(47)]), wrap_list([wrap_int(48), -wrap_int(85), -wrap_int(55)]), wrap_list([-wrap_int(82), -wrap_int(29), wrap_int(65)])])):
    return all(sym_generator((sym_sum(sym_generator((vec[i] for vec in nums))) + delta[i] == wrap_int(0) for i in sym_range(3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (+ -56 (list.get.int x 0)) 0) (= (+ -310 (list.get.int x 1)) 0)) (= (+ 215 (list.get.int x 2)) 0)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 56 ((as cons (List Int)) 310 ((as cons (List Int)) (- 215) ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))
)

Found solution [56, 310, -215, 0, 0]
Yes! Solved for puzzle  Triple0:3

Solving puzzle 459/732: Triple0:4
sat_func def sat(delta: List[int], nums=[[-16, 53, 37], [-54, -85, 65], [-46, 49, -81], [88, -47, -35], [53, -82, 4], [45, 94, 39], [72, -57, 27], [40, 35, -44], [-15, 32, 21]]):
    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))
modified_func def sat(delta: List[int], nums=wrap_list([wrap_list([-wrap_int(16), wrap_int(53), wrap_int(37)]), wrap_list([-wrap_int(54), -wrap_int(85), wrap_int(65)]), wrap_list([-wrap_int(46), wrap_int(49), -wrap_int(81)]), wrap_list([wrap_int(88), -wrap_int(47), -wrap_int(35)]), wrap_list([wrap_int(53), -wrap_int(82), wrap_int(4)]), wrap_list([wrap_int(45), wrap_int(94), wrap_int(39)]), wrap_list([wrap_int(72), -wrap_int(57), wrap_int(27)]), wrap_list([wrap_int(40), wrap_int(35), -wrap_int(44)]), wrap_list([-wrap_int(15), wrap_int(32), wrap_int(21)])])):
    return all(sym_generator((sym_sum(sym_generator((vec[i] for vec in nums))) + delta[i] == wrap_int(0) for i in sym_range(3))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (+ 167 (list.get.int x 0)) 0) (= (+ -8 (list.get.int x 1)) 0)) (= (+ 33 (list.get.int x 2)) 0)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 167) ((as cons (List Int)) 8 ((as cons (List Int)) (- 33) ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))
)

Found solution [-167, 8, -33, 0, 0]
Yes! Solved for puzzle  Triple0:4

Solving puzzle 460/732: ShortestDecDelta:0
sat_func def sat(li: List[int], n=149432, upper=14943):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(149432), upper=wrap_int(14943)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 14943) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
WARNING: Solution verification failed for puzzle ShortestDecDelta:0
Two large constants for extrapolation
Solving simpler variation replaced 14943 with 3 and 149432 with 5
sat_func def sat(li: List[int], n=5, upper=3):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(5), upper=wrap_int(3)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 3) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []

Solving puzzle 461/732: ShortestDecDelta:1
sat_func def sat(li: List[int], n=493863, upper=49386):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(493863), upper=wrap_int(49386)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 49386) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
WARNING: Solution verification failed for puzzle ShortestDecDelta:1
Two large constants for extrapolation
Solving simpler variation replaced 49386 with 3 and 493863 with 5
sat_func def sat(li: List[int], n=5, upper=3):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(5), upper=wrap_int(3)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 3) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []

Solving puzzle 462/732: ShortestDecDelta:2
sat_func def sat(li: List[int], n=827208, upper=82720):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(827208), upper=wrap_int(82720)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 82720) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
WARNING: Solution verification failed for puzzle ShortestDecDelta:2
Two large constants for extrapolation
Solving simpler variation replaced 82720 with 3 and 827208 with 5
sat_func def sat(li: List[int], n=5, upper=3):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(5), upper=wrap_int(3)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 3) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []

Solving puzzle 463/732: ShortestDecDelta:3
sat_func def sat(li: List[int], n=176183, upper=17618):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(176183), upper=wrap_int(17618)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 17618) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
WARNING: Solution verification failed for puzzle ShortestDecDelta:3
Two large constants for extrapolation
Solving simpler variation replaced 17618 with 3 and 176183 with 5
sat_func def sat(li: List[int], n=5, upper=3):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(5), upper=wrap_int(3)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 3) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []

Solving puzzle 464/732: ShortestDecDelta:4
sat_func def sat(li: List[int], n=483088, upper=48308):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(483088), upper=wrap_int(48308)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 48308) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
WARNING: Solution verification failed for puzzle ShortestDecDelta:4
Two large constants for extrapolation
Solving simpler variation replaced 48308 with 3 and 483088 with 5
sat_func def sat(li: List[int], n=5, upper=3):
    return len(li) <= upper and all(abs(a - b) <= 10 for a, b in zip([1] + li, li + [n]))
modified_func def sat(li: List[int], n=wrap_int(5), upper=wrap_int(3)):
    return (sym_len(li) <= upper).__and__(all(sym_generator((abs(a - b) <= wrap_int(10) for a, b in sym_zip(wrap_list([wrap_int(1)]) + li, li + wrap_list([n]))))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (<= (list.length.int x) 3) true))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []

Solving puzzle 465/732: Sssuubbstriiingg:0
sat_func def sat(inds: List[int], string="Sssuubbstrissiingg"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
modified_func def sat(inds: List[int], string=wrap_str('Sssuubbstrissiingg')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('substring'))
Exception -- for puzzle Sssuubbstriiingg:0 Cannot convert symbolic integer to index

Solving puzzle 466/732: Sssuubbstriiingg:1
sat_func def sat(inds: List[int], string="su absItIstrilnvgenw"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
modified_func def sat(inds: List[int], string=wrap_str('su absItIstrilnvgenw')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('substring'))
Exception -- for puzzle Sssuubbstriiingg:1 Cannot convert symbolic integer to index

Solving puzzle 467/732: Sssuubbstriiingg:2
sat_func def sat(inds: List[int], string="sKubssB  tzCzPrZiL inCgN"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
modified_func def sat(inds: List[int], string=wrap_str('sKubssB  tzCzPrZiL inCgN')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('substring'))
Exception -- for puzzle Sssuubbstriiingg:2 Cannot convert symbolic integer to index

Solving puzzle 468/732: Sssuubbstriiingg:3
sat_func def sat(inds: List[int], string="suUbstriPng"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
modified_func def sat(inds: List[int], string=wrap_str('suUbstriPng')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('substring'))
Exception -- for puzzle Sssuubbstriiingg:3 Cannot convert symbolic integer to index

Solving puzzle 469/732: Sssuubbstriiingg:4
sat_func def sat(inds: List[int], string="stuqb VqsMJptxriWYe nmfgNfW"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "substring"
modified_func def sat(inds: List[int], string=wrap_str('stuqb VqsMJptxriWYe nmfgNfW')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('substring'))
Exception -- for puzzle Sssuubbstriiingg:4 Cannot convert symbolic integer to index

Solving puzzle 470/732: Sstriiinggssuubb:0
sat_func def sat(inds: List[int], string="enlightenment"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
modified_func def sat(inds: List[int], string=wrap_str('enlightenment')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('intelligent'))
Exception -- for puzzle Sstriiinggssuubb:0 Cannot convert symbolic integer to index

Solving puzzle 471/732: Sstriiinggssuubb:1
sat_func def sat(inds: List[int], string="inntGetlige"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
modified_func def sat(inds: List[int], string=wrap_str('inntGetlige')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('intelligent'))
Exception -- for puzzle Sstriiinggssuubb:1 Cannot convert symbolic integer to index

Solving puzzle 472/732: Sstriiinggssuubb:2
sat_func def sat(inds: List[int], string="gteliikeenGgqIHent"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
modified_func def sat(inds: List[int], string=wrap_str('gteliikeenGgqIHent')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('intelligent'))
Exception -- for puzzle Sstriiinggssuubb:2 Cannot convert symbolic integer to index

Solving puzzle 473/732: Sstriiinggssuubb:3
sat_func def sat(inds: List[int], string="xaGliigNntJfeeSm  nnEyt"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
modified_func def sat(inds: List[int], string=wrap_str('xaGliigNntJfeeSm  nnEyt')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('intelligent'))
Exception -- for puzzle Sstriiinggssuubb:3 Cannot convert symbolic integer to index

Solving puzzle 474/732: Sstriiinggssuubb:4
sat_func def sat(inds: List[int], string="  einliJSgeteq ne CAlti"):
    return inds == sorted(inds) and "".join(string[i] for i in inds) == "intelligent"
modified_func def sat(inds: List[int], string=wrap_str('  einliJSgeteq ne CAlti')):
    return (inds == sym_sorted(inds)).__and__(wrap_str('').join(sym_generator((string[i] for i in inds))) == wrap_str('intelligent'))
Exception -- for puzzle Sstriiinggssuubb:4 Cannot convert symbolic integer to index

Solving puzzle 475/732: Moving0s:0
sat_func def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], n_steps=4):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
modified_func def sat(seq: List[int], target=wrap_list([wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(1), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), n_steps=wrap_int(4)):
    s = seq[:]
    for step in sym_range(n_steps):
        for i in sym_range(sym_len(seq) - 1):
            if (s[i], s[i + wrap_int(1)]) == (wrap_int(0), wrap_int(1)):
                s[i], s[i + wrap_int(1)] = (wrap_int(1), wrap_int(0))
    return s == target
Exception -- for puzzle Moving0s:0 Cannot convert symbolic integer to index

Solving puzzle 476/732: Moving0s:1
sat_func def sat(seq: List[int], target=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=9):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
modified_func def sat(seq: List[int], target=wrap_list([wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), n_steps=wrap_int(9)):
    s = seq[:]
    for step in sym_range(n_steps):
        for i in sym_range(sym_len(seq) - 1):
            if (s[i], s[i + wrap_int(1)]) == (wrap_int(0), wrap_int(1)):
                s[i], s[i + wrap_int(1)] = (wrap_int(1), wrap_int(0))
    return s == target
Exception -- for puzzle Moving0s:1 Cannot convert symbolic integer to index

Solving puzzle 477/732: Moving0s:2
sat_func def sat(seq: List[int], target=[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], n_steps=4):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
modified_func def sat(seq: List[int], target=wrap_list([wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(0), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), n_steps=wrap_int(4)):
    s = seq[:]
    for step in sym_range(n_steps):
        for i in sym_range(sym_len(seq) - 1):
            if (s[i], s[i + wrap_int(1)]) == (wrap_int(0), wrap_int(1)):
                s[i], s[i + wrap_int(1)] = (wrap_int(1), wrap_int(0))
    return s == target
Exception -- for puzzle Moving0s:2 Cannot convert symbolic integer to index

Solving puzzle 478/732: Moving0s:3
sat_func def sat(seq: List[int], target=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], n_steps=12):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
modified_func def sat(seq: List[int], target=wrap_list([wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), n_steps=wrap_int(12)):
    s = seq[:]
    for step in sym_range(n_steps):
        for i in sym_range(sym_len(seq) - 1):
            if (s[i], s[i + wrap_int(1)]) == (wrap_int(0), wrap_int(1)):
                s[i], s[i + wrap_int(1)] = (wrap_int(1), wrap_int(0))
    return s == target
Exception -- for puzzle Moving0s:3 Cannot convert symbolic integer to index

Solving puzzle 479/732: Moving0s:4
sat_func def sat(seq: List[int], target=[1, 1, 1, 0, 0, 0, 0], n_steps=3):
    s = seq[:]  # copy
    for step in range(n_steps):
        for i in range(len(seq) - 1):
            if (s[i], s[i + 1]) == (0, 1):
                (s[i], s[i + 1]) = (1, 0)
    return s == target
modified_func def sat(seq: List[int], target=wrap_list([wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(0)]), n_steps=wrap_int(3)):
    s = seq[:]
    for step in sym_range(n_steps):
        for i in sym_range(sym_len(seq) - 1):
            if (s[i], s[i + wrap_int(1)]) == (wrap_int(0), wrap_int(1)):
                s[i], s[i + wrap_int(1)] = (wrap_int(1), wrap_int(0))
    return s == target
Exception -- for puzzle Moving0s:4 Cannot convert symbolic integer to index

Solving puzzle 480/732: MinBigger:0
sat_func def sat(taken: List[int], val_counts=[[4, 3], [5, 2], [9, 3], [13, 13], [8, 11], [56, 1]], upper=11):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
modified_func def sat(taken: List[int], val_counts=wrap_list([wrap_list([wrap_int(4), wrap_int(3)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(9), wrap_int(3)]), wrap_list([wrap_int(13), wrap_int(13)]), wrap_list([wrap_int(8), wrap_int(11)]), wrap_list([wrap_int(56), wrap_int(1)])]), upper=wrap_int(11)):
    advantage = wrap_int(0)
    _assert((sym_len(taken) == sym_len(val_counts)).__and__(sym_sum(taken) <= upper))
    for i, (val, count) in sym_zip(taken, val_counts):
        _assert((wrap_int(0) <= i).__and__(i <= count))
        advantage += val * i - val * count / wrap_int(2)
    return advantage > wrap_int(0)
Exception -- for puzzle MinBigger:0 cannot unpack non-iterable SymbolicInt object

Solving puzzle 481/732: MinBigger:1
sat_func def sat(taken: List[int], val_counts=[[51, 67], [78, 13], [7, 68], [84, 54], [39, 38]], upper=66):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
modified_func def sat(taken: List[int], val_counts=wrap_list([wrap_list([wrap_int(51), wrap_int(67)]), wrap_list([wrap_int(78), wrap_int(13)]), wrap_list([wrap_int(7), wrap_int(68)]), wrap_list([wrap_int(84), wrap_int(54)]), wrap_list([wrap_int(39), wrap_int(38)])]), upper=wrap_int(66)):
    advantage = wrap_int(0)
    _assert((sym_len(taken) == sym_len(val_counts)).__and__(sym_sum(taken) <= upper))
    for i, (val, count) in sym_zip(taken, val_counts):
        _assert((wrap_int(0) <= i).__and__(i <= count))
        advantage += val * i - val * count / wrap_int(2)
    return advantage > wrap_int(0)
Exception -- for puzzle MinBigger:1 cannot unpack non-iterable SymbolicInt object

Solving puzzle 482/732: MinBigger:2
sat_func def sat(taken: List[int], val_counts=[[28, 29], [42, 54], [62, 85], [42, 95], [92, 32], [36, 35], [78, 56], [43, 20], [49, 17]], upper=153):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
modified_func def sat(taken: List[int], val_counts=wrap_list([wrap_list([wrap_int(28), wrap_int(29)]), wrap_list([wrap_int(42), wrap_int(54)]), wrap_list([wrap_int(62), wrap_int(85)]), wrap_list([wrap_int(42), wrap_int(95)]), wrap_list([wrap_int(92), wrap_int(32)]), wrap_list([wrap_int(36), wrap_int(35)]), wrap_list([wrap_int(78), wrap_int(56)]), wrap_list([wrap_int(43), wrap_int(20)]), wrap_list([wrap_int(49), wrap_int(17)])]), upper=wrap_int(153)):
    advantage = wrap_int(0)
    _assert((sym_len(taken) == sym_len(val_counts)).__and__(sym_sum(taken) <= upper))
    for i, (val, count) in sym_zip(taken, val_counts):
        _assert((wrap_int(0) <= i).__and__(i <= count))
        advantage += val * i - val * count / wrap_int(2)
    return advantage > wrap_int(0)
Exception -- for puzzle MinBigger:2 cannot unpack non-iterable SymbolicInt object

Solving puzzle 483/732: MinBigger:3
sat_func def sat(taken: List[int], val_counts=[[44, 92], [28, 7], [56, 37], [37, 66]], upper=90):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
modified_func def sat(taken: List[int], val_counts=wrap_list([wrap_list([wrap_int(44), wrap_int(92)]), wrap_list([wrap_int(28), wrap_int(7)]), wrap_list([wrap_int(56), wrap_int(37)]), wrap_list([wrap_int(37), wrap_int(66)])]), upper=wrap_int(90)):
    advantage = wrap_int(0)
    _assert((sym_len(taken) == sym_len(val_counts)).__and__(sym_sum(taken) <= upper))
    for i, (val, count) in sym_zip(taken, val_counts):
        _assert((wrap_int(0) <= i).__and__(i <= count))
        advantage += val * i - val * count / wrap_int(2)
    return advantage > wrap_int(0)
Exception -- for puzzle MinBigger:3 cannot unpack non-iterable SymbolicInt object

Solving puzzle 484/732: MinBigger:4
sat_func def sat(taken: List[int], val_counts=[[23, 93], [64, 14], [36, 8], [89, 92]], upper=65):
    advantage = 0
    assert len(taken) == len(val_counts) and sum(taken) <= upper
    for i, (val, count) in zip(taken, val_counts):
        assert 0 <= i <= count
        advantage += val * i - val * count / 2
    return advantage > 0
modified_func def sat(taken: List[int], val_counts=wrap_list([wrap_list([wrap_int(23), wrap_int(93)]), wrap_list([wrap_int(64), wrap_int(14)]), wrap_list([wrap_int(36), wrap_int(8)]), wrap_list([wrap_int(89), wrap_int(92)])]), upper=wrap_int(65)):
    advantage = wrap_int(0)
    _assert((sym_len(taken) == sym_len(val_counts)).__and__(sym_sum(taken) <= upper))
    for i, (val, count) in sym_zip(taken, val_counts):
        _assert((wrap_int(0) <= i).__and__(i <= count))
        advantage += val * i - val * count / wrap_int(2)
    return advantage > wrap_int(0)
Exception -- for puzzle MinBigger:4 cannot unpack non-iterable SymbolicInt object

Solving puzzle 485/732: DistinctDigits:0
sat_func def sat(nums: List[int], a=100, b=1000, count=648):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
modified_func def sat(nums: List[int], a=wrap_int(100), b=wrap_int(1000), count=wrap_int(648)):
    _assert(all(sym_generator(((sym_len(sym_str(n)) == sym_len(set(sym_str(n)))).__and__((a <= n).__and__(n <= b)) for n in nums))))
    return sym_len(set(nums)) >= count
Exception -- for puzzle DistinctDigits:0 Symbolic hash not yet implemented

Solving puzzle 486/732: DistinctDigits:1
sat_func def sat(nums: List[int], a=79, b=169, count=67):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
modified_func def sat(nums: List[int], a=wrap_int(79), b=wrap_int(169), count=wrap_int(67)):
    _assert(all(sym_generator(((sym_len(sym_str(n)) == sym_len(set(sym_str(n)))).__and__((a <= n).__and__(n <= b)) for n in nums))))
    return sym_len(set(nums)) >= count
Exception -- for puzzle DistinctDigits:1 Symbolic hash not yet implemented

Solving puzzle 487/732: DistinctDigits:2
sat_func def sat(nums: List[int], a=31, b=105, count=66):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
modified_func def sat(nums: List[int], a=wrap_int(31), b=wrap_int(105), count=wrap_int(66)):
    _assert(all(sym_generator(((sym_len(sym_str(n)) == sym_len(set(sym_str(n)))).__and__((a <= n).__and__(n <= b)) for n in nums))))
    return sym_len(set(nums)) >= count
Exception -- for puzzle DistinctDigits:2 Symbolic hash not yet implemented

Solving puzzle 488/732: DistinctDigits:3
sat_func def sat(nums: List[int], a=52, b=95, count=40):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
modified_func def sat(nums: List[int], a=wrap_int(52), b=wrap_int(95), count=wrap_int(40)):
    _assert(all(sym_generator(((sym_len(sym_str(n)) == sym_len(set(sym_str(n)))).__and__((a <= n).__and__(n <= b)) for n in nums))))
    return sym_len(set(nums)) >= count
Exception -- for puzzle DistinctDigits:3 Symbolic hash not yet implemented

Solving puzzle 489/732: DistinctDigits:4
sat_func def sat(nums: List[int], a=136, b=176, count=34):
    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)
    return len(set(nums)) >= count
modified_func def sat(nums: List[int], a=wrap_int(136), b=wrap_int(176), count=wrap_int(34)):
    _assert(all(sym_generator(((sym_len(sym_str(n)) == sym_len(set(sym_str(n)))).__and__((a <= n).__and__(n <= b)) for n in nums))))
    return sym_len(set(nums)) >= count
Exception -- for puzzle DistinctDigits:4 Symbolic hash not yet implemented

Solving puzzle 490/732: InvertIndices:0
sat_func def sat(indexes: List[int], target=[1, 3, 4, 2, 5, 6, 7, 13, 12, 11, 9, 10, 8]):
    for i in range(1, len(target) + 1):
        if target[indexes[i - 1] - 1] != i:
            return False
    return True
modified_func def sat(indexes: List[int], target=wrap_list([wrap_int(1), wrap_int(3), wrap_int(4), wrap_int(2), wrap_int(5), wrap_int(6), wrap_int(7), wrap_int(13), wrap_int(12), wrap_int(11), wrap_int(9), wrap_int(10), wrap_int(8)])):
    for i in sym_range(1, sym_len(target) + 1):
        if target[indexes[i - wrap_int(1)] - wrap_int(1)] != i:
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (- (list.get.int x (- 1 1)) 1) 13))
(assert (>= (- (list.get.int x (- 1 1)) 1) -13))
(assert (=> (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite (or (= (-...
(assert (< (- (list.get.int x (- 1 1)) 1) 13))
(assert (>= (- (list.get.int x (- 1 1)) 1) -13))
(assert (=> (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite (or ...
(assert (=> (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite (or ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 12) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 11) (= (- (list.get.int x (- 1 1)) 1) -2)) 10 (ite (or (= (- (list.get.int x (- 1 1)) 1) 10) (= (- (list.get.int x (- 1 1)) 1) -3)) 9 (ite (or (= (- (list.get.int x (- 1 1)) 1) 9) (= (- (list.get.int x (- 1 1)) 1) -4)) 11 (ite (or (= (- (list.get.int x (- 1 1)) 1) 8) (= (- (list.get.int x (- 1 1)) 1) -5)) 12 (ite (or (= (- (list.get.int x (- 1 1)) 1) 7) (= (- (list.get.int x (- 1 1)) 1) -6)) 13 (ite (or (= (- (list.get.int x (- 1 1)) 1) 6) (= (- (list.get.int x (- 1 1)) 1) -7)) 7 (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -8)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -9)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -11)) 4 (ite...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle InvertIndices:0
Too many constants for extrapolation

Solving puzzle 491/732: InvertIndices:1
sat_func def sat(indexes: List[int], target=[16, 12, 67, 77, 23, 47, 24, 45, 61, 80, 43, 50, 57, 81, 21, 55, 9, 28, 14, 87, 58, 35, 37, 63, 41, 38, 6, 86, 59, 13, 49, 68, 83, 30, 40, 73, 15, 11, 85, 70, 33, 22, 76, 5, 82, 52, 27, 26, 34, 89, 1, 48, 64, 88, 19, 29, 65, 69, 31, 2, 74, 32, 60, 7, 46, 56, 78, 79, 36, 51, 72, 71, 54, 20, 90, 8, 53, 75, 39, 4, 17, 62, 25, 3, 84, 42, 44, 10, 66, 18]):
    for i in range(1, len(target) + 1):
        if target[indexes[i - 1] - 1] != i:
            return False
    return True
modified_func def sat(indexes: List[int], target=wrap_list([wrap_int(16), wrap_int(12), wrap_int(67), wrap_int(77), wrap_int(23), wrap_int(47), wrap_int(24), wrap_int(45), wrap_int(61), wrap_int(80), wrap_int(43), wrap_int(50), wrap_int(57), wrap_int(81), wrap_int(21), wrap_int(55), wrap_int(9), wrap_int(28), wrap_int(14), wrap_int(87), wrap_int(58), wrap_int(35), wrap_int(37), wrap_int(63), wrap_int(41), wrap_int(38), wrap_int(6), wrap_int(86), wrap_int(59), wrap_int(13), wrap_int(49), wrap_int(68), wrap_int(83), wrap_int(30), wrap_int(40), wrap_int(73), wrap_int(15), wrap_int(11), wrap_int(85), wrap_int(70), wrap_int(33), wrap_int(22), wrap_int(76), wrap_int(5), wrap_int(82), wrap_int(52), wrap_int(27), wrap_int(26), wrap_int(34), wrap_int(89), wrap_int(1), wrap_int(48), wrap_int(64), wrap_int(88), wrap_int(19), wrap_int(29), wrap_int(65), wrap_int(69), wrap_int(31), wrap_int(2), wrap_int(74), wrap_int(32), wrap_int(60), wrap_int(7), wrap_int(46), wrap_int(56), wrap_int(78), wrap_int(79), wrap_int(36), wrap_int(51), wrap_int(72), wrap_int(71), wrap_int(54), wrap_int(20), wrap_int(90), wrap_int(8), wrap_int(53), wrap_int(75), wrap_int(39), wrap_int(4), wrap_int(17), wrap_int(62), wrap_int(25), wrap_int(3), wrap_int(84), wrap_int(42), wrap_int(44), wrap_int(10), wrap_int(66), wrap_int(18)])):
    for i in sym_range(1, sym_len(target) + 1):
        if target[indexes[i - wrap_int(1)] - wrap_int(1)] != i:
            return False
    return True
Timed out for puzzle InvertIndices:1

Solving puzzle 492/732: InvertIndices:2
sat_func def sat(indexes: List[int], target=[4, 66, 52, 28, 11, 59, 15, 37, 32, 71, 48, 23, 41, 7, 68, 30, 2, 44, 33, 3, 14, 63, 40, 22, 35, 6, 27, 58, 36, 38, 53, 9, 24, 49, 54, 50, 72, 64, 69, 77, 25, 31, 42, 17, 57, 67, 55, 70, 47, 46, 10, 75, 20, 61, 34, 39, 18, 12, 56, 29, 62, 26, 73, 21, 5, 1, 8, 19, 51, 45, 74, 13, 43, 16, 76, 65, 60]):
    for i in range(1, len(target) + 1):
        if target[indexes[i - 1] - 1] != i:
            return False
    return True
modified_func def sat(indexes: List[int], target=wrap_list([wrap_int(4), wrap_int(66), wrap_int(52), wrap_int(28), wrap_int(11), wrap_int(59), wrap_int(15), wrap_int(37), wrap_int(32), wrap_int(71), wrap_int(48), wrap_int(23), wrap_int(41), wrap_int(7), wrap_int(68), wrap_int(30), wrap_int(2), wrap_int(44), wrap_int(33), wrap_int(3), wrap_int(14), wrap_int(63), wrap_int(40), wrap_int(22), wrap_int(35), wrap_int(6), wrap_int(27), wrap_int(58), wrap_int(36), wrap_int(38), wrap_int(53), wrap_int(9), wrap_int(24), wrap_int(49), wrap_int(54), wrap_int(50), wrap_int(72), wrap_int(64), wrap_int(69), wrap_int(77), wrap_int(25), wrap_int(31), wrap_int(42), wrap_int(17), wrap_int(57), wrap_int(67), wrap_int(55), wrap_int(70), wrap_int(47), wrap_int(46), wrap_int(10), wrap_int(75), wrap_int(20), wrap_int(61), wrap_int(34), wrap_int(39), wrap_int(18), wrap_int(12), wrap_int(56), wrap_int(29), wrap_int(62), wrap_int(26), wrap_int(73), wrap_int(21), wrap_int(5), wrap_int(1), wrap_int(8), wrap_int(19), wrap_int(51), wrap_int(45), wrap_int(74), wrap_int(13), wrap_int(43), wrap_int(16), wrap_int(76), wrap_int(65), wrap_int(60)])):
    for i in sym_range(1, sym_len(target) + 1):
        if target[indexes[i - wrap_int(1)] - wrap_int(1)] != i:
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (- (list.get.int x (- 1 1)) 1) 64))
(assert (>= (- (list.get.int x (- 1 1)) 1) -64))
(assert (=> (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) -11)) 15 (...
(assert (< (- (list.get.int x (- 1 1)) 1) 64))
(assert (>= (- (list.get.int x (- 1 1)) 1) -64))
(assert (=> (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) -11))...
(assert (=> (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) -11))...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 63) (= (- (list.get.int x (- 1 1)) 1) -1)) 8 (ite (or (= (- (list.get.int x (- 1 1)) 1) 62) (= (- (list.get.int x (- 1 1)) 1) -2)) 37 (ite (or (= (- (list.get.int x (- 1 1)) 1) 61) (= (- (list.get.int x (- 1 1)) 1) -3)) 30 (ite (or (= (- (list.get.int x (- 1 1)) 1) 60) (= (- (list.get.int x (- 1 1)) 1) -4)) 62 (ite (or (= (- (list.get.int x (- 1 1)) 1) 59) (= (- (list.get.int x (- 1 1)) 1) -5)) 54 (ite (or (= (- (list.get.int x (- 1 1)) 1) 58) (= (- (list.get.int x (- 1 1)) 1) -6)) 44 (ite (or (= (- (list.get.int x (- 1 1)) 1) 57) (= (- (list.get.int x (- 1 1)) 1) -7)) 28 (ite (or (= (- (list.get.int x (- 1 1)) 1) 56) (= (- (list.get.int x (- 1 1)) 1) -8)) 21 (ite (or (= (- (list.get.int x (- 1 1)) 1) 55) (= (- (list.get.int x (- 1 1)) 1) -9)) 14 (ite (or (= (- (list.get.int x (- 1 1)) 1) 54) (= (- (list.get.int x (- 1 1)) 1) -10)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 53) (= (- (list.get.int x (- 1 1)) 1) ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle InvertIndices:3
Too many constants for extrapolation

Solving puzzle 494/732: InvertIndices:4
sat_func def sat(indexes: List[int], target=[3, 1, 6, 5, 4, 2]):
    for i in range(1, len(target) + 1):
        if target[indexes[i - 1] - 1] != i:
            return False
    return True
modified_func def sat(indexes: List[int], target=wrap_list([wrap_int(3), wrap_int(1), wrap_int(6), wrap_int(5), wrap_int(4), wrap_int(2)])):
    for i in sym_range(1, sym_len(target) + 1):
        if target[indexes[i - wrap_int(1)] - wrap_int(1)] != i:
            return False
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (- (list.get.int x (- 1 1)) 1) 6))
(assert (>= (- (list.get.int x (- 1 1)) 1) -6))
(assert (=> (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1)) false))
(assert (< (- (list.get.int x (- 1 1)) 1) 6))
(assert (>= (- (list.get.int x (- 1 1)) 1) -6))
(assert (=> (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (< (- (list.get.int x (- 2 1)) 1) 6)))
(assert (=> (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (>= (- (list.get.int x (- 2 1)) 1) -6)))
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2)))) (< (- (list.get.int x (- 3 1)) 1) 6)))
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2)))) (>= (- (list.get.int x (- 3 1)) 1) -6)))
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2))) (not (not (= (ite (or (= (- (list.get.int x (- 3 1)) 1) 5) (= (...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2))) (not (not (= (ite (or (= (- (list.get.int x (- 3 1)) 1) 5) (= (...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2))) (not (not (= (ite (or (= (- (list.get.int x (- 3 1)) 1) 5) (= (...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2))) (not (not (= (ite (or (= (- (list.get.int x (- 3 1)) 1) 5) (= (...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2))) (not (not (= (ite (or (= (- (list.get.int x (- 3 1)) 1) 5) (= (...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2))) (not (not (= (ite (or (= (- (list.get.int x (- 3 1)) 1) 5) (= (...
(assert (=> (and (not (not (= (ite (or (= (- (list.get.int x (- 1 1)) 1) 5) (= (- (list.get.int x (- 1 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 1 1)) 1) 4) (= (- (list.get.int x (- 1 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 1 1)) 1) 3) (= (- (list.get.int x (- 1 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 1 1)) 1) 2) (= (- (list.get.int x (- 1 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 1 1)) 1) 1) (= (- (list.get.int x (- 1 1)) 1) -5)) 1 3))))) 1))) (not (not (= (ite (or (= (- (list.get.int x (- 2 1)) 1) 5) (= (- (list.get.int x (- 2 1)) 1) -1)) 2 (ite (or (= (- (list.get.int x (- 2 1)) 1) 4) (= (- (list.get.int x (- 2 1)) 1) -2)) 4 (ite (or (= (- (list.get.int x (- 2 1)) 1) 3) (= (- (list.get.int x (- 2 1)) 1) -3)) 5 (ite (or (= (- (list.get.int x (- 2 1)) 1) 2) (= (- (list.get.int x (- 2 1)) 1) -4)) 6 (ite (or (= (- (list.get.int x (- 2 1)) 1) 1) (= (- (list.get.int x (- 2 1)) 1) -5)) 1 3))))) 2))) (not (not (= (ite (or (= (- (list.get.int x (- 3 1)) 1) 5) (= (...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle InvertIndices:4
Too many constants for extrapolation

Solving puzzle 495/732: CombinationLock:0
sat_func def sat(states: List[str], start="424", combo="778", target_len=12):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
modified_func def sat(states: List[str], start=wrap_str('424'), combo=wrap_str('778'), target_len=wrap_int(12)):
    _assert(all(sym_generator((sym_len(s) == sym_len(start) for s in states))).__and__(all(sym_generator((sym_in(c, wrap_str('0123456789')) for s in states for c in s)))))
    for a, b in sym_zip(wrap_list([start]) + states, states + wrap_list([combo])):
        _assert(sym_sum(sym_generator((i != j for i, j in sym_zip(a, b)))) == wrap_int(1))
        _assert(all(sym_generator((sym_in(abs(sym_int(i) - sym_int(j)), {wrap_int(0), wrap_int(1), wrap_int(9)}) for i, j in sym_zip(a, b)))))
    return sym_len(states) <= target_len
Exception -- for puzzle CombinationLock:0 'set' object has no attribute 'contains'

Solving puzzle 496/732: CombinationLock:1
sat_func def sat(states: List[str], start="77872", combo="43506", target_len=16):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
modified_func def sat(states: List[str], start=wrap_str('77872'), combo=wrap_str('43506'), target_len=wrap_int(16)):
    _assert(all(sym_generator((sym_len(s) == sym_len(start) for s in states))).__and__(all(sym_generator((sym_in(c, wrap_str('0123456789')) for s in states for c in s)))))
    for a, b in sym_zip(wrap_list([start]) + states, states + wrap_list([combo])):
        _assert(sym_sum(sym_generator((i != j for i, j in sym_zip(a, b)))) == wrap_int(1))
        _assert(all(sym_generator((sym_in(abs(sym_int(i) - sym_int(j)), {wrap_int(0), wrap_int(1), wrap_int(9)}) for i, j in sym_zip(a, b)))))
    return sym_len(states) <= target_len
Exception -- for puzzle CombinationLock:1 'set' object has no attribute 'contains'

Solving puzzle 497/732: CombinationLock:2
sat_func def sat(states: List[str], start="268", combo="180", target_len=4):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
modified_func def sat(states: List[str], start=wrap_str('268'), combo=wrap_str('180'), target_len=wrap_int(4)):
    _assert(all(sym_generator((sym_len(s) == sym_len(start) for s in states))).__and__(all(sym_generator((sym_in(c, wrap_str('0123456789')) for s in states for c in s)))))
    for a, b in sym_zip(wrap_list([start]) + states, states + wrap_list([combo])):
        _assert(sym_sum(sym_generator((i != j for i, j in sym_zip(a, b)))) == wrap_int(1))
        _assert(all(sym_generator((sym_in(abs(sym_int(i) - sym_int(j)), {wrap_int(0), wrap_int(1), wrap_int(9)}) for i, j in sym_zip(a, b)))))
    return sym_len(states) <= target_len
Exception -- for puzzle CombinationLock:2 'set' object has no attribute 'contains'

Solving puzzle 498/732: CombinationLock:3
sat_func def sat(states: List[str], start="4675159714", combo="9758013840", target_len=27):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
modified_func def sat(states: List[str], start=wrap_str('4675159714'), combo=wrap_str('9758013840'), target_len=wrap_int(27)):
    _assert(all(sym_generator((sym_len(s) == sym_len(start) for s in states))).__and__(all(sym_generator((sym_in(c, wrap_str('0123456789')) for s in states for c in s)))))
    for a, b in sym_zip(wrap_list([start]) + states, states + wrap_list([combo])):
        _assert(sym_sum(sym_generator((i != j for i, j in sym_zip(a, b)))) == wrap_int(1))
        _assert(all(sym_generator((sym_in(abs(sym_int(i) - sym_int(j)), {wrap_int(0), wrap_int(1), wrap_int(9)}) for i, j in sym_zip(a, b)))))
    return sym_len(states) <= target_len
Exception -- for puzzle CombinationLock:3 'set' object has no attribute 'contains'

Solving puzzle 499/732: CombinationLock:4
sat_func def sat(states: List[str], start="242716", combo="891245", target_len=18):
    assert all(len(s) == len(start) for s in states) and all(c in "0123456789" for s in states for c in s)
    for a, b in zip([start] + states, states + [combo]):
        assert sum(i != j for i, j in zip(a, b)) == 1
        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))

    return len(states) <= target_len
modified_func def sat(states: List[str], start=wrap_str('242716'), combo=wrap_str('891245'), target_len=wrap_int(18)):
    _assert(all(sym_generator((sym_len(s) == sym_len(start) for s in states))).__and__(all(sym_generator((sym_in(c, wrap_str('0123456789')) for s in states for c in s)))))
    for a, b in sym_zip(wrap_list([start]) + states, states + wrap_list([combo])):
        _assert(sym_sum(sym_generator((i != j for i, j in sym_zip(a, b)))) == wrap_int(1))
        _assert(all(sym_generator((sym_in(abs(sym_int(i) - sym_int(j)), {wrap_int(0), wrap_int(1), wrap_int(9)}) for i, j in sym_zip(a, b)))))
    return sym_len(states) <= target_len
Exception -- for puzzle CombinationLock:4 'set' object has no attribute 'contains'

Solving puzzle 500/732: CombinationLockObfuscated:0
sat_func def sat(states: List[str], start="424", combo="778", target_len=12):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
modified_func def sat(states: List[str], start=wrap_str('424'), combo=wrap_str('778'), target_len=wrap_int(12)):
    return all(sym_generator((sym_sum(sym_generator(((sym_int(a[i]) - sym_int(b[i])) ** wrap_int(2) % wrap_int(10) for i in sym_range(sym_len(start))))) == wrap_int(1) for a, b in sym_zip(wrap_list([start]) + states, states[:target_len] + wrap_list([combo])))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "424" (as nil (List String))) x) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 12 1) (cons "778" (as nil (List String)))) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "424" (as nil (List String))) x) zip_pos_0) 1)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 12 1) (cons "778" (as nil (List String)))) zip_pos_0) 1)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "424" (as nil (List String))) x) zip_pos_0) 2)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 12 1) (cons "778" (as nil (List String)))) zip_pos_0) 2)) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:143.112: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle CombinationLockObfuscated:0
Two large constants for extrapolation
Solving simpler variation replaced 424 with 3 and 778 with 5
sat_func def sat(states: List[str], start="3", combo="5", target_len=12):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
modified_func def sat(states: List[str], start=wrap_str('3'), combo=wrap_str('5'), target_len=wrap_int(12)):
    return all(sym_generator((sym_sum(sym_generator(((sym_int(a[i]) - sym_int(b[i])) ** wrap_int(2) % wrap_int(10) for i in sym_range(sym_len(start))))) == wrap_int(1) for a, b in sym_zip(wrap_list([start]) + states, states[:target_len] + wrap_list([combo])))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "3" (as nil (List String))) x) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 12 1) (cons "5" (as nil (List String)))) zip_pos_0) 0)) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:143.110: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle CombinationLockObfuscated:0

Solving puzzle 501/732: CombinationLockObfuscated:1
sat_func def sat(states: List[str], start="50", combo="59", target_len=0):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
modified_func def sat(states: List[str], start=wrap_str('50'), combo=wrap_str('59'), target_len=wrap_int(0)):
    return all(sym_generator((sym_sum(sym_generator(((sym_int(a[i]) - sym_int(b[i])) ** wrap_int(2) % wrap_int(10) for i in sym_range(sym_len(start))))) == wrap_int(1) for a, b in sym_zip(wrap_list([start]) + states, states[:target_len] + wrap_list([combo])))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "50" (as nil (List String))) x) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 0 1) (cons "59" (as nil (List String)))) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "50" (as nil (List String))) x) zip_pos_0) 1)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 0 1) (cons "59" (as nil (List String)))) zip_pos_0) 1)) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:143.111: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle CombinationLockObfuscated:1
Too many constants for extrapolation

Solving puzzle 502/732: CombinationLockObfuscated:2
sat_func def sat(states: List[str], start="23", combo="12", target_len=1):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
modified_func def sat(states: List[str], start=wrap_str('23'), combo=wrap_str('12'), target_len=wrap_int(1)):
    return all(sym_generator((sym_sum(sym_generator(((sym_int(a[i]) - sym_int(b[i])) ** wrap_int(2) % wrap_int(10) for i in sym_range(sym_len(start))))) == wrap_int(1) for a, b in sym_zip(wrap_list([start]) + states, states[:target_len] + wrap_list([combo])))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "23" (as nil (List String))) x) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 1 1) (cons "12" (as nil (List String)))) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "23" (as nil (List String))) x) zip_pos_0) 1)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 1 1) (cons "12" (as nil (List String)))) zip_pos_0) 1)) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:143.111: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle CombinationLockObfuscated:2
Too many constants for extrapolation

Solving puzzle 503/732: CombinationLockObfuscated:3
sat_func def sat(states: List[str], start="4", combo="3", target_len=0):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
modified_func def sat(states: List[str], start=wrap_str('4'), combo=wrap_str('3'), target_len=wrap_int(0)):
    return all(sym_generator((sym_sum(sym_generator(((sym_int(a[i]) - sym_int(b[i])) ** wrap_int(2) % wrap_int(10) for i in sym_range(sym_len(start))))) == wrap_int(1) for a, b in sym_zip(wrap_list([start]) + states, states[:target_len] + wrap_list([combo])))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "4" (as nil (List String))) x) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 0 1) (cons "3" (as nil (List String)))) zip_pos_0) 0)) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:143.110: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle CombinationLockObfuscated:3
Too many constants for extrapolation

Solving puzzle 504/732: CombinationLockObfuscated:4
sat_func def sat(states: List[str], start="2184377", combo="7002994", target_len=18):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
modified_func def sat(states: List[str], start=wrap_str('2184377'), combo=wrap_str('7002994'), target_len=wrap_int(18)):
    return all(sym_generator((sym_sum(sym_generator(((sym_int(a[i]) - sym_int(b[i])) ** wrap_int(2) % wrap_int(10) for i in sym_range(sym_len(start))))) == wrap_int(1) for a, b in sym_zip(wrap_list([start]) + states, states[:target_len] + wrap_list([combo])))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "2184377" (as nil (List String))) x) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 18 1) (cons "7002994" (as nil (List String)))) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "2184377" (as nil (List String))) x) zip_pos_0) 1)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 18 1) (cons "7002994" (as nil (List String)))) zip_pos_0) 1)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "2184377" (as nil (List String))) x) zip_pos_0) 2)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 18 1) (cons "7002994" (as nil (List String)))) zip_pos_0) 2)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "2184377" (as nil (List String))) x) zip_pos_0) 3)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 18 1) (cons "7002994" (as nil (List String)))) zip_pos_0) 3)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "2184377" (as nil (List String))) x) zip_pos_0) 4)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 18 1) (cons "7002994" (as nil (List String)))) zip_pos_0) 4)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "2184377" (as nil (List String))) x) zip_pos_0) 5)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 18 1) (cons "7002994" (as nil (List String)))) zip_pos_0) 5)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "2184377" (as nil (List String))) x) zip_pos_0) 6)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 18 1) (cons "7002994" (as nil (List String)))) zip_pos_0) 6)) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:143.116: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle CombinationLockObfuscated:4
Two large constants for extrapolation
Solving simpler variation replaced 2184377 with 3 and 7002994 with 5
sat_func def sat(states: List[str], start="3", combo="5", target_len=18):
    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1
               for a, b in zip([start] + states, states[:target_len] + [combo]))
modified_func def sat(states: List[str], start=wrap_str('3'), combo=wrap_str('5'), target_len=wrap_int(18)):
    return all(sym_generator((sym_sum(sym_generator(((sym_int(a[i]) - sym_int(b[i])) ** wrap_int(2) % wrap_int(10) for i in sym_range(sym_len(start))))) == wrap_int(1) for a, b in sym_zip(wrap_list([start]) + states, states[:target_len] + wrap_list([combo])))))
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List String))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (cons "3" (as nil (List String))) x) zip_pos_0) 0)) 0))
(assert (> (str.len (python.str.at (list.get.string (list.append.string (list.slice.string x 0 18 1) (cons "5" (as nil (List String)))) zip_pos_0) 0)) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:143.110: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle CombinationLockObfuscated:4

Solving puzzle 505/732: OnesAndTwos:0
sat_func def sat(seq: List[int], n=10000, length=5017):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
modified_func def sat(seq: List[int], n=wrap_int(10000), length=wrap_int(5017)):
    return all(sym_generator((sym_in(i, wrap_list([wrap_int(1), wrap_int(2)])) for i in seq))).__and__(sym_sum(seq) == n).__and__(sym_len(seq) == length)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_535 Int)) (=> (and (>= list_pos_535 0) (< list_pos_535 (list.length.int x))) (forall ((list_pos_534 Int)) (=> (and (>= list_pos_534 0) (< list_pos_534 (list.length.int x))) (and (and (or (= (list.get.int x list_pos_534) 1) (= (list.get.int x list_pos_534) 2)) (= (+ (list.get.int x list_pos_535) 0) 10000)) (= (list.length.int x) 5017)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OnesAndTwos:0
Two large constants for extrapolation
Solving simpler variation replaced 10000 with 3 and 5017 with 5
sat_func def sat(seq: List[int], n=3, length=5):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
modified_func def sat(seq: List[int], n=wrap_int(3), length=wrap_int(5)):
    return all(sym_generator((sym_in(i, wrap_list([wrap_int(1), wrap_int(2)])) for i in seq))).__and__(sym_sum(seq) == n).__and__(sym_len(seq) == length)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_537 Int)) (=> (and (>= list_pos_537 0) (< list_pos_537 (list.length.int x))) (forall ((list_pos_536 Int)) (=> (and (>= list_pos_536 0) (< list_pos_536 (list.length.int x))) (and (and (or (= (list.get.int x list_pos_536) 1) (= (list.get.int x list_pos_536) 2)) (= (+ (list.get.int x list_pos_537) 0) 3)) (= (list.length.int x) 5)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OnesAndTwos:0

Solving puzzle 506/732: OnesAndTwos:1
sat_func def sat(seq: List[int], n=867, length=785):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
modified_func def sat(seq: List[int], n=wrap_int(867), length=wrap_int(785)):
    return all(sym_generator((sym_in(i, wrap_list([wrap_int(1), wrap_int(2)])) for i in seq))).__and__(sym_sum(seq) == n).__and__(sym_len(seq) == length)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_539 Int)) (=> (and (>= list_pos_539 0) (< list_pos_539 (list.length.int x))) (forall ((list_pos_538 Int)) (=> (and (>= list_pos_538 0) (< list_pos_538 (list.length.int x))) (and (and (or (= (list.get.int x list_pos_538) 1) (= (list.get.int x list_pos_538) 2)) (= (+ (list.get.int x list_pos_539) 0) 867)) (= (list.length.int x) 785)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OnesAndTwos:1
Two large constants for extrapolation
Solving simpler variation replaced 785 with 3 and 867 with 5
sat_func def sat(seq: List[int], n=5, length=3):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
modified_func def sat(seq: List[int], n=wrap_int(5), length=wrap_int(3)):
    return all(sym_generator((sym_in(i, wrap_list([wrap_int(1), wrap_int(2)])) for i in seq))).__and__(sym_sum(seq) == n).__and__(sym_len(seq) == length)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_541 Int)) (=> (and (>= list_pos_541 0) (< list_pos_541 (list.length.int x))) (forall ((list_pos_540 Int)) (=> (and (>= list_pos_540 0) (< list_pos_540 (list.length.int x))) (and (and (or (= (list.get.int x list_pos_540) 1) (= (list.get.int x list_pos_540) 2)) (= (+ (list.get.int x list_pos_541) 0) 5)) (= (list.length.int x) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OnesAndTwos:1

Solving puzzle 507/732: OnesAndTwos:2
sat_func def sat(seq: List[int], n=0, length=0):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
modified_func def sat(seq: List[int], n=wrap_int(0), length=wrap_int(0)):
    return all(sym_generator((sym_in(i, wrap_list([wrap_int(1), wrap_int(2)])) for i in seq))).__and__(sym_sum(seq) == n).__and__(sym_len(seq) == length)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_543 Int)) (=> (and (>= list_pos_543 0) (< list_pos_543 (list.length.int x))) (forall ((list_pos_542 Int)) (=> (and (>= list_pos_542 0) (< list_pos_542 (list.length.int x))) (and (and (or (= (list.get.int x list_pos_542) 1) (= (list.get.int x list_pos_542) 2)) (= (+ (list.get.int x list_pos_543) 0) 0)) (= (list.length.int x) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OnesAndTwos:2
Too many constants for extrapolation

Solving puzzle 508/732: OnesAndTwos:3
sat_func def sat(seq: List[int], n=4, length=2):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
modified_func def sat(seq: List[int], n=wrap_int(4), length=wrap_int(2)):
    return all(sym_generator((sym_in(i, wrap_list([wrap_int(1), wrap_int(2)])) for i in seq))).__and__(sym_sum(seq) == n).__and__(sym_len(seq) == length)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_545 Int)) (=> (and (>= list_pos_545 0) (< list_pos_545 (list.length.int x))) (forall ((list_pos_544 Int)) (=> (and (>= list_pos_544 0) (< list_pos_544 (list.length.int x))) (and (and (or (= (list.get.int x list_pos_544) 1) (= (list.get.int x list_pos_544) 2)) (= (+ (list.get.int x list_pos_545) 0) 4)) (= (list.length.int x) 2)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OnesAndTwos:3
Too many constants for extrapolation

Solving puzzle 509/732: OnesAndTwos:4
sat_func def sat(seq: List[int], n=5514, length=4310):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
modified_func def sat(seq: List[int], n=wrap_int(5514), length=wrap_int(4310)):
    return all(sym_generator((sym_in(i, wrap_list([wrap_int(1), wrap_int(2)])) for i in seq))).__and__(sym_sum(seq) == n).__and__(sym_len(seq) == length)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_547 Int)) (=> (and (>= list_pos_547 0) (< list_pos_547 (list.length.int x))) (forall ((list_pos_546 Int)) (=> (and (>= list_pos_546 0) (< list_pos_546 (list.length.int x))) (and (and (or (= (list.get.int x list_pos_546) 1) (= (list.get.int x list_pos_546) 2)) (= (+ (list.get.int x list_pos_547) 0) 5514)) (= (list.length.int x) 4310)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OnesAndTwos:4
Two large constants for extrapolation
Solving simpler variation replaced 4310 with 3 and 5514 with 5
sat_func def sat(seq: List[int], n=5, length=3):
    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length
modified_func def sat(seq: List[int], n=wrap_int(5), length=wrap_int(3)):
    return all(sym_generator((sym_in(i, wrap_list([wrap_int(1), wrap_int(2)])) for i in seq))).__and__(sym_sum(seq) == n).__and__(sym_len(seq) == length)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_549 Int)) (=> (and (>= list_pos_549 0) (< list_pos_549 (list.length.int x))) (forall ((list_pos_548 Int)) (=> (and (>= list_pos_548 0) (< list_pos_548 (list.length.int x))) (and (and (or (= (list.get.int x list_pos_548) 1) (= (list.get.int x list_pos_548) 2)) (= (+ (list.get.int x list_pos_549) 0) 5)) (= (list.length.int x) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle OnesAndTwos:4

Solving puzzle 510/732: DistinctOddSum:0
sat_func def sat(nums: List[int], tot=12345, n=5):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(12345), n=wrap_int(5)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_553 Int)) (=> (and (>= list_pos_553 0) (< list_pos_553 (list.length.int x))) (forall ((list_pos_552 Int)) (=> (and (>= list_pos_552 0) (< list_pos_552 (list.length.int x))) (forall ((list_pos_551 Int)) (=> (and (>= list_pos_551 0) (< list_pos_551 (list.length.int x))) (forall ((list_pos_550 Int)) (=> (and (>= list_pos_550 0) (< list_pos_550 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_552) 0) 12345)) (and (>= (list.get.int x list_pos_553) (mod (list.get.int x list_pos_553) 2)) (> (mod (list.get.int x list_pos_553) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:0
One large constant for extrapolation
Solving simpler variation replaced 12345 with 3
sat_func def sat(nums: List[int], tot=3, n=5):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(3), n=wrap_int(5)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_557 Int)) (=> (and (>= list_pos_557 0) (< list_pos_557 (list.length.int x))) (forall ((list_pos_556 Int)) (=> (and (>= list_pos_556 0) (< list_pos_556 (list.length.int x))) (forall ((list_pos_555 Int)) (=> (and (>= list_pos_555 0) (< list_pos_555 (list.length.int x))) (forall ((list_pos_554 Int)) (=> (and (>= list_pos_554 0) (< list_pos_554 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_556) 0) 3)) (and (>= (list.get.int x list_pos_557) (mod (list.get.int x list_pos_557) 2)) (> (mod (list.get.int x list_pos_557) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:0

Solving puzzle 511/732: DistinctOddSum:1
sat_func def sat(nums: List[int], tot=1819, n=3):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(1819), n=wrap_int(3)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_561 Int)) (=> (and (>= list_pos_561 0) (< list_pos_561 (list.length.int x))) (forall ((list_pos_560 Int)) (=> (and (>= list_pos_560 0) (< list_pos_560 (list.length.int x))) (forall ((list_pos_559 Int)) (=> (and (>= list_pos_559 0) (< list_pos_559 (list.length.int x))) (forall ((list_pos_558 Int)) (=> (and (>= list_pos_558 0) (< list_pos_558 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_560) 0) 1819)) (and (>= (list.get.int x list_pos_561) (mod (list.get.int x list_pos_561) 2)) (> (mod (list.get.int x list_pos_561) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:1
One large constant for extrapolation
Solving simpler variation replaced 1819 with 3
sat_func def sat(nums: List[int], tot=3, n=3):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(3), n=wrap_int(3)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_565 Int)) (=> (and (>= list_pos_565 0) (< list_pos_565 (list.length.int x))) (forall ((list_pos_564 Int)) (=> (and (>= list_pos_564 0) (< list_pos_564 (list.length.int x))) (forall ((list_pos_563 Int)) (=> (and (>= list_pos_563 0) (< list_pos_563 (list.length.int x))) (forall ((list_pos_562 Int)) (=> (and (>= list_pos_562 0) (< list_pos_562 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_564) 0) 3)) (and (>= (list.get.int x list_pos_565) (mod (list.get.int x list_pos_565) 2)) (> (mod (list.get.int x list_pos_565) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:1

Solving puzzle 512/732: DistinctOddSum:2
sat_func def sat(nums: List[int], tot=37729, n=73):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(37729), n=wrap_int(73)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_569 Int)) (=> (and (>= list_pos_569 0) (< list_pos_569 (list.length.int x))) (forall ((list_pos_568 Int)) (=> (and (>= list_pos_568 0) (< list_pos_568 (list.length.int x))) (forall ((list_pos_567 Int)) (=> (and (>= list_pos_567 0) (< list_pos_567 (list.length.int x))) (forall ((list_pos_566 Int)) (=> (and (>= list_pos_566 0) (< list_pos_566 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_568) 0) 37729)) (and (>= (list.get.int x list_pos_569) (mod (list.get.int x list_pos_569) 2)) (> (mod (list.get.int x list_pos_569) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:2
One large constant for extrapolation
Solving simpler variation replaced 37729 with 3
sat_func def sat(nums: List[int], tot=3, n=73):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(3), n=wrap_int(73)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_573 Int)) (=> (and (>= list_pos_573 0) (< list_pos_573 (list.length.int x))) (forall ((list_pos_572 Int)) (=> (and (>= list_pos_572 0) (< list_pos_572 (list.length.int x))) (forall ((list_pos_571 Int)) (=> (and (>= list_pos_571 0) (< list_pos_571 (list.length.int x))) (forall ((list_pos_570 Int)) (=> (and (>= list_pos_570 0) (< list_pos_570 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_572) 0) 3)) (and (>= (list.get.int x list_pos_573) (mod (list.get.int x list_pos_573) 2)) (> (mod (list.get.int x list_pos_573) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:2

Solving puzzle 513/732: DistinctOddSum:3
sat_func def sat(nums: List[int], tot=5359, n=11):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(5359), n=wrap_int(11)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_577 Int)) (=> (and (>= list_pos_577 0) (< list_pos_577 (list.length.int x))) (forall ((list_pos_576 Int)) (=> (and (>= list_pos_576 0) (< list_pos_576 (list.length.int x))) (forall ((list_pos_575 Int)) (=> (and (>= list_pos_575 0) (< list_pos_575 (list.length.int x))) (forall ((list_pos_574 Int)) (=> (and (>= list_pos_574 0) (< list_pos_574 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_576) 0) 5359)) (and (>= (list.get.int x list_pos_577) (mod (list.get.int x list_pos_577) 2)) (> (mod (list.get.int x list_pos_577) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:3
One large constant for extrapolation
Solving simpler variation replaced 5359 with 3
sat_func def sat(nums: List[int], tot=3, n=11):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(3), n=wrap_int(11)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_581 Int)) (=> (and (>= list_pos_581 0) (< list_pos_581 (list.length.int x))) (forall ((list_pos_580 Int)) (=> (and (>= list_pos_580 0) (< list_pos_580 (list.length.int x))) (forall ((list_pos_579 Int)) (=> (and (>= list_pos_579 0) (< list_pos_579 (list.length.int x))) (forall ((list_pos_578 Int)) (=> (and (>= list_pos_578 0) (< list_pos_578 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_580) 0) 3)) (and (>= (list.get.int x list_pos_581) (mod (list.get.int x list_pos_581) 2)) (> (mod (list.get.int x list_pos_581) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:3

Solving puzzle 514/732: DistinctOddSum:4
sat_func def sat(nums: List[int], tot=36505, n=73):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(36505), n=wrap_int(73)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_585 Int)) (=> (and (>= list_pos_585 0) (< list_pos_585 (list.length.int x))) (forall ((list_pos_584 Int)) (=> (and (>= list_pos_584 0) (< list_pos_584 (list.length.int x))) (forall ((list_pos_583 Int)) (=> (and (>= list_pos_583 0) (< list_pos_583 (list.length.int x))) (forall ((list_pos_582 Int)) (=> (and (>= list_pos_582 0) (< list_pos_582 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_584) 0) 36505)) (and (>= (list.get.int x list_pos_585) (mod (list.get.int x list_pos_585) 2)) (> (mod (list.get.int x list_pos_585) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:4
One large constant for extrapolation
Solving simpler variation replaced 36505 with 3
sat_func def sat(nums: List[int], tot=3, n=73):
    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)
modified_func def sat(nums: List[int], tot=wrap_int(3), n=wrap_int(73)):
    return (sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == n).__and__(sym_sum(nums) == tot).__and__(all(sym_generator(((i >= i % wrap_int(2)).__and__(i % wrap_int(2) > wrap_int(0)) for i in nums))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_589 Int)) (=> (and (>= list_pos_589 0) (< list_pos_589 (list.length.int x))) (forall ((list_pos_588 Int)) (=> (and (>= list_pos_588 0) (< list_pos_588 (list.length.int x))) (forall ((list_pos_587 Int)) (=> (and (>= list_pos_587 0) (< list_pos_587 (list.length.int x))) (forall ((list_pos_586 Int)) (=> (and (>= list_pos_586 0) (< list_pos_586 (list.length.int x))) (and (and (and (= (list.length.int x) 1) false) (= (+ (list.get.int x list_pos_588) 0) 3)) (and (>= (list.get.int x list_pos_589) (mod (list.get.int x list_pos_589) 2)) (> (mod (list.get.int x list_pos_589) 2) 0))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle DistinctOddSum:4

Solving puzzle 515/732: MinRotations:0
sat_func def sat(rotations: List[int], target="wonderful", upper=69):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
modified_func def sat(rotations: List[int], target=wrap_str('wonderful'), upper=wrap_int(69)):
    s = wrap_str('abcdefghijklmnopqrstuvwxyz')
    _assert(sym_len(rotations) == sym_len(target))
    for r, c in sym_zip(rotations, target):
        s = s[r:] + s[:r]
        _assert(s[wrap_int(0)] == c)
    return sym_sum(sym_generator((abs(r) for r in rotations))) <= upper
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (= (list.length.int x) 9))
(assert (= (python.str.at (str.++ (str.substr "abcdefghijklmnopqrstuvwxyz" (list.get.int x zip_pos_0) (- 26 (list.get.int x zip_pos_0))) (str.substr "abcdefghijklmnopqrstuvwxyz" 0 (- (list.get.int x zip_pos_0) 0))) 0) (python.str.at "wonderful" zip_pos_0)))
(assert (forall ((list_pos_590 Int)) (=> (and (>= list_pos_590 0) (< list_pos_590 (list.length.int x))) (<= (+ (ite (>= (list.get.int x list_pos_590) 0) (list.get.int x list_pos_590) (- (list.get.int x list_pos_590))) 0) 69))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:105.92: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle MinRotations:0
Too many constants for extrapolation

Solving puzzle 516/732: MinRotations:1
sat_func def sat(rotations: List[int], target="tubolele", upper=52):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
modified_func def sat(rotations: List[int], target=wrap_str('tubolele'), upper=wrap_int(52)):
    s = wrap_str('abcdefghijklmnopqrstuvwxyz')
    _assert(sym_len(rotations) == sym_len(target))
    for r, c in sym_zip(rotations, target):
        s = s[r:] + s[:r]
        _assert(s[wrap_int(0)] == c)
    return sym_sum(sym_generator((abs(r) for r in rotations))) <= upper
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (= (list.length.int x) 8))
(assert (= (python.str.at (str.++ (str.substr "abcdefghijklmnopqrstuvwxyz" (list.get.int x zip_pos_0) (- 26 (list.get.int x zip_pos_0))) (str.substr "abcdefghijklmnopqrstuvwxyz" 0 (- (list.get.int x zip_pos_0) 0))) 0) (python.str.at "tubolele" zip_pos_0)))
(assert (forall ((list_pos_591 Int)) (=> (and (>= list_pos_591 0) (< list_pos_591 (list.length.int x))) (<= (+ (ite (>= (list.get.int x list_pos_591) 0) (list.get.int x list_pos_591) (- (list.get.int x list_pos_591))) 0) 52))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:105.92: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle MinRotations:1
Too many constants for extrapolation

Solving puzzle 517/732: MinRotations:2
sat_func def sat(rotations: List[int], target="soquogisawah", upper=67):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
modified_func def sat(rotations: List[int], target=wrap_str('soquogisawah'), upper=wrap_int(67)):
    s = wrap_str('abcdefghijklmnopqrstuvwxyz')
    _assert(sym_len(rotations) == sym_len(target))
    for r, c in sym_zip(rotations, target):
        s = s[r:] + s[:r]
        _assert(s[wrap_int(0)] == c)
    return sym_sum(sym_generator((abs(r) for r in rotations))) <= upper
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (= (list.length.int x) 12))
(assert (= (python.str.at (str.++ (str.substr "abcdefghijklmnopqrstuvwxyz" (list.get.int x zip_pos_0) (- 26 (list.get.int x zip_pos_0))) (str.substr "abcdefghijklmnopqrstuvwxyz" 0 (- (list.get.int x zip_pos_0) 0))) 0) (python.str.at "soquogisawah" zip_pos_0)))
(assert (forall ((list_pos_592 Int)) (=> (and (>= list_pos_592 0) (< list_pos_592 (list.length.int x))) (<= (+ (ite (>= (list.get.int x list_pos_592) 0) (list.get.int x list_pos_592) (- (list.get.int x list_pos_592))) 0) 67))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:105.92: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle MinRotations:2
Too many constants for extrapolation

Solving puzzle 518/732: MinRotations:3
sat_func def sat(rotations: List[int], target="jacepa", upper=44):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
modified_func def sat(rotations: List[int], target=wrap_str('jacepa'), upper=wrap_int(44)):
    s = wrap_str('abcdefghijklmnopqrstuvwxyz')
    _assert(sym_len(rotations) == sym_len(target))
    for r, c in sym_zip(rotations, target):
        s = s[r:] + s[:r]
        _assert(s[wrap_int(0)] == c)
    return sym_sum(sym_generator((abs(r) for r in rotations))) <= upper
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (= (list.length.int x) 6))
(assert (= (python.str.at (str.++ (str.substr "abcdefghijklmnopqrstuvwxyz" (list.get.int x zip_pos_0) (- 26 (list.get.int x zip_pos_0))) (str.substr "abcdefghijklmnopqrstuvwxyz" 0 (- (list.get.int x zip_pos_0) 0))) 0) (python.str.at "jacepa" zip_pos_0)))
(assert (forall ((list_pos_593 Int)) (=> (and (>= list_pos_593 0) (< list_pos_593 (list.length.int x))) (<= (+ (ite (>= (list.get.int x list_pos_593) 0) (list.get.int x list_pos_593) (- (list.get.int x list_pos_593))) 0) 44))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:105.92: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle MinRotations:3
Too many constants for extrapolation

Solving puzzle 519/732: MinRotations:4
sat_func def sat(rotations: List[int], target="miwykucehexo", upper=84):
    s = "abcdefghijklmnopqrstuvwxyz"
    assert len(rotations) == len(target)
    for r, c in zip(rotations, target):
        s = s[r:] + s[:r]
        assert s[0] == c

    return sum(abs(r) for r in rotations) <= upper
modified_func def sat(rotations: List[int], target=wrap_str('miwykucehexo'), upper=wrap_int(84)):
    s = wrap_str('abcdefghijklmnopqrstuvwxyz')
    _assert(sym_len(rotations) == sym_len(target))
    for r, c in sym_zip(rotations, target):
        s = s[r:] + s[:r]
        _assert(s[wrap_int(0)] == c)
    return sym_sum(sym_generator((abs(r) for r in rotations))) <= upper
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun python.str.at ((s String) (start Int)) String
  (let ((start (ite (< start 0) (+ (str.len s) start) start)))
    (str.substr s start 1)))

(declare-const x (List Int))
(assert (= (list.length.int x) 12))
(assert (= (python.str.at (str.++ (str.substr "abcdefghijklmnopqrstuvwxyz" (list.get.int x zip_pos_0) (- 26 (list.get.int x zip_pos_0))) (str.substr "abcdefghijklmnopqrstuvwxyz" 0 (- (list.get.int x zip_pos_0) 0))) 0) (python.str.at "miwykucehexo" zip_pos_0)))
(assert (forall ((list_pos_594 Int)) (=> (and (>= list_pos_594 0) (< list_pos_594 (list.length.int x))) (<= (+ (ite (>= (list.get.int x list_pos_594) 0) (list.get.int x list_pos_594) (- (list.get.int x list_pos_594))) 0) 84))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:105.92: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle MinRotations:4
Too many constants for extrapolation

Solving puzzle 520/732: BillSums:0
sat_func def sat(bills: List[int], denominations=[1, 25, 35, 84], n=980, max_len=14):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(25), wrap_int(35), wrap_int(84)]), n=wrap_int(980), max_len=wrap_int(14)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_596 Int)) (=> (and (>= list_pos_596 0) (< list_pos_596 (list.length.int x))) (forall ((list_pos_595 Int)) (=> (and (>= list_pos_595 0) (< list_pos_595 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_595) 0) 980) (or (= (list.get.int x list_pos_596) 1) (= (list.get.int x list_pos_596) 25) (= (list.get.int x list_pos_596) 35) (= (list.get.int x list_pos_596) 84))) (<= (list.length.int x) 14)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:0
One large constant for extrapolation
Solving simpler variation replaced 980 with 3
sat_func def sat(bills: List[int], denominations=[1, 25, 35, 84], n=3, max_len=14):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(25), wrap_int(35), wrap_int(84)]), n=wrap_int(3), max_len=wrap_int(14)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_598 Int)) (=> (and (>= list_pos_598 0) (< list_pos_598 (list.length.int x))) (forall ((list_pos_597 Int)) (=> (and (>= list_pos_597 0) (< list_pos_597 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_597) 0) 3) (or (= (list.get.int x list_pos_598) 1) (= (list.get.int x list_pos_598) 25) (= (list.get.int x list_pos_598) 35) (= (list.get.int x list_pos_598) 84))) (<= (list.length.int x) 14)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:0

Solving puzzle 521/732: BillSums:1
sat_func def sat(bills: List[int], denominations=[1, 5, 7, 11], n=29377, max_len=2671):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(5), wrap_int(7), wrap_int(11)]), n=wrap_int(29377), max_len=wrap_int(2671)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_600 Int)) (=> (and (>= list_pos_600 0) (< list_pos_600 (list.length.int x))) (forall ((list_pos_599 Int)) (=> (and (>= list_pos_599 0) (< list_pos_599 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_599) 0) 29377) (or (= (list.get.int x list_pos_600) 1) (= (list.get.int x list_pos_600) 5) (= (list.get.int x list_pos_600) 7) (= (list.get.int x list_pos_600) 11))) (<= (list.length.int x) 2671)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:1
Two large constants for extrapolation
Solving simpler variation replaced 2671 with 3 and 29377 with 5
sat_func def sat(bills: List[int], denominations=[1, 5, 7, 11], n=5, max_len=3):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(5), wrap_int(7), wrap_int(11)]), n=wrap_int(5), max_len=wrap_int(3)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_602 Int)) (=> (and (>= list_pos_602 0) (< list_pos_602 (list.length.int x))) (forall ((list_pos_601 Int)) (=> (and (>= list_pos_601 0) (< list_pos_601 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_601) 0) 5) (or (= (list.get.int x list_pos_602) 1) (= (list.get.int x list_pos_602) 5) (= (list.get.int x list_pos_602) 7) (= (list.get.int x list_pos_602) 11))) (<= (list.length.int x) 3)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:1

Solving puzzle 522/732: BillSums:2
sat_func def sat(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(44), wrap_int(69)]), n=wrap_int(727), max_len=wrap_int(18)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_604 Int)) (=> (and (>= list_pos_604 0) (< list_pos_604 (list.length.int x))) (forall ((list_pos_603 Int)) (=> (and (>= list_pos_603 0) (< list_pos_603 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_603) 0) 727) (or (= (list.get.int x list_pos_604) 1) (= (list.get.int x list_pos_604) 44) (= (list.get.int x list_pos_604) 69))) (<= (list.length.int x) 18)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:2
One large constant for extrapolation
Solving simpler variation replaced 727 with 3
sat_func def sat(bills: List[int], denominations=[1, 44, 69], n=3, max_len=18):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(44), wrap_int(69)]), n=wrap_int(3), max_len=wrap_int(18)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_606 Int)) (=> (and (>= list_pos_606 0) (< list_pos_606 (list.length.int x))) (forall ((list_pos_605 Int)) (=> (and (>= list_pos_605 0) (< list_pos_605 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_605) 0) 3) (or (= (list.get.int x list_pos_606) 1) (= (list.get.int x list_pos_606) 44) (= (list.get.int x list_pos_606) 69))) (<= (list.length.int x) 18)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:2

Solving puzzle 523/732: BillSums:3
sat_func def sat(bills: List[int], denominations=[1, 25, 29], n=537, max_len=21):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(25), wrap_int(29)]), n=wrap_int(537), max_len=wrap_int(21)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_608 Int)) (=> (and (>= list_pos_608 0) (< list_pos_608 (list.length.int x))) (forall ((list_pos_607 Int)) (=> (and (>= list_pos_607 0) (< list_pos_607 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_607) 0) 537) (or (= (list.get.int x list_pos_608) 1) (= (list.get.int x list_pos_608) 25) (= (list.get.int x list_pos_608) 29))) (<= (list.length.int x) 21)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:3
One large constant for extrapolation
Solving simpler variation replaced 537 with 3
sat_func def sat(bills: List[int], denominations=[1, 25, 29], n=3, max_len=21):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(25), wrap_int(29)]), n=wrap_int(3), max_len=wrap_int(21)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_610 Int)) (=> (and (>= list_pos_610 0) (< list_pos_610 (list.length.int x))) (forall ((list_pos_609 Int)) (=> (and (>= list_pos_609 0) (< list_pos_609 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_609) 0) 3) (or (= (list.get.int x list_pos_610) 1) (= (list.get.int x list_pos_610) 25) (= (list.get.int x list_pos_610) 29))) (<= (list.length.int x) 21)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:3

Solving puzzle 524/732: BillSums:4
sat_func def sat(bills: List[int], denominations=[1, 10, 23, 49], n=74, max_len=4):
    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len
modified_func def sat(bills: List[int], denominations=wrap_list([wrap_int(1), wrap_int(10), wrap_int(23), wrap_int(49)]), n=wrap_int(74), max_len=wrap_int(4)):
    return (sym_sum(bills) == n).__and__(all(sym_generator((sym_in(b, denominations) for b in bills)))).__and__(sym_len(bills) <= max_len)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_612 Int)) (=> (and (>= list_pos_612 0) (< list_pos_612 (list.length.int x))) (forall ((list_pos_611 Int)) (=> (and (>= list_pos_611 0) (< list_pos_611 (list.length.int x))) (and (and (= (+ (list.get.int x list_pos_611) 0) 74) (or (= (list.get.int x list_pos_612) 1) (= (list.get.int x list_pos_612) 10) (= (list.get.int x list_pos_612) 23) (= (list.get.int x list_pos_612) 49))) (<= (list.length.int x) 4)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BillSums:4
Too many constants for extrapolation

Solving puzzle 525/732: BoxVolume:0
sat_func def sat(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
modified_func def sat(sides: List[int], options=wrap_list([wrap_int(2), wrap_int(512), wrap_int(1024)]), n=wrap_int(340282366920938463463374607431768211456), max_dim=wrap_int(13)):
    prod = wrap_int(1)
    for b in sides:
        prod *= b
    return (prod == n).__and__(set(sides) <= set(options)).__and__(sym_len(sides) <= max_dim)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_614 Int)) (=> (and (>= list_pos_614 0) (< list_pos_614 (list.length.int x))) (forall ((list_pos_613 Int)) (=> (and (>= list_pos_613 0) (< list_pos_613 (list.length.int x))) (and (and (= (* 1 (list.get.int x list_pos_613)) 340282366920938463463374607431768211456) false) (<= (list.length.int x) 13)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BoxVolume:0
Too many constants for extrapolation

Solving puzzle 526/732: BoxVolume:1
sat_func def sat(sides: List[int], options=[2, 32, 128, 2048], n=228130115719126719403436248654018132587240700300069484783024476396726369300757361858486149336528857415050585140022669260683533846520228615414824699513965623011283630204688776606537822433903248866264246250472816019829634613450432640540476545312147582016319329176365649861438112055219416307889844810164481913129640729676567935637319847974104737041819733016269814095538825986746872964316260742048948842881864927312578954616543873339090000235516611035976675319992951155425592590971354482499219065911551659299442284010821489032878061237960883641148400358779732380029929731755431392589957363797811587552907493225515131362976630371588393769290980736545625490532833401799533953657008471171187904833042604191595654563052739341699008374536877944129683396035943703772775574923305193036335454829886522712928671689842429868129065816806317184528393809093537482604512070817490962382058600995548188534203183821947412497991334185434644234223497426696856425081004631697882694737783657734748584914343393446495655603077914405339198501652640033384883248202008796431768177660311524505375032465859911969645720782885945304020206901948785067162180147604944416802494237380295502898725709699989316239611948841761179630356857432537740268880887406363698339697884778928867070095601679136329773121122427957476591692077252692128084462084666562367516110718889596553029368485592312571562760467825734375966403657494757513742901716957512515999554215394910749910705062184378036402811375228424564672896328484400844595493109009999483758555965249861718868505692086014690841384328807750643083870429560141041100275605070593340307777014146422286286174141328734305861765975142642533328283052695019530894917054320937603586353968931629943177100198544320130592080317808699102134050255107270490491866451598651191237073743434416055324965245162816436688506766798907631409318862813999619267517691129416882206979571876987670409601093143594006666877317942246151185196703526359657208564220263995224577466875935694654571263504652726005785629951670929607532333340077417449014738737013346326087193441376781403017104776528773370114633214397553406205844983209794006628986960804493464678425632234950959510169749894285280278283738406987643831719730840932795296580290643750811511261778066991567984806115883476196314905009957269037243416953344853497398305731263857286565805740574002573468233255419591302501435585946727352997645518600735324783808084419495985356968106531724233422062762588856840753502904727554461930814392985988583994344625901267465334680461022145630478703628829329214105057598498060165611002555328089927562335110353619756270727870578861254390831489833288520806796527530233204302267437547065838761620867335585044147746062666641204836971836326240475987046035522808201203159329079453415117803276772632387741778875346277155398622874525185657020894389122946631102004676447465064652881476735210624605751725260196714783487821662079677160631607184350517490457782630582235697826366596839098468662601860843910244925043204559895831233405782087371882757970774478474456873255395627305993127448835175163234402865711702330195641472753972521303188861456649807013475719673540071791198682554468915003105114658732620778592368025010627074092048770677221666930787774307426025130737526294176368225554400859962054685688030870382537978901917116576720339440289697234523317616314038117415668096017357904607750516858893107088258836773840081269481533772759281055281700189820269430782472437953000818618620073622195951192485912449122811233373872720728771442190884380599983059328804281149117350956948229322152773453262155799120217785942195894432200049075535098740412553027257995610825803094581023661379076874649822855869540676929026434776986202199736335291086433750024634767647140351636139668469623425852015023217614605601509807425262068267436928967585507261326427312192469433846382754391958778190093898722931985614221781005700500186774555621410213366027104482083356617237286158279541722415195573634119626161145784283399399763136624234679728759972590678720441851340526642105986068992675508623421201319495330632683326640681447849893540200819910937029765557508137488203702135573415958504919756451764701424427616007186711716814731754356696294815225309000903038863786582011151301767020033435488951952515328694739238611436697506492409350399051491860286180916641995435036798744630218175609818767447434417101324494299048701375363995201208156077912500466647001096398105097526014328010704551098721141422402194540968220131279390845880754347325090679635736861222456047497894985750004735992813665737790270893848091556206678545839263262921269604717011176408056673577863963647995994679194792859835924183303294858830520237184847307088921165828069254730539210820781321214188691456066198669698221986283054877560403229938707456087823056229168657150416667472353923056485151256206281259934588996856957165363419959086737278132371225618045208766940894851830536221997939414764739510874614136757754731916169592243013858728423395629916861873250059908376640593353458920525817510096165639822536116104014564983262641835696648770796437401025069947591765576169212854786072852037200412675323852228612643476420810700506802979469371193707478238102372738573446551135494399083768640394423902510360568345963566956628316386503835770637993395889794935064583369456457251364106039002197061249640656337408285516947104128384648071872093149185222817195549313653521423697663580452218339727675869442230637147896150992109058378079284047987408513151424582426733908811332984743426926921482525672979132388569204856728480053543657314645848629452707066384786683940683922294349706905116833856400816002318580982472177845076143240683398799002252052620073260453978750375575223410433119522136481155383781061087345580876922667168909793260459989117418608371057291625605742980576502324517701043654641735294862171567996649051774368556674742803204305115479624063288540683801642080951288085873119685282033998440038309690901065668529995699263324324647663786987570997092769208911017915884270972152889988269937518906215458313814671282111935739061027874324706982875737155498573655909937861180443564435913525096059145949918294793776507173166107542059434114036766604950338860659503927865444687234023577758066365219472193319060107680269235616121325491303450849189026066604825116203403688819256549446469872454719979920079537099106304473570385681301430528769647421769240063242145063519073744152649494347821386673801477876591176898296658169802358064222303060868163538278020710591214386547249222952832818252842480178040572184084541071252073329855267036622763497225362671868043427997760221082785500384040742315799726682553888439254019033785740045784304237440355626690384344706900984786817034803207351161123175189215391916314291940696635993614322400314858617500069240761161101656033019211764256155420375348098566252555605378514744357978092011966637756282555883252547041098779361571592132511685974148955404843221146265096853450620709172105401754899975093227930688317971723555701302765701773289547141581265923801348450949162571448538932045007651581274796679173418467222661434739407456208067855969412215915828478533782205100053640112586053063309082312341996582816268147273845664101303622557781193410302781763062479639834516875758224554471296826756056995444356753101918287733079420101251086687448407074623452964778375926960581677381582362486643216332229928123236483635773267705721199409263698193020255835863136791913383111490081693301513932140406489776742165709629714987751458823040519007937519033772815412530564305120069350242278768783296719236430743732117712801991081268630206231139274033284907511906721452335462501166317547326594594957955217049374662407117141307601583000669214782094806782805113075265906828482252499002596357458621191160586625586111512272634529183613371281132957233425400325605401620814098603442053561895456042327363678383162487239895454728331055945869193536242853599717228788292205516180939641663484893911412444566747695275948642648631192599418045380803238852331361777586116015967092138091810017242532292746564005317567875162264651817447488681351477216121794453291559549365332550900514942221303837134657256366225256511675688256592613810130160871589071197842978260453456841801688807509997664221548899295846247899587131486967937781129153559530907098259658901823499223231462924893901110210162304614366220400600462508511005070809268751890443966184634738431571192464718609875536811814107818803946825222751690118887747643980508890911810875193517706876433214609535343577395964208443875870857748307152837416868580525555743549769445078834804561676514215910911559965763038223728194702912682866098246175065061179531928672739869105315436205040641895882311949809960043452332003364331016564406606479528418850597459996692115304751014933652479556318399189077142182676442159582999101191812232513521611405580381460497513444446648638490157000309696473736964812935464820324980925994537043070153654272, max_dim=2671):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
Exception -- for puzzle BoxVolume:1 Exceeds the limit (4300 digits) for integer string conversion: value has 8844 digits; use sys.set_int_max_str_digits() to increase the limit - Consider hexadecimal for huge integer literals to avoid decimal conversion limits. (<unknown>, line 1)

Solving puzzle 527/732: BoxVolume:2
sat_func def sat(sides: List[int], options=[5, 5684341886080801486968994140625, 1694065894508600678136645001359283924102783203125], n=14164235936814247246943953676783316651469999599259488526297703814252125093918086614885937400554283434172053854937092875501351523725603695985262279092166781262962870903549601084831041808313096168206454204432965872990952135614781500037949647186895146848775449563088704805081355726771444219003252553140494372583795600460039446480996347267095412342936844101488043829191704193224433757153659988332565127014442298522610686943372161710084163946718544591837540089627956441911856011461878779300604946911334991455078125, max_dim=18):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
modified_func def sat(sides: List[int], options=wrap_list([wrap_int(5), wrap_int(5684341886080801486968994140625), wrap_int(1694065894508600678136645001359283924102783203125)]), n=wrap_int(14164235936814247246943953676783316651469999599259488526297703814252125093918086614885937400554283434172053854937092875501351523725603695985262279092166781262962870903549601084831041808313096168206454204432965872990952135614781500037949647186895146848775449563088704805081355726771444219003252553140494372583795600460039446480996347267095412342936844101488043829191704193224433757153659988332565127014442298522610686943372161710084163946718544591837540089627956441911856011461878779300604946911334991455078125), max_dim=wrap_int(18)):
    prod = wrap_int(1)
    for b in sides:
        prod *= b
    return (prod == n).__and__(set(sides) <= set(options)).__and__(sym_len(sides) <= max_dim)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_616 Int)) (=> (and (>= list_pos_616 0) (< list_pos_616 (list.length.int x))) (forall ((list_pos_615 Int)) (=> (and (>= list_pos_615 0) (< list_pos_615 (list.length.int x))) (and (and (= (* 1 (list.get.int x list_pos_615)) 14164235936814247246943953676783316651469999599259488526297703814252125093918086614885937400554283434172053854937092875501351523725603695985262279092166781262962870903549601084831041808313096168206454204432965872990952135614781500037949647186895146848775449563088704805081355726771444219003252553140494372583795600460039446480996347267095412342936844101488043829191704193224433757153659988332565127014442298522610686943372161710084163946718544591837540089627956441911856011461878779300604946911334991455078125) false) (<= (list.length.int x) 18)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BoxVolume:2
Too many constants for extrapolation

Solving puzzle 528/732: BoxVolume:3
sat_func def sat(sides: List[int], options=[7, 1341068619663964900807, 3219905755813179726837607], n=6571242398704579720578070114049260568175867016132732117282677704710285377366495338413477575773225344143668665616691026039505250116800576464209614274689081547617879363134212486963646613891813824577824293441956456783410239143356741482364072743485236424053098241559823295733445894310196746774269493235867749396614000266398083913285305446265094243982850288066583162232189087239052303868564232298028341023504220837967414535260504654309004337585867867005771207, max_dim=21):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
modified_func def sat(sides: List[int], options=wrap_list([wrap_int(7), wrap_int(1341068619663964900807), wrap_int(3219905755813179726837607)]), n=wrap_int(6571242398704579720578070114049260568175867016132732117282677704710285377366495338413477575773225344143668665616691026039505250116800576464209614274689081547617879363134212486963646613891813824577824293441956456783410239143356741482364072743485236424053098241559823295733445894310196746774269493235867749396614000266398083913285305446265094243982850288066583162232189087239052303868564232298028341023504220837967414535260504654309004337585867867005771207), max_dim=wrap_int(21)):
    prod = wrap_int(1)
    for b in sides:
        prod *= b
    return (prod == n).__and__(set(sides) <= set(options)).__and__(sym_len(sides) <= max_dim)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_618 Int)) (=> (and (>= list_pos_618 0) (< list_pos_618 (list.length.int x))) (forall ((list_pos_617 Int)) (=> (and (>= list_pos_617 0) (< list_pos_617 (list.length.int x))) (and (and (= (* 1 (list.get.int x list_pos_617)) 6571242398704579720578070114049260568175867016132732117282677704710285377366495338413477575773225344143668665616691026039505250116800576464209614274689081547617879363134212486963646613891813824577824293441956456783410239143356741482364072743485236424053098241559823295733445894310196746774269493235867749396614000266398083913285305446265094243982850288066583162232189087239052303868564232298028341023504220837967414535260504654309004337585867867005771207) false) (<= (list.length.int x) 21)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BoxVolume:3
Too many constants for extrapolation

Solving puzzle 529/732: BoxVolume:4
sat_func def sat(sides: List[int], options=[2, 8, 64, 256], n=3885337784451458141838923813647037813284813678104279042503624819477808570410416996352, max_dim=36):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
modified_func def sat(sides: List[int], options=wrap_list([wrap_int(2), wrap_int(8), wrap_int(64), wrap_int(256)]), n=wrap_int(3885337784451458141838923813647037813284813678104279042503624819477808570410416996352), max_dim=wrap_int(36)):
    prod = wrap_int(1)
    for b in sides:
        prod *= b
    return (prod == n).__and__(set(sides) <= set(options)).__and__(sym_len(sides) <= max_dim)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_620 Int)) (=> (and (>= list_pos_620 0) (< list_pos_620 (list.length.int x))) (forall ((list_pos_619 Int)) (=> (and (>= list_pos_619 0) (< list_pos_619 (list.length.int x))) (and (and (= (* 1 (list.get.int x list_pos_619)) 3885337784451458141838923813647037813284813678104279042503624819477808570410416996352) false) (<= (list.length.int x) 36)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BoxVolume:4
Two large constants for extrapolation
Solving simpler variation replaced 256 with 3 and 3885337784451458141838923813647037813284813678104279042503624819477808570410416996352 with 5
sat_func def sat(sides: List[int], options=[2, 8, 64, 3], n=5, max_dim=36):
    prod = 1
    for b in sides:
        prod *= b
    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim
modified_func def sat(sides: List[int], options=wrap_list([wrap_int(2), wrap_int(8), wrap_int(64), wrap_int(3)]), n=wrap_int(5), max_dim=wrap_int(36)):
    prod = wrap_int(1)
    for b in sides:
        prod *= b
    return (prod == n).__and__(set(sides) <= set(options)).__and__(sym_len(sides) <= max_dim)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_622 Int)) (=> (and (>= list_pos_622 0) (< list_pos_622 (list.length.int x))) (forall ((list_pos_621 Int)) (=> (and (>= list_pos_621 0) (< list_pos_621 (list.length.int x))) (and (and (= (* 1 (list.get.int x list_pos_621)) 5) false) (<= (list.length.int x) 36)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle BoxVolume:4

Solving puzzle 530/732: ArithmeticSequence:0
sat_func def sat(x: List[int], a=7, s=5, e=200):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=wrap_int(7), s=wrap_int(5), e=wrap_int(200)):
    return (x[wrap_int(0)] == a).__and__(x[-wrap_int(1)] <= e).__and__(x[-wrap_int(1)] + s > e).__and__(all([x[i] + s == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (and (= (list.get.int x 0) 7) (<= (list.get.int x -1) 200)) (> (+ (list.get.int x -1) 5) 200)) (= (+ (list.get.int x i_0) 5) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ArithmeticSequence:0
One large constant for extrapolation
Solving simpler variation replaced 200 with 3
sat_func def sat(x: List[int], a=7, s=5, e=3):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=wrap_int(7), s=wrap_int(5), e=wrap_int(3)):
    return (x[wrap_int(0)] == a).__and__(x[-wrap_int(1)] <= e).__and__(x[-wrap_int(1)] + s > e).__and__(all([x[i] + s == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (and (= (list.get.int x 0) 7) (<= (list.get.int x -1) 3)) (> (+ (list.get.int x -1) 5) 3)) (= (+ (list.get.int x i_0) 5) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ArithmeticSequence:0

Solving puzzle 531/732: ArithmeticSequence:1
sat_func def sat(x: List[int], a=43536, s=3795, e=417606):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=wrap_int(43536), s=wrap_int(3795), e=wrap_int(417606)):
    return (x[wrap_int(0)] == a).__and__(x[-wrap_int(1)] <= e).__and__(x[-wrap_int(1)] + s > e).__and__(all([x[i] + s == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (and (= (list.get.int x 0) 43536) (<= (list.get.int x -1) 417606)) (> (+ (list.get.int x -1) 3795) 417606)) (= (+ (list.get.int x i_0) 3795) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ArithmeticSequence:1
Too many constants for extrapolation

Solving puzzle 532/732: ArithmeticSequence:2
sat_func def sat(x: List[int], a=-70138, s=4868, e=498910):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=-wrap_int(70138), s=wrap_int(4868), e=wrap_int(498910)):
    return (x[wrap_int(0)] == a).__and__(x[-wrap_int(1)] <= e).__and__(x[-wrap_int(1)] + s > e).__and__(all([x[i] + s == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (and (= (list.get.int x 0) -70138) (<= (list.get.int x -1) 498910)) (> (+ (list.get.int x -1) 4868) 498910)) (= (+ (list.get.int x i_0) 4868) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ArithmeticSequence:2
Too many constants for extrapolation

Solving puzzle 533/732: ArithmeticSequence:3
sat_func def sat(x: List[int], a=55980, s=7402, e=155818):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=wrap_int(55980), s=wrap_int(7402), e=wrap_int(155818)):
    return (x[wrap_int(0)] == a).__and__(x[-wrap_int(1)] <= e).__and__(x[-wrap_int(1)] + s > e).__and__(all([x[i] + s == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (and (= (list.get.int x 0) 55980) (<= (list.get.int x -1) 155818)) (> (+ (list.get.int x -1) 7402) 155818)) (= (+ (list.get.int x i_0) 7402) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ArithmeticSequence:3
Too many constants for extrapolation

Solving puzzle 534/732: ArithmeticSequence:4
sat_func def sat(x: List[int], a=-44635, s=5046, e=503563):
    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=-wrap_int(44635), s=wrap_int(5046), e=wrap_int(503563)):
    return (x[wrap_int(0)] == a).__and__(x[-wrap_int(1)] <= e).__and__(x[-wrap_int(1)] + s > e).__and__(all([x[i] + s == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (and (= (list.get.int x 0) -44635) (<= (list.get.int x -1) 503563)) (> (+ (list.get.int x -1) 5046) 503563)) (= (+ (list.get.int x i_0) 5046) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ArithmeticSequence:4
Too many constants for extrapolation

Solving puzzle 535/732: GeometricSequence:0
sat_func def sat(x: List[int], a=8, r=2, l=50):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=wrap_int(8), r=wrap_int(2), l=wrap_int(50)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) 8) (= (list.length.int x) 50)) (= (* (list.get.int x i_0) 2) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:0
Too many constants for extrapolation

Solving puzzle 536/732: GeometricSequence:1
sat_func def sat(x: List[int], a=-484, r=4, l=589):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=-wrap_int(484), r=wrap_int(4), l=wrap_int(589)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) -484) (= (list.length.int x) 589)) (= (* (list.get.int x i_0) 4) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:1
Two large constants for extrapolation
Solving simpler variation replaced 484 with 3 and 589 with 5
sat_func def sat(x: List[int], a=-3, r=4, l=5):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=-wrap_int(3), r=wrap_int(4), l=wrap_int(5)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) -3) (= (list.length.int x) 5)) (= (* (list.get.int x i_0) 4) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:1

Solving puzzle 537/732: GeometricSequence:2
sat_func def sat(x: List[int], a=889, r=7, l=393):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=wrap_int(889), r=wrap_int(7), l=wrap_int(393)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) 889) (= (list.length.int x) 393)) (= (* (list.get.int x i_0) 7) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:2
Two large constants for extrapolation
Solving simpler variation replaced 393 with 3 and 889 with 5
sat_func def sat(x: List[int], a=5, r=7, l=3):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=wrap_int(5), r=wrap_int(7), l=wrap_int(3)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) 5) (= (list.length.int x) 3)) (= (* (list.get.int x i_0) 7) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:2

Solving puzzle 538/732: GeometricSequence:3
sat_func def sat(x: List[int], a=-777, r=4, l=103):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=-wrap_int(777), r=wrap_int(4), l=wrap_int(103)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) -777) (= (list.length.int x) 103)) (= (* (list.get.int x i_0) 4) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:3
Two large constants for extrapolation
Solving simpler variation replaced 103 with 3 and 777 with 5
sat_func def sat(x: List[int], a=-5, r=4, l=3):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=-wrap_int(5), r=wrap_int(4), l=wrap_int(3)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) -5) (= (list.length.int x) 3)) (= (* (list.get.int x i_0) 4) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:3

Solving puzzle 539/732: GeometricSequence:4
sat_func def sat(x: List[int], a=-736, r=4, l=92):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=-wrap_int(736), r=wrap_int(4), l=wrap_int(92)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) -736) (= (list.length.int x) 92)) (= (* (list.get.int x i_0) 4) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:4
One large constant for extrapolation
Solving simpler variation replaced 736 with 3
sat_func def sat(x: List[int], a=-3, r=4, l=92):
    return x[0] == a and len(x) == l and all([x[i] * r == x[i + 1] for i in range(len(x) - 1)])
modified_func def sat(x: List[int], a=-wrap_int(3), r=wrap_int(4), l=wrap_int(92)):
    return (x[wrap_int(0)] == a).__and__(sym_len(x) == l).__and__(all([x[i] * r == x[i + wrap_int(1)] for i in sym_range(sym_len(x) - 1)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (and (and (= (list.get.int x 0) -3) (= (list.length.int x) 92)) (= (* (list.get.int x i_0) 4) (list.get.int x (+ i_0 1)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GeometricSequence:4

Solving puzzle 540/732: LineIntersection:0
sat_func def sat(e: List[int], a=2, b=-1, c=1, d=2021):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
modified_func def sat(e: List[int], a=wrap_int(2), b=-wrap_int(1), c=wrap_int(1), d=wrap_int(2021)):
    x = e[wrap_int(0)] / e[wrap_int(1)]
    return abs(a * x + b - c * x - d) < wrap_int(10) ** (-wrap_int(5))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (ite (>= (- (- (+ (* 2 (/ (list.get.int x 0) (list.get.int x 1))) -1) (* 1 (/ (list.get.int x 0) (list.get.int x 1)))) 2021) 0) (- (- (+ (* 2 (/ (list.get.int x 0) (list.get.int x 1))) -1) (* 1 (/ (list.get.int x 0) (list.get.int x 1)))) 2021) (- (- (- (+ (* 2 (/ (list.get.int x 0) (list.get.int x 1))) -1) (* 1 (/ (list.get.int x 0) (list.get.int x 1)))) 2021))) 9765625))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle LineIntersection:0
One large constant for extrapolation
Solving simpler variation replaced 2021 with 3
sat_func def sat(e: List[int], a=2, b=-1, c=1, d=3):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
modified_func def sat(e: List[int], a=wrap_int(2), b=-wrap_int(1), c=wrap_int(1), d=wrap_int(3)):
    x = e[wrap_int(0)] / e[wrap_int(1)]
    return abs(a * x + b - c * x - d) < wrap_int(10) ** (-wrap_int(5))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (ite (>= (- (- (+ (* 2 (/ (list.get.int x 0) (list.get.int x 1))) -1) (* 1 (/ (list.get.int x 0) (list.get.int x 1)))) 3) 0) (- (- (+ (* 2 (/ (list.get.int x 0) (list.get.int x 1))) -1) (* 1 (/ (list.get.int x 0) (list.get.int x 1)))) 3) (- (- (- (+ (* 2 (/ (list.get.int x 0) (list.get.int x 1))) -1) (* 1 (/ (list.get.int x 0) (list.get.int x 1)))) 3))) 9765625))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle LineIntersection:0

Solving puzzle 541/732: LineIntersection:1
sat_func def sat(e: List[int], a=-77698407, b=-31793716, c=-10799659, d=89278024):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
modified_func def sat(e: List[int], a=-wrap_int(77698407), b=-wrap_int(31793716), c=-wrap_int(10799659), d=wrap_int(89278024)):
    x = e[wrap_int(0)] / e[wrap_int(1)]
    return abs(a * x + b - c * x - d) < wrap_int(10) ** (-wrap_int(5))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (ite (>= (- (- (+ (* -77698407 (/ (list.get.int x 0) (list.get.int x 1))) -31793716) (* -10799659 (/ (list.get.int x 0) (list.get.int x 1)))) 89278024) 0) (- (- (+ (* -77698407 (/ (list.get.int x 0) (list.get.int x 1))) -31793716) (* -10799659 (/ (list.get.int x 0) (list.get.int x 1)))) 89278024) (- (- (- (+ (* -77698407 (/ (list.get.int x 0) (list.get.int x 1))) -31793716) (* -10799659 (/ (list.get.int x 0) (list.get.int x 1)))) 89278024))) 9765625))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle LineIntersection:1
Too many constants for extrapolation

Solving puzzle 542/732: LineIntersection:2
sat_func def sat(e: List[int], a=89600582, b=-47657198, c=95101265, d=-52126265):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
modified_func def sat(e: List[int], a=wrap_int(89600582), b=-wrap_int(47657198), c=wrap_int(95101265), d=-wrap_int(52126265)):
    x = e[wrap_int(0)] / e[wrap_int(1)]
    return abs(a * x + b - c * x - d) < wrap_int(10) ** (-wrap_int(5))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (ite (>= (- (- (+ (* 89600582 (/ (list.get.int x 0) (list.get.int x 1))) -47657198) (* 95101265 (/ (list.get.int x 0) (list.get.int x 1)))) -52126265) 0) (- (- (+ (* 89600582 (/ (list.get.int x 0) (list.get.int x 1))) -47657198) (* 95101265 (/ (list.get.int x 0) (list.get.int x 1)))) -52126265) (- (- (- (+ (* 89600582 (/ (list.get.int x 0) (list.get.int x 1))) -47657198) (* 95101265 (/ (list.get.int x 0) (list.get.int x 1)))) -52126265))) 9765625))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle LineIntersection:2
Too many constants for extrapolation

Solving puzzle 543/732: LineIntersection:3
sat_func def sat(e: List[int], a=-11422303, b=-57150416, c=-59162339, d=-37428439):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
modified_func def sat(e: List[int], a=-wrap_int(11422303), b=-wrap_int(57150416), c=-wrap_int(59162339), d=-wrap_int(37428439)):
    x = e[wrap_int(0)] / e[wrap_int(1)]
    return abs(a * x + b - c * x - d) < wrap_int(10) ** (-wrap_int(5))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (ite (>= (- (- (+ (* -11422303 (/ (list.get.int x 0) (list.get.int x 1))) -57150416) (* -59162339 (/ (list.get.int x 0) (list.get.int x 1)))) -37428439) 0) (- (- (+ (* -11422303 (/ (list.get.int x 0) (list.get.int x 1))) -57150416) (* -59162339 (/ (list.get.int x 0) (list.get.int x 1)))) -37428439) (- (- (- (+ (* -11422303 (/ (list.get.int x 0) (list.get.int x 1))) -57150416) (* -59162339 (/ (list.get.int x 0) (list.get.int x 1)))) -37428439))) 9765625))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle LineIntersection:3
Too many constants for extrapolation

Solving puzzle 544/732: LineIntersection:4
sat_func def sat(e: List[int], a=-18517001, b=-13662763, c=-11156613, d=9271005):
    x = e[0] / e[1]
    return abs(a * x + b - c * x - d) < 10 ** -5
modified_func def sat(e: List[int], a=-wrap_int(18517001), b=-wrap_int(13662763), c=-wrap_int(11156613), d=wrap_int(9271005)):
    x = e[wrap_int(0)] / e[wrap_int(1)]
    return abs(a * x + b - c * x - d) < wrap_int(10) ** (-wrap_int(5))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (< (ite (>= (- (- (+ (* -18517001 (/ (list.get.int x 0) (list.get.int x 1))) -13662763) (* -11156613 (/ (list.get.int x 0) (list.get.int x 1)))) 9271005) 0) (- (- (+ (* -18517001 (/ (list.get.int x 0) (list.get.int x 1))) -13662763) (* -11156613 (/ (list.get.int x 0) (list.get.int x 1)))) 9271005) (- (- (- (+ (* -18517001 (/ (list.get.int x 0) (list.get.int x 1))) -13662763) (* -11156613 (/ (list.get.int x 0) (list.get.int x 1)))) 9271005))) 9765625))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle LineIntersection:4
Too many constants for extrapolation

Solving puzzle 545/732: ListPosSum:0
sat_func def sat(x: List[int], n=5, s=19):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(5), s=wrap_int(19)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_624 Int)) (=> (and (>= list_pos_624 0) (< list_pos_624 (list.length.int x))) (forall ((list_pos_623 Int)) (=> (and (>= list_pos_623 0) (< list_pos_623 (list.length.int x))) (and (and (= (list.length.int x) 5) (= (+ (list.get.int x list_pos_623) 0) 19)) (> (list.get.int x list_pos_624) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:0
Too many constants for extrapolation

Solving puzzle 546/732: ListPosSum:1
sat_func def sat(x: List[int], n=6241, s=54594969):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(6241), s=wrap_int(54594969)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_626 Int)) (=> (and (>= list_pos_626 0) (< list_pos_626 (list.length.int x))) (forall ((list_pos_625 Int)) (=> (and (>= list_pos_625 0) (< list_pos_625 (list.length.int x))) (and (and (= (list.length.int x) 6241) (= (+ (list.get.int x list_pos_625) 0) 54594969)) (> (list.get.int x list_pos_626) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:1
Two large constants for extrapolation
Solving simpler variation replaced 54594969 with 3 and 6241 with 5
sat_func def sat(x: List[int], n=5, s=3):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(5), s=wrap_int(3)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_628 Int)) (=> (and (>= list_pos_628 0) (< list_pos_628 (list.length.int x))) (forall ((list_pos_627 Int)) (=> (and (>= list_pos_627 0) (< list_pos_627 (list.length.int x))) (and (and (= (list.length.int x) 5) (= (+ (list.get.int x list_pos_627) 0) 3)) (> (list.get.int x list_pos_628) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:1

Solving puzzle 547/732: ListPosSum:2
sat_func def sat(x: List[int], n=8427, s=33081884):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(8427), s=wrap_int(33081884)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_630 Int)) (=> (and (>= list_pos_630 0) (< list_pos_630 (list.length.int x))) (forall ((list_pos_629 Int)) (=> (and (>= list_pos_629 0) (< list_pos_629 (list.length.int x))) (and (and (= (list.length.int x) 8427) (= (+ (list.get.int x list_pos_629) 0) 33081884)) (> (list.get.int x list_pos_630) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:2
Two large constants for extrapolation
Solving simpler variation replaced 33081884 with 3 and 8427 with 5
sat_func def sat(x: List[int], n=5, s=3):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(5), s=wrap_int(3)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_632 Int)) (=> (and (>= list_pos_632 0) (< list_pos_632 (list.length.int x))) (forall ((list_pos_631 Int)) (=> (and (>= list_pos_631 0) (< list_pos_631 (list.length.int x))) (and (and (= (list.length.int x) 5) (= (+ (list.get.int x list_pos_631) 0) 3)) (> (list.get.int x list_pos_632) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:2

Solving puzzle 548/732: ListPosSum:3
sat_func def sat(x: List[int], n=3363, s=67595319):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(3363), s=wrap_int(67595319)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_634 Int)) (=> (and (>= list_pos_634 0) (< list_pos_634 (list.length.int x))) (forall ((list_pos_633 Int)) (=> (and (>= list_pos_633 0) (< list_pos_633 (list.length.int x))) (and (and (= (list.length.int x) 3363) (= (+ (list.get.int x list_pos_633) 0) 67595319)) (> (list.get.int x list_pos_634) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:3
Two large constants for extrapolation
Solving simpler variation replaced 3363 with 3 and 67595319 with 5
sat_func def sat(x: List[int], n=3, s=5):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(3), s=wrap_int(5)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_636 Int)) (=> (and (>= list_pos_636 0) (< list_pos_636 (list.length.int x))) (forall ((list_pos_635 Int)) (=> (and (>= list_pos_635 0) (< list_pos_635 (list.length.int x))) (and (and (= (list.length.int x) 3) (= (+ (list.get.int x list_pos_635) 0) 5)) (> (list.get.int x list_pos_636) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:3

Solving puzzle 549/732: ListPosSum:4
sat_func def sat(x: List[int], n=9909, s=88140438):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(9909), s=wrap_int(88140438)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_638 Int)) (=> (and (>= list_pos_638 0) (< list_pos_638 (list.length.int x))) (forall ((list_pos_637 Int)) (=> (and (>= list_pos_637 0) (< list_pos_637 (list.length.int x))) (and (and (= (list.length.int x) 9909) (= (+ (list.get.int x list_pos_637) 0) 88140438)) (> (list.get.int x list_pos_638) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:4
Two large constants for extrapolation
Solving simpler variation replaced 88140438 with 3 and 9909 with 5
sat_func def sat(x: List[int], n=5, s=3):
    return len(x) == n and sum(x) == s and all([a > 0 for a in x])
modified_func def sat(x: List[int], n=wrap_int(5), s=wrap_int(3)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(all([a > wrap_int(0) for a in x]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_640 Int)) (=> (and (>= list_pos_640 0) (< list_pos_640 (list.length.int x))) (forall ((list_pos_639 Int)) (=> (and (>= list_pos_639 0) (< list_pos_639 (list.length.int x))) (and (and (= (list.length.int x) 5) (= (+ (list.get.int x list_pos_639) 0) 3)) (> (list.get.int x list_pos_640) 0)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListPosSum:4

Solving puzzle 550/732: ListDistinctSum:0
sat_func def sat(x: List[int], n=4, s=2021):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(4), s=wrap_int(2021)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_642 Int)) (=> (and (>= list_pos_642 0) (< list_pos_642 (list.length.int x))) (forall ((list_pos_641 Int)) (=> (and (>= list_pos_641 0) (< list_pos_641 (list.length.int x))) (and (and (= (list.length.int x) 4) (= (+ (list.get.int x list_pos_641) 0) 2021)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:0
One large constant for extrapolation
Solving simpler variation replaced 2021 with 3
sat_func def sat(x: List[int], n=4, s=3):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(4), s=wrap_int(3)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_644 Int)) (=> (and (>= list_pos_644 0) (< list_pos_644 (list.length.int x))) (forall ((list_pos_643 Int)) (=> (and (>= list_pos_643 0) (< list_pos_643 (list.length.int x))) (and (and (= (list.length.int x) 4) (= (+ (list.get.int x list_pos_643) 0) 3)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:0

Solving puzzle 551/732: ListDistinctSum:1
sat_func def sat(x: List[int], n=124, s=2603089):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(124), s=wrap_int(2603089)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_646 Int)) (=> (and (>= list_pos_646 0) (< list_pos_646 (list.length.int x))) (forall ((list_pos_645 Int)) (=> (and (>= list_pos_645 0) (< list_pos_645 (list.length.int x))) (and (and (= (list.length.int x) 124) (= (+ (list.get.int x list_pos_645) 0) 2603089)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:1
Two large constants for extrapolation
Solving simpler variation replaced 124 with 3 and 2603089 with 5
sat_func def sat(x: List[int], n=3, s=5):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(3), s=wrap_int(5)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_648 Int)) (=> (and (>= list_pos_648 0) (< list_pos_648 (list.length.int x))) (forall ((list_pos_647 Int)) (=> (and (>= list_pos_647 0) (< list_pos_647 (list.length.int x))) (and (and (= (list.length.int x) 3) (= (+ (list.get.int x list_pos_647) 0) 5)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:1

Solving puzzle 552/732: ListDistinctSum:2
sat_func def sat(x: List[int], n=823, s=8609609):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(823), s=wrap_int(8609609)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_650 Int)) (=> (and (>= list_pos_650 0) (< list_pos_650 (list.length.int x))) (forall ((list_pos_649 Int)) (=> (and (>= list_pos_649 0) (< list_pos_649 (list.length.int x))) (and (and (= (list.length.int x) 823) (= (+ (list.get.int x list_pos_649) 0) 8609609)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:2
Two large constants for extrapolation
Solving simpler variation replaced 823 with 3 and 8609609 with 5
sat_func def sat(x: List[int], n=3, s=5):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(3), s=wrap_int(5)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_652 Int)) (=> (and (>= list_pos_652 0) (< list_pos_652 (list.length.int x))) (forall ((list_pos_651 Int)) (=> (and (>= list_pos_651 0) (< list_pos_651 (list.length.int x))) (and (and (= (list.length.int x) 3) (= (+ (list.get.int x list_pos_651) 0) 5)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:2

Solving puzzle 553/732: ListDistinctSum:3
sat_func def sat(x: List[int], n=796, s=86694751):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(796), s=wrap_int(86694751)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_654 Int)) (=> (and (>= list_pos_654 0) (< list_pos_654 (list.length.int x))) (forall ((list_pos_653 Int)) (=> (and (>= list_pos_653 0) (< list_pos_653 (list.length.int x))) (and (and (= (list.length.int x) 796) (= (+ (list.get.int x list_pos_653) 0) 86694751)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:3
Two large constants for extrapolation
Solving simpler variation replaced 796 with 3 and 86694751 with 5
sat_func def sat(x: List[int], n=3, s=5):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(3), s=wrap_int(5)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_656 Int)) (=> (and (>= list_pos_656 0) (< list_pos_656 (list.length.int x))) (forall ((list_pos_655 Int)) (=> (and (>= list_pos_655 0) (< list_pos_655 (list.length.int x))) (and (and (= (list.length.int x) 3) (= (+ (list.get.int x list_pos_655) 0) 5)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:3

Solving puzzle 554/732: ListDistinctSum:4
sat_func def sat(x: List[int], n=225, s=38417364):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(225), s=wrap_int(38417364)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_658 Int)) (=> (and (>= list_pos_658 0) (< list_pos_658 (list.length.int x))) (forall ((list_pos_657 Int)) (=> (and (>= list_pos_657 0) (< list_pos_657 (list.length.int x))) (and (and (= (list.length.int x) 225) (= (+ (list.get.int x list_pos_657) 0) 38417364)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:4
Two large constants for extrapolation
Solving simpler variation replaced 225 with 3 and 38417364 with 5
sat_func def sat(x: List[int], n=3, s=5):
    return len(x) == n and sum(x) == s and len(set(x)) == n
modified_func def sat(x: List[int], n=wrap_int(3), s=wrap_int(5)):
    return (sym_len(x) == n).__and__(sym_sum(x) == s).__and__(sym_len(set(x)) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_660 Int)) (=> (and (>= list_pos_660 0) (< list_pos_660 (list.length.int x))) (forall ((list_pos_659 Int)) (=> (and (>= list_pos_659 0) (< list_pos_659 (list.length.int x))) (and (and (= (list.length.int x) 3) (= (+ (list.get.int x list_pos_659) 0) 5)) false))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListDistinctSum:4

Solving puzzle 555/732: SublistSum:0
sat_func def sat(x: List[int], t=677, a=43, e=125, s=10):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
modified_func def sat(x: List[int], t=wrap_int(677), a=wrap_int(43), e=wrap_int(125), s=wrap_int(10)):
    non_zero = [z for z in x if z != wrap_int(0)]
    return (t == sym_sum([x[i] for i in sym_range(a, e, s)])).__and__(sym_len(set(non_zero)) == sym_len(non_zero)).__and__(all([x[i] != wrap_int(0) for i in sym_range(a, e, s)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_661 Int)) (=> (and (>= list_pos_661 0) (< list_pos_661 (list.length.int x))) (=> (not (= (list.get.int x list_pos_661) 0)) (and (and (= 677 (+ (+ (+ (+ (+ (+ (+ (+ (+ (list.get.int x 43) 0) (list.get.int x 53)) (list.get.int x 63)) (list.get.int x 73)) (list.get.int x 83)) (list.get.int x 93)) (list.get.int x 103)) (list.get.int x 113)) (list.get.int x 123))) true) (and (and (and (and (and (and (and (and (not (= (list.get.int x 43) 0)) (not (= (list.get.int x 53) 0))) (not (= (list.get.int x 63) 0))) (not (= (list.get.int x 73) 0))) (not (= (list.get.int x 83) 0))) (not (= (list.get.int x 93) 0))) (not (= (list.get.int x 103) 0))) (not (= (list.get.int x 113) 0))) (not (= (list.get.int x 123) 0))))))))
(assert (forall ((list_pos_662 Int)) (=> (and (>= list_pos_662 0) (< list_pos_662 (list.length.int x))) (forall ((list_pos_661 Int)) (=> (and (>= list_pos_661 0) (< list_pos_661 (list.length.int x))) (=> (not (not (= (list.get.int x list_pos_662) 0))) (and (and (= 677 (+ (+ (+ (+ (+ (+ (+ (+ (+ (list.get.int x 43) 0) (list.get.int x 53)) (list.get.int x 63)) (list.get.int x 73)) (list.get.int x 83)) (list.get.int x 93)) (list.get.int x 103)) (list.get.int x 113)) (list.get.int x 123))) true) (and (and (and (and (and (and (and (and (not (= (list.get.int x 43) 0)) (not (= (list.get.int x 53) 0))) (not (= (list.get.int x 63) 0))) (not (= (list.get.int x 73) 0))) (not (= (list.get.int x 83) 0))) (not (= (list.get.int x 93) 0))) (not (= (list.get.int x 103) 0))) (not (= (list.get.int x 113) 0))) (not (= (list.get.int x 123) 0))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle SublistSum:0
Two large constants for extrapolation
Solving simpler variation replaced 125 with 3 and 677 with 5
sat_func def sat(x: List[int], t=5, a=43, e=3, s=10):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
modified_func def sat(x: List[int], t=wrap_int(5), a=wrap_int(43), e=wrap_int(3), s=wrap_int(10)):
    non_zero = [z for z in x if z != wrap_int(0)]
    return (t == sym_sum([x[i] for i in sym_range(a, e, s)])).__and__(sym_len(set(non_zero)) == sym_len(non_zero)).__and__(all([x[i] != wrap_int(0) for i in sym_range(a, e, s)]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_663 Int)) (=> (and (>= list_pos_663 0) (< list_pos_663 (list.length.int x))) (=> (not (= (list.get.int x list_pos_663) 0)) (and (and false true) true)))))
(assert (forall ((list_pos_664 Int)) (=> (and (>= list_pos_664 0) (< list_pos_664 (list.length.int x))) (forall ((list_pos_663 Int)) (=> (and (>= list_pos_663 0) (< list_pos_663 (list.length.int x))) (=> (not (not (= (list.get.int x list_pos_664) 0))) (and (and false true) true)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle SublistSum:0

Solving puzzle 556/732: SublistSum:1
sat_func def sat(x: List[int], t=44475424, a=93, e=8496, s=6):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
modified_func def sat(x: List[int], t=wrap_int(44475424), a=wrap_int(93), e=wrap_int(8496), s=wrap_int(6)):
    non_zero = [z for z in x if z != wrap_int(0)]
    return (t == sym_sum([x[i] for i in sym_range(a, e, s)])).__and__(sym_len(set(non_zero)) == sym_len(non_zero)).__and__(all([x[i] != wrap_int(0) for i in sym_range(a, e, s)]))
Exception -- for puzzle SublistSum:1 maximum recursion depth exceeded

Solving puzzle 557/732: SublistSum:2
sat_func def sat(x: List[int], t=2183536, a=36, e=8450, s=1):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
modified_func def sat(x: List[int], t=wrap_int(2183536), a=wrap_int(36), e=wrap_int(8450), s=wrap_int(1)):
    non_zero = [z for z in x if z != wrap_int(0)]
    return (t == sym_sum([x[i] for i in sym_range(a, e, s)])).__and__(sym_len(set(non_zero)) == sym_len(non_zero)).__and__(all([x[i] != wrap_int(0) for i in sym_range(a, e, s)]))
Exception -- for puzzle SublistSum:2 maximum recursion depth exceeded

Solving puzzle 558/732: SublistSum:3
sat_func def sat(x: List[int], t=1196610, a=15, e=4376, s=3):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
modified_func def sat(x: List[int], t=wrap_int(1196610), a=wrap_int(15), e=wrap_int(4376), s=wrap_int(3)):
    non_zero = [z for z in x if z != wrap_int(0)]
    return (t == sym_sum([x[i] for i in sym_range(a, e, s)])).__and__(sym_len(set(non_zero)) == sym_len(non_zero)).__and__(all([x[i] != wrap_int(0) for i in sym_range(a, e, s)]))
Exception -- for puzzle SublistSum:3 maximum recursion depth exceeded

Solving puzzle 559/732: SublistSum:4
sat_func def sat(x: List[int], t=6165697, a=47, e=3830, s=2):
    non_zero = [z for z in x if z != 0]
    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(
        [x[i] != 0 for i in range(a, e, s)])
modified_func def sat(x: List[int], t=wrap_int(6165697), a=wrap_int(47), e=wrap_int(3830), s=wrap_int(2)):
    non_zero = [z for z in x if z != wrap_int(0)]
    return (t == sym_sum([x[i] for i in sym_range(a, e, s)])).__and__(sym_len(set(non_zero)) == sym_len(non_zero)).__and__(all([x[i] != wrap_int(0) for i in sym_range(a, e, s)]))
Exception -- for puzzle SublistSum:4 maximum recursion depth exceeded

Solving puzzle 560/732: CumulativeSum:0
sat_func def sat(x: List[int], t=50, n=10):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
modified_func def sat(x: List[int], t=wrap_int(50), n=wrap_int(10)):
    _assert(all([v > wrap_int(0) for v in x]))
    s = wrap_int(0)
    i = wrap_int(0)
    for v in sym_sorted(x):
        s += v
        if s > t:
            return i == n
        i += wrap_int(1)
    return i == n
Exception -- for puzzle CumulativeSum:0 Cannot convert symbolic integer to index

Solving puzzle 561/732: CumulativeSum:1
sat_func def sat(x: List[int], t=364928431, n=1088):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
modified_func def sat(x: List[int], t=wrap_int(364928431), n=wrap_int(1088)):
    _assert(all([v > wrap_int(0) for v in x]))
    s = wrap_int(0)
    i = wrap_int(0)
    for v in sym_sorted(x):
        s += v
        if s > t:
            return i == n
        i += wrap_int(1)
    return i == n
Exception -- for puzzle CumulativeSum:1 Cannot convert symbolic integer to index

Solving puzzle 562/732: CumulativeSum:2
sat_func def sat(x: List[int], t=7978940451, n=5932):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
modified_func def sat(x: List[int], t=wrap_int(7978940451), n=wrap_int(5932)):
    _assert(all([v > wrap_int(0) for v in x]))
    s = wrap_int(0)
    i = wrap_int(0)
    for v in sym_sorted(x):
        s += v
        if s > t:
            return i == n
        i += wrap_int(1)
    return i == n
Exception -- for puzzle CumulativeSum:2 Cannot convert symbolic integer to index

Solving puzzle 563/732: CumulativeSum:3
sat_func def sat(x: List[int], t=4545622399, n=1009):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
modified_func def sat(x: List[int], t=wrap_int(4545622399), n=wrap_int(1009)):
    _assert(all([v > wrap_int(0) for v in x]))
    s = wrap_int(0)
    i = wrap_int(0)
    for v in sym_sorted(x):
        s += v
        if s > t:
            return i == n
        i += wrap_int(1)
    return i == n
Exception -- for puzzle CumulativeSum:3 Cannot convert symbolic integer to index

Solving puzzle 564/732: CumulativeSum:4
sat_func def sat(x: List[int], t=4917027557, n=4815):
    assert all([v > 0 for v in x])
    s = 0
    i = 0
    for v in sorted(x):
        s += v
        if s > t:
            return i == n
        i += 1
    return i == n
modified_func def sat(x: List[int], t=wrap_int(4917027557), n=wrap_int(4815)):
    _assert(all([v > wrap_int(0) for v in x]))
    s = wrap_int(0)
    i = wrap_int(0)
    for v in sym_sorted(x):
        s += v
        if s > t:
            return i == n
        i += wrap_int(1)
    return i == n
Exception -- for puzzle CumulativeSum:4 Cannot convert symbolic integer to index

Solving puzzle 565/732: EngineerNumbers:0
sat_func def sat(ls: List[str], n=100, a="bar", b="foo"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
modified_func def sat(ls: List[str], n=wrap_int(100), a=wrap_str('bar'), b=wrap_str('foo')):
    return (sym_len(ls) == sym_len(set(ls))).__and__(sym_len(set(ls)) == n).__and__(ls[wrap_int(0)] == a).__and__(ls[-wrap_int(1)] == b).__and__(ls == sym_sorted(ls))
Exception -- for puzzle EngineerNumbers:0 Symbolic hash not yet implemented

Solving puzzle 566/732: EngineerNumbers:1
sat_func def sat(ls: List[str], n=44, a="lychezothotextocev", b="th"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
modified_func def sat(ls: List[str], n=wrap_int(44), a=wrap_str('lychezothotextocev'), b=wrap_str('th')):
    return (sym_len(ls) == sym_len(set(ls))).__and__(sym_len(set(ls)) == n).__and__(ls[wrap_int(0)] == a).__and__(ls[-wrap_int(1)] == b).__and__(ls == sym_sorted(ls))
Exception -- for puzzle EngineerNumbers:1 Symbolic hash not yet implemented

Solving puzzle 567/732: EngineerNumbers:2
sat_func def sat(ls: List[str], n=13, a="kacukebyhapuniryh", b="te"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
modified_func def sat(ls: List[str], n=wrap_int(13), a=wrap_str('kacukebyhapuniryh'), b=wrap_str('te')):
    return (sym_len(ls) == sym_len(set(ls))).__and__(sym_len(set(ls)) == n).__and__(ls[wrap_int(0)] == a).__and__(ls[-wrap_int(1)] == b).__and__(ls == sym_sorted(ls))
Exception -- for puzzle EngineerNumbers:2 Symbolic hash not yet implemented

Solving puzzle 568/732: EngineerNumbers:3
sat_func def sat(ls: List[str], n=61, a="cisoceratext", b="milusicochylitextyco"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
modified_func def sat(ls: List[str], n=wrap_int(61), a=wrap_str('cisoceratext'), b=wrap_str('milusicochylitextyco')):
    return (sym_len(ls) == sym_len(set(ls))).__and__(sym_len(set(ls)) == n).__and__(ls[wrap_int(0)] == a).__and__(ls[-wrap_int(1)] == b).__and__(ls == sym_sorted(ls))
Exception -- for puzzle EngineerNumbers:3 Symbolic hash not yet implemented

Solving puzzle 569/732: EngineerNumbers:4
sat_func def sat(ls: List[str], n=59, a="hokitextawelaxah", b="maryhedu"):
    return len(ls) == len(set(ls)) == n and ls[0] == a and ls[-1] == b and ls == sorted(ls)
modified_func def sat(ls: List[str], n=wrap_int(59), a=wrap_str('hokitextawelaxah'), b=wrap_str('maryhedu')):
    return (sym_len(ls) == sym_len(set(ls))).__and__(sym_len(set(ls)) == n).__and__(ls[wrap_int(0)] == a).__and__(ls[-wrap_int(1)] == b).__and__(ls == sym_sorted(ls))
Exception -- for puzzle EngineerNumbers:4 Symbolic hash not yet implemented

Solving puzzle 570/732: LZW:0
sat_func def sat(seq: List[int], compressed_len=17, text="Hellooooooooooooooooooooo world!"):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
modified_func def sat(seq: List[int], compressed_len=wrap_int(17), text=wrap_str('Hellooooooooooooooooooooo world!')):
    index = [sym_chr(i) for i in sym_range(256)]
    pieces = wrap_list([wrap_str('')])
    for i in seq:
        pieces.append(pieces[-wrap_int(1)] + pieces[-wrap_int(1)][wrap_int(0)] if i == sym_len(index) else index[i])
        index.append(pieces[-wrap_int(2)] + pieces[-wrap_int(1)][wrap_int(0)])
    return (wrap_str('').join(pieces) == text).__and__(sym_len(seq) <= compressed_len)
Exception -- for puzzle LZW:0 'SymbolicList' object has no attribute 'append'

Solving puzzle 571/732: LZW:1
sat_func def sat(seq: List[int], compressed_len=0, text=""):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
modified_func def sat(seq: List[int], compressed_len=wrap_int(0), text=wrap_str('')):
    index = [sym_chr(i) for i in sym_range(256)]
    pieces = wrap_list([wrap_str('')])
    for i in seq:
        pieces.append(pieces[-wrap_int(1)] + pieces[-wrap_int(1)][wrap_int(0)] if i == sym_len(index) else index[i])
        index.append(pieces[-wrap_int(2)] + pieces[-wrap_int(1)][wrap_int(0)])
    return (wrap_str('').join(pieces) == text).__and__(sym_len(seq) <= compressed_len)
Exception -- for puzzle LZW:1 'SymbolicList' object has no attribute 'append'

Solving puzzle 572/732: LZW:2
sat_func def sat(seq: List[int], compressed_len=45, text="cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
modified_func def sat(seq: List[int], compressed_len=wrap_int(45), text=wrap_str('cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc')):
    index = [sym_chr(i) for i in sym_range(256)]
    pieces = wrap_list([wrap_str('')])
    for i in seq:
        pieces.append(pieces[-wrap_int(1)] + pieces[-wrap_int(1)][wrap_int(0)] if i == sym_len(index) else index[i])
        index.append(pieces[-wrap_int(2)] + pieces[-wrap_int(1)][wrap_int(0)])
    return (wrap_str('').join(pieces) == text).__and__(sym_len(seq) <= compressed_len)
Exception -- for puzzle LZW:2 'SymbolicList' object has no attribute 'append'

Solving puzzle 573/732: LZW:3
sat_func def sat(seq: List[int], compressed_len=154, text="cupewoquabipemecacichytogycykythyzydizutextojokosapysetextethilabequypagichichimipyhuquithyzuwukychycokigomylotextoquochachikalocejiwyzagodothilythetiquypirabafusubasufylejulitudosisyrahezitextoluquevy"):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
modified_func def sat(seq: List[int], compressed_len=wrap_int(154), text=wrap_str('cupewoquabipemecacichytogycykythyzydizutextojokosapysetextethilabequypagichichimipyhuquithyzuwukychycokigomylotextoquochachikalocejiwyzagodothilythetiquypirabafusubasufylejulitudosisyrahezitextoluquevy')):
    index = [sym_chr(i) for i in sym_range(256)]
    pieces = wrap_list([wrap_str('')])
    for i in seq:
        pieces.append(pieces[-wrap_int(1)] + pieces[-wrap_int(1)][wrap_int(0)] if i == sym_len(index) else index[i])
        index.append(pieces[-wrap_int(2)] + pieces[-wrap_int(1)][wrap_int(0)])
    return (wrap_str('').join(pieces) == text).__and__(sym_len(seq) <= compressed_len)
Exception -- for puzzle LZW:3 'SymbolicList' object has no attribute 'append'

Solving puzzle 574/732: LZW:4
sat_func def sat(seq: List[int], compressed_len=2, text="si"):
    index = [chr(i) for i in range(256)]
    pieces = [""]
    for i in seq:
        pieces.append((pieces[-1] + pieces[-1][0]) if i == len(index) else index[i])
        index.append(pieces[-2] + pieces[-1][0])
    return "".join(pieces) == text and len(seq) <= compressed_len
modified_func def sat(seq: List[int], compressed_len=wrap_int(2), text=wrap_str('si')):
    index = [sym_chr(i) for i in sym_range(256)]
    pieces = wrap_list([wrap_str('')])
    for i in seq:
        pieces.append(pieces[-wrap_int(1)] + pieces[-wrap_int(1)][wrap_int(0)] if i == sym_len(index) else index[i])
        index.append(pieces[-wrap_int(2)] + pieces[-wrap_int(1)][wrap_int(0)])
    return (wrap_str('').join(pieces) == text).__and__(sym_len(seq) <= compressed_len)
Exception -- for puzzle LZW:4 'SymbolicList' object has no attribute 'append'

Solving puzzle 575/732: PackingHam:0
sat_func def sat(words: List[str], num=100, bits=100, dist=34):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
modified_func def sat(words: List[str], num=wrap_int(100), bits=wrap_int(100), dist=wrap_int(34)):
    _assert((sym_len(words) == num).__and__(all(sym_generator(((sym_len(word) == bits).__and__(set(word) <= {wrap_str('0'), wrap_str('1')}) for word in words)))))
    return all(sym_generator((sym_sum([a != b for a, b in sym_zip(words[i], words[j])]) >= dist for i in sym_range(num) for j in sym_range(i))))
Exception -- for puzzle PackingHam:0 Symbolic hash not yet implemented

Solving puzzle 576/732: PackingHam:1
sat_func def sat(words: List[str], num=5, bits=81, dist=30):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
modified_func def sat(words: List[str], num=wrap_int(5), bits=wrap_int(81), dist=wrap_int(30)):
    _assert((sym_len(words) == num).__and__(all(sym_generator(((sym_len(word) == bits).__and__(set(word) <= {wrap_str('0'), wrap_str('1')}) for word in words)))))
    return all(sym_generator((sym_sum([a != b for a, b in sym_zip(words[i], words[j])]) >= dist for i in sym_range(num) for j in sym_range(i))))
Exception -- for puzzle PackingHam:1 Symbolic hash not yet implemented

Solving puzzle 577/732: PackingHam:2
sat_func def sat(words: List[str], num=78, bits=64, dist=16):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
modified_func def sat(words: List[str], num=wrap_int(78), bits=wrap_int(64), dist=wrap_int(16)):
    _assert((sym_len(words) == num).__and__(all(sym_generator(((sym_len(word) == bits).__and__(set(word) <= {wrap_str('0'), wrap_str('1')}) for word in words)))))
    return all(sym_generator((sym_sum([a != b for a, b in sym_zip(words[i], words[j])]) >= dist for i in sym_range(num) for j in sym_range(i))))
Exception -- for puzzle PackingHam:2 Symbolic hash not yet implemented

Solving puzzle 578/732: PackingHam:3
sat_func def sat(words: List[str], num=28, bits=11, dist=1):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
modified_func def sat(words: List[str], num=wrap_int(28), bits=wrap_int(11), dist=wrap_int(1)):
    _assert((sym_len(words) == num).__and__(all(sym_generator(((sym_len(word) == bits).__and__(set(word) <= {wrap_str('0'), wrap_str('1')}) for word in words)))))
    return all(sym_generator((sym_sum([a != b for a, b in sym_zip(words[i], words[j])]) >= dist for i in sym_range(num) for j in sym_range(i))))
Exception -- for puzzle PackingHam:3 Symbolic hash not yet implemented

Solving puzzle 579/732: PackingHam:4
sat_func def sat(words: List[str], num=8, bits=75, dist=24):
    assert len(words) == num and all(len(word) == bits and set(word) <= {"0", "1"} for word in words)
    return all(sum([a != b for a, b in zip(words[i], words[j])]) >= dist for i in range(num) for j in range(i))
modified_func def sat(words: List[str], num=wrap_int(8), bits=wrap_int(75), dist=wrap_int(24)):
    _assert((sym_len(words) == num).__and__(all(sym_generator(((sym_len(word) == bits).__and__(set(word) <= {wrap_str('0'), wrap_str('1')}) for word in words)))))
    return all(sym_generator((sym_sum([a != b for a, b in sym_zip(words[i], words[j])]) >= dist for i in sym_range(num) for j in sym_range(i))))
Exception -- for puzzle PackingHam:4 Symbolic hash not yet implemented

Solving puzzle 580/732: Mastermind:0
sat_func def sat(transcripts: List[str], max_moves=10):
    COLORS = "ABCDEF"

    def helper(secret: str, transcript=""):
        if transcript.count("\n") == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        assert all(g in COLORS for g in guess)
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return helper(secret, transcript + f"{guess} {sum(perfect.values())}{almost}\n")

    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)
modified_func def sat(transcripts: List[str], max_moves=wrap_int(10)):
    COLORS = wrap_str('ABCDEF')

    def helper(secret: str, transcript=wrap_str('')):
        if transcript.count('\n') == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        _assert(all(sym_generator((sym_in(g, COLORS) for g in guess))))
        perfect = {c: sym_sum([(g == s).__and__(s == c) for g, s in sym_zip(guess, secret)]) for c in COLORS}
        almost = sym_sum(sym_generator((min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)))
        return helper(secret, transcript + (sym_str(guess) + wrap_str(' ') + sym_str(sym_sum(perfect.values())) + sym_str(almost) + wrap_str('\n')))
    return all(sym_generator((helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)))
Exception -- for puzzle Mastermind:0 min() iterable argument is empty

Solving puzzle 581/732: Mastermind:1
sat_func def sat(transcripts: List[str], max_moves=8):
    COLORS = "ABCDEF"

    def helper(secret: str, transcript=""):
        if transcript.count("\n") == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        assert all(g in COLORS for g in guess)
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return helper(secret, transcript + f"{guess} {sum(perfect.values())}{almost}\n")

    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)
modified_func def sat(transcripts: List[str], max_moves=wrap_int(8)):
    COLORS = wrap_str('ABCDEF')

    def helper(secret: str, transcript=wrap_str('')):
        if transcript.count('\n') == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        _assert(all(sym_generator((sym_in(g, COLORS) for g in guess))))
        perfect = {c: sym_sum([(g == s).__and__(s == c) for g, s in sym_zip(guess, secret)]) for c in COLORS}
        almost = sym_sum(sym_generator((min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)))
        return helper(secret, transcript + (sym_str(guess) + wrap_str(' ') + sym_str(sym_sum(perfect.values())) + sym_str(almost) + wrap_str('\n')))
    return all(sym_generator((helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)))
Exception -- for puzzle Mastermind:1 min() iterable argument is empty

Solving puzzle 582/732: Mastermind:2
sat_func def sat(transcripts: List[str], max_moves=6):
    COLORS = "ABCDEF"

    def helper(secret: str, transcript=""):
        if transcript.count("\n") == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        assert all(g in COLORS for g in guess)
        perfect = {c: sum([g == s == c for g, s in zip(guess, secret)]) for c in COLORS}
        almost = sum(min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)
        return helper(secret, transcript + f"{guess} {sum(perfect.values())}{almost}\n")

    return all(helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)
modified_func def sat(transcripts: List[str], max_moves=wrap_int(6)):
    COLORS = wrap_str('ABCDEF')

    def helper(secret: str, transcript=wrap_str('')):
        if transcript.count('\n') == max_moves:
            return False
        guess = min([t for t in transcripts if t.startswith(transcript)], key=len)[-4:]
        if guess == secret:
            return True
        _assert(all(sym_generator((sym_in(g, COLORS) for g in guess))))
        perfect = {c: sym_sum([(g == s).__and__(s == c) for g, s in sym_zip(guess, secret)]) for c in COLORS}
        almost = sym_sum(sym_generator((min(guess.count(c), secret.count(c)) - perfect[c] for c in COLORS)))
        return helper(secret, transcript + (sym_str(guess) + wrap_str(' ') + sym_str(sym_sum(perfect.values())) + sym_str(almost) + wrap_str('\n')))
    return all(sym_generator((helper(r + s + t + u) for r in COLORS for s in COLORS for t in COLORS for u in COLORS)))
Exception -- for puzzle Mastermind:2 min() iterable argument is empty

Solving puzzle 583/732: TicTacToeX:0
sat_func def sat(good_boards: List[str]):
    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in "XO") for b in good_boards}
    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]

    def tie(x, o):  # returns True if X has a forced tie/win assuming it's X's turn to move.
        x |= 1 << [i for i in range(9) if (x | (1 << i), o) in board_bit_reps][0]
        return not win[o] and (win[x] or all((x | o) & (1 << i) or tie(x, o | (1 << i)) for i in range(9)))

    return tie(0, 0)
modified_func def sat(good_boards: List[str]):
    board_bit_reps = {tuple(sym_generator((sym_sum(sym_generator((wrap_int(1) << i for i in sym_range(9) if b[i] == c))) for c in wrap_str('XO')))) for b in good_boards}
    win = [any(sym_generator((i & w == w for w in wrap_list([wrap_int(7), wrap_int(56), wrap_int(73), wrap_int(84), wrap_int(146), wrap_int(273), wrap_int(292), wrap_int(448)])))) for i in sym_range(512)]

    def tie(x, o):
        x |= wrap_int(1) << [i for i in sym_range(9) if sym_in((x | wrap_int(1) << i, o), board_bit_reps)][wrap_int(0)]
        return sym_not(win[o]).__and__(win[x].__or__(all(sym_generator((((x | o) & wrap_int(1) << i).__or__(tie(x, o | wrap_int(1) << i)) for i in sym_range(9))))))
    return tie(wrap_int(0), wrap_int(0))
Exception -- for puzzle TicTacToeX:0 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 584/732: TicTacToeO:0
sat_func def sat(good_boards: List[str]):
    board_bit_reps = {tuple(sum(1 << i for i in range(9) if b[i] == c) for c in "XO") for b in good_boards}
    win = [any(i & w == w for w in [7, 56, 73, 84, 146, 273, 292, 448]) for i in range(512)]

    def tie(x, o):  # returns True if O has a forced tie/win. It's O's turn to move.
        if o | x != 511:  # complete board
            o |= 1 << [i for i in range(9) if (x, o | (1 << i)) in board_bit_reps][0]
        return not win[x] and (win[o] or all((x | o) & (1 << i) or tie(x | (1 << i), o) for i in range(9)))

    return all(tie(1 << i, 0) for i in range(9))
modified_func def sat(good_boards: List[str]):
    board_bit_reps = {tuple(sym_generator((sym_sum(sym_generator((wrap_int(1) << i for i in sym_range(9) if b[i] == c))) for c in wrap_str('XO')))) for b in good_boards}
    win = [any(sym_generator((i & w == w for w in wrap_list([wrap_int(7), wrap_int(56), wrap_int(73), wrap_int(84), wrap_int(146), wrap_int(273), wrap_int(292), wrap_int(448)])))) for i in sym_range(512)]

    def tie(x, o):
        if o | x != wrap_int(511):
            o |= wrap_int(1) << [i for i in sym_range(9) if sym_in((x, o | wrap_int(1) << i), board_bit_reps)][wrap_int(0)]
        return sym_not(win[x]).__and__(win[o].__or__(all(sym_generator((((x | o) & wrap_int(1) << i).__or__(tie(x | wrap_int(1) << i, o)) for i in sym_range(9))))))
    return all(sym_generator((tie(wrap_int(1) << i, wrap_int(0)) for i in sym_range(9))))
Exception -- for puzzle TicTacToeO:0 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 585/732: AnyEdge:0
sat_func def sat(e: List[int], edges=[[0, 217], [40, 11], [17, 29], [11, 12], [31, 51]]):
    return e in edges
modified_func def sat(e: List[int], edges=wrap_list([wrap_list([wrap_int(0), wrap_int(217)]), wrap_list([wrap_int(40), wrap_int(11)]), wrap_list([wrap_int(17), wrap_int(29)]), wrap_list([wrap_int(11), wrap_int(12)]), wrap_list([wrap_int(31), wrap_int(51)])])):
    return sym_in(e, edges)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (or (= x (cons 0 (cons 217 (as nil (List Int))))) (= x (cons 40 (cons 11 (as nil (List Int))))) (= x (cons 17 (cons 29 (as nil (List Int))))) (= x (cons 11 (cons 12 (as nil (List Int))))) (= x (cons 31 (cons 51 (as nil (List Int)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 217 (as nil (List Int)))))
)

Found solution [0, 217]
Yes! Solved for puzzle  AnyEdge:0

Solving puzzle 586/732: AnyEdge:1
sat_func def sat(e: List[int], edges=[[0, 1], [1, 1], [0, 0]]):
    return e in edges
modified_func def sat(e: List[int], edges=wrap_list([wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(0)])])):
    return sym_in(e, edges)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (or (= x (cons 0 (cons 1 (as nil (List Int))))) (= x (cons 1 (cons 1 (as nil (List Int))))) (= x (cons 0 (cons 0 (as nil (List Int)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 1 (as nil (List Int)))))
)

Found solution [0, 1]
Yes! Solved for puzzle  AnyEdge:1

Solving puzzle 587/732: AnyEdge:2
sat_func def sat(e: List[int], edges=[[1, 0], [0, 1], [1, 1]]):
    return e in edges
modified_func def sat(e: List[int], edges=wrap_list([wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(1)])])):
    return sym_in(e, edges)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (or (= x (cons 1 (cons 0 (as nil (List Int))))) (= x (cons 0 (cons 1 (as nil (List Int))))) (= x (cons 1 (cons 1 (as nil (List Int)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) 0 (as nil (List Int)))))
)

Found solution [1, 0]
Yes! Solved for puzzle  AnyEdge:2

Solving puzzle 588/732: AnyEdge:3
sat_func def sat(e: List[int], edges=[[1, 15], [15, 3], [5, 12], [11, 0], [8, 5], [1, 9], [3, 6], [5, 10], [12, 0], [6, 6], [9, 2], [13, 15], [2, 9], [5, 1], [10, 11], [4, 12], [0, 6], [8, 12], [15, 14], [1, 13], [11, 7], [15, 4], [13, 5], [7, 14], [14, 5], [12, 2], [7, 8], [2, 14], [3, 15], [2, 2], [7, 2], [3, 4], [4, 2], [1, 3], [4, 4], [3, 11], [14, 6], [14, 8], [14, 12], [7, 15], [7, 3], [7, 10], [10, 8], [7, 13], [2, 15], [14, 0], [1, 5], [11, 15], [1, 8], [6, 4], [15, 8], [9, 3], [1, 10], [2, 3], [4, 13], [7, 5], [2, 11], [0, 1], [15, 6], [0, 2], [5, 5]]):
    return e in edges
modified_func def sat(e: List[int], edges=wrap_list([wrap_list([wrap_int(1), wrap_int(15)]), wrap_list([wrap_int(15), wrap_int(3)]), wrap_list([wrap_int(5), wrap_int(12)]), wrap_list([wrap_int(11), wrap_int(0)]), wrap_list([wrap_int(8), wrap_int(5)]), wrap_list([wrap_int(1), wrap_int(9)]), wrap_list([wrap_int(3), wrap_int(6)]), wrap_list([wrap_int(5), wrap_int(10)]), wrap_list([wrap_int(12), wrap_int(0)]), wrap_list([wrap_int(6), wrap_int(6)]), wrap_list([wrap_int(9), wrap_int(2)]), wrap_list([wrap_int(13), wrap_int(15)]), wrap_list([wrap_int(2), wrap_int(9)]), wrap_list([wrap_int(5), wrap_int(1)]), wrap_list([wrap_int(10), wrap_int(11)]), wrap_list([wrap_int(4), wrap_int(12)]), wrap_list([wrap_int(0), wrap_int(6)]), wrap_list([wrap_int(8), wrap_int(12)]), wrap_list([wrap_int(15), wrap_int(14)]), wrap_list([wrap_int(1), wrap_int(13)]), wrap_list([wrap_int(11), wrap_int(7)]), wrap_list([wrap_int(15), wrap_int(4)]), wrap_list([wrap_int(13), wrap_int(5)]), wrap_list([wrap_int(7), wrap_int(14)]), wrap_list([wrap_int(14), wrap_int(5)]), wrap_list([wrap_int(12), wrap_int(2)]), wrap_list([wrap_int(7), wrap_int(8)]), wrap_list([wrap_int(2), wrap_int(14)]), wrap_list([wrap_int(3), wrap_int(15)]), wrap_list([wrap_int(2), wrap_int(2)]), wrap_list([wrap_int(7), wrap_int(2)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(4), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(4)]), wrap_list([wrap_int(3), wrap_int(11)]), wrap_list([wrap_int(14), wrap_int(6)]), wrap_list([wrap_int(14), wrap_int(8)]), wrap_list([wrap_int(14), wrap_int(12)]), wrap_list([wrap_int(7), wrap_int(15)]), wrap_list([wrap_int(7), wrap_int(3)]), wrap_list([wrap_int(7), wrap_int(10)]), wrap_list([wrap_int(10), wrap_int(8)]), wrap_list([wrap_int(7), wrap_int(13)]), wrap_list([wrap_int(2), wrap_int(15)]), wrap_list([wrap_int(14), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(11), wrap_int(15)]), wrap_list([wrap_int(1), wrap_int(8)]), wrap_list([wrap_int(6), wrap_int(4)]), wrap_list([wrap_int(15), wrap_int(8)]), wrap_list([wrap_int(9), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(10)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(13)]), wrap_list([wrap_int(7), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(11)]), wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(15), wrap_int(6)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(5), wrap_int(5)])])):
    return sym_in(e, edges)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (or (= x (cons 1 (cons 15 (as nil (List Int))))) (= x (cons 15 (cons 3 (as nil (List Int))))) (= x (cons 5 (cons 12 (as nil (List Int))))) (= x (cons 11 (cons 0 (as nil (List Int))))) (= x (cons 8 (cons 5 (as nil (List Int))))) (= x (cons 1 (cons 9 (as nil (List Int))))) (= x (cons 3 (cons 6 (as nil (List Int))))) (= x (cons 5 (cons 10 (as nil (List Int))))) (= x (cons 12 (cons 0 (as nil (List Int))))) (= x (cons 6 (cons 6 (as nil (List Int))))) (= x (cons 9 (cons 2 (as nil (List Int))))) (= x (cons 13 (cons 15 (as nil (List Int))))) (= x (cons 2 (cons 9 (as nil (List Int))))) (= x (cons 5 (cons 1 (as nil (List Int))))) (= x (cons 10 (cons 11 (as nil (List Int))))) (= x (cons 4 (cons 12 (as nil (List Int))))) (= x (cons 0 (cons 6 (as nil (List Int))))) (= x (cons 8 (cons 12 (as nil (List Int))))) (= x (cons 15 (cons 14 (as nil (List Int))))) (= x (cons 1 (cons 13 (as nil (List Int))))) (= x (cons 11 (cons 7 (as nil (List Int))))) (= x (cons 15 (cons 4 (as nil (List Int))))) (= ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 1 ((as cons (List Int)) 15 (as nil (List Int)))))
)

Found solution [1, 15]
Yes! Solved for puzzle  AnyEdge:3

Solving puzzle 589/732: AnyEdge:4
sat_func def sat(e: List[int], edges=[[7, 84], [72, 0], [65, 93], [66, 13], [39, 15], [91, 6], [16, 77], [43, 71], [34, 72], [83, 1], [91, 93], [41, 20], [71, 69], [51, 60], [75, 22], [25, 82], [93, 45], [54, 31], [38, 22], [76, 33], [18, 81], [91, 74], [28, 97], [39, 69], [15, 26], [83, 75], [57, 24], [94, 38], [26, 23], [40, 48], [37, 20], [90, 84], [75, 8], [36, 21], [93, 11], [97, 74], [79, 74], [69, 36], [3, 29], [66, 82], [49, 15], [52, 43], [76, 25], [39, 11], [9, 93], [68, 55], [53, 46], [29, 90], [12, 81], [44, 66], [54, 55], [2, 30], [1, 6], [8, 61], [67, 10], [61, 84], [72, 51], [13, 27], [93, 53], [44, 38], [86, 14], [90, 8], [22, 62], [5, 72], [63, 36], [31, 51], [83, 5], [36, 53], [92, 78], [44, 80], [23, 16], [43, 16], [18, 37], [34, 14], [23, 6], [19, 61], [59, 10], [85, 30], [25, 80], [76, 39], [21, 28], [60, 47], [15, 43], [26, 80], [59, 19], [83, 81], [4, 64], [3, 71], [52, 34], [90, 14], [44, 84], [37, 56], [76, 10], [69, 89], [30, 38], [17, 38], [42, 7], [79, 62], [15, 87], [45, 4], [96, 0], [44, 43], [84, 42], [26, 22], [1, 91], [1, 11], [68, 7], [72, 32], [8, 0], [64, 59], [16, 86], [25, 46], [65, 30], [10, 43], [89, 43], [55, 0], [91, 66], [49, 0], [22, 77], [80, 21], [16, 58], [55, 45], [64, 13], [55, 56], [89, 96], [84, 20], [11, 74], [92, 91], [36, 15], [51, 8], [4, 44], [55, 55], [6, 83], [76, 5], [3, 11], [15, 96], [18, 15], [43, 58], [19, 70], [87, 41], [43, 47], [2, 51], [47, 32], [14, 93], [27, 61], [21, 26], [78, 88], [52, 40], [21, 79], [12, 8], [74, 73], [5, 22], [50, 4], [15, 67], [87, 10], [90, 24], [17, 45], [75, 96], [27, 81], [76, 29], [52, 93], [74, 40], [48, 62], [5, 75], [68, 58], [61, 19], [56, 54], [4, 29], [26, 60], [24, 1], [37, 41], [95, 63], [49, 37], [81, 18], [79, 91], [82, 8], [29, 73], [55, 84], [18, 13], [32, 7], [77, 63], [26, 72], [90, 5], [95, 4], [46, 13], [0, 64], [84, 34], [52, 51], [32, 30], [24, 55], [51, 17], [12, 7], [73, 34], [54, 47], [96, 95], [65, 67], [46, 90], [58, 17], [54, 2], [45, 10], [84, 45], [46, 6], [0, 4], [16, 60], [50, 35], [86, 45], [89, 19], [48, 10], [4, 57], [43, 62], [19, 30], [2, 35], [83, 68], [36, 26], [69, 4], [41, 82], [12, 52], [77, 95], [90, 75], [78, 58], [93, 29], [38, 87], [15, 82], [42, 86], [39, 90], [20, 53], [79, 25], [68, 81], [64, 82], [45, 56], [14, 85], [97, 13], [46, 15], [46, 43], [8, 71], [90, 72], [97, 66], [80, 57], [25, 8], [90, 74]]):
    return e in edges
modified_func def sat(e: List[int], edges=wrap_list([wrap_list([wrap_int(7), wrap_int(84)]), wrap_list([wrap_int(72), wrap_int(0)]), wrap_list([wrap_int(65), wrap_int(93)]), wrap_list([wrap_int(66), wrap_int(13)]), wrap_list([wrap_int(39), wrap_int(15)]), wrap_list([wrap_int(91), wrap_int(6)]), wrap_list([wrap_int(16), wrap_int(77)]), wrap_list([wrap_int(43), wrap_int(71)]), wrap_list([wrap_int(34), wrap_int(72)]), wrap_list([wrap_int(83), wrap_int(1)]), wrap_list([wrap_int(91), wrap_int(93)]), wrap_list([wrap_int(41), wrap_int(20)]), wrap_list([wrap_int(71), wrap_int(69)]), wrap_list([wrap_int(51), wrap_int(60)]), wrap_list([wrap_int(75), wrap_int(22)]), wrap_list([wrap_int(25), wrap_int(82)]), wrap_list([wrap_int(93), wrap_int(45)]), wrap_list([wrap_int(54), wrap_int(31)]), wrap_list([wrap_int(38), wrap_int(22)]), wrap_list([wrap_int(76), wrap_int(33)]), wrap_list([wrap_int(18), wrap_int(81)]), wrap_list([wrap_int(91), wrap_int(74)]), wrap_list([wrap_int(28), wrap_int(97)]), wrap_list([wrap_int(39), wrap_int(69)]), wrap_list([wrap_int(15), wrap_int(26)]), wrap_list([wrap_int(83), wrap_int(75)]), wrap_list([wrap_int(57), wrap_int(24)]), wrap_list([wrap_int(94), wrap_int(38)]), wrap_list([wrap_int(26), wrap_int(23)]), wrap_list([wrap_int(40), wrap_int(48)]), wrap_list([wrap_int(37), wrap_int(20)]), wrap_list([wrap_int(90), wrap_int(84)]), wrap_list([wrap_int(75), wrap_int(8)]), wrap_list([wrap_int(36), wrap_int(21)]), wrap_list([wrap_int(93), wrap_int(11)]), wrap_list([wrap_int(97), wrap_int(74)]), wrap_list([wrap_int(79), wrap_int(74)]), wrap_list([wrap_int(69), wrap_int(36)]), wrap_list([wrap_int(3), wrap_int(29)]), wrap_list([wrap_int(66), wrap_int(82)]), wrap_list([wrap_int(49), wrap_int(15)]), wrap_list([wrap_int(52), wrap_int(43)]), wrap_list([wrap_int(76), wrap_int(25)]), wrap_list([wrap_int(39), wrap_int(11)]), wrap_list([wrap_int(9), wrap_int(93)]), wrap_list([wrap_int(68), wrap_int(55)]), wrap_list([wrap_int(53), wrap_int(46)]), wrap_list([wrap_int(29), wrap_int(90)]), wrap_list([wrap_int(12), wrap_int(81)]), wrap_list([wrap_int(44), wrap_int(66)]), wrap_list([wrap_int(54), wrap_int(55)]), wrap_list([wrap_int(2), wrap_int(30)]), wrap_list([wrap_int(1), wrap_int(6)]), wrap_list([wrap_int(8), wrap_int(61)]), wrap_list([wrap_int(67), wrap_int(10)]), wrap_list([wrap_int(61), wrap_int(84)]), wrap_list([wrap_int(72), wrap_int(51)]), wrap_list([wrap_int(13), wrap_int(27)]), wrap_list([wrap_int(93), wrap_int(53)]), wrap_list([wrap_int(44), wrap_int(38)]), wrap_list([wrap_int(86), wrap_int(14)]), wrap_list([wrap_int(90), wrap_int(8)]), wrap_list([wrap_int(22), wrap_int(62)]), wrap_list([wrap_int(5), wrap_int(72)]), wrap_list([wrap_int(63), wrap_int(36)]), wrap_list([wrap_int(31), wrap_int(51)]), wrap_list([wrap_int(83), wrap_int(5)]), wrap_list([wrap_int(36), wrap_int(53)]), wrap_list([wrap_int(92), wrap_int(78)]), wrap_list([wrap_int(44), wrap_int(80)]), wrap_list([wrap_int(23), wrap_int(16)]), wrap_list([wrap_int(43), wrap_int(16)]), wrap_list([wrap_int(18), wrap_int(37)]), wrap_list([wrap_int(34), wrap_int(14)]), wrap_list([wrap_int(23), wrap_int(6)]), wrap_list([wrap_int(19), wrap_int(61)]), wrap_list([wrap_int(59), wrap_int(10)]), wrap_list([wrap_int(85), wrap_int(30)]), wrap_list([wrap_int(25), wrap_int(80)]), wrap_list([wrap_int(76), wrap_int(39)]), wrap_list([wrap_int(21), wrap_int(28)]), wrap_list([wrap_int(60), wrap_int(47)]), wrap_list([wrap_int(15), wrap_int(43)]), wrap_list([wrap_int(26), wrap_int(80)]), wrap_list([wrap_int(59), wrap_int(19)]), wrap_list([wrap_int(83), wrap_int(81)]), wrap_list([wrap_int(4), wrap_int(64)]), wrap_list([wrap_int(3), wrap_int(71)]), wrap_list([wrap_int(52), wrap_int(34)]), wrap_list([wrap_int(90), wrap_int(14)]), wrap_list([wrap_int(44), wrap_int(84)]), wrap_list([wrap_int(37), wrap_int(56)]), wrap_list([wrap_int(76), wrap_int(10)]), wrap_list([wrap_int(69), wrap_int(89)]), wrap_list([wrap_int(30), wrap_int(38)]), wrap_list([wrap_int(17), wrap_int(38)]), wrap_list([wrap_int(42), wrap_int(7)]), wrap_list([wrap_int(79), wrap_int(62)]), wrap_list([wrap_int(15), wrap_int(87)]), wrap_list([wrap_int(45), wrap_int(4)]), wrap_list([wrap_int(96), wrap_int(0)]), wrap_list([wrap_int(44), wrap_int(43)]), wrap_list([wrap_int(84), wrap_int(42)]), wrap_list([wrap_int(26), wrap_int(22)]), wrap_list([wrap_int(1), wrap_int(91)]), wrap_list([wrap_int(1), wrap_int(11)]), wrap_list([wrap_int(68), wrap_int(7)]), wrap_list([wrap_int(72), wrap_int(32)]), wrap_list([wrap_int(8), wrap_int(0)]), wrap_list([wrap_int(64), wrap_int(59)]), wrap_list([wrap_int(16), wrap_int(86)]), wrap_list([wrap_int(25), wrap_int(46)]), wrap_list([wrap_int(65), wrap_int(30)]), wrap_list([wrap_int(10), wrap_int(43)]), wrap_list([wrap_int(89), wrap_int(43)]), wrap_list([wrap_int(55), wrap_int(0)]), wrap_list([wrap_int(91), wrap_int(66)]), wrap_list([wrap_int(49), wrap_int(0)]), wrap_list([wrap_int(22), wrap_int(77)]), wrap_list([wrap_int(80), wrap_int(21)]), wrap_list([wrap_int(16), wrap_int(58)]), wrap_list([wrap_int(55), wrap_int(45)]), wrap_list([wrap_int(64), wrap_int(13)]), wrap_list([wrap_int(55), wrap_int(56)]), wrap_list([wrap_int(89), wrap_int(96)]), wrap_list([wrap_int(84), wrap_int(20)]), wrap_list([wrap_int(11), wrap_int(74)]), wrap_list([wrap_int(92), wrap_int(91)]), wrap_list([wrap_int(36), wrap_int(15)]), wrap_list([wrap_int(51), wrap_int(8)]), wrap_list([wrap_int(4), wrap_int(44)]), wrap_list([wrap_int(55), wrap_int(55)]), wrap_list([wrap_int(6), wrap_int(83)]), wrap_list([wrap_int(76), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(11)]), wrap_list([wrap_int(15), wrap_int(96)]), wrap_list([wrap_int(18), wrap_int(15)]), wrap_list([wrap_int(43), wrap_int(58)]), wrap_list([wrap_int(19), wrap_int(70)]), wrap_list([wrap_int(87), wrap_int(41)]), wrap_list([wrap_int(43), wrap_int(47)]), wrap_list([wrap_int(2), wrap_int(51)]), wrap_list([wrap_int(47), wrap_int(32)]), wrap_list([wrap_int(14), wrap_int(93)]), wrap_list([wrap_int(27), wrap_int(61)]), wrap_list([wrap_int(21), wrap_int(26)]), wrap_list([wrap_int(78), wrap_int(88)]), wrap_list([wrap_int(52), wrap_int(40)]), wrap_list([wrap_int(21), wrap_int(79)]), wrap_list([wrap_int(12), wrap_int(8)]), wrap_list([wrap_int(74), wrap_int(73)]), wrap_list([wrap_int(5), wrap_int(22)]), wrap_list([wrap_int(50), wrap_int(4)]), wrap_list([wrap_int(15), wrap_int(67)]), wrap_list([wrap_int(87), wrap_int(10)]), wrap_list([wrap_int(90), wrap_int(24)]), wrap_list([wrap_int(17), wrap_int(45)]), wrap_list([wrap_int(75), wrap_int(96)]), wrap_list([wrap_int(27), wrap_int(81)]), wrap_list([wrap_int(76), wrap_int(29)]), wrap_list([wrap_int(52), wrap_int(93)]), wrap_list([wrap_int(74), wrap_int(40)]), wrap_list([wrap_int(48), wrap_int(62)]), wrap_list([wrap_int(5), wrap_int(75)]), wrap_list([wrap_int(68), wrap_int(58)]), wrap_list([wrap_int(61), wrap_int(19)]), wrap_list([wrap_int(56), wrap_int(54)]), wrap_list([wrap_int(4), wrap_int(29)]), wrap_list([wrap_int(26), wrap_int(60)]), wrap_list([wrap_int(24), wrap_int(1)]), wrap_list([wrap_int(37), wrap_int(41)]), wrap_list([wrap_int(95), wrap_int(63)]), wrap_list([wrap_int(49), wrap_int(37)]), wrap_list([wrap_int(81), wrap_int(18)]), wrap_list([wrap_int(79), wrap_int(91)]), wrap_list([wrap_int(82), wrap_int(8)]), wrap_list([wrap_int(29), wrap_int(73)]), wrap_list([wrap_int(55), wrap_int(84)]), wrap_list([wrap_int(18), wrap_int(13)]), wrap_list([wrap_int(32), wrap_int(7)]), wrap_list([wrap_int(77), wrap_int(63)]), wrap_list([wrap_int(26), wrap_int(72)]), wrap_list([wrap_int(90), wrap_int(5)]), wrap_list([wrap_int(95), wrap_int(4)]), wrap_list([wrap_int(46), wrap_int(13)]), wrap_list([wrap_int(0), wrap_int(64)]), wrap_list([wrap_int(84), wrap_int(34)]), wrap_list([wrap_int(52), wrap_int(51)]), wrap_list([wrap_int(32), wrap_int(30)]), wrap_list([wrap_int(24), wrap_int(55)]), wrap_list([wrap_int(51), wrap_int(17)]), wrap_list([wrap_int(12), wrap_int(7)]), wrap_list([wrap_int(73), wrap_int(34)]), wrap_list([wrap_int(54), wrap_int(47)]), wrap_list([wrap_int(96), wrap_int(95)]), wrap_list([wrap_int(65), wrap_int(67)]), wrap_list([wrap_int(46), wrap_int(90)]), wrap_list([wrap_int(58), wrap_int(17)]), wrap_list([wrap_int(54), wrap_int(2)]), wrap_list([wrap_int(45), wrap_int(10)]), wrap_list([wrap_int(84), wrap_int(45)]), wrap_list([wrap_int(46), wrap_int(6)]), wrap_list([wrap_int(0), wrap_int(4)]), wrap_list([wrap_int(16), wrap_int(60)]), wrap_list([wrap_int(50), wrap_int(35)]), wrap_list([wrap_int(86), wrap_int(45)]), wrap_list([wrap_int(89), wrap_int(19)]), wrap_list([wrap_int(48), wrap_int(10)]), wrap_list([wrap_int(4), wrap_int(57)]), wrap_list([wrap_int(43), wrap_int(62)]), wrap_list([wrap_int(19), wrap_int(30)]), wrap_list([wrap_int(2), wrap_int(35)]), wrap_list([wrap_int(83), wrap_int(68)]), wrap_list([wrap_int(36), wrap_int(26)]), wrap_list([wrap_int(69), wrap_int(4)]), wrap_list([wrap_int(41), wrap_int(82)]), wrap_list([wrap_int(12), wrap_int(52)]), wrap_list([wrap_int(77), wrap_int(95)]), wrap_list([wrap_int(90), wrap_int(75)]), wrap_list([wrap_int(78), wrap_int(58)]), wrap_list([wrap_int(93), wrap_int(29)]), wrap_list([wrap_int(38), wrap_int(87)]), wrap_list([wrap_int(15), wrap_int(82)]), wrap_list([wrap_int(42), wrap_int(86)]), wrap_list([wrap_int(39), wrap_int(90)]), wrap_list([wrap_int(20), wrap_int(53)]), wrap_list([wrap_int(79), wrap_int(25)]), wrap_list([wrap_int(68), wrap_int(81)]), wrap_list([wrap_int(64), wrap_int(82)]), wrap_list([wrap_int(45), wrap_int(56)]), wrap_list([wrap_int(14), wrap_int(85)]), wrap_list([wrap_int(97), wrap_int(13)]), wrap_list([wrap_int(46), wrap_int(15)]), wrap_list([wrap_int(46), wrap_int(43)]), wrap_list([wrap_int(8), wrap_int(71)]), wrap_list([wrap_int(90), wrap_int(72)]), wrap_list([wrap_int(97), wrap_int(66)]), wrap_list([wrap_int(80), wrap_int(57)]), wrap_list([wrap_int(25), wrap_int(8)]), wrap_list([wrap_int(90), wrap_int(74)])])):
    return sym_in(e, edges)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (or (= x (cons 7 (cons 84 (as nil (List Int))))) (= x (cons 72 (cons 0 (as nil (List Int))))) (= x (cons 65 (cons 93 (as nil (List Int))))) (= x (cons 66 (cons 13 (as nil (List Int))))) (= x (cons 39 (cons 15 (as nil (List Int))))) (= x (cons 91 (cons 6 (as nil (List Int))))) (= x (cons 16 (cons 77 (as nil (List Int))))) (= x (cons 43 (cons 71 (as nil (List Int))))) (= x (cons 34 (cons 72 (as nil (List Int))))) (= x (cons 83 (cons 1 (as nil (List Int))))) (= x (cons 91 (cons 93 (as nil (List Int))))) (= x (cons 41 (cons 20 (as nil (List Int))))) (= x (cons 71 (cons 69 (as nil (List Int))))) (= x (cons 51 (cons 60 (as nil (List Int))))) (= x (cons 75 (cons 22 (as nil (List Int))))) (= x (cons 25 (cons 82 (as nil (List Int))))) (= x (cons 93 (cons 45 (as nil (List Int))))) (= x (cons 54 (cons 31 (as nil (List Int))))) (= x (cons 38 (cons 22 (as nil (List Int))))) (= x (cons 76 (cons 33 (as nil (List Int))))) (= x (cons 18 (cons 81 (as nil (List Int))))) (= x (cons 91 (cons 74 (as...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 7 ((as cons (List Int)) 84 (as nil (List Int)))))
)

Found solution [7, 84]
Yes! Solved for puzzle  AnyEdge:4

Solving puzzle 590/732: AnyTriangle:0
sat_func def sat(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
modified_func def sat(tri: List[int], edges=wrap_list([wrap_list([wrap_int(0), wrap_int(17)]), wrap_list([wrap_int(0), wrap_int(22)]), wrap_list([wrap_int(17), wrap_int(22)]), wrap_list([wrap_int(17), wrap_int(31)]), wrap_list([wrap_int(22), wrap_int(31)]), wrap_list([wrap_int(31), wrap_int(17)])])):
    a, b, c = tri
    return sym_in(wrap_list([a, b]), edges).__and__(sym_in(wrap_list([b, c]), edges)).__and__(sym_in(wrap_list([c, a]), edges)).__and__((a != b).__and__(b != c).__and__(c != a))
Exception -- for puzzle AnyTriangle:0 not enough values to unpack (expected 3, got 1)

Solving puzzle 591/732: AnyTriangle:1
sat_func def sat(tri: List[int], edges=[[19, 48], [14, 42], [19, 14], [56, 3], [37, 16], [46, 5], [14, 14], [62, 40], [12, 41], [37, 1], [46, 40], [4, 9], [70, 39], [75, 49], [61, 55], [65, 61], [5, 1], [67, 44], [46, 68], [49, 62], [41, 61], [39, 43], [44, 60], [71, 40], [8, 42], [54, 67], [33, 27], [25, 70], [50, 3], [53, 22], [61, 34], [5, 16], [39, 62], [30, 44], [10, 3], [21, 67], [41, 54], [10, 66], [34, 1], [45, 44], [38, 47], [25, 36], [2, 47], [46, 2], [38, 4], [50, 66], [45, 18], [45, 50], [63, 57], [19, 43], [39, 66], [29, 13], [39, 65], [63, 39], [7, 25], [34, 51], [65, 54], [13, 64], [9, 70], [28, 12], [41, 69], [67, 53], [33, 38], [59, 27], [18, 37], [11, 3], [13, 23], [33, 50], [44, 49], [9, 50], [23, 55], [59, 66], [4, 74], [50, 12], [14, 24], [0, 28], [75, 29], [62, 60], [68, 35], [69, 55], [3, 19], [72, 30], [25, 9], [12, 58], [3, 66], [43, 8], [12, 11], [15, 56], [30, 75], [35, 57], [19, 20], [71, 36], [34, 35], [30, 17], [7, 52], [49, 31], [39, 58], [48, 32], [4, 57], [75, 31], [42, 1], [0, 48], [22, 13], [18, 17], [71, 52], [41, 19], [48, 12], [9, 48], [63, 65], [68, 63], [46, 39], [24, 30], [46, 61], [55, 25], [75, 36], [49, 5], [44, 12], [29, 5], [64, 69], [15, 64], [8, 66], [49, 25], [24, 53], [7, 39], [41, 2], [29, 48], [51, 30], [41, 21], [46, 30], [63, 75], [19, 3], [58, 72], [62, 59], [68, 54], [9, 61], [70, 74], [56, 48], [74, 48], [2, 9], [51, 22], [69, 61], [0, 35], [28, 46], [7, 11], [56, 57], [14, 67], [15, 4], [53, 12], [64, 42], [20, 15], [52, 53], [44, 16], [8, 7], [21, 7], [42, 45], [4, 66], [39, 59], [20, 1], [60, 0], [52, 28], [75, 63], [59, 14], [40, 69], [74, 46], [60, 67], [6, 57], [38, 68], [24, 22], [59, 61], [53, 30], [10, 56], [49, 59], [12, 27], [75, 22], [24, 25], [37, 11], [56, 12], [62, 47], [22, 9], [34, 17], [57, 10], [52, 43], [17, 22], [14, 73], [54, 75], [28, 22], [18, 51], [38, 46], [6, 22], [75, 15], [10, 1], [37, 12], [67, 34], [28, 43], [5, 2], [60, 40], [9, 22], [3, 75], [50, 1], [19, 8], [17, 57], [43, 60], [45, 60], [57, 32], [52, 35], [18, 22], [11, 38], [16, 57], [31, 39], [13, 18], [61, 54], [25, 10], [23, 46], [47, 5], [42, 66], [73, 67], [44, 28], [65, 34], [35, 50], [67, 1], [12, 44], [17, 51], [70, 23], [44, 35], [0, 16], [65, 53], [10, 74], [5, 60], [45, 8], [13, 46], [57, 6], [72, 47], [1, 36], [60, 4], [11, 31], [46, 21], [60, 29], [58, 44], [53, 41], [33, 44], [47, 34], [58, 35], [74, 51], [71, 35], [58, 10], [47, 59], [32, 36], [16, 67], [62, 9], [14, 44], [12, 32], [6, 19], [35, 21], [49, 71], [7, 7], [25, 39], [25, 24], [45, 40], [44, 20], [9, 37], [58, 18], [59, 52], [12, 23], [26, 49], [62, 69], [8, 2], [66, 52], [25, 42], [34, 70], [64, 1], [29, 57], [8, 26], [25, 63], [75, 56], [51, 49], [70, 9], [63, 51], [6, 28], [1, 38], [47, 27], [74, 26], [27, 63], [20, 47], [25, 37], [31, 67], [59, 71], [56, 32], [28, 65], [37, 10], [30, 50], [42, 32], [56, 63], [32, 65], [48, 70], [37, 21], [10, 11], [5, 24], [51, 8], [46, 6], [75, 23], [42, 28], [60, 26], [37, 9], [0, 19], [11, 34], [66, 51], [49, 42], [16, 37], [52, 55], [20, 39], [46, 12], [1, 70], [45, 37], [18, 63], [63, 23], [54, 7], [18, 11], [51, 28], [21, 65], [28, 71], [46, 53], [14, 36], [35, 71], [30, 5], [50, 62], [32, 28], [64, 38], [66, 61], [0, 10]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
modified_func def sat(tri: List[int], edges=wrap_list([wrap_list([wrap_int(19), wrap_int(48)]), wrap_list([wrap_int(14), wrap_int(42)]), wrap_list([wrap_int(19), wrap_int(14)]), wrap_list([wrap_int(56), wrap_int(3)]), wrap_list([wrap_int(37), wrap_int(16)]), wrap_list([wrap_int(46), wrap_int(5)]), wrap_list([wrap_int(14), wrap_int(14)]), wrap_list([wrap_int(62), wrap_int(40)]), wrap_list([wrap_int(12), wrap_int(41)]), wrap_list([wrap_int(37), wrap_int(1)]), wrap_list([wrap_int(46), wrap_int(40)]), wrap_list([wrap_int(4), wrap_int(9)]), wrap_list([wrap_int(70), wrap_int(39)]), wrap_list([wrap_int(75), wrap_int(49)]), wrap_list([wrap_int(61), wrap_int(55)]), wrap_list([wrap_int(65), wrap_int(61)]), wrap_list([wrap_int(5), wrap_int(1)]), wrap_list([wrap_int(67), wrap_int(44)]), wrap_list([wrap_int(46), wrap_int(68)]), wrap_list([wrap_int(49), wrap_int(62)]), wrap_list([wrap_int(41), wrap_int(61)]), wrap_list([wrap_int(39), wrap_int(43)]), wrap_list([wrap_int(44), wrap_int(60)]), wrap_list([wrap_int(71), wrap_int(40)]), wrap_list([wrap_int(8), wrap_int(42)]), wrap_list([wrap_int(54), wrap_int(67)]), wrap_list([wrap_int(33), wrap_int(27)]), wrap_list([wrap_int(25), wrap_int(70)]), wrap_list([wrap_int(50), wrap_int(3)]), wrap_list([wrap_int(53), wrap_int(22)]), wrap_list([wrap_int(61), wrap_int(34)]), wrap_list([wrap_int(5), wrap_int(16)]), wrap_list([wrap_int(39), wrap_int(62)]), wrap_list([wrap_int(30), wrap_int(44)]), wrap_list([wrap_int(10), wrap_int(3)]), wrap_list([wrap_int(21), wrap_int(67)]), wrap_list([wrap_int(41), wrap_int(54)]), wrap_list([wrap_int(10), wrap_int(66)]), wrap_list([wrap_int(34), wrap_int(1)]), wrap_list([wrap_int(45), wrap_int(44)]), wrap_list([wrap_int(38), wrap_int(47)]), wrap_list([wrap_int(25), wrap_int(36)]), wrap_list([wrap_int(2), wrap_int(47)]), wrap_list([wrap_int(46), wrap_int(2)]), wrap_list([wrap_int(38), wrap_int(4)]), wrap_list([wrap_int(50), wrap_int(66)]), wrap_list([wrap_int(45), wrap_int(18)]), wrap_list([wrap_int(45), wrap_int(50)]), wrap_list([wrap_int(63), wrap_int(57)]), wrap_list([wrap_int(19), wrap_int(43)]), wrap_list([wrap_int(39), wrap_int(66)]), wrap_list([wrap_int(29), wrap_int(13)]), wrap_list([wrap_int(39), wrap_int(65)]), wrap_list([wrap_int(63), wrap_int(39)]), wrap_list([wrap_int(7), wrap_int(25)]), wrap_list([wrap_int(34), wrap_int(51)]), wrap_list([wrap_int(65), wrap_int(54)]), wrap_list([wrap_int(13), wrap_int(64)]), wrap_list([wrap_int(9), wrap_int(70)]), wrap_list([wrap_int(28), wrap_int(12)]), wrap_list([wrap_int(41), wrap_int(69)]), wrap_list([wrap_int(67), wrap_int(53)]), wrap_list([wrap_int(33), wrap_int(38)]), wrap_list([wrap_int(59), wrap_int(27)]), wrap_list([wrap_int(18), wrap_int(37)]), wrap_list([wrap_int(11), wrap_int(3)]), wrap_list([wrap_int(13), wrap_int(23)]), wrap_list([wrap_int(33), wrap_int(50)]), wrap_list([wrap_int(44), wrap_int(49)]), wrap_list([wrap_int(9), wrap_int(50)]), wrap_list([wrap_int(23), wrap_int(55)]), wrap_list([wrap_int(59), wrap_int(66)]), wrap_list([wrap_int(4), wrap_int(74)]), wrap_list([wrap_int(50), wrap_int(12)]), wrap_list([wrap_int(14), wrap_int(24)]), wrap_list([wrap_int(0), wrap_int(28)]), wrap_list([wrap_int(75), wrap_int(29)]), wrap_list([wrap_int(62), wrap_int(60)]), wrap_list([wrap_int(68), wrap_int(35)]), wrap_list([wrap_int(69), wrap_int(55)]), wrap_list([wrap_int(3), wrap_int(19)]), wrap_list([wrap_int(72), wrap_int(30)]), wrap_list([wrap_int(25), wrap_int(9)]), wrap_list([wrap_int(12), wrap_int(58)]), wrap_list([wrap_int(3), wrap_int(66)]), wrap_list([wrap_int(43), wrap_int(8)]), wrap_list([wrap_int(12), wrap_int(11)]), wrap_list([wrap_int(15), wrap_int(56)]), wrap_list([wrap_int(30), wrap_int(75)]), wrap_list([wrap_int(35), wrap_int(57)]), wrap_list([wrap_int(19), wrap_int(20)]), wrap_list([wrap_int(71), wrap_int(36)]), wrap_list([wrap_int(34), wrap_int(35)]), wrap_list([wrap_int(30), wrap_int(17)]), wrap_list([wrap_int(7), wrap_int(52)]), wrap_list([wrap_int(49), wrap_int(31)]), wrap_list([wrap_int(39), wrap_int(58)]), wrap_list([wrap_int(48), wrap_int(32)]), wrap_list([wrap_int(4), wrap_int(57)]), wrap_list([wrap_int(75), wrap_int(31)]), wrap_list([wrap_int(42), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(48)]), wrap_list([wrap_int(22), wrap_int(13)]), wrap_list([wrap_int(18), wrap_int(17)]), wrap_list([wrap_int(71), wrap_int(52)]), wrap_list([wrap_int(41), wrap_int(19)]), wrap_list([wrap_int(48), wrap_int(12)]), wrap_list([wrap_int(9), wrap_int(48)]), wrap_list([wrap_int(63), wrap_int(65)]), wrap_list([wrap_int(68), wrap_int(63)]), wrap_list([wrap_int(46), wrap_int(39)]), wrap_list([wrap_int(24), wrap_int(30)]), wrap_list([wrap_int(46), wrap_int(61)]), wrap_list([wrap_int(55), wrap_int(25)]), wrap_list([wrap_int(75), wrap_int(36)]), wrap_list([wrap_int(49), wrap_int(5)]), wrap_list([wrap_int(44), wrap_int(12)]), wrap_list([wrap_int(29), wrap_int(5)]), wrap_list([wrap_int(64), wrap_int(69)]), wrap_list([wrap_int(15), wrap_int(64)]), wrap_list([wrap_int(8), wrap_int(66)]), wrap_list([wrap_int(49), wrap_int(25)]), wrap_list([wrap_int(24), wrap_int(53)]), wrap_list([wrap_int(7), wrap_int(39)]), wrap_list([wrap_int(41), wrap_int(2)]), wrap_list([wrap_int(29), wrap_int(48)]), wrap_list([wrap_int(51), wrap_int(30)]), wrap_list([wrap_int(41), wrap_int(21)]), wrap_list([wrap_int(46), wrap_int(30)]), wrap_list([wrap_int(63), wrap_int(75)]), wrap_list([wrap_int(19), wrap_int(3)]), wrap_list([wrap_int(58), wrap_int(72)]), wrap_list([wrap_int(62), wrap_int(59)]), wrap_list([wrap_int(68), wrap_int(54)]), wrap_list([wrap_int(9), wrap_int(61)]), wrap_list([wrap_int(70), wrap_int(74)]), wrap_list([wrap_int(56), wrap_int(48)]), wrap_list([wrap_int(74), wrap_int(48)]), wrap_list([wrap_int(2), wrap_int(9)]), wrap_list([wrap_int(51), wrap_int(22)]), wrap_list([wrap_int(69), wrap_int(61)]), wrap_list([wrap_int(0), wrap_int(35)]), wrap_list([wrap_int(28), wrap_int(46)]), wrap_list([wrap_int(7), wrap_int(11)]), wrap_list([wrap_int(56), wrap_int(57)]), wrap_list([wrap_int(14), wrap_int(67)]), wrap_list([wrap_int(15), wrap_int(4)]), wrap_list([wrap_int(53), wrap_int(12)]), wrap_list([wrap_int(64), wrap_int(42)]), wrap_list([wrap_int(20), wrap_int(15)]), wrap_list([wrap_int(52), wrap_int(53)]), wrap_list([wrap_int(44), wrap_int(16)]), wrap_list([wrap_int(8), wrap_int(7)]), wrap_list([wrap_int(21), wrap_int(7)]), wrap_list([wrap_int(42), wrap_int(45)]), wrap_list([wrap_int(4), wrap_int(66)]), wrap_list([wrap_int(39), wrap_int(59)]), wrap_list([wrap_int(20), wrap_int(1)]), wrap_list([wrap_int(60), wrap_int(0)]), wrap_list([wrap_int(52), wrap_int(28)]), wrap_list([wrap_int(75), wrap_int(63)]), wrap_list([wrap_int(59), wrap_int(14)]), wrap_list([wrap_int(40), wrap_int(69)]), wrap_list([wrap_int(74), wrap_int(46)]), wrap_list([wrap_int(60), wrap_int(67)]), wrap_list([wrap_int(6), wrap_int(57)]), wrap_list([wrap_int(38), wrap_int(68)]), wrap_list([wrap_int(24), wrap_int(22)]), wrap_list([wrap_int(59), wrap_int(61)]), wrap_list([wrap_int(53), wrap_int(30)]), wrap_list([wrap_int(10), wrap_int(56)]), wrap_list([wrap_int(49), wrap_int(59)]), wrap_list([wrap_int(12), wrap_int(27)]), wrap_list([wrap_int(75), wrap_int(22)]), wrap_list([wrap_int(24), wrap_int(25)]), wrap_list([wrap_int(37), wrap_int(11)]), wrap_list([wrap_int(56), wrap_int(12)]), wrap_list([wrap_int(62), wrap_int(47)]), wrap_list([wrap_int(22), wrap_int(9)]), wrap_list([wrap_int(34), wrap_int(17)]), wrap_list([wrap_int(57), wrap_int(10)]), wrap_list([wrap_int(52), wrap_int(43)]), wrap_list([wrap_int(17), wrap_int(22)]), wrap_list([wrap_int(14), wrap_int(73)]), wrap_list([wrap_int(54), wrap_int(75)]), wrap_list([wrap_int(28), wrap_int(22)]), wrap_list([wrap_int(18), wrap_int(51)]), wrap_list([wrap_int(38), wrap_int(46)]), wrap_list([wrap_int(6), wrap_int(22)]), wrap_list([wrap_int(75), wrap_int(15)]), wrap_list([wrap_int(10), wrap_int(1)]), wrap_list([wrap_int(37), wrap_int(12)]), wrap_list([wrap_int(67), wrap_int(34)]), wrap_list([wrap_int(28), wrap_int(43)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(60), wrap_int(40)]), wrap_list([wrap_int(9), wrap_int(22)]), wrap_list([wrap_int(3), wrap_int(75)]), wrap_list([wrap_int(50), wrap_int(1)]), wrap_list([wrap_int(19), wrap_int(8)]), wrap_list([wrap_int(17), wrap_int(57)]), wrap_list([wrap_int(43), wrap_int(60)]), wrap_list([wrap_int(45), wrap_int(60)]), wrap_list([wrap_int(57), wrap_int(32)]), wrap_list([wrap_int(52), wrap_int(35)]), wrap_list([wrap_int(18), wrap_int(22)]), wrap_list([wrap_int(11), wrap_int(38)]), wrap_list([wrap_int(16), wrap_int(57)]), wrap_list([wrap_int(31), wrap_int(39)]), wrap_list([wrap_int(13), wrap_int(18)]), wrap_list([wrap_int(61), wrap_int(54)]), wrap_list([wrap_int(25), wrap_int(10)]), wrap_list([wrap_int(23), wrap_int(46)]), wrap_list([wrap_int(47), wrap_int(5)]), wrap_list([wrap_int(42), wrap_int(66)]), wrap_list([wrap_int(73), wrap_int(67)]), wrap_list([wrap_int(44), wrap_int(28)]), wrap_list([wrap_int(65), wrap_int(34)]), wrap_list([wrap_int(35), wrap_int(50)]), wrap_list([wrap_int(67), wrap_int(1)]), wrap_list([wrap_int(12), wrap_int(44)]), wrap_list([wrap_int(17), wrap_int(51)]), wrap_list([wrap_int(70), wrap_int(23)]), wrap_list([wrap_int(44), wrap_int(35)]), wrap_list([wrap_int(0), wrap_int(16)]), wrap_list([wrap_int(65), wrap_int(53)]), wrap_list([wrap_int(10), wrap_int(74)]), wrap_list([wrap_int(5), wrap_int(60)]), wrap_list([wrap_int(45), wrap_int(8)]), wrap_list([wrap_int(13), wrap_int(46)]), wrap_list([wrap_int(57), wrap_int(6)]), wrap_list([wrap_int(72), wrap_int(47)]), wrap_list([wrap_int(1), wrap_int(36)]), wrap_list([wrap_int(60), wrap_int(4)]), wrap_list([wrap_int(11), wrap_int(31)]), wrap_list([wrap_int(46), wrap_int(21)]), wrap_list([wrap_int(60), wrap_int(29)]), wrap_list([wrap_int(58), wrap_int(44)]), wrap_list([wrap_int(53), wrap_int(41)]), wrap_list([wrap_int(33), wrap_int(44)]), wrap_list([wrap_int(47), wrap_int(34)]), wrap_list([wrap_int(58), wrap_int(35)]), wrap_list([wrap_int(74), wrap_int(51)]), wrap_list([wrap_int(71), wrap_int(35)]), wrap_list([wrap_int(58), wrap_int(10)]), wrap_list([wrap_int(47), wrap_int(59)]), wrap_list([wrap_int(32), wrap_int(36)]), wrap_list([wrap_int(16), wrap_int(67)]), wrap_list([wrap_int(62), wrap_int(9)]), wrap_list([wrap_int(14), wrap_int(44)]), wrap_list([wrap_int(12), wrap_int(32)]), wrap_list([wrap_int(6), wrap_int(19)]), wrap_list([wrap_int(35), wrap_int(21)]), wrap_list([wrap_int(49), wrap_int(71)]), wrap_list([wrap_int(7), wrap_int(7)]), wrap_list([wrap_int(25), wrap_int(39)]), wrap_list([wrap_int(25), wrap_int(24)]), wrap_list([wrap_int(45), wrap_int(40)]), wrap_list([wrap_int(44), wrap_int(20)]), wrap_list([wrap_int(9), wrap_int(37)]), wrap_list([wrap_int(58), wrap_int(18)]), wrap_list([wrap_int(59), wrap_int(52)]), wrap_list([wrap_int(12), wrap_int(23)]), wrap_list([wrap_int(26), wrap_int(49)]), wrap_list([wrap_int(62), wrap_int(69)]), wrap_list([wrap_int(8), wrap_int(2)]), wrap_list([wrap_int(66), wrap_int(52)]), wrap_list([wrap_int(25), wrap_int(42)]), wrap_list([wrap_int(34), wrap_int(70)]), wrap_list([wrap_int(64), wrap_int(1)]), wrap_list([wrap_int(29), wrap_int(57)]), wrap_list([wrap_int(8), wrap_int(26)]), wrap_list([wrap_int(25), wrap_int(63)]), wrap_list([wrap_int(75), wrap_int(56)]), wrap_list([wrap_int(51), wrap_int(49)]), wrap_list([wrap_int(70), wrap_int(9)]), wrap_list([wrap_int(63), wrap_int(51)]), wrap_list([wrap_int(6), wrap_int(28)]), wrap_list([wrap_int(1), wrap_int(38)]), wrap_list([wrap_int(47), wrap_int(27)]), wrap_list([wrap_int(74), wrap_int(26)]), wrap_list([wrap_int(27), wrap_int(63)]), wrap_list([wrap_int(20), wrap_int(47)]), wrap_list([wrap_int(25), wrap_int(37)]), wrap_list([wrap_int(31), wrap_int(67)]), wrap_list([wrap_int(59), wrap_int(71)]), wrap_list([wrap_int(56), wrap_int(32)]), wrap_list([wrap_int(28), wrap_int(65)]), wrap_list([wrap_int(37), wrap_int(10)]), wrap_list([wrap_int(30), wrap_int(50)]), wrap_list([wrap_int(42), wrap_int(32)]), wrap_list([wrap_int(56), wrap_int(63)]), wrap_list([wrap_int(32), wrap_int(65)]), wrap_list([wrap_int(48), wrap_int(70)]), wrap_list([wrap_int(37), wrap_int(21)]), wrap_list([wrap_int(10), wrap_int(11)]), wrap_list([wrap_int(5), wrap_int(24)]), wrap_list([wrap_int(51), wrap_int(8)]), wrap_list([wrap_int(46), wrap_int(6)]), wrap_list([wrap_int(75), wrap_int(23)]), wrap_list([wrap_int(42), wrap_int(28)]), wrap_list([wrap_int(60), wrap_int(26)]), wrap_list([wrap_int(37), wrap_int(9)]), wrap_list([wrap_int(0), wrap_int(19)]), wrap_list([wrap_int(11), wrap_int(34)]), wrap_list([wrap_int(66), wrap_int(51)]), wrap_list([wrap_int(49), wrap_int(42)]), wrap_list([wrap_int(16), wrap_int(37)]), wrap_list([wrap_int(52), wrap_int(55)]), wrap_list([wrap_int(20), wrap_int(39)]), wrap_list([wrap_int(46), wrap_int(12)]), wrap_list([wrap_int(1), wrap_int(70)]), wrap_list([wrap_int(45), wrap_int(37)]), wrap_list([wrap_int(18), wrap_int(63)]), wrap_list([wrap_int(63), wrap_int(23)]), wrap_list([wrap_int(54), wrap_int(7)]), wrap_list([wrap_int(18), wrap_int(11)]), wrap_list([wrap_int(51), wrap_int(28)]), wrap_list([wrap_int(21), wrap_int(65)]), wrap_list([wrap_int(28), wrap_int(71)]), wrap_list([wrap_int(46), wrap_int(53)]), wrap_list([wrap_int(14), wrap_int(36)]), wrap_list([wrap_int(35), wrap_int(71)]), wrap_list([wrap_int(30), wrap_int(5)]), wrap_list([wrap_int(50), wrap_int(62)]), wrap_list([wrap_int(32), wrap_int(28)]), wrap_list([wrap_int(64), wrap_int(38)]), wrap_list([wrap_int(66), wrap_int(61)]), wrap_list([wrap_int(0), wrap_int(10)])])):
    a, b, c = tri
    return sym_in(wrap_list([a, b]), edges).__and__(sym_in(wrap_list([b, c]), edges)).__and__(sym_in(wrap_list([c, a]), edges)).__and__((a != b).__and__(b != c).__and__(c != a))
Exception -- for puzzle AnyTriangle:1 not enough values to unpack (expected 3, got 1)

Solving puzzle 592/732: AnyTriangle:2
sat_func def sat(tri: List[int], edges=[[51, 44], [11, 59], [57, 15], [18, 1], [41, 1], [44, 6], [58, 44], [43, 10], [41, 9], [50, 43], [56, 0], [47, 4], [42, 45], [51, 15], [60, 18], [11, 56], [21, 45], [39, 42], [57, 34], [60, 25], [57, 33], [6, 17], [26, 43], [38, 25], [29, 18], [39, 43], [34, 4], [22, 61], [0, 9], [1, 20], [36, 28], [10, 37], [53, 7], [49, 60], [12, 48], [31, 33], [4, 8], [5, 56], [27, 59], [56, 29], [60, 17], [17, 27], [24, 58], [46, 47], [60, 35], [4, 37], [41, 43], [37, 33], [30, 7], [53, 31], [3, 60], [24, 39], [14, 41], [14, 54], [33, 35], [50, 1], [60, 57], [23, 17], [34, 15], [60, 26], [22, 0], [5, 4], [8, 41], [16, 4], [56, 40], [60, 44], [2, 26], [42, 21], [21, 28], [58, 32], [58, 12], [31, 22], [43, 0], [28, 3], [35, 21], [54, 18], [0, 58], [3, 9], [6, 59], [57, 46], [48, 45], [30, 12], [46, 27], [41, 55], [52, 58], [30, 21], [51, 24], [23, 18], [31, 59], [34, 49], [41, 34], [19, 58], [1, 32], [52, 16], [17, 8], [20, 3], [56, 12], [3, 51], [60, 31], [41, 5], [58, 23], [59, 6], [39, 2], [6, 6], [11, 38], [3, 44], [61, 58], [13, 46], [56, 1], [35, 14], [25, 7], [29, 60], [16, 32], [32, 32], [7, 44], [3, 48], [38, 21], [19, 43], [60, 4], [56, 56], [21, 33], [15, 11], [32, 0], [8, 10], [44, 11], [37, 36], [24, 28], [4, 23], [37, 22], [44, 4], [34, 28], [1, 7], [15, 48], [11, 20], [60, 13], [7, 30], [51, 18], [3, 56], [14, 57], [14, 22], [55, 13], [47, 50], [36, 14], [42, 46], [7, 29], [58, 36], [52, 49], [33, 4], [51, 51], [47, 55], [7, 60], [4, 17], [53, 6], [59, 28], [51, 52], [50, 24], [30, 18], [37, 42], [51, 30], [6, 37], [0, 41], [38, 30], [0, 24], [43, 38], [33, 2], [10, 21], [44, 33], [57, 29], [28, 45], [2, 27], [59, 38], [41, 28], [49, 61], [54, 23], [44, 32], [58, 33], [2, 43], [34, 39], [37, 28], [40, 56], [55, 59], [28, 43], [36, 36], [29, 41], [16, 35], [50, 33], [51, 4], [33, 11], [26, 17], [2, 49], [7, 18], [15, 60], [14, 47], [40, 16], [47, 19], [18, 43], [38, 53], [28, 10], [46, 12], [26, 48], [1, 45], [9, 45], [2, 12], [8, 55], [19, 24], [2, 10], [17, 38], [30, 48], [2, 13], [59, 22], [11, 39], [32, 47], [23, 26], [43, 25], [9, 34], [46, 30], [36, 32], [33, 36], [38, 54], [33, 14], [48, 46], [29, 53], [46, 60], [14, 10], [0, 3], [13, 39], [53, 53], [22, 16], [33, 31], [33, 13], [54, 51], [25, 34], [14, 33], [19, 56], [51, 10], [58, 43], [4, 20], [28, 54], [3, 34], [47, 45], [1, 58], [55, 43], [13, 21], [31, 46], [23, 57], [58, 15], [54, 36], [44, 7], [16, 52], [20, 40], [46, 18], [59, 19], [14, 44], [3, 4], [58, 52], [31, 42], [21, 17], [42, 18], [46, 57], [7, 35], [52, 4], [30, 11], [17, 14], [60, 10], [57, 59], [59, 46], [18, 15], [35, 27], [46, 31], [49, 18], [21, 23], [50, 25], [24, 59], [51, 26], [36, 34], [27, 17], [13, 16], [54, 56], [53, 13], [27, 25], [8, 33], [52, 7], [45, 61], [39, 0], [6, 51], [35, 23], [31, 5], [38, 33], [47, 58], [28, 61], [36, 0], [18, 30], [51, 11], [39, 51], [39, 36], [60, 37], [37, 43], [46, 42]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
modified_func def sat(tri: List[int], edges=wrap_list([wrap_list([wrap_int(51), wrap_int(44)]), wrap_list([wrap_int(11), wrap_int(59)]), wrap_list([wrap_int(57), wrap_int(15)]), wrap_list([wrap_int(18), wrap_int(1)]), wrap_list([wrap_int(41), wrap_int(1)]), wrap_list([wrap_int(44), wrap_int(6)]), wrap_list([wrap_int(58), wrap_int(44)]), wrap_list([wrap_int(43), wrap_int(10)]), wrap_list([wrap_int(41), wrap_int(9)]), wrap_list([wrap_int(50), wrap_int(43)]), wrap_list([wrap_int(56), wrap_int(0)]), wrap_list([wrap_int(47), wrap_int(4)]), wrap_list([wrap_int(42), wrap_int(45)]), wrap_list([wrap_int(51), wrap_int(15)]), wrap_list([wrap_int(60), wrap_int(18)]), wrap_list([wrap_int(11), wrap_int(56)]), wrap_list([wrap_int(21), wrap_int(45)]), wrap_list([wrap_int(39), wrap_int(42)]), wrap_list([wrap_int(57), wrap_int(34)]), wrap_list([wrap_int(60), wrap_int(25)]), wrap_list([wrap_int(57), wrap_int(33)]), wrap_list([wrap_int(6), wrap_int(17)]), wrap_list([wrap_int(26), wrap_int(43)]), wrap_list([wrap_int(38), wrap_int(25)]), wrap_list([wrap_int(29), wrap_int(18)]), wrap_list([wrap_int(39), wrap_int(43)]), wrap_list([wrap_int(34), wrap_int(4)]), wrap_list([wrap_int(22), wrap_int(61)]), wrap_list([wrap_int(0), wrap_int(9)]), wrap_list([wrap_int(1), wrap_int(20)]), wrap_list([wrap_int(36), wrap_int(28)]), wrap_list([wrap_int(10), wrap_int(37)]), wrap_list([wrap_int(53), wrap_int(7)]), wrap_list([wrap_int(49), wrap_int(60)]), wrap_list([wrap_int(12), wrap_int(48)]), wrap_list([wrap_int(31), wrap_int(33)]), wrap_list([wrap_int(4), wrap_int(8)]), wrap_list([wrap_int(5), wrap_int(56)]), wrap_list([wrap_int(27), wrap_int(59)]), wrap_list([wrap_int(56), wrap_int(29)]), wrap_list([wrap_int(60), wrap_int(17)]), wrap_list([wrap_int(17), wrap_int(27)]), wrap_list([wrap_int(24), wrap_int(58)]), wrap_list([wrap_int(46), wrap_int(47)]), wrap_list([wrap_int(60), wrap_int(35)]), wrap_list([wrap_int(4), wrap_int(37)]), wrap_list([wrap_int(41), wrap_int(43)]), wrap_list([wrap_int(37), wrap_int(33)]), wrap_list([wrap_int(30), wrap_int(7)]), wrap_list([wrap_int(53), wrap_int(31)]), wrap_list([wrap_int(3), wrap_int(60)]), wrap_list([wrap_int(24), wrap_int(39)]), wrap_list([wrap_int(14), wrap_int(41)]), wrap_list([wrap_int(14), wrap_int(54)]), wrap_list([wrap_int(33), wrap_int(35)]), wrap_list([wrap_int(50), wrap_int(1)]), wrap_list([wrap_int(60), wrap_int(57)]), wrap_list([wrap_int(23), wrap_int(17)]), wrap_list([wrap_int(34), wrap_int(15)]), wrap_list([wrap_int(60), wrap_int(26)]), wrap_list([wrap_int(22), wrap_int(0)]), wrap_list([wrap_int(5), wrap_int(4)]), wrap_list([wrap_int(8), wrap_int(41)]), wrap_list([wrap_int(16), wrap_int(4)]), wrap_list([wrap_int(56), wrap_int(40)]), wrap_list([wrap_int(60), wrap_int(44)]), wrap_list([wrap_int(2), wrap_int(26)]), wrap_list([wrap_int(42), wrap_int(21)]), wrap_list([wrap_int(21), wrap_int(28)]), wrap_list([wrap_int(58), wrap_int(32)]), wrap_list([wrap_int(58), wrap_int(12)]), wrap_list([wrap_int(31), wrap_int(22)]), wrap_list([wrap_int(43), wrap_int(0)]), wrap_list([wrap_int(28), wrap_int(3)]), wrap_list([wrap_int(35), wrap_int(21)]), wrap_list([wrap_int(54), wrap_int(18)]), wrap_list([wrap_int(0), wrap_int(58)]), wrap_list([wrap_int(3), wrap_int(9)]), wrap_list([wrap_int(6), wrap_int(59)]), wrap_list([wrap_int(57), wrap_int(46)]), wrap_list([wrap_int(48), wrap_int(45)]), wrap_list([wrap_int(30), wrap_int(12)]), wrap_list([wrap_int(46), wrap_int(27)]), wrap_list([wrap_int(41), wrap_int(55)]), wrap_list([wrap_int(52), wrap_int(58)]), wrap_list([wrap_int(30), wrap_int(21)]), wrap_list([wrap_int(51), wrap_int(24)]), wrap_list([wrap_int(23), wrap_int(18)]), wrap_list([wrap_int(31), wrap_int(59)]), wrap_list([wrap_int(34), wrap_int(49)]), wrap_list([wrap_int(41), wrap_int(34)]), wrap_list([wrap_int(19), wrap_int(58)]), wrap_list([wrap_int(1), wrap_int(32)]), wrap_list([wrap_int(52), wrap_int(16)]), wrap_list([wrap_int(17), wrap_int(8)]), wrap_list([wrap_int(20), wrap_int(3)]), wrap_list([wrap_int(56), wrap_int(12)]), wrap_list([wrap_int(3), wrap_int(51)]), wrap_list([wrap_int(60), wrap_int(31)]), wrap_list([wrap_int(41), wrap_int(5)]), wrap_list([wrap_int(58), wrap_int(23)]), wrap_list([wrap_int(59), wrap_int(6)]), wrap_list([wrap_int(39), wrap_int(2)]), wrap_list([wrap_int(6), wrap_int(6)]), wrap_list([wrap_int(11), wrap_int(38)]), wrap_list([wrap_int(3), wrap_int(44)]), wrap_list([wrap_int(61), wrap_int(58)]), wrap_list([wrap_int(13), wrap_int(46)]), wrap_list([wrap_int(56), wrap_int(1)]), wrap_list([wrap_int(35), wrap_int(14)]), wrap_list([wrap_int(25), wrap_int(7)]), wrap_list([wrap_int(29), wrap_int(60)]), wrap_list([wrap_int(16), wrap_int(32)]), wrap_list([wrap_int(32), wrap_int(32)]), wrap_list([wrap_int(7), wrap_int(44)]), wrap_list([wrap_int(3), wrap_int(48)]), wrap_list([wrap_int(38), wrap_int(21)]), wrap_list([wrap_int(19), wrap_int(43)]), wrap_list([wrap_int(60), wrap_int(4)]), wrap_list([wrap_int(56), wrap_int(56)]), wrap_list([wrap_int(21), wrap_int(33)]), wrap_list([wrap_int(15), wrap_int(11)]), wrap_list([wrap_int(32), wrap_int(0)]), wrap_list([wrap_int(8), wrap_int(10)]), wrap_list([wrap_int(44), wrap_int(11)]), wrap_list([wrap_int(37), wrap_int(36)]), wrap_list([wrap_int(24), wrap_int(28)]), wrap_list([wrap_int(4), wrap_int(23)]), wrap_list([wrap_int(37), wrap_int(22)]), wrap_list([wrap_int(44), wrap_int(4)]), wrap_list([wrap_int(34), wrap_int(28)]), wrap_list([wrap_int(1), wrap_int(7)]), wrap_list([wrap_int(15), wrap_int(48)]), wrap_list([wrap_int(11), wrap_int(20)]), wrap_list([wrap_int(60), wrap_int(13)]), wrap_list([wrap_int(7), wrap_int(30)]), wrap_list([wrap_int(51), wrap_int(18)]), wrap_list([wrap_int(3), wrap_int(56)]), wrap_list([wrap_int(14), wrap_int(57)]), wrap_list([wrap_int(14), wrap_int(22)]), wrap_list([wrap_int(55), wrap_int(13)]), wrap_list([wrap_int(47), wrap_int(50)]), wrap_list([wrap_int(36), wrap_int(14)]), wrap_list([wrap_int(42), wrap_int(46)]), wrap_list([wrap_int(7), wrap_int(29)]), wrap_list([wrap_int(58), wrap_int(36)]), wrap_list([wrap_int(52), wrap_int(49)]), wrap_list([wrap_int(33), wrap_int(4)]), wrap_list([wrap_int(51), wrap_int(51)]), wrap_list([wrap_int(47), wrap_int(55)]), wrap_list([wrap_int(7), wrap_int(60)]), wrap_list([wrap_int(4), wrap_int(17)]), wrap_list([wrap_int(53), wrap_int(6)]), wrap_list([wrap_int(59), wrap_int(28)]), wrap_list([wrap_int(51), wrap_int(52)]), wrap_list([wrap_int(50), wrap_int(24)]), wrap_list([wrap_int(30), wrap_int(18)]), wrap_list([wrap_int(37), wrap_int(42)]), wrap_list([wrap_int(51), wrap_int(30)]), wrap_list([wrap_int(6), wrap_int(37)]), wrap_list([wrap_int(0), wrap_int(41)]), wrap_list([wrap_int(38), wrap_int(30)]), wrap_list([wrap_int(0), wrap_int(24)]), wrap_list([wrap_int(43), wrap_int(38)]), wrap_list([wrap_int(33), wrap_int(2)]), wrap_list([wrap_int(10), wrap_int(21)]), wrap_list([wrap_int(44), wrap_int(33)]), wrap_list([wrap_int(57), wrap_int(29)]), wrap_list([wrap_int(28), wrap_int(45)]), wrap_list([wrap_int(2), wrap_int(27)]), wrap_list([wrap_int(59), wrap_int(38)]), wrap_list([wrap_int(41), wrap_int(28)]), wrap_list([wrap_int(49), wrap_int(61)]), wrap_list([wrap_int(54), wrap_int(23)]), wrap_list([wrap_int(44), wrap_int(32)]), wrap_list([wrap_int(58), wrap_int(33)]), wrap_list([wrap_int(2), wrap_int(43)]), wrap_list([wrap_int(34), wrap_int(39)]), wrap_list([wrap_int(37), wrap_int(28)]), wrap_list([wrap_int(40), wrap_int(56)]), wrap_list([wrap_int(55), wrap_int(59)]), wrap_list([wrap_int(28), wrap_int(43)]), wrap_list([wrap_int(36), wrap_int(36)]), wrap_list([wrap_int(29), wrap_int(41)]), wrap_list([wrap_int(16), wrap_int(35)]), wrap_list([wrap_int(50), wrap_int(33)]), wrap_list([wrap_int(51), wrap_int(4)]), wrap_list([wrap_int(33), wrap_int(11)]), wrap_list([wrap_int(26), wrap_int(17)]), wrap_list([wrap_int(2), wrap_int(49)]), wrap_list([wrap_int(7), wrap_int(18)]), wrap_list([wrap_int(15), wrap_int(60)]), wrap_list([wrap_int(14), wrap_int(47)]), wrap_list([wrap_int(40), wrap_int(16)]), wrap_list([wrap_int(47), wrap_int(19)]), wrap_list([wrap_int(18), wrap_int(43)]), wrap_list([wrap_int(38), wrap_int(53)]), wrap_list([wrap_int(28), wrap_int(10)]), wrap_list([wrap_int(46), wrap_int(12)]), wrap_list([wrap_int(26), wrap_int(48)]), wrap_list([wrap_int(1), wrap_int(45)]), wrap_list([wrap_int(9), wrap_int(45)]), wrap_list([wrap_int(2), wrap_int(12)]), wrap_list([wrap_int(8), wrap_int(55)]), wrap_list([wrap_int(19), wrap_int(24)]), wrap_list([wrap_int(2), wrap_int(10)]), wrap_list([wrap_int(17), wrap_int(38)]), wrap_list([wrap_int(30), wrap_int(48)]), wrap_list([wrap_int(2), wrap_int(13)]), wrap_list([wrap_int(59), wrap_int(22)]), wrap_list([wrap_int(11), wrap_int(39)]), wrap_list([wrap_int(32), wrap_int(47)]), wrap_list([wrap_int(23), wrap_int(26)]), wrap_list([wrap_int(43), wrap_int(25)]), wrap_list([wrap_int(9), wrap_int(34)]), wrap_list([wrap_int(46), wrap_int(30)]), wrap_list([wrap_int(36), wrap_int(32)]), wrap_list([wrap_int(33), wrap_int(36)]), wrap_list([wrap_int(38), wrap_int(54)]), wrap_list([wrap_int(33), wrap_int(14)]), wrap_list([wrap_int(48), wrap_int(46)]), wrap_list([wrap_int(29), wrap_int(53)]), wrap_list([wrap_int(46), wrap_int(60)]), wrap_list([wrap_int(14), wrap_int(10)]), wrap_list([wrap_int(0), wrap_int(3)]), wrap_list([wrap_int(13), wrap_int(39)]), wrap_list([wrap_int(53), wrap_int(53)]), wrap_list([wrap_int(22), wrap_int(16)]), wrap_list([wrap_int(33), wrap_int(31)]), wrap_list([wrap_int(33), wrap_int(13)]), wrap_list([wrap_int(54), wrap_int(51)]), wrap_list([wrap_int(25), wrap_int(34)]), wrap_list([wrap_int(14), wrap_int(33)]), wrap_list([wrap_int(19), wrap_int(56)]), wrap_list([wrap_int(51), wrap_int(10)]), wrap_list([wrap_int(58), wrap_int(43)]), wrap_list([wrap_int(4), wrap_int(20)]), wrap_list([wrap_int(28), wrap_int(54)]), wrap_list([wrap_int(3), wrap_int(34)]), wrap_list([wrap_int(47), wrap_int(45)]), wrap_list([wrap_int(1), wrap_int(58)]), wrap_list([wrap_int(55), wrap_int(43)]), wrap_list([wrap_int(13), wrap_int(21)]), wrap_list([wrap_int(31), wrap_int(46)]), wrap_list([wrap_int(23), wrap_int(57)]), wrap_list([wrap_int(58), wrap_int(15)]), wrap_list([wrap_int(54), wrap_int(36)]), wrap_list([wrap_int(44), wrap_int(7)]), wrap_list([wrap_int(16), wrap_int(52)]), wrap_list([wrap_int(20), wrap_int(40)]), wrap_list([wrap_int(46), wrap_int(18)]), wrap_list([wrap_int(59), wrap_int(19)]), wrap_list([wrap_int(14), wrap_int(44)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(58), wrap_int(52)]), wrap_list([wrap_int(31), wrap_int(42)]), wrap_list([wrap_int(21), wrap_int(17)]), wrap_list([wrap_int(42), wrap_int(18)]), wrap_list([wrap_int(46), wrap_int(57)]), wrap_list([wrap_int(7), wrap_int(35)]), wrap_list([wrap_int(52), wrap_int(4)]), wrap_list([wrap_int(30), wrap_int(11)]), wrap_list([wrap_int(17), wrap_int(14)]), wrap_list([wrap_int(60), wrap_int(10)]), wrap_list([wrap_int(57), wrap_int(59)]), wrap_list([wrap_int(59), wrap_int(46)]), wrap_list([wrap_int(18), wrap_int(15)]), wrap_list([wrap_int(35), wrap_int(27)]), wrap_list([wrap_int(46), wrap_int(31)]), wrap_list([wrap_int(49), wrap_int(18)]), wrap_list([wrap_int(21), wrap_int(23)]), wrap_list([wrap_int(50), wrap_int(25)]), wrap_list([wrap_int(24), wrap_int(59)]), wrap_list([wrap_int(51), wrap_int(26)]), wrap_list([wrap_int(36), wrap_int(34)]), wrap_list([wrap_int(27), wrap_int(17)]), wrap_list([wrap_int(13), wrap_int(16)]), wrap_list([wrap_int(54), wrap_int(56)]), wrap_list([wrap_int(53), wrap_int(13)]), wrap_list([wrap_int(27), wrap_int(25)]), wrap_list([wrap_int(8), wrap_int(33)]), wrap_list([wrap_int(52), wrap_int(7)]), wrap_list([wrap_int(45), wrap_int(61)]), wrap_list([wrap_int(39), wrap_int(0)]), wrap_list([wrap_int(6), wrap_int(51)]), wrap_list([wrap_int(35), wrap_int(23)]), wrap_list([wrap_int(31), wrap_int(5)]), wrap_list([wrap_int(38), wrap_int(33)]), wrap_list([wrap_int(47), wrap_int(58)]), wrap_list([wrap_int(28), wrap_int(61)]), wrap_list([wrap_int(36), wrap_int(0)]), wrap_list([wrap_int(18), wrap_int(30)]), wrap_list([wrap_int(51), wrap_int(11)]), wrap_list([wrap_int(39), wrap_int(51)]), wrap_list([wrap_int(39), wrap_int(36)]), wrap_list([wrap_int(60), wrap_int(37)]), wrap_list([wrap_int(37), wrap_int(43)]), wrap_list([wrap_int(46), wrap_int(42)])])):
    a, b, c = tri
    return sym_in(wrap_list([a, b]), edges).__and__(sym_in(wrap_list([b, c]), edges)).__and__(sym_in(wrap_list([c, a]), edges)).__and__((a != b).__and__(b != c).__and__(c != a))
Exception -- for puzzle AnyTriangle:2 not enough values to unpack (expected 3, got 1)

Solving puzzle 593/732: AnyTriangle:3
sat_func def sat(tri: List[int], edges=[[8, 0], [2, 7], [1, 2], [4, 5], [2, 1], [7, 1], [5, 6], [6, 3], [3, 8], [3, 4], [0, 1], [6, 6], [4, 0], [2, 8], [1, 5], [4, 2]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
modified_func def sat(tri: List[int], edges=wrap_list([wrap_list([wrap_int(8), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(4), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(1)]), wrap_list([wrap_int(7), wrap_int(1)]), wrap_list([wrap_int(5), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(3)]), wrap_list([wrap_int(3), wrap_int(8)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(6), wrap_int(6)]), wrap_list([wrap_int(4), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(8)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(4), wrap_int(2)])])):
    a, b, c = tri
    return sym_in(wrap_list([a, b]), edges).__and__(sym_in(wrap_list([b, c]), edges)).__and__(sym_in(wrap_list([c, a]), edges)).__and__((a != b).__and__(b != c).__and__(c != a))
Exception -- for puzzle AnyTriangle:3 not enough values to unpack (expected 3, got 1)

Solving puzzle 594/732: AnyTriangle:4
sat_func def sat(tri: List[int], edges=[[4, 4], [5, 5], [3, 5], [3, 1], [0, 1], [4, 0], [3, 2], [5, 3], [1, 3], [2, 5], [2, 0]]):
    a, b, c = tri
    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a
modified_func def sat(tri: List[int], edges=wrap_list([wrap_list([wrap_int(4), wrap_int(4)]), wrap_list([wrap_int(5), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(4), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(2)]), wrap_list([wrap_int(5), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(0)])])):
    a, b, c = tri
    return sym_in(wrap_list([a, b]), edges).__and__(sym_in(wrap_list([b, c]), edges)).__and__(sym_in(wrap_list([c, a]), edges)).__and__((a != b).__and__(b != c).__and__(c != a))
Exception -- for puzzle AnyTriangle:4 not enough values to unpack (expected 3, got 1)

Solving puzzle 595/732: PlantedClique:0
sat_func def sat(nodes: List[int], size=3, edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):
    assert len(nodes) == len(set(nodes)) >= size
    edge_set = {(a, b) for (a, b) in edges}
    for a in nodes:
        for b in nodes:
            assert a == b or (a, b) in edge_set or (b, a) in edge_set

    return True
modified_func def sat(nodes: List[int], size=wrap_int(3), edges=wrap_list([wrap_list([wrap_int(0), wrap_int(17)]), wrap_list([wrap_int(0), wrap_int(22)]), wrap_list([wrap_int(17), wrap_int(22)]), wrap_list([wrap_int(17), wrap_int(31)]), wrap_list([wrap_int(22), wrap_int(31)]), wrap_list([wrap_int(31), wrap_int(17)])])):
    _assert((sym_len(nodes) == sym_len(set(nodes))).__and__(sym_len(set(nodes)) >= size))
    edge_set = {(a, b) for a, b in edges}
    for a in nodes:
        for b in nodes:
            _assert((a == b).__or__(sym_in((a, b), edge_set)).__or__(sym_in((b, a), edge_set)))
    return True
Exception -- for puzzle PlantedClique:0 'set' object has no attribute 'contains'

Solving puzzle 596/732: PlantedClique:1
sat_func def sat(nodes: List[int], size=0, edges=[[1, 0]]):
    assert len(nodes) == len(set(nodes)) >= size
    edge_set = {(a, b) for (a, b) in edges}
    for a in nodes:
        for b in nodes:
            assert a == b or (a, b) in edge_set or (b, a) in edge_set

    return True
modified_func def sat(nodes: List[int], size=wrap_int(0), edges=wrap_list([wrap_list([wrap_int(1), wrap_int(0)])])):
    _assert((sym_len(nodes) == sym_len(set(nodes))).__and__(sym_len(set(nodes)) >= size))
    edge_set = {(a, b) for a, b in edges}
    for a in nodes:
        for b in nodes:
            _assert((a == b).__or__(sym_in((a, b), edge_set)).__or__(sym_in((b, a), edge_set)))
    return True
Exception -- for puzzle PlantedClique:1 'set' object has no attribute 'contains'

Solving puzzle 597/732: PlantedClique:2
sat_func def sat(nodes: List[int], size=15, edges=[[36, 31], [31, 39], [16, 41], [62, 39], [57, 38], [29, 46], [39, 30], [71, 41], [18, 0], [73, 71], [20, 23], [41, 53], [17, 12], [76, 23], [36, 29], [53, 32], [34, 61], [58, 29], [39, 46], [18, 73], [21, 51], [74, 26], [67, 10], [71, 74], [27, 71], [67, 39], [41, 26], [51, 20], [5, 2], [24, 3], [14, 60], [28, 21], [61, 1], [56, 75], [62, 37], [67, 41], [32, 69], [22, 16], [1, 67], [37, 14], [55, 40], [0, 58], [16, 63], [8, 59], [26, 61], [34, 51], [43, 66], [31, 33], [7, 51], [1, 0], [22, 9], [59, 68], [9, 10], [8, 74], [62, 8], [26, 16], [45, 69], [51, 52], [72, 67], [37, 53], [48, 5], [18, 41], [15, 11], [72, 43], [64, 51], [4, 9], [54, 42], [62, 15], [12, 38], [30, 31], [56, 37], [29, 2], [14, 9], [43, 43], [51, 28], [10, 15], [20, 5], [24, 61], [53, 2], [69, 1], [35, 63], [12, 64], [50, 12], [69, 65], [60, 75], [56, 48], [36, 67], [21, 6], [38, 67], [15, 34], [46, 54], [37, 18], [32, 2], [12, 49], [52, 15], [60, 2], [67, 43], [13, 49], [55, 59], [33, 72], [37, 30], [11, 27], [67, 2], [57, 55], [21, 65], [54, 66], [6, 63], [71, 59], [20, 59], [47, 34], [66, 67], [4, 8], [73, 61], [68, 41], [61, 7], [52, 38], [8, 51], [50, 15], [5, 12], [76, 74], [66, 33], [59, 18], [13, 55], [6, 16], [13, 26], [29, 44], [18, 43], [63, 47], [46, 30], [41, 18], [66, 18], [34, 26], [57, 28], [38, 10], [34, 57], [73, 41], [67, 3], [47, 57], [63, 62], [36, 30], [72, 45], [68, 19], [7, 28], [50, 23], [42, 29], [3, 66], [56, 45], [4, 25], [2, 43], [4, 38], [56, 74], [55, 10], [0, 13], [9, 19], [38, 69], [40, 57], [70, 41], [49, 45], [47, 27], [11, 8], [32, 5], [9, 38], [76, 64], [24, 33], [74, 63], [73, 58], [58, 41], [75, 0], [33, 55], [74, 2], [41, 72], [1, 64], [36, 74], [51, 71], [75, 9], [53, 36], [8, 70], [53, 42], [58, 25], [29, 37], [34, 46], [37, 39], [59, 61], [52, 20], [16, 58], [39, 43], [37, 40], [10, 72], [76, 14], [49, 13], [21, 37], [42, 2], [10, 29], [76, 19], [57, 66], [55, 62], [76, 53], [0, 0], [58, 5], [14, 2], [5, 32], [70, 57], [20, 18], [74, 66], [39, 57], [32, 36], [15, 30], [56, 23], [67, 16], [66, 51], [6, 74], [43, 59], [33, 70], [11, 71], [59, 28], [75, 29], [17, 13], [75, 67], [70, 1], [68, 10], [8, 46], [37, 27], [20, 24], [72, 75], [37, 41], [68, 24], [35, 10], [67, 66], [18, 24], [52, 3], [55, 34], [28, 75], [41, 3], [44, 3], [44, 30], [23, 17], [44, 4], [72, 73], [67, 12], [43, 21], [16, 55], [59, 71], [26, 62], [34, 60], [15, 22], [5, 10], [2, 55], [48, 15], [60, 34], [39, 35], [52, 36], [11, 46], [18, 10], [3, 43], [37, 6], [34, 47], [73, 29], [59, 29], [49, 72], [64, 73], [20, 76], [39, 39], [0, 16], [62, 73], [15, 36], [73, 18], [16, 34], [18, 68], [66, 45], [16, 66], [47, 52], [46, 66], [73, 43], [22, 55], [70, 58], [63, 11], [40, 2], [58, 60], [47, 29], [19, 45], [15, 41], [54, 5], [1, 18], [36, 38], [16, 19], [32, 4], [56, 14], [15, 51], [14, 35], [74, 10], [7, 20], [25, 38], [35, 13], [57, 34], [3, 16], [56, 28], [21, 56], [63, 65], [46, 35], [17, 57], [2, 30], [52, 73], [68, 73], [53, 10], [58, 59], [29, 16], [11, 20], [42, 27], [10, 66], [73, 5], [61, 58], [68, 67], [14, 47], [19, 59], [8, 42], [31, 12], [3, 2], [52, 66], [28, 72], [30, 56], [27, 12], [29, 18], [38, 56], [11, 17], [59, 66], [70, 7], [1, 54], [2, 16], [1, 14], [25, 20], [69, 72], [20, 74], [10, 59], [72, 52], [26, 15], [44, 42], [5, 51], [76, 69], [16, 10], [75, 39], [5, 44], [0, 46], [16, 76], [66, 73], [66, 72], [11, 11], [47, 13], [20, 26], [73, 59], [3, 10], [46, 49], [17, 38], [32, 62], [41, 2], [16, 72], [76, 61], [15, 37], [74, 69], [38, 46], [68, 58], [51, 70], [20, 46], [59, 2], [35, 21], [72, 37], [69, 20], [3, 72], [43, 71], [1, 71], [48, 59], [43, 58], [74, 5], [59, 72], [45, 24], [66, 69], [35, 38], [16, 5], [40, 24], [63, 30], [16, 18], [72, 29], [72, 58], [42, 5], [17, 30], [14, 21], [48, 23], [53, 44], [1, 47], [57, 33], [47, 69], [65, 52], [51, 44], [60, 35], [41, 9], [59, 75], [57, 73], [58, 28], [65, 23], [36, 48], [26, 40], [39, 41], [58, 3], [40, 42], [58, 49], [28, 42], [33, 36], [44, 24], [2, 68], [30, 57], [10, 51], [3, 68], [26, 42], [51, 13], [12, 69], [19, 60], [58, 39], [1, 45], [66, 16], [41, 27], [56, 1], [28, 18], [66, 29], [37, 49], [59, 4], [29, 67], [38, 29], [54, 57], [47, 61], [68, 29], [38, 9], [51, 41], [41, 10], [19, 61], [3, 22], [72, 23], [18, 11], [27, 17], [72, 74], [5, 37], [66, 68], [2, 3], [60, 27], [68, 72], [64, 20], [67, 18], [6, 66], [24, 60], [14, 75], [9, 11], [71, 50], [66, 43], [6, 60], [54, 22], [71, 53], [51, 7], [49, 40], [7, 74], [72, 30], [20, 71], [28, 74], [36, 55], [16, 17], [66, 2], [53, 8], [18, 2], [62, 63], [63, 26], [19, 34], [26, 27], [67, 51], [61, 46], [37, 29], [66, 41], [51, 54], [3, 17], [35, 6], [50, 51], [8, 15], [15, 55], [10, 65], [57, 59], [69, 21], [73, 70], [21, 30], [28, 28], [67, 59], [39, 76], [56, 12], [22, 69], [76, 7], [63, 66], [9, 40], [64, 28], [65, 31], [6, 59], [73, 73], [24, 29], [44, 18], [67, 1], [16, 12], [73, 2], [74, 27], [25, 58], [18, 52], [12, 66], [32, 25], [26, 4], [34, 27], [51, 39], [23, 11], [13, 65], [18, 28], [19, 6], [68, 59], [51, 72], [59, 74], [59, 3], [41, 29], [36, 6], [49, 37], [71, 39], [33, 13], [38, 68], [34, 19], [64, 36], [4, 29], [72, 60], [52, 41], [36, 66], [34, 70], [22, 32], [67, 40], [3, 73], [19, 12], [17, 0], [22, 8], [42, 35], [34, 54], [71, 29], [6, 7], [10, 43], [8, 56], [2, 58], [72, 2], [67, 65], [1, 23], [13, 21], [62, 38], [2, 66], [42, 62], [38, 27], [1, 22], [16, 29], [39, 54], [41, 0], [42, 54], [50, 58], [62, 45], [59, 76], [40, 44], [72, 18], [45, 40], [31, 3], [13, 45], [38, 64], [1, 21], [10, 32], [35, 12], [32, 6], [62, 75], [52, 59], [1, 42], [72, 31], [55, 17], [18, 50], [43, 29], [48, 37], [73, 16], [43, 68], [47, 12], [55, 46], [41, 30], [69, 32], [55, 14], [74, 61], [55, 72], [75, 24], [63, 40], [10, 58], [67, 73], [20, 11], [42, 40], [27, 53], [5, 8], [10, 2], [27, 49], [50, 48], [18, 58], [60, 25], [74, 71], [0, 30], [3, 29], [59, 5], [43, 16], [59, 41], [74, 4], [19, 20], [53, 19], [57, 50], [60, 11], [16, 68], [9, 50], [71, 17], [73, 66], [59, 43], [68, 32], [75, 31], [27, 56], [47, 24], [29, 7], [27, 25], [48, 36], [0, 53], [0, 72], [24, 53], [13, 64], [19, 44], [9, 56], [35, 75], [75, 17], [47, 16], [11, 42], [40, 45], [43, 60], [21, 59], [29, 50], [8, 9], [3, 18], [7, 57], [32, 9], [61, 6], [11, 6], [7, 72], [42, 61], [73, 75], [68, 44], [68, 66], [25, 56], [14, 20], [3, 50], [32, 57], [67, 58], [41, 68], [19, 26], [30, 3], [23, 45], [16, 60], [41, 43], [5, 30], [5, 25], [72, 16], [16, 73], [21, 17], [16, 59], [8, 34], [4, 39], [23, 72], [35, 53], [31, 50], [20, 44], [50, 13], [72, 1], [8, 8], [74, 54], [1, 1], [16, 43], [39, 36], [51, 2], [23, 54], [66, 58], [60, 33], [2, 63], [73, 10]]):
    assert len(nodes) == len(set(nodes)) >= size
    edge_set = {(a, b) for (a, b) in edges}
    for a in nodes:
        for b in nodes:
            assert a == b or (a, b) in edge_set or (b, a) in edge_set

    return True
modified_func def sat(nodes: List[int], size=wrap_int(15), edges=wrap_list([wrap_list([wrap_int(36), wrap_int(31)]), wrap_list([wrap_int(31), wrap_int(39)]), wrap_list([wrap_int(16), wrap_int(41)]), wrap_list([wrap_int(62), wrap_int(39)]), wrap_list([wrap_int(57), wrap_int(38)]), wrap_list([wrap_int(29), wrap_int(46)]), wrap_list([wrap_int(39), wrap_int(30)]), wrap_list([wrap_int(71), wrap_int(41)]), wrap_list([wrap_int(18), wrap_int(0)]), wrap_list([wrap_int(73), wrap_int(71)]), wrap_list([wrap_int(20), wrap_int(23)]), wrap_list([wrap_int(41), wrap_int(53)]), wrap_list([wrap_int(17), wrap_int(12)]), wrap_list([wrap_int(76), wrap_int(23)]), wrap_list([wrap_int(36), wrap_int(29)]), wrap_list([wrap_int(53), wrap_int(32)]), wrap_list([wrap_int(34), wrap_int(61)]), wrap_list([wrap_int(58), wrap_int(29)]), wrap_list([wrap_int(39), wrap_int(46)]), wrap_list([wrap_int(18), wrap_int(73)]), wrap_list([wrap_int(21), wrap_int(51)]), wrap_list([wrap_int(74), wrap_int(26)]), wrap_list([wrap_int(67), wrap_int(10)]), wrap_list([wrap_int(71), wrap_int(74)]), wrap_list([wrap_int(27), wrap_int(71)]), wrap_list([wrap_int(67), wrap_int(39)]), wrap_list([wrap_int(41), wrap_int(26)]), wrap_list([wrap_int(51), wrap_int(20)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(24), wrap_int(3)]), wrap_list([wrap_int(14), wrap_int(60)]), wrap_list([wrap_int(28), wrap_int(21)]), wrap_list([wrap_int(61), wrap_int(1)]), wrap_list([wrap_int(56), wrap_int(75)]), wrap_list([wrap_int(62), wrap_int(37)]), wrap_list([wrap_int(67), wrap_int(41)]), wrap_list([wrap_int(32), wrap_int(69)]), wrap_list([wrap_int(22), wrap_int(16)]), wrap_list([wrap_int(1), wrap_int(67)]), wrap_list([wrap_int(37), wrap_int(14)]), wrap_list([wrap_int(55), wrap_int(40)]), wrap_list([wrap_int(0), wrap_int(58)]), wrap_list([wrap_int(16), wrap_int(63)]), wrap_list([wrap_int(8), wrap_int(59)]), wrap_list([wrap_int(26), wrap_int(61)]), wrap_list([wrap_int(34), wrap_int(51)]), wrap_list([wrap_int(43), wrap_int(66)]), wrap_list([wrap_int(31), wrap_int(33)]), wrap_list([wrap_int(7), wrap_int(51)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(22), wrap_int(9)]), wrap_list([wrap_int(59), wrap_int(68)]), wrap_list([wrap_int(9), wrap_int(10)]), wrap_list([wrap_int(8), wrap_int(74)]), wrap_list([wrap_int(62), wrap_int(8)]), wrap_list([wrap_int(26), wrap_int(16)]), wrap_list([wrap_int(45), wrap_int(69)]), wrap_list([wrap_int(51), wrap_int(52)]), wrap_list([wrap_int(72), wrap_int(67)]), wrap_list([wrap_int(37), wrap_int(53)]), wrap_list([wrap_int(48), wrap_int(5)]), wrap_list([wrap_int(18), wrap_int(41)]), wrap_list([wrap_int(15), wrap_int(11)]), wrap_list([wrap_int(72), wrap_int(43)]), wrap_list([wrap_int(64), wrap_int(51)]), wrap_list([wrap_int(4), wrap_int(9)]), wrap_list([wrap_int(54), wrap_int(42)]), wrap_list([wrap_int(62), wrap_int(15)]), wrap_list([wrap_int(12), wrap_int(38)]), wrap_list([wrap_int(30), wrap_int(31)]), wrap_list([wrap_int(56), wrap_int(37)]), wrap_list([wrap_int(29), wrap_int(2)]), wrap_list([wrap_int(14), wrap_int(9)]), wrap_list([wrap_int(43), wrap_int(43)]), wrap_list([wrap_int(51), wrap_int(28)]), wrap_list([wrap_int(10), wrap_int(15)]), wrap_list([wrap_int(20), wrap_int(5)]), wrap_list([wrap_int(24), wrap_int(61)]), wrap_list([wrap_int(53), wrap_int(2)]), wrap_list([wrap_int(69), wrap_int(1)]), wrap_list([wrap_int(35), wrap_int(63)]), wrap_list([wrap_int(12), wrap_int(64)]), wrap_list([wrap_int(50), wrap_int(12)]), wrap_list([wrap_int(69), wrap_int(65)]), wrap_list([wrap_int(60), wrap_int(75)]), wrap_list([wrap_int(56), wrap_int(48)]), wrap_list([wrap_int(36), wrap_int(67)]), wrap_list([wrap_int(21), wrap_int(6)]), wrap_list([wrap_int(38), wrap_int(67)]), wrap_list([wrap_int(15), wrap_int(34)]), wrap_list([wrap_int(46), wrap_int(54)]), wrap_list([wrap_int(37), wrap_int(18)]), wrap_list([wrap_int(32), wrap_int(2)]), wrap_list([wrap_int(12), wrap_int(49)]), wrap_list([wrap_int(52), wrap_int(15)]), wrap_list([wrap_int(60), wrap_int(2)]), wrap_list([wrap_int(67), wrap_int(43)]), wrap_list([wrap_int(13), wrap_int(49)]), wrap_list([wrap_int(55), wrap_int(59)]), wrap_list([wrap_int(33), wrap_int(72)]), wrap_list([wrap_int(37), wrap_int(30)]), wrap_list([wrap_int(11), wrap_int(27)]), wrap_list([wrap_int(67), wrap_int(2)]), wrap_list([wrap_int(57), wrap_int(55)]), wrap_list([wrap_int(21), wrap_int(65)]), wrap_list([wrap_int(54), wrap_int(66)]), wrap_list([wrap_int(6), wrap_int(63)]), wrap_list([wrap_int(71), wrap_int(59)]), wrap_list([wrap_int(20), wrap_int(59)]), wrap_list([wrap_int(47), wrap_int(34)]), wrap_list([wrap_int(66), wrap_int(67)]), wrap_list([wrap_int(4), wrap_int(8)]), wrap_list([wrap_int(73), wrap_int(61)]), wrap_list([wrap_int(68), wrap_int(41)]), wrap_list([wrap_int(61), wrap_int(7)]), wrap_list([wrap_int(52), wrap_int(38)]), wrap_list([wrap_int(8), wrap_int(51)]), wrap_list([wrap_int(50), wrap_int(15)]), wrap_list([wrap_int(5), wrap_int(12)]), wrap_list([wrap_int(76), wrap_int(74)]), wrap_list([wrap_int(66), wrap_int(33)]), wrap_list([wrap_int(59), wrap_int(18)]), wrap_list([wrap_int(13), wrap_int(55)]), wrap_list([wrap_int(6), wrap_int(16)]), wrap_list([wrap_int(13), wrap_int(26)]), wrap_list([wrap_int(29), wrap_int(44)]), wrap_list([wrap_int(18), wrap_int(43)]), wrap_list([wrap_int(63), wrap_int(47)]), wrap_list([wrap_int(46), wrap_int(30)]), wrap_list([wrap_int(41), wrap_int(18)]), wrap_list([wrap_int(66), wrap_int(18)]), wrap_list([wrap_int(34), wrap_int(26)]), wrap_list([wrap_int(57), wrap_int(28)]), wrap_list([wrap_int(38), wrap_int(10)]), wrap_list([wrap_int(34), wrap_int(57)]), wrap_list([wrap_int(73), wrap_int(41)]), wrap_list([wrap_int(67), wrap_int(3)]), wrap_list([wrap_int(47), wrap_int(57)]), wrap_list([wrap_int(63), wrap_int(62)]), wrap_list([wrap_int(36), wrap_int(30)]), wrap_list([wrap_int(72), wrap_int(45)]), wrap_list([wrap_int(68), wrap_int(19)]), wrap_list([wrap_int(7), wrap_int(28)]), wrap_list([wrap_int(50), wrap_int(23)]), wrap_list([wrap_int(42), wrap_int(29)]), wrap_list([wrap_int(3), wrap_int(66)]), wrap_list([wrap_int(56), wrap_int(45)]), wrap_list([wrap_int(4), wrap_int(25)]), wrap_list([wrap_int(2), wrap_int(43)]), wrap_list([wrap_int(4), wrap_int(38)]), wrap_list([wrap_int(56), wrap_int(74)]), wrap_list([wrap_int(55), wrap_int(10)]), wrap_list([wrap_int(0), wrap_int(13)]), wrap_list([wrap_int(9), wrap_int(19)]), wrap_list([wrap_int(38), wrap_int(69)]), wrap_list([wrap_int(40), wrap_int(57)]), wrap_list([wrap_int(70), wrap_int(41)]), wrap_list([wrap_int(49), wrap_int(45)]), wrap_list([wrap_int(47), wrap_int(27)]), wrap_list([wrap_int(11), wrap_int(8)]), wrap_list([wrap_int(32), wrap_int(5)]), wrap_list([wrap_int(9), wrap_int(38)]), wrap_list([wrap_int(76), wrap_int(64)]), wrap_list([wrap_int(24), wrap_int(33)]), wrap_list([wrap_int(74), wrap_int(63)]), wrap_list([wrap_int(73), wrap_int(58)]), wrap_list([wrap_int(58), wrap_int(41)]), wrap_list([wrap_int(75), wrap_int(0)]), wrap_list([wrap_int(33), wrap_int(55)]), wrap_list([wrap_int(74), wrap_int(2)]), wrap_list([wrap_int(41), wrap_int(72)]), wrap_list([wrap_int(1), wrap_int(64)]), wrap_list([wrap_int(36), wrap_int(74)]), wrap_list([wrap_int(51), wrap_int(71)]), wrap_list([wrap_int(75), wrap_int(9)]), wrap_list([wrap_int(53), wrap_int(36)]), wrap_list([wrap_int(8), wrap_int(70)]), wrap_list([wrap_int(53), wrap_int(42)]), wrap_list([wrap_int(58), wrap_int(25)]), wrap_list([wrap_int(29), wrap_int(37)]), wrap_list([wrap_int(34), wrap_int(46)]), wrap_list([wrap_int(37), wrap_int(39)]), wrap_list([wrap_int(59), wrap_int(61)]), wrap_list([wrap_int(52), wrap_int(20)]), wrap_list([wrap_int(16), wrap_int(58)]), wrap_list([wrap_int(39), wrap_int(43)]), wrap_list([wrap_int(37), wrap_int(40)]), wrap_list([wrap_int(10), wrap_int(72)]), wrap_list([wrap_int(76), wrap_int(14)]), wrap_list([wrap_int(49), wrap_int(13)]), wrap_list([wrap_int(21), wrap_int(37)]), wrap_list([wrap_int(42), wrap_int(2)]), wrap_list([wrap_int(10), wrap_int(29)]), wrap_list([wrap_int(76), wrap_int(19)]), wrap_list([wrap_int(57), wrap_int(66)]), wrap_list([wrap_int(55), wrap_int(62)]), wrap_list([wrap_int(76), wrap_int(53)]), wrap_list([wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(58), wrap_int(5)]), wrap_list([wrap_int(14), wrap_int(2)]), wrap_list([wrap_int(5), wrap_int(32)]), wrap_list([wrap_int(70), wrap_int(57)]), wrap_list([wrap_int(20), wrap_int(18)]), wrap_list([wrap_int(74), wrap_int(66)]), wrap_list([wrap_int(39), wrap_int(57)]), wrap_list([wrap_int(32), wrap_int(36)]), wrap_list([wrap_int(15), wrap_int(30)]), wrap_list([wrap_int(56), wrap_int(23)]), wrap_list([wrap_int(67), wrap_int(16)]), wrap_list([wrap_int(66), wrap_int(51)]), wrap_list([wrap_int(6), wrap_int(74)]), wrap_list([wrap_int(43), wrap_int(59)]), wrap_list([wrap_int(33), wrap_int(70)]), wrap_list([wrap_int(11), wrap_int(71)]), wrap_list([wrap_int(59), wrap_int(28)]), wrap_list([wrap_int(75), wrap_int(29)]), wrap_list([wrap_int(17), wrap_int(13)]), wrap_list([wrap_int(75), wrap_int(67)]), wrap_list([wrap_int(70), wrap_int(1)]), wrap_list([wrap_int(68), wrap_int(10)]), wrap_list([wrap_int(8), wrap_int(46)]), wrap_list([wrap_int(37), wrap_int(27)]), wrap_list([wrap_int(20), wrap_int(24)]), wrap_list([wrap_int(72), wrap_int(75)]), wrap_list([wrap_int(37), wrap_int(41)]), wrap_list([wrap_int(68), wrap_int(24)]), wrap_list([wrap_int(35), wrap_int(10)]), wrap_list([wrap_int(67), wrap_int(66)]), wrap_list([wrap_int(18), wrap_int(24)]), wrap_list([wrap_int(52), wrap_int(3)]), wrap_list([wrap_int(55), wrap_int(34)]), wrap_list([wrap_int(28), wrap_int(75)]), wrap_list([wrap_int(41), wrap_int(3)]), wrap_list([wrap_int(44), wrap_int(3)]), wrap_list([wrap_int(44), wrap_int(30)]), wrap_list([wrap_int(23), wrap_int(17)]), wrap_list([wrap_int(44), wrap_int(4)]), wrap_list([wrap_int(72), wrap_int(73)]), wrap_list([wrap_int(67), wrap_int(12)]), wrap_list([wrap_int(43), wrap_int(21)]), wrap_list([wrap_int(16), wrap_int(55)]), wrap_list([wrap_int(59), wrap_int(71)]), wrap_list([wrap_int(26), wrap_int(62)]), wrap_list([wrap_int(34), wrap_int(60)]), wrap_list([wrap_int(15), wrap_int(22)]), wrap_list([wrap_int(5), wrap_int(10)]), wrap_list([wrap_int(2), wrap_int(55)]), wrap_list([wrap_int(48), wrap_int(15)]), wrap_list([wrap_int(60), wrap_int(34)]), wrap_list([wrap_int(39), wrap_int(35)]), wrap_list([wrap_int(52), wrap_int(36)]), wrap_list([wrap_int(11), wrap_int(46)]), wrap_list([wrap_int(18), wrap_int(10)]), wrap_list([wrap_int(3), wrap_int(43)]), wrap_list([wrap_int(37), wrap_int(6)]), wrap_list([wrap_int(34), wrap_int(47)]), wrap_list([wrap_int(73), wrap_int(29)]), wrap_list([wrap_int(59), wrap_int(29)]), wrap_list([wrap_int(49), wrap_int(72)]), wrap_list([wrap_int(64), wrap_int(73)]), wrap_list([wrap_int(20), wrap_int(76)]), wrap_list([wrap_int(39), wrap_int(39)]), wrap_list([wrap_int(0), wrap_int(16)]), wrap_list([wrap_int(62), wrap_int(73)]), wrap_list([wrap_int(15), wrap_int(36)]), wrap_list([wrap_int(73), wrap_int(18)]), wrap_list([wrap_int(16), wrap_int(34)]), wrap_list([wrap_int(18), wrap_int(68)]), wrap_list([wrap_int(66), wrap_int(45)]), wrap_list([wrap_int(16), wrap_int(66)]), wrap_list([wrap_int(47), wrap_int(52)]), wrap_list([wrap_int(46), wrap_int(66)]), wrap_list([wrap_int(73), wrap_int(43)]), wrap_list([wrap_int(22), wrap_int(55)]), wrap_list([wrap_int(70), wrap_int(58)]), wrap_list([wrap_int(63), wrap_int(11)]), wrap_list([wrap_int(40), wrap_int(2)]), wrap_list([wrap_int(58), wrap_int(60)]), wrap_list([wrap_int(47), wrap_int(29)]), wrap_list([wrap_int(19), wrap_int(45)]), wrap_list([wrap_int(15), wrap_int(41)]), wrap_list([wrap_int(54), wrap_int(5)]), wrap_list([wrap_int(1), wrap_int(18)]), wrap_list([wrap_int(36), wrap_int(38)]), wrap_list([wrap_int(16), wrap_int(19)]), wrap_list([wrap_int(32), wrap_int(4)]), wrap_list([wrap_int(56), wrap_int(14)]), wrap_list([wrap_int(15), wrap_int(51)]), wrap_list([wrap_int(14), wrap_int(35)]), wrap_list([wrap_int(74), wrap_int(10)]), wrap_list([wrap_int(7), wrap_int(20)]), wrap_list([wrap_int(25), wrap_int(38)]), wrap_list([wrap_int(35), wrap_int(13)]), wrap_list([wrap_int(57), wrap_int(34)]), wrap_list([wrap_int(3), wrap_int(16)]), wrap_list([wrap_int(56), wrap_int(28)]), wrap_list([wrap_int(21), wrap_int(56)]), wrap_list([wrap_int(63), wrap_int(65)]), wrap_list([wrap_int(46), wrap_int(35)]), wrap_list([wrap_int(17), wrap_int(57)]), wrap_list([wrap_int(2), wrap_int(30)]), wrap_list([wrap_int(52), wrap_int(73)]), wrap_list([wrap_int(68), wrap_int(73)]), wrap_list([wrap_int(53), wrap_int(10)]), wrap_list([wrap_int(58), wrap_int(59)]), wrap_list([wrap_int(29), wrap_int(16)]), wrap_list([wrap_int(11), wrap_int(20)]), wrap_list([wrap_int(42), wrap_int(27)]), wrap_list([wrap_int(10), wrap_int(66)]), wrap_list([wrap_int(73), wrap_int(5)]), wrap_list([wrap_int(61), wrap_int(58)]), wrap_list([wrap_int(68), wrap_int(67)]), wrap_list([wrap_int(14), wrap_int(47)]), wrap_list([wrap_int(19), wrap_int(59)]), wrap_list([wrap_int(8), wrap_int(42)]), wrap_list([wrap_int(31), wrap_int(12)]), wrap_list([wrap_int(3), wrap_int(2)]), wrap_list([wrap_int(52), wrap_int(66)]), wrap_list([wrap_int(28), wrap_int(72)]), wrap_list([wrap_int(30), wrap_int(56)]), wrap_list([wrap_int(27), wrap_int(12)]), wrap_list([wrap_int(29), wrap_int(18)]), wrap_list([wrap_int(38), wrap_int(56)]), wrap_list([wrap_int(11), wrap_int(17)]), wrap_list([wrap_int(59), wrap_int(66)]), wrap_list([wrap_int(70), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(54)]), wrap_list([wrap_int(2), wrap_int(16)]), wrap_list([wrap_int(1), wrap_int(14)]), wrap_list([wrap_int(25), wrap_int(20)]), wrap_list([wrap_int(69), wrap_int(72)]), wrap_list([wrap_int(20), wrap_int(74)]), wrap_list([wrap_int(10), wrap_int(59)]), wrap_list([wrap_int(72), wrap_int(52)]), wrap_list([wrap_int(26), wrap_int(15)]), wrap_list([wrap_int(44), wrap_int(42)]), wrap_list([wrap_int(5), wrap_int(51)]), wrap_list([wrap_int(76), wrap_int(69)]), wrap_list([wrap_int(16), wrap_int(10)]), wrap_list([wrap_int(75), wrap_int(39)]), wrap_list([wrap_int(5), wrap_int(44)]), wrap_list([wrap_int(0), wrap_int(46)]), wrap_list([wrap_int(16), wrap_int(76)]), wrap_list([wrap_int(66), wrap_int(73)]), wrap_list([wrap_int(66), wrap_int(72)]), wrap_list([wrap_int(11), wrap_int(11)]), wrap_list([wrap_int(47), wrap_int(13)]), wrap_list([wrap_int(20), wrap_int(26)]), wrap_list([wrap_int(73), wrap_int(59)]), wrap_list([wrap_int(3), wrap_int(10)]), wrap_list([wrap_int(46), wrap_int(49)]), wrap_list([wrap_int(17), wrap_int(38)]), wrap_list([wrap_int(32), wrap_int(62)]), wrap_list([wrap_int(41), wrap_int(2)]), wrap_list([wrap_int(16), wrap_int(72)]), wrap_list([wrap_int(76), wrap_int(61)]), wrap_list([wrap_int(15), wrap_int(37)]), wrap_list([wrap_int(74), wrap_int(69)]), wrap_list([wrap_int(38), wrap_int(46)]), wrap_list([wrap_int(68), wrap_int(58)]), wrap_list([wrap_int(51), wrap_int(70)]), wrap_list([wrap_int(20), wrap_int(46)]), wrap_list([wrap_int(59), wrap_int(2)]), wrap_list([wrap_int(35), wrap_int(21)]), wrap_list([wrap_int(72), wrap_int(37)]), wrap_list([wrap_int(69), wrap_int(20)]), wrap_list([wrap_int(3), wrap_int(72)]), wrap_list([wrap_int(43), wrap_int(71)]), wrap_list([wrap_int(1), wrap_int(71)]), wrap_list([wrap_int(48), wrap_int(59)]), wrap_list([wrap_int(43), wrap_int(58)]), wrap_list([wrap_int(74), wrap_int(5)]), wrap_list([wrap_int(59), wrap_int(72)]), wrap_list([wrap_int(45), wrap_int(24)]), wrap_list([wrap_int(66), wrap_int(69)]), wrap_list([wrap_int(35), wrap_int(38)]), wrap_list([wrap_int(16), wrap_int(5)]), wrap_list([wrap_int(40), wrap_int(24)]), wrap_list([wrap_int(63), wrap_int(30)]), wrap_list([wrap_int(16), wrap_int(18)]), wrap_list([wrap_int(72), wrap_int(29)]), wrap_list([wrap_int(72), wrap_int(58)]), wrap_list([wrap_int(42), wrap_int(5)]), wrap_list([wrap_int(17), wrap_int(30)]), wrap_list([wrap_int(14), wrap_int(21)]), wrap_list([wrap_int(48), wrap_int(23)]), wrap_list([wrap_int(53), wrap_int(44)]), wrap_list([wrap_int(1), wrap_int(47)]), wrap_list([wrap_int(57), wrap_int(33)]), wrap_list([wrap_int(47), wrap_int(69)]), wrap_list([wrap_int(65), wrap_int(52)]), wrap_list([wrap_int(51), wrap_int(44)]), wrap_list([wrap_int(60), wrap_int(35)]), wrap_list([wrap_int(41), wrap_int(9)]), wrap_list([wrap_int(59), wrap_int(75)]), wrap_list([wrap_int(57), wrap_int(73)]), wrap_list([wrap_int(58), wrap_int(28)]), wrap_list([wrap_int(65), wrap_int(23)]), wrap_list([wrap_int(36), wrap_int(48)]), wrap_list([wrap_int(26), wrap_int(40)]), wrap_list([wrap_int(39), wrap_int(41)]), wrap_list([wrap_int(58), wrap_int(3)]), wrap_list([wrap_int(40), wrap_int(42)]), wrap_list([wrap_int(58), wrap_int(49)]), wrap_list([wrap_int(28), wrap_int(42)]), wrap_list([wrap_int(33), wrap_int(36)]), wrap_list([wrap_int(44), wrap_int(24)]), wrap_list([wrap_int(2), wrap_int(68)]), wrap_list([wrap_int(30), wrap_int(57)]), wrap_list([wrap_int(10), wrap_int(51)]), wrap_list([wrap_int(3), wrap_int(68)]), wrap_list([wrap_int(26), wrap_int(42)]), wrap_list([wrap_int(51), wrap_int(13)]), wrap_list([wrap_int(12), wrap_int(69)]), wrap_list([wrap_int(19), wrap_int(60)]), wrap_list([wrap_int(58), wrap_int(39)]), wrap_list([wrap_int(1), wrap_int(45)]), wrap_list([wrap_int(66), wrap_int(16)]), wrap_list([wrap_int(41), wrap_int(27)]), wrap_list([wrap_int(56), wrap_int(1)]), wrap_list([wrap_int(28), wrap_int(18)]), wrap_list([wrap_int(66), wrap_int(29)]), wrap_list([wrap_int(37), wrap_int(49)]), wrap_list([wrap_int(59), wrap_int(4)]), wrap_list([wrap_int(29), wrap_int(67)]), wrap_list([wrap_int(38), wrap_int(29)]), wrap_list([wrap_int(54), wrap_int(57)]), wrap_list([wrap_int(47), wrap_int(61)]), wrap_list([wrap_int(68), wrap_int(29)]), wrap_list([wrap_int(38), wrap_int(9)]), wrap_list([wrap_int(51), wrap_int(41)]), wrap_list([wrap_int(41), wrap_int(10)]), wrap_list([wrap_int(19), wrap_int(61)]), wrap_list([wrap_int(3), wrap_int(22)]), wrap_list([wrap_int(72), wrap_int(23)]), wrap_list([wrap_int(18), wrap_int(11)]), wrap_list([wrap_int(27), wrap_int(17)]), wrap_list([wrap_int(72), wrap_int(74)]), wrap_list([wrap_int(5), wrap_int(37)]), wrap_list([wrap_int(66), wrap_int(68)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(60), wrap_int(27)]), wrap_list([wrap_int(68), wrap_int(72)]), wrap_list([wrap_int(64), wrap_int(20)]), wrap_list([wrap_int(67), wrap_int(18)]), wrap_list([wrap_int(6), wrap_int(66)]), wrap_list([wrap_int(24), wrap_int(60)]), wrap_list([wrap_int(14), wrap_int(75)]), wrap_list([wrap_int(9), wrap_int(11)]), wrap_list([wrap_int(71), wrap_int(50)]), wrap_list([wrap_int(66), wrap_int(43)]), wrap_list([wrap_int(6), wrap_int(60)]), wrap_list([wrap_int(54), wrap_int(22)]), wrap_list([wrap_int(71), wrap_int(53)]), wrap_list([wrap_int(51), wrap_int(7)]), wrap_list([wrap_int(49), wrap_int(40)]), wrap_list([wrap_int(7), wrap_int(74)]), wrap_list([wrap_int(72), wrap_int(30)]), wrap_list([wrap_int(20), wrap_int(71)]), wrap_list([wrap_int(28), wrap_int(74)]), wrap_list([wrap_int(36), wrap_int(55)]), wrap_list([wrap_int(16), wrap_int(17)]), wrap_list([wrap_int(66), wrap_int(2)]), wrap_list([wrap_int(53), wrap_int(8)]), wrap_list([wrap_int(18), wrap_int(2)]), wrap_list([wrap_int(62), wrap_int(63)]), wrap_list([wrap_int(63), wrap_int(26)]), wrap_list([wrap_int(19), wrap_int(34)]), wrap_list([wrap_int(26), wrap_int(27)]), wrap_list([wrap_int(67), wrap_int(51)]), wrap_list([wrap_int(61), wrap_int(46)]), wrap_list([wrap_int(37), wrap_int(29)]), wrap_list([wrap_int(66), wrap_int(41)]), wrap_list([wrap_int(51), wrap_int(54)]), wrap_list([wrap_int(3), wrap_int(17)]), wrap_list([wrap_int(35), wrap_int(6)]), wrap_list([wrap_int(50), wrap_int(51)]), wrap_list([wrap_int(8), wrap_int(15)]), wrap_list([wrap_int(15), wrap_int(55)]), wrap_list([wrap_int(10), wrap_int(65)]), wrap_list([wrap_int(57), wrap_int(59)]), wrap_list([wrap_int(69), wrap_int(21)]), wrap_list([wrap_int(73), wrap_int(70)]), wrap_list([wrap_int(21), wrap_int(30)]), wrap_list([wrap_int(28), wrap_int(28)]), wrap_list([wrap_int(67), wrap_int(59)]), wrap_list([wrap_int(39), wrap_int(76)]), wrap_list([wrap_int(56), wrap_int(12)]), wrap_list([wrap_int(22), wrap_int(69)]), wrap_list([wrap_int(76), wrap_int(7)]), wrap_list([wrap_int(63), wrap_int(66)]), wrap_list([wrap_int(9), wrap_int(40)]), wrap_list([wrap_int(64), wrap_int(28)]), wrap_list([wrap_int(65), wrap_int(31)]), wrap_list([wrap_int(6), wrap_int(59)]), wrap_list([wrap_int(73), wrap_int(73)]), wrap_list([wrap_int(24), wrap_int(29)]), wrap_list([wrap_int(44), wrap_int(18)]), wrap_list([wrap_int(67), wrap_int(1)]), wrap_list([wrap_int(16), wrap_int(12)]), wrap_list([wrap_int(73), wrap_int(2)]), wrap_list([wrap_int(74), wrap_int(27)]), wrap_list([wrap_int(25), wrap_int(58)]), wrap_list([wrap_int(18), wrap_int(52)]), wrap_list([wrap_int(12), wrap_int(66)]), wrap_list([wrap_int(32), wrap_int(25)]), wrap_list([wrap_int(26), wrap_int(4)]), wrap_list([wrap_int(34), wrap_int(27)]), wrap_list([wrap_int(51), wrap_int(39)]), wrap_list([wrap_int(23), wrap_int(11)]), wrap_list([wrap_int(13), wrap_int(65)]), wrap_list([wrap_int(18), wrap_int(28)]), wrap_list([wrap_int(19), wrap_int(6)]), wrap_list([wrap_int(68), wrap_int(59)]), wrap_list([wrap_int(51), wrap_int(72)]), wrap_list([wrap_int(59), wrap_int(74)]), wrap_list([wrap_int(59), wrap_int(3)]), wrap_list([wrap_int(41), wrap_int(29)]), wrap_list([wrap_int(36), wrap_int(6)]), wrap_list([wrap_int(49), wrap_int(37)]), wrap_list([wrap_int(71), wrap_int(39)]), wrap_list([wrap_int(33), wrap_int(13)]), wrap_list([wrap_int(38), wrap_int(68)]), wrap_list([wrap_int(34), wrap_int(19)]), wrap_list([wrap_int(64), wrap_int(36)]), wrap_list([wrap_int(4), wrap_int(29)]), wrap_list([wrap_int(72), wrap_int(60)]), wrap_list([wrap_int(52), wrap_int(41)]), wrap_list([wrap_int(36), wrap_int(66)]), wrap_list([wrap_int(34), wrap_int(70)]), wrap_list([wrap_int(22), wrap_int(32)]), wrap_list([wrap_int(67), wrap_int(40)]), wrap_list([wrap_int(3), wrap_int(73)]), wrap_list([wrap_int(19), wrap_int(12)]), wrap_list([wrap_int(17), wrap_int(0)]), wrap_list([wrap_int(22), wrap_int(8)]), wrap_list([wrap_int(42), wrap_int(35)]), wrap_list([wrap_int(34), wrap_int(54)]), wrap_list([wrap_int(71), wrap_int(29)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(10), wrap_int(43)]), wrap_list([wrap_int(8), wrap_int(56)]), wrap_list([wrap_int(2), wrap_int(58)]), wrap_list([wrap_int(72), wrap_int(2)]), wrap_list([wrap_int(67), wrap_int(65)]), wrap_list([wrap_int(1), wrap_int(23)]), wrap_list([wrap_int(13), wrap_int(21)]), wrap_list([wrap_int(62), wrap_int(38)]), wrap_list([wrap_int(2), wrap_int(66)]), wrap_list([wrap_int(42), wrap_int(62)]), wrap_list([wrap_int(38), wrap_int(27)]), wrap_list([wrap_int(1), wrap_int(22)]), wrap_list([wrap_int(16), wrap_int(29)]), wrap_list([wrap_int(39), wrap_int(54)]), wrap_list([wrap_int(41), wrap_int(0)]), wrap_list([wrap_int(42), wrap_int(54)]), wrap_list([wrap_int(50), wrap_int(58)]), wrap_list([wrap_int(62), wrap_int(45)]), wrap_list([wrap_int(59), wrap_int(76)]), wrap_list([wrap_int(40), wrap_int(44)]), wrap_list([wrap_int(72), wrap_int(18)]), wrap_list([wrap_int(45), wrap_int(40)]), wrap_list([wrap_int(31), wrap_int(3)]), wrap_list([wrap_int(13), wrap_int(45)]), wrap_list([wrap_int(38), wrap_int(64)]), wrap_list([wrap_int(1), wrap_int(21)]), wrap_list([wrap_int(10), wrap_int(32)]), wrap_list([wrap_int(35), wrap_int(12)]), wrap_list([wrap_int(32), wrap_int(6)]), wrap_list([wrap_int(62), wrap_int(75)]), wrap_list([wrap_int(52), wrap_int(59)]), wrap_list([wrap_int(1), wrap_int(42)]), wrap_list([wrap_int(72), wrap_int(31)]), wrap_list([wrap_int(55), wrap_int(17)]), wrap_list([wrap_int(18), wrap_int(50)]), wrap_list([wrap_int(43), wrap_int(29)]), wrap_list([wrap_int(48), wrap_int(37)]), wrap_list([wrap_int(73), wrap_int(16)]), wrap_list([wrap_int(43), wrap_int(68)]), wrap_list([wrap_int(47), wrap_int(12)]), wrap_list([wrap_int(55), wrap_int(46)]), wrap_list([wrap_int(41), wrap_int(30)]), wrap_list([wrap_int(69), wrap_int(32)]), wrap_list([wrap_int(55), wrap_int(14)]), wrap_list([wrap_int(74), wrap_int(61)]), wrap_list([wrap_int(55), wrap_int(72)]), wrap_list([wrap_int(75), wrap_int(24)]), wrap_list([wrap_int(63), wrap_int(40)]), wrap_list([wrap_int(10), wrap_int(58)]), wrap_list([wrap_int(67), wrap_int(73)]), wrap_list([wrap_int(20), wrap_int(11)]), wrap_list([wrap_int(42), wrap_int(40)]), wrap_list([wrap_int(27), wrap_int(53)]), wrap_list([wrap_int(5), wrap_int(8)]), wrap_list([wrap_int(10), wrap_int(2)]), wrap_list([wrap_int(27), wrap_int(49)]), wrap_list([wrap_int(50), wrap_int(48)]), wrap_list([wrap_int(18), wrap_int(58)]), wrap_list([wrap_int(60), wrap_int(25)]), wrap_list([wrap_int(74), wrap_int(71)]), wrap_list([wrap_int(0), wrap_int(30)]), wrap_list([wrap_int(3), wrap_int(29)]), wrap_list([wrap_int(59), wrap_int(5)]), wrap_list([wrap_int(43), wrap_int(16)]), wrap_list([wrap_int(59), wrap_int(41)]), wrap_list([wrap_int(74), wrap_int(4)]), wrap_list([wrap_int(19), wrap_int(20)]), wrap_list([wrap_int(53), wrap_int(19)]), wrap_list([wrap_int(57), wrap_int(50)]), wrap_list([wrap_int(60), wrap_int(11)]), wrap_list([wrap_int(16), wrap_int(68)]), wrap_list([wrap_int(9), wrap_int(50)]), wrap_list([wrap_int(71), wrap_int(17)]), wrap_list([wrap_int(73), wrap_int(66)]), wrap_list([wrap_int(59), wrap_int(43)]), wrap_list([wrap_int(68), wrap_int(32)]), wrap_list([wrap_int(75), wrap_int(31)]), wrap_list([wrap_int(27), wrap_int(56)]), wrap_list([wrap_int(47), wrap_int(24)]), wrap_list([wrap_int(29), wrap_int(7)]), wrap_list([wrap_int(27), wrap_int(25)]), wrap_list([wrap_int(48), wrap_int(36)]), wrap_list([wrap_int(0), wrap_int(53)]), wrap_list([wrap_int(0), wrap_int(72)]), wrap_list([wrap_int(24), wrap_int(53)]), wrap_list([wrap_int(13), wrap_int(64)]), wrap_list([wrap_int(19), wrap_int(44)]), wrap_list([wrap_int(9), wrap_int(56)]), wrap_list([wrap_int(35), wrap_int(75)]), wrap_list([wrap_int(75), wrap_int(17)]), wrap_list([wrap_int(47), wrap_int(16)]), wrap_list([wrap_int(11), wrap_int(42)]), wrap_list([wrap_int(40), wrap_int(45)]), wrap_list([wrap_int(43), wrap_int(60)]), wrap_list([wrap_int(21), wrap_int(59)]), wrap_list([wrap_int(29), wrap_int(50)]), wrap_list([wrap_int(8), wrap_int(9)]), wrap_list([wrap_int(3), wrap_int(18)]), wrap_list([wrap_int(7), wrap_int(57)]), wrap_list([wrap_int(32), wrap_int(9)]), wrap_list([wrap_int(61), wrap_int(6)]), wrap_list([wrap_int(11), wrap_int(6)]), wrap_list([wrap_int(7), wrap_int(72)]), wrap_list([wrap_int(42), wrap_int(61)]), wrap_list([wrap_int(73), wrap_int(75)]), wrap_list([wrap_int(68), wrap_int(44)]), wrap_list([wrap_int(68), wrap_int(66)]), wrap_list([wrap_int(25), wrap_int(56)]), wrap_list([wrap_int(14), wrap_int(20)]), wrap_list([wrap_int(3), wrap_int(50)]), wrap_list([wrap_int(32), wrap_int(57)]), wrap_list([wrap_int(67), wrap_int(58)]), wrap_list([wrap_int(41), wrap_int(68)]), wrap_list([wrap_int(19), wrap_int(26)]), wrap_list([wrap_int(30), wrap_int(3)]), wrap_list([wrap_int(23), wrap_int(45)]), wrap_list([wrap_int(16), wrap_int(60)]), wrap_list([wrap_int(41), wrap_int(43)]), wrap_list([wrap_int(5), wrap_int(30)]), wrap_list([wrap_int(5), wrap_int(25)]), wrap_list([wrap_int(72), wrap_int(16)]), wrap_list([wrap_int(16), wrap_int(73)]), wrap_list([wrap_int(21), wrap_int(17)]), wrap_list([wrap_int(16), wrap_int(59)]), wrap_list([wrap_int(8), wrap_int(34)]), wrap_list([wrap_int(4), wrap_int(39)]), wrap_list([wrap_int(23), wrap_int(72)]), wrap_list([wrap_int(35), wrap_int(53)]), wrap_list([wrap_int(31), wrap_int(50)]), wrap_list([wrap_int(20), wrap_int(44)]), wrap_list([wrap_int(50), wrap_int(13)]), wrap_list([wrap_int(72), wrap_int(1)]), wrap_list([wrap_int(8), wrap_int(8)]), wrap_list([wrap_int(74), wrap_int(54)]), wrap_list([wrap_int(1), wrap_int(1)]), wrap_list([wrap_int(16), wrap_int(43)]), wrap_list([wrap_int(39), wrap_int(36)]), wrap_list([wrap_int(51), wrap_int(2)]), wrap_list([wrap_int(23), wrap_int(54)]), wrap_list([wrap_int(66), wrap_int(58)]), wrap_list([wrap_int(60), wrap_int(33)]), wrap_list([wrap_int(2), wrap_int(63)]), wrap_list([wrap_int(73), wrap_int(10)])])):
    _assert((sym_len(nodes) == sym_len(set(nodes))).__and__(sym_len(set(nodes)) >= size))
    edge_set = {(a, b) for a, b in edges}
    for a in nodes:
        for b in nodes:
            _assert((a == b).__or__(sym_in((a, b), edge_set)).__or__(sym_in((b, a), edge_set)))
    return True
Exception -- for puzzle PlantedClique:2 'set' object has no attribute 'contains'

Solving puzzle 598/732: PlantedClique:3
sat_func def sat(nodes: List[int], size=18, edges=[[34, 43], [45, 8], [7, 46], [53, 11], [48, 24], [47, 46], [20, 46], [11, 57], [39, 17], [25, 13], [9, 49], [47, 51], [5, 22], [56, 8], [5, 20], [11, 26], [40, 20], [30, 42], [46, 35], [41, 11], [49, 57], [24, 46], [40, 27], [3, 13], [25, 36], [20, 49], [57, 24], [56, 26], [1, 52], [8, 26], [17, 44], [1, 21], [5, 6], [45, 45], [39, 25], [48, 27], [26, 17], [37, 25], [17, 16], [49, 0], [17, 56], [33, 43], [20, 43], [24, 20], [31, 56], [54, 28], [25, 27], [50, 5], [21, 43], [54, 25], [57, 45], [48, 5], [45, 34], [18, 46], [25, 47], [56, 48], [17, 57], [15, 29], [40, 22], [23, 57], [17, 27], [1, 14], [7, 54], [15, 24], [27, 44], [24, 44], [6, 7], [59, 13], [56, 51], [49, 46], [1, 32], [20, 36], [46, 13], [15, 46], [6, 46], [59, 51], [35, 5], [27, 10], [3, 16], [24, 33], [34, 49], [4, 38], [46, 24], [46, 3], [41, 39], [12, 9], [44, 39], [27, 23], [33, 11], [16, 24], [29, 59], [47, 39], [32, 10], [23, 36], [48, 30], [48, 20], [18, 43], [36, 9], [36, 16], [27, 57], [29, 35], [13, 41], [52, 12], [32, 20], [9, 50], [29, 27], [47, 44], [57, 39], [48, 57], [35, 45], [9, 23], [25, 55], [32, 25], [5, 57], [44, 16], [5, 27], [16, 37], [15, 25], [39, 51], [43, 14], [13, 44], [2, 5], [40, 4], [58, 30], [43, 6], [25, 28], [16, 35], [57, 44], [51, 54], [21, 11], [18, 19], [41, 20], [44, 48], [14, 54], [57, 16], [15, 5], [37, 15], [44, 49], [15, 20], [11, 20], [45, 1], [3, 32], [7, 22], [48, 39], [28, 37], [11, 51], [20, 16], [32, 4], [13, 17], [16, 15], [20, 37], [37, 46], [33, 59], [46, 25], [42, 1], [32, 33], [13, 53], [46, 18], [44, 23], [17, 48], [5, 24], [10, 40], [19, 11], [37, 47], [11, 42], [13, 24], [13, 27], [42, 9], [13, 5], [29, 17], [57, 4], [31, 25], [38, 32], [21, 45], [0, 21], [1, 0], [20, 13], [24, 37], [20, 25], [5, 17], [20, 47], [46, 41], [11, 0], [25, 22], [5, 28], [44, 5], [10, 11], [41, 22], [17, 25], [25, 20], [20, 17], [39, 46], [49, 25], [41, 0], [12, 44], [41, 49], [55, 8], [47, 49], [27, 49], [2, 11], [38, 11], [27, 46], [16, 9], [41, 47], [17, 15], [37, 31], [48, 48], [53, 59], [25, 24], [3, 44], [34, 48], [33, 13], [15, 47], [16, 39], [48, 8], [32, 55], [38, 22], [11, 23], [41, 16], [21, 44], [20, 27], [13, 57], [27, 41], [29, 32], [56, 39], [31, 51], [46, 20], [24, 49], [25, 3], [57, 37], [15, 44], [9, 41], [15, 48], [42, 57], [47, 5], [48, 37], [45, 49], [44, 41], [7, 3], [39, 49], [49, 37], [24, 16], [57, 41], [56, 2], [49, 20], [19, 5], [58, 18], [7, 31], [24, 5], [41, 32], [34, 23], [17, 5], [47, 27], [49, 41], [31, 12], [0, 11], [49, 15], [13, 15], [29, 31], [14, 56], [24, 41], [35, 1], [16, 25], [26, 28], [16, 49], [12, 46], [47, 16], [17, 37], [37, 39], [3, 22], [27, 24], [20, 39], [24, 4], [33, 15], [53, 50], [32, 1], [23, 40], [33, 25], [4, 24], [48, 25], [47, 57], [25, 8], [39, 30], [17, 53], [41, 53], [31, 8], [39, 33], [33, 16], [32, 19], [41, 5], [49, 17], [53, 40], [42, 52], [24, 17], [30, 59], [13, 14], [43, 27], [48, 16], [24, 47], [37, 23], [30, 47], [49, 10], [47, 12], [5, 37], [48, 47], [59, 27], [57, 17], [27, 33], [12, 30], [41, 48], [5, 46], [12, 25], [53, 46], [54, 8], [48, 1], [22, 25], [20, 44], [14, 38], [48, 13], [3, 3], [59, 4], [14, 7], [49, 26], [36, 5], [28, 32], [57, 46], [22, 34], [11, 54], [27, 58], [4, 11], [24, 39], [57, 25], [15, 27], [6, 15], [27, 29], [51, 37], [48, 23], [15, 57], [27, 25], [0, 57], [49, 48], [27, 34], [21, 5], [31, 40], [38, 45], [15, 1], [17, 42], [5, 16], [59, 32], [13, 51], [17, 47], [38, 54], [4, 43], [54, 9], [42, 31], [16, 13], [20, 57], [58, 10], [41, 30], [52, 19], [52, 35], [46, 44], [51, 4], [30, 39], [47, 13], [30, 32], [36, 42], [39, 15], [3, 19], [12, 16], [46, 16], [12, 37], [46, 48], [58, 46], [5, 25], [46, 6], [49, 44], [18, 23], [50, 24], [16, 16], [49, 53], [37, 33], [4, 15], [46, 17], [7, 20], [25, 41], [27, 56], [37, 41], [38, 55], [59, 28], [31, 7], [10, 47], [40, 23], [49, 5], [44, 25], [8, 36], [26, 39], [34, 3], [5, 12], [54, 22], [15, 41], [40, 19], [21, 12], [16, 5], [13, 49], [39, 5], [9, 9], [11, 53], [27, 16], [27, 39], [52, 14], [3, 56], [27, 37], [30, 15], [41, 17], [1, 34], [55, 32], [28, 22], [49, 27], [10, 55], [39, 37], [30, 17], [23, 9], [22, 11], [44, 37], [41, 37], [37, 13], [51, 18], [4, 34], [23, 12], [39, 13], [32, 9], [58, 14], [25, 48], [29, 14], [52, 2]]):
    assert len(nodes) == len(set(nodes)) >= size
    edge_set = {(a, b) for (a, b) in edges}
    for a in nodes:
        for b in nodes:
            assert a == b or (a, b) in edge_set or (b, a) in edge_set

    return True
modified_func def sat(nodes: List[int], size=wrap_int(18), edges=wrap_list([wrap_list([wrap_int(34), wrap_int(43)]), wrap_list([wrap_int(45), wrap_int(8)]), wrap_list([wrap_int(7), wrap_int(46)]), wrap_list([wrap_int(53), wrap_int(11)]), wrap_list([wrap_int(48), wrap_int(24)]), wrap_list([wrap_int(47), wrap_int(46)]), wrap_list([wrap_int(20), wrap_int(46)]), wrap_list([wrap_int(11), wrap_int(57)]), wrap_list([wrap_int(39), wrap_int(17)]), wrap_list([wrap_int(25), wrap_int(13)]), wrap_list([wrap_int(9), wrap_int(49)]), wrap_list([wrap_int(47), wrap_int(51)]), wrap_list([wrap_int(5), wrap_int(22)]), wrap_list([wrap_int(56), wrap_int(8)]), wrap_list([wrap_int(5), wrap_int(20)]), wrap_list([wrap_int(11), wrap_int(26)]), wrap_list([wrap_int(40), wrap_int(20)]), wrap_list([wrap_int(30), wrap_int(42)]), wrap_list([wrap_int(46), wrap_int(35)]), wrap_list([wrap_int(41), wrap_int(11)]), wrap_list([wrap_int(49), wrap_int(57)]), wrap_list([wrap_int(24), wrap_int(46)]), wrap_list([wrap_int(40), wrap_int(27)]), wrap_list([wrap_int(3), wrap_int(13)]), wrap_list([wrap_int(25), wrap_int(36)]), wrap_list([wrap_int(20), wrap_int(49)]), wrap_list([wrap_int(57), wrap_int(24)]), wrap_list([wrap_int(56), wrap_int(26)]), wrap_list([wrap_int(1), wrap_int(52)]), wrap_list([wrap_int(8), wrap_int(26)]), wrap_list([wrap_int(17), wrap_int(44)]), wrap_list([wrap_int(1), wrap_int(21)]), wrap_list([wrap_int(5), wrap_int(6)]), wrap_list([wrap_int(45), wrap_int(45)]), wrap_list([wrap_int(39), wrap_int(25)]), wrap_list([wrap_int(48), wrap_int(27)]), wrap_list([wrap_int(26), wrap_int(17)]), wrap_list([wrap_int(37), wrap_int(25)]), wrap_list([wrap_int(17), wrap_int(16)]), wrap_list([wrap_int(49), wrap_int(0)]), wrap_list([wrap_int(17), wrap_int(56)]), wrap_list([wrap_int(33), wrap_int(43)]), wrap_list([wrap_int(20), wrap_int(43)]), wrap_list([wrap_int(24), wrap_int(20)]), wrap_list([wrap_int(31), wrap_int(56)]), wrap_list([wrap_int(54), wrap_int(28)]), wrap_list([wrap_int(25), wrap_int(27)]), wrap_list([wrap_int(50), wrap_int(5)]), wrap_list([wrap_int(21), wrap_int(43)]), wrap_list([wrap_int(54), wrap_int(25)]), wrap_list([wrap_int(57), wrap_int(45)]), wrap_list([wrap_int(48), wrap_int(5)]), wrap_list([wrap_int(45), wrap_int(34)]), wrap_list([wrap_int(18), wrap_int(46)]), wrap_list([wrap_int(25), wrap_int(47)]), wrap_list([wrap_int(56), wrap_int(48)]), wrap_list([wrap_int(17), wrap_int(57)]), wrap_list([wrap_int(15), wrap_int(29)]), wrap_list([wrap_int(40), wrap_int(22)]), wrap_list([wrap_int(23), wrap_int(57)]), wrap_list([wrap_int(17), wrap_int(27)]), wrap_list([wrap_int(1), wrap_int(14)]), wrap_list([wrap_int(7), wrap_int(54)]), wrap_list([wrap_int(15), wrap_int(24)]), wrap_list([wrap_int(27), wrap_int(44)]), wrap_list([wrap_int(24), wrap_int(44)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(59), wrap_int(13)]), wrap_list([wrap_int(56), wrap_int(51)]), wrap_list([wrap_int(49), wrap_int(46)]), wrap_list([wrap_int(1), wrap_int(32)]), wrap_list([wrap_int(20), wrap_int(36)]), wrap_list([wrap_int(46), wrap_int(13)]), wrap_list([wrap_int(15), wrap_int(46)]), wrap_list([wrap_int(6), wrap_int(46)]), wrap_list([wrap_int(59), wrap_int(51)]), wrap_list([wrap_int(35), wrap_int(5)]), wrap_list([wrap_int(27), wrap_int(10)]), wrap_list([wrap_int(3), wrap_int(16)]), wrap_list([wrap_int(24), wrap_int(33)]), wrap_list([wrap_int(34), wrap_int(49)]), wrap_list([wrap_int(4), wrap_int(38)]), wrap_list([wrap_int(46), wrap_int(24)]), wrap_list([wrap_int(46), wrap_int(3)]), wrap_list([wrap_int(41), wrap_int(39)]), wrap_list([wrap_int(12), wrap_int(9)]), wrap_list([wrap_int(44), wrap_int(39)]), wrap_list([wrap_int(27), wrap_int(23)]), wrap_list([wrap_int(33), wrap_int(11)]), wrap_list([wrap_int(16), wrap_int(24)]), wrap_list([wrap_int(29), wrap_int(59)]), wrap_list([wrap_int(47), wrap_int(39)]), wrap_list([wrap_int(32), wrap_int(10)]), wrap_list([wrap_int(23), wrap_int(36)]), wrap_list([wrap_int(48), wrap_int(30)]), wrap_list([wrap_int(48), wrap_int(20)]), wrap_list([wrap_int(18), wrap_int(43)]), wrap_list([wrap_int(36), wrap_int(9)]), wrap_list([wrap_int(36), wrap_int(16)]), wrap_list([wrap_int(27), wrap_int(57)]), wrap_list([wrap_int(29), wrap_int(35)]), wrap_list([wrap_int(13), wrap_int(41)]), wrap_list([wrap_int(52), wrap_int(12)]), wrap_list([wrap_int(32), wrap_int(20)]), wrap_list([wrap_int(9), wrap_int(50)]), wrap_list([wrap_int(29), wrap_int(27)]), wrap_list([wrap_int(47), wrap_int(44)]), wrap_list([wrap_int(57), wrap_int(39)]), wrap_list([wrap_int(48), wrap_int(57)]), wrap_list([wrap_int(35), wrap_int(45)]), wrap_list([wrap_int(9), wrap_int(23)]), wrap_list([wrap_int(25), wrap_int(55)]), wrap_list([wrap_int(32), wrap_int(25)]), wrap_list([wrap_int(5), wrap_int(57)]), wrap_list([wrap_int(44), wrap_int(16)]), wrap_list([wrap_int(5), wrap_int(27)]), wrap_list([wrap_int(16), wrap_int(37)]), wrap_list([wrap_int(15), wrap_int(25)]), wrap_list([wrap_int(39), wrap_int(51)]), wrap_list([wrap_int(43), wrap_int(14)]), wrap_list([wrap_int(13), wrap_int(44)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(40), wrap_int(4)]), wrap_list([wrap_int(58), wrap_int(30)]), wrap_list([wrap_int(43), wrap_int(6)]), wrap_list([wrap_int(25), wrap_int(28)]), wrap_list([wrap_int(16), wrap_int(35)]), wrap_list([wrap_int(57), wrap_int(44)]), wrap_list([wrap_int(51), wrap_int(54)]), wrap_list([wrap_int(21), wrap_int(11)]), wrap_list([wrap_int(18), wrap_int(19)]), wrap_list([wrap_int(41), wrap_int(20)]), wrap_list([wrap_int(44), wrap_int(48)]), wrap_list([wrap_int(14), wrap_int(54)]), wrap_list([wrap_int(57), wrap_int(16)]), wrap_list([wrap_int(15), wrap_int(5)]), wrap_list([wrap_int(37), wrap_int(15)]), wrap_list([wrap_int(44), wrap_int(49)]), wrap_list([wrap_int(15), wrap_int(20)]), wrap_list([wrap_int(11), wrap_int(20)]), wrap_list([wrap_int(45), wrap_int(1)]), wrap_list([wrap_int(3), wrap_int(32)]), wrap_list([wrap_int(7), wrap_int(22)]), wrap_list([wrap_int(48), wrap_int(39)]), wrap_list([wrap_int(28), wrap_int(37)]), wrap_list([wrap_int(11), wrap_int(51)]), wrap_list([wrap_int(20), wrap_int(16)]), wrap_list([wrap_int(32), wrap_int(4)]), wrap_list([wrap_int(13), wrap_int(17)]), wrap_list([wrap_int(16), wrap_int(15)]), wrap_list([wrap_int(20), wrap_int(37)]), wrap_list([wrap_int(37), wrap_int(46)]), wrap_list([wrap_int(33), wrap_int(59)]), wrap_list([wrap_int(46), wrap_int(25)]), wrap_list([wrap_int(42), wrap_int(1)]), wrap_list([wrap_int(32), wrap_int(33)]), wrap_list([wrap_int(13), wrap_int(53)]), wrap_list([wrap_int(46), wrap_int(18)]), wrap_list([wrap_int(44), wrap_int(23)]), wrap_list([wrap_int(17), wrap_int(48)]), wrap_list([wrap_int(5), wrap_int(24)]), wrap_list([wrap_int(10), wrap_int(40)]), wrap_list([wrap_int(19), wrap_int(11)]), wrap_list([wrap_int(37), wrap_int(47)]), wrap_list([wrap_int(11), wrap_int(42)]), wrap_list([wrap_int(13), wrap_int(24)]), wrap_list([wrap_int(13), wrap_int(27)]), wrap_list([wrap_int(42), wrap_int(9)]), wrap_list([wrap_int(13), wrap_int(5)]), wrap_list([wrap_int(29), wrap_int(17)]), wrap_list([wrap_int(57), wrap_int(4)]), wrap_list([wrap_int(31), wrap_int(25)]), wrap_list([wrap_int(38), wrap_int(32)]), wrap_list([wrap_int(21), wrap_int(45)]), wrap_list([wrap_int(0), wrap_int(21)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(20), wrap_int(13)]), wrap_list([wrap_int(24), wrap_int(37)]), wrap_list([wrap_int(20), wrap_int(25)]), wrap_list([wrap_int(5), wrap_int(17)]), wrap_list([wrap_int(20), wrap_int(47)]), wrap_list([wrap_int(46), wrap_int(41)]), wrap_list([wrap_int(11), wrap_int(0)]), wrap_list([wrap_int(25), wrap_int(22)]), wrap_list([wrap_int(5), wrap_int(28)]), wrap_list([wrap_int(44), wrap_int(5)]), wrap_list([wrap_int(10), wrap_int(11)]), wrap_list([wrap_int(41), wrap_int(22)]), wrap_list([wrap_int(17), wrap_int(25)]), wrap_list([wrap_int(25), wrap_int(20)]), wrap_list([wrap_int(20), wrap_int(17)]), wrap_list([wrap_int(39), wrap_int(46)]), wrap_list([wrap_int(49), wrap_int(25)]), wrap_list([wrap_int(41), wrap_int(0)]), wrap_list([wrap_int(12), wrap_int(44)]), wrap_list([wrap_int(41), wrap_int(49)]), wrap_list([wrap_int(55), wrap_int(8)]), wrap_list([wrap_int(47), wrap_int(49)]), wrap_list([wrap_int(27), wrap_int(49)]), wrap_list([wrap_int(2), wrap_int(11)]), wrap_list([wrap_int(38), wrap_int(11)]), wrap_list([wrap_int(27), wrap_int(46)]), wrap_list([wrap_int(16), wrap_int(9)]), wrap_list([wrap_int(41), wrap_int(47)]), wrap_list([wrap_int(17), wrap_int(15)]), wrap_list([wrap_int(37), wrap_int(31)]), wrap_list([wrap_int(48), wrap_int(48)]), wrap_list([wrap_int(53), wrap_int(59)]), wrap_list([wrap_int(25), wrap_int(24)]), wrap_list([wrap_int(3), wrap_int(44)]), wrap_list([wrap_int(34), wrap_int(48)]), wrap_list([wrap_int(33), wrap_int(13)]), wrap_list([wrap_int(15), wrap_int(47)]), wrap_list([wrap_int(16), wrap_int(39)]), wrap_list([wrap_int(48), wrap_int(8)]), wrap_list([wrap_int(32), wrap_int(55)]), wrap_list([wrap_int(38), wrap_int(22)]), wrap_list([wrap_int(11), wrap_int(23)]), wrap_list([wrap_int(41), wrap_int(16)]), wrap_list([wrap_int(21), wrap_int(44)]), wrap_list([wrap_int(20), wrap_int(27)]), wrap_list([wrap_int(13), wrap_int(57)]), wrap_list([wrap_int(27), wrap_int(41)]), wrap_list([wrap_int(29), wrap_int(32)]), wrap_list([wrap_int(56), wrap_int(39)]), wrap_list([wrap_int(31), wrap_int(51)]), wrap_list([wrap_int(46), wrap_int(20)]), wrap_list([wrap_int(24), wrap_int(49)]), wrap_list([wrap_int(25), wrap_int(3)]), wrap_list([wrap_int(57), wrap_int(37)]), wrap_list([wrap_int(15), wrap_int(44)]), wrap_list([wrap_int(9), wrap_int(41)]), wrap_list([wrap_int(15), wrap_int(48)]), wrap_list([wrap_int(42), wrap_int(57)]), wrap_list([wrap_int(47), wrap_int(5)]), wrap_list([wrap_int(48), wrap_int(37)]), wrap_list([wrap_int(45), wrap_int(49)]), wrap_list([wrap_int(44), wrap_int(41)]), wrap_list([wrap_int(7), wrap_int(3)]), wrap_list([wrap_int(39), wrap_int(49)]), wrap_list([wrap_int(49), wrap_int(37)]), wrap_list([wrap_int(24), wrap_int(16)]), wrap_list([wrap_int(57), wrap_int(41)]), wrap_list([wrap_int(56), wrap_int(2)]), wrap_list([wrap_int(49), wrap_int(20)]), wrap_list([wrap_int(19), wrap_int(5)]), wrap_list([wrap_int(58), wrap_int(18)]), wrap_list([wrap_int(7), wrap_int(31)]), wrap_list([wrap_int(24), wrap_int(5)]), wrap_list([wrap_int(41), wrap_int(32)]), wrap_list([wrap_int(34), wrap_int(23)]), wrap_list([wrap_int(17), wrap_int(5)]), wrap_list([wrap_int(47), wrap_int(27)]), wrap_list([wrap_int(49), wrap_int(41)]), wrap_list([wrap_int(31), wrap_int(12)]), wrap_list([wrap_int(0), wrap_int(11)]), wrap_list([wrap_int(49), wrap_int(15)]), wrap_list([wrap_int(13), wrap_int(15)]), wrap_list([wrap_int(29), wrap_int(31)]), wrap_list([wrap_int(14), wrap_int(56)]), wrap_list([wrap_int(24), wrap_int(41)]), wrap_list([wrap_int(35), wrap_int(1)]), wrap_list([wrap_int(16), wrap_int(25)]), wrap_list([wrap_int(26), wrap_int(28)]), wrap_list([wrap_int(16), wrap_int(49)]), wrap_list([wrap_int(12), wrap_int(46)]), wrap_list([wrap_int(47), wrap_int(16)]), wrap_list([wrap_int(17), wrap_int(37)]), wrap_list([wrap_int(37), wrap_int(39)]), wrap_list([wrap_int(3), wrap_int(22)]), wrap_list([wrap_int(27), wrap_int(24)]), wrap_list([wrap_int(20), wrap_int(39)]), wrap_list([wrap_int(24), wrap_int(4)]), wrap_list([wrap_int(33), wrap_int(15)]), wrap_list([wrap_int(53), wrap_int(50)]), wrap_list([wrap_int(32), wrap_int(1)]), wrap_list([wrap_int(23), wrap_int(40)]), wrap_list([wrap_int(33), wrap_int(25)]), wrap_list([wrap_int(4), wrap_int(24)]), wrap_list([wrap_int(48), wrap_int(25)]), wrap_list([wrap_int(47), wrap_int(57)]), wrap_list([wrap_int(25), wrap_int(8)]), wrap_list([wrap_int(39), wrap_int(30)]), wrap_list([wrap_int(17), wrap_int(53)]), wrap_list([wrap_int(41), wrap_int(53)]), wrap_list([wrap_int(31), wrap_int(8)]), wrap_list([wrap_int(39), wrap_int(33)]), wrap_list([wrap_int(33), wrap_int(16)]), wrap_list([wrap_int(32), wrap_int(19)]), wrap_list([wrap_int(41), wrap_int(5)]), wrap_list([wrap_int(49), wrap_int(17)]), wrap_list([wrap_int(53), wrap_int(40)]), wrap_list([wrap_int(42), wrap_int(52)]), wrap_list([wrap_int(24), wrap_int(17)]), wrap_list([wrap_int(30), wrap_int(59)]), wrap_list([wrap_int(13), wrap_int(14)]), wrap_list([wrap_int(43), wrap_int(27)]), wrap_list([wrap_int(48), wrap_int(16)]), wrap_list([wrap_int(24), wrap_int(47)]), wrap_list([wrap_int(37), wrap_int(23)]), wrap_list([wrap_int(30), wrap_int(47)]), wrap_list([wrap_int(49), wrap_int(10)]), wrap_list([wrap_int(47), wrap_int(12)]), wrap_list([wrap_int(5), wrap_int(37)]), wrap_list([wrap_int(48), wrap_int(47)]), wrap_list([wrap_int(59), wrap_int(27)]), wrap_list([wrap_int(57), wrap_int(17)]), wrap_list([wrap_int(27), wrap_int(33)]), wrap_list([wrap_int(12), wrap_int(30)]), wrap_list([wrap_int(41), wrap_int(48)]), wrap_list([wrap_int(5), wrap_int(46)]), wrap_list([wrap_int(12), wrap_int(25)]), wrap_list([wrap_int(53), wrap_int(46)]), wrap_list([wrap_int(54), wrap_int(8)]), wrap_list([wrap_int(48), wrap_int(1)]), wrap_list([wrap_int(22), wrap_int(25)]), wrap_list([wrap_int(20), wrap_int(44)]), wrap_list([wrap_int(14), wrap_int(38)]), wrap_list([wrap_int(48), wrap_int(13)]), wrap_list([wrap_int(3), wrap_int(3)]), wrap_list([wrap_int(59), wrap_int(4)]), wrap_list([wrap_int(14), wrap_int(7)]), wrap_list([wrap_int(49), wrap_int(26)]), wrap_list([wrap_int(36), wrap_int(5)]), wrap_list([wrap_int(28), wrap_int(32)]), wrap_list([wrap_int(57), wrap_int(46)]), wrap_list([wrap_int(22), wrap_int(34)]), wrap_list([wrap_int(11), wrap_int(54)]), wrap_list([wrap_int(27), wrap_int(58)]), wrap_list([wrap_int(4), wrap_int(11)]), wrap_list([wrap_int(24), wrap_int(39)]), wrap_list([wrap_int(57), wrap_int(25)]), wrap_list([wrap_int(15), wrap_int(27)]), wrap_list([wrap_int(6), wrap_int(15)]), wrap_list([wrap_int(27), wrap_int(29)]), wrap_list([wrap_int(51), wrap_int(37)]), wrap_list([wrap_int(48), wrap_int(23)]), wrap_list([wrap_int(15), wrap_int(57)]), wrap_list([wrap_int(27), wrap_int(25)]), wrap_list([wrap_int(0), wrap_int(57)]), wrap_list([wrap_int(49), wrap_int(48)]), wrap_list([wrap_int(27), wrap_int(34)]), wrap_list([wrap_int(21), wrap_int(5)]), wrap_list([wrap_int(31), wrap_int(40)]), wrap_list([wrap_int(38), wrap_int(45)]), wrap_list([wrap_int(15), wrap_int(1)]), wrap_list([wrap_int(17), wrap_int(42)]), wrap_list([wrap_int(5), wrap_int(16)]), wrap_list([wrap_int(59), wrap_int(32)]), wrap_list([wrap_int(13), wrap_int(51)]), wrap_list([wrap_int(17), wrap_int(47)]), wrap_list([wrap_int(38), wrap_int(54)]), wrap_list([wrap_int(4), wrap_int(43)]), wrap_list([wrap_int(54), wrap_int(9)]), wrap_list([wrap_int(42), wrap_int(31)]), wrap_list([wrap_int(16), wrap_int(13)]), wrap_list([wrap_int(20), wrap_int(57)]), wrap_list([wrap_int(58), wrap_int(10)]), wrap_list([wrap_int(41), wrap_int(30)]), wrap_list([wrap_int(52), wrap_int(19)]), wrap_list([wrap_int(52), wrap_int(35)]), wrap_list([wrap_int(46), wrap_int(44)]), wrap_list([wrap_int(51), wrap_int(4)]), wrap_list([wrap_int(30), wrap_int(39)]), wrap_list([wrap_int(47), wrap_int(13)]), wrap_list([wrap_int(30), wrap_int(32)]), wrap_list([wrap_int(36), wrap_int(42)]), wrap_list([wrap_int(39), wrap_int(15)]), wrap_list([wrap_int(3), wrap_int(19)]), wrap_list([wrap_int(12), wrap_int(16)]), wrap_list([wrap_int(46), wrap_int(16)]), wrap_list([wrap_int(12), wrap_int(37)]), wrap_list([wrap_int(46), wrap_int(48)]), wrap_list([wrap_int(58), wrap_int(46)]), wrap_list([wrap_int(5), wrap_int(25)]), wrap_list([wrap_int(46), wrap_int(6)]), wrap_list([wrap_int(49), wrap_int(44)]), wrap_list([wrap_int(18), wrap_int(23)]), wrap_list([wrap_int(50), wrap_int(24)]), wrap_list([wrap_int(16), wrap_int(16)]), wrap_list([wrap_int(49), wrap_int(53)]), wrap_list([wrap_int(37), wrap_int(33)]), wrap_list([wrap_int(4), wrap_int(15)]), wrap_list([wrap_int(46), wrap_int(17)]), wrap_list([wrap_int(7), wrap_int(20)]), wrap_list([wrap_int(25), wrap_int(41)]), wrap_list([wrap_int(27), wrap_int(56)]), wrap_list([wrap_int(37), wrap_int(41)]), wrap_list([wrap_int(38), wrap_int(55)]), wrap_list([wrap_int(59), wrap_int(28)]), wrap_list([wrap_int(31), wrap_int(7)]), wrap_list([wrap_int(10), wrap_int(47)]), wrap_list([wrap_int(40), wrap_int(23)]), wrap_list([wrap_int(49), wrap_int(5)]), wrap_list([wrap_int(44), wrap_int(25)]), wrap_list([wrap_int(8), wrap_int(36)]), wrap_list([wrap_int(26), wrap_int(39)]), wrap_list([wrap_int(34), wrap_int(3)]), wrap_list([wrap_int(5), wrap_int(12)]), wrap_list([wrap_int(54), wrap_int(22)]), wrap_list([wrap_int(15), wrap_int(41)]), wrap_list([wrap_int(40), wrap_int(19)]), wrap_list([wrap_int(21), wrap_int(12)]), wrap_list([wrap_int(16), wrap_int(5)]), wrap_list([wrap_int(13), wrap_int(49)]), wrap_list([wrap_int(39), wrap_int(5)]), wrap_list([wrap_int(9), wrap_int(9)]), wrap_list([wrap_int(11), wrap_int(53)]), wrap_list([wrap_int(27), wrap_int(16)]), wrap_list([wrap_int(27), wrap_int(39)]), wrap_list([wrap_int(52), wrap_int(14)]), wrap_list([wrap_int(3), wrap_int(56)]), wrap_list([wrap_int(27), wrap_int(37)]), wrap_list([wrap_int(30), wrap_int(15)]), wrap_list([wrap_int(41), wrap_int(17)]), wrap_list([wrap_int(1), wrap_int(34)]), wrap_list([wrap_int(55), wrap_int(32)]), wrap_list([wrap_int(28), wrap_int(22)]), wrap_list([wrap_int(49), wrap_int(27)]), wrap_list([wrap_int(10), wrap_int(55)]), wrap_list([wrap_int(39), wrap_int(37)]), wrap_list([wrap_int(30), wrap_int(17)]), wrap_list([wrap_int(23), wrap_int(9)]), wrap_list([wrap_int(22), wrap_int(11)]), wrap_list([wrap_int(44), wrap_int(37)]), wrap_list([wrap_int(41), wrap_int(37)]), wrap_list([wrap_int(37), wrap_int(13)]), wrap_list([wrap_int(51), wrap_int(18)]), wrap_list([wrap_int(4), wrap_int(34)]), wrap_list([wrap_int(23), wrap_int(12)]), wrap_list([wrap_int(39), wrap_int(13)]), wrap_list([wrap_int(32), wrap_int(9)]), wrap_list([wrap_int(58), wrap_int(14)]), wrap_list([wrap_int(25), wrap_int(48)]), wrap_list([wrap_int(29), wrap_int(14)]), wrap_list([wrap_int(52), wrap_int(2)])])):
    _assert((sym_len(nodes) == sym_len(set(nodes))).__and__(sym_len(set(nodes)) >= size))
    edge_set = {(a, b) for a, b in edges}
    for a in nodes:
        for b in nodes:
            _assert((a == b).__or__(sym_in((a, b), edge_set)).__or__(sym_in((b, a), edge_set)))
    return True
Exception -- for puzzle PlantedClique:3 'set' object has no attribute 'contains'

Solving puzzle 599/732: PlantedClique:4
sat_func def sat(nodes: List[int], size=0, edges=[[0, 1], [1, 0]]):
    assert len(nodes) == len(set(nodes)) >= size
    edge_set = {(a, b) for (a, b) in edges}
    for a in nodes:
        for b in nodes:
            assert a == b or (a, b) in edge_set or (b, a) in edge_set

    return True
modified_func def sat(nodes: List[int], size=wrap_int(0), edges=wrap_list([wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(0)])])):
    _assert((sym_len(nodes) == sym_len(set(nodes))).__and__(sym_len(set(nodes)) >= size))
    edge_set = {(a, b) for a, b in edges}
    for a in nodes:
        for b in nodes:
            _assert((a == b).__or__(sym_in((a, b), edge_set)).__or__(sym_in((b, a), edge_set)))
    return True
Exception -- for puzzle PlantedClique:4 'set' object has no attribute 'contains'

Solving puzzle 600/732: ShortestPath:0
sat_func def sat(path: List[int], weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
modified_func def sat(path: List[int], weights=wrap_list([{wrap_int(1): wrap_int(20), wrap_int(2): wrap_int(1)}, {wrap_int(2): wrap_int(2), wrap_int(3): wrap_int(5)}, {wrap_int(1): wrap_int(10)}]), bound=wrap_int(11)):
    return (path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == wrap_int(1)).__and__(sym_sum(sym_generator((weights[a][b] for a, b in sym_zip(path, path[1:])))) <= bound)
Exception -- for puzzle ShortestPath:0 'dict' object has no attribute 'z3_expr'

Solving puzzle 601/732: ShortestPath:1
sat_func def sat(path: List[int], weights=[{3: 210, 0: 513, 1: 66, 5: 612}, {0: 794, 1: 111, 3: 598}, {4: 295, 0: 601}, {}, {3: 452, 0: 689, 5: 124, 1: 406}, {2: 289, 5: 660, 3: 498}], bound=66):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
modified_func def sat(path: List[int], weights=wrap_list([{wrap_int(3): wrap_int(210), wrap_int(0): wrap_int(513), wrap_int(1): wrap_int(66), wrap_int(5): wrap_int(612)}, {wrap_int(0): wrap_int(794), wrap_int(1): wrap_int(111), wrap_int(3): wrap_int(598)}, {wrap_int(4): wrap_int(295), wrap_int(0): wrap_int(601)}, {}, {wrap_int(3): wrap_int(452), wrap_int(0): wrap_int(689), wrap_int(5): wrap_int(124), wrap_int(1): wrap_int(406)}, {wrap_int(2): wrap_int(289), wrap_int(5): wrap_int(660), wrap_int(3): wrap_int(498)}]), bound=wrap_int(66)):
    return (path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == wrap_int(1)).__and__(sym_sum(sym_generator((weights[a][b] for a, b in sym_zip(path, path[1:])))) <= bound)
Exception -- for puzzle ShortestPath:1 'dict' object has no attribute 'z3_expr'

Solving puzzle 602/732: ShortestPath:2
sat_func def sat(path: List[int], weights=[{25: 594, 24: 349}, {}, {29: 745}, {}, {7: 245}, {9: 384}, {1: 490, 21: 253, 22: 904, 13: 526}, {4: 452, 27: 179, 28: 673}, {22: 30, 29: 307, 8: 104}, {12: 399, 0: 792}, {}, {}, {20: 349, 6: 53}, {}, {}, {}, {14: 223}, {23: 705}, {13: 903, 21: 159}, {}, {27: 144, 28: 181}, {26: 922, 20: 241}, {}, {24: 966, 29: 78}, {26: 107}, {1: 121}, {18: 898, 0: 280, 12: 425}, {}, {18: 750, 25: 440, 28: 152, 29: 109, 6: 330}, {23: 298}], bound=715):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
modified_func def sat(path: List[int], weights=wrap_list([{wrap_int(25): wrap_int(594), wrap_int(24): wrap_int(349)}, {}, {wrap_int(29): wrap_int(745)}, {}, {wrap_int(7): wrap_int(245)}, {wrap_int(9): wrap_int(384)}, {wrap_int(1): wrap_int(490), wrap_int(21): wrap_int(253), wrap_int(22): wrap_int(904), wrap_int(13): wrap_int(526)}, {wrap_int(4): wrap_int(452), wrap_int(27): wrap_int(179), wrap_int(28): wrap_int(673)}, {wrap_int(22): wrap_int(30), wrap_int(29): wrap_int(307), wrap_int(8): wrap_int(104)}, {wrap_int(12): wrap_int(399), wrap_int(0): wrap_int(792)}, {}, {}, {wrap_int(20): wrap_int(349), wrap_int(6): wrap_int(53)}, {}, {}, {}, {wrap_int(14): wrap_int(223)}, {wrap_int(23): wrap_int(705)}, {wrap_int(13): wrap_int(903), wrap_int(21): wrap_int(159)}, {}, {wrap_int(27): wrap_int(144), wrap_int(28): wrap_int(181)}, {wrap_int(26): wrap_int(922), wrap_int(20): wrap_int(241)}, {}, {wrap_int(24): wrap_int(966), wrap_int(29): wrap_int(78)}, {wrap_int(26): wrap_int(107)}, {wrap_int(1): wrap_int(121)}, {wrap_int(18): wrap_int(898), wrap_int(0): wrap_int(280), wrap_int(12): wrap_int(425)}, {}, {wrap_int(18): wrap_int(750), wrap_int(25): wrap_int(440), wrap_int(28): wrap_int(152), wrap_int(29): wrap_int(109), wrap_int(6): wrap_int(330)}, {wrap_int(23): wrap_int(298)}]), bound=wrap_int(715)):
    return (path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == wrap_int(1)).__and__(sym_sum(sym_generator((weights[a][b] for a, b in sym_zip(path, path[1:])))) <= bound)
Exception -- for puzzle ShortestPath:2 'dict' object has no attribute 'z3_expr'

Solving puzzle 603/732: ShortestPath:3
sat_func def sat(path: List[int], weights=[{1: 239}, {0: 602, 2: 280}, {2: 293, 0: 816, 3: 925}, {}], bound=239):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
modified_func def sat(path: List[int], weights=wrap_list([{wrap_int(1): wrap_int(239)}, {wrap_int(0): wrap_int(602), wrap_int(2): wrap_int(280)}, {wrap_int(2): wrap_int(293), wrap_int(0): wrap_int(816), wrap_int(3): wrap_int(925)}, {}]), bound=wrap_int(239)):
    return (path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == wrap_int(1)).__and__(sym_sum(sym_generator((weights[a][b] for a, b in sym_zip(path, path[1:])))) <= bound)
Exception -- for puzzle ShortestPath:3 'dict' object has no attribute 'z3_expr'

Solving puzzle 604/732: ShortestPath:4
sat_func def sat(path: List[int], weights=[{1: 996, 2: 237, 4: 264}, {4: 329, 5: 12, 2: 542, 0: 419}, {2: 170, 6: 339, 5: 211}, {1: 714, 5: 885, 3: 640}, {5: 652, 4: 3, 3: 26, 6: 74}, {0: 647, 5: 346}, {2: 297, 6: 358, 3: 636, 0: 722, 4: 942}], bound=996):
    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound
modified_func def sat(path: List[int], weights=wrap_list([{wrap_int(1): wrap_int(996), wrap_int(2): wrap_int(237), wrap_int(4): wrap_int(264)}, {wrap_int(4): wrap_int(329), wrap_int(5): wrap_int(12), wrap_int(2): wrap_int(542), wrap_int(0): wrap_int(419)}, {wrap_int(2): wrap_int(170), wrap_int(6): wrap_int(339), wrap_int(5): wrap_int(211)}, {wrap_int(1): wrap_int(714), wrap_int(5): wrap_int(885), wrap_int(3): wrap_int(640)}, {wrap_int(5): wrap_int(652), wrap_int(4): wrap_int(3), wrap_int(3): wrap_int(26), wrap_int(6): wrap_int(74)}, {wrap_int(0): wrap_int(647), wrap_int(5): wrap_int(346)}, {wrap_int(2): wrap_int(297), wrap_int(6): wrap_int(358), wrap_int(3): wrap_int(636), wrap_int(0): wrap_int(722), wrap_int(4): wrap_int(942)}]), bound=wrap_int(996)):
    return (path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == wrap_int(1)).__and__(sym_sum(sym_generator((weights[a][b] for a, b in sym_zip(path, path[1:])))) <= bound)
Exception -- for puzzle ShortestPath:4 'dict' object has no attribute 'z3_expr'

Solving puzzle 605/732: UnweightedShortestPath:0
sat_func def sat(path: List[int], edges=[[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(0), wrap_int(11)]), wrap_list([wrap_int(0), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(5)]), wrap_list([wrap_int(0), wrap_int(22)]), wrap_list([wrap_int(11), wrap_int(22)]), wrap_list([wrap_int(11), wrap_int(33)]), wrap_list([wrap_int(22), wrap_int(33)])]), u=wrap_int(0), v=wrap_int(33), bound=wrap_int(3)):
    _assert((path[wrap_int(0)] == u).__and__(path[-wrap_int(1)] == v).__and__(all(sym_generator((sym_in(wrap_list([i, j]), edges) for i, j in sym_zip(path, path[1:]))))))
    return sym_len(path) <= bound
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 0) (= (list.get.int x -1) 33)) true))
(assert (<= (list.length.int x) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle UnweightedShortestPath:0
Too many constants for extrapolation

Solving puzzle 606/732: UnweightedShortestPath:1
sat_func def sat(path: List[int], edges=[[12, 4], [33, 15], [37, 12], [11, 1], [34, 19], [42, 36], [2, 38], [6, 25], [29, 25], [30, 6], [16, 31], [10, 41], [15, 2], [3, 19], [1, 26], [17, 17], [19, 4], [0, 6], [42, 5], [11, 13], [22, 15], [39, 11], [35, 34], [39, 20], [7, 31], [38, 27], [9, 30], [31, 25], [0, 9], [13, 34], [31, 34], [19, 42], [37, 32], [4, 13], [11, 43], [14, 0], [22, 41], [20, 17], [0, 15], [13, 4], [20, 6], [34, 42], [42, 10], [32, 19], [41, 8], [26, 42], [0, 13], [28, 42], [9, 0], [32, 26], [6, 4], [27, 19], [37, 9], [7, 6], [25, 14], [23, 14], [31, 39], [18, 27], [34, 36], [24, 16], [24, 31], [16, 17], [2, 4], [34, 40], [28, 6], [41, 9], [17, 18], [43, 11], [11, 39], [43, 29], [1, 19], [27, 27], [4, 42], [0, 16], [16, 14], [40, 22], [22, 22], [38, 16], [3, 34], [33, 23], [2, 18], [3, 11], [4, 5], [18, 3], [23, 11], [41, 22], [7, 26], [31, 42], [35, 33], [15, 28], [34, 10], [36, 3], [9, 38], [17, 5], [3, 9], [37, 21], [36, 1], [25, 6], [22, 12], [42, 3], [16, 32], [0, 11], [24, 33], [15, 31], [18, 34], [11, 8], [30, 41], [19, 19], [4, 11], [22, 16], [1, 13], [6, 22], [12, 30], [19, 15], [3, 21], [38, 29], [32, 39], [1, 17], [16, 20], [10, 39], [32, 27], [37, 6], [18, 18], [22, 32], [31, 32], [24, 32], [22, 25], [38, 18], [38, 21], [39, 12], [9, 17], [10, 42], [29, 36], [34, 23], [27, 29], [17, 24], [24, 28], [31, 23], [28, 7], [5, 2], [24, 26], [27, 13], [43, 19], [37, 36], [2, 13], [10, 11], [30, 11], [29, 32], [4, 24], [17, 27], [21, 2], [24, 43], [26, 37], [16, 6], [43, 35], [42, 27], [26, 12], [39, 3], [38, 25], [20, 5], [36, 8], [25, 42], [27, 40], [39, 23], [6, 12], [27, 32], [12, 34], [2, 5], [40, 35], [15, 12], [22, 29], [21, 11], [0, 22], [13, 23], [27, 4], [35, 24], [32, 29], [4, 14], [9, 7], [32, 11], [11, 26], [26, 41], [2, 16], [38, 23], [30, 29], [6, 31], [1, 34], [4, 39], [24, 3], [25, 22], [9, 14], [33, 26], [34, 38], [35, 29], [32, 38], [5, 42], [42, 24], [15, 38], [41, 14], [39, 9], [4, 36], [21, 24], [36, 9]], u=14, v=1, bound=4):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(12), wrap_int(4)]), wrap_list([wrap_int(33), wrap_int(15)]), wrap_list([wrap_int(37), wrap_int(12)]), wrap_list([wrap_int(11), wrap_int(1)]), wrap_list([wrap_int(34), wrap_int(19)]), wrap_list([wrap_int(42), wrap_int(36)]), wrap_list([wrap_int(2), wrap_int(38)]), wrap_list([wrap_int(6), wrap_int(25)]), wrap_list([wrap_int(29), wrap_int(25)]), wrap_list([wrap_int(30), wrap_int(6)]), wrap_list([wrap_int(16), wrap_int(31)]), wrap_list([wrap_int(10), wrap_int(41)]), wrap_list([wrap_int(15), wrap_int(2)]), wrap_list([wrap_int(3), wrap_int(19)]), wrap_list([wrap_int(1), wrap_int(26)]), wrap_list([wrap_int(17), wrap_int(17)]), wrap_list([wrap_int(19), wrap_int(4)]), wrap_list([wrap_int(0), wrap_int(6)]), wrap_list([wrap_int(42), wrap_int(5)]), wrap_list([wrap_int(11), wrap_int(13)]), wrap_list([wrap_int(22), wrap_int(15)]), wrap_list([wrap_int(39), wrap_int(11)]), wrap_list([wrap_int(35), wrap_int(34)]), wrap_list([wrap_int(39), wrap_int(20)]), wrap_list([wrap_int(7), wrap_int(31)]), wrap_list([wrap_int(38), wrap_int(27)]), wrap_list([wrap_int(9), wrap_int(30)]), wrap_list([wrap_int(31), wrap_int(25)]), wrap_list([wrap_int(0), wrap_int(9)]), wrap_list([wrap_int(13), wrap_int(34)]), wrap_list([wrap_int(31), wrap_int(34)]), wrap_list([wrap_int(19), wrap_int(42)]), wrap_list([wrap_int(37), wrap_int(32)]), wrap_list([wrap_int(4), wrap_int(13)]), wrap_list([wrap_int(11), wrap_int(43)]), wrap_list([wrap_int(14), wrap_int(0)]), wrap_list([wrap_int(22), wrap_int(41)]), wrap_list([wrap_int(20), wrap_int(17)]), wrap_list([wrap_int(0), wrap_int(15)]), wrap_list([wrap_int(13), wrap_int(4)]), wrap_list([wrap_int(20), wrap_int(6)]), wrap_list([wrap_int(34), wrap_int(42)]), wrap_list([wrap_int(42), wrap_int(10)]), wrap_list([wrap_int(32), wrap_int(19)]), wrap_list([wrap_int(41), wrap_int(8)]), wrap_list([wrap_int(26), wrap_int(42)]), wrap_list([wrap_int(0), wrap_int(13)]), wrap_list([wrap_int(28), wrap_int(42)]), wrap_list([wrap_int(9), wrap_int(0)]), wrap_list([wrap_int(32), wrap_int(26)]), wrap_list([wrap_int(6), wrap_int(4)]), wrap_list([wrap_int(27), wrap_int(19)]), wrap_list([wrap_int(37), wrap_int(9)]), wrap_list([wrap_int(7), wrap_int(6)]), wrap_list([wrap_int(25), wrap_int(14)]), wrap_list([wrap_int(23), wrap_int(14)]), wrap_list([wrap_int(31), wrap_int(39)]), wrap_list([wrap_int(18), wrap_int(27)]), wrap_list([wrap_int(34), wrap_int(36)]), wrap_list([wrap_int(24), wrap_int(16)]), wrap_list([wrap_int(24), wrap_int(31)]), wrap_list([wrap_int(16), wrap_int(17)]), wrap_list([wrap_int(2), wrap_int(4)]), wrap_list([wrap_int(34), wrap_int(40)]), wrap_list([wrap_int(28), wrap_int(6)]), wrap_list([wrap_int(41), wrap_int(9)]), wrap_list([wrap_int(17), wrap_int(18)]), wrap_list([wrap_int(43), wrap_int(11)]), wrap_list([wrap_int(11), wrap_int(39)]), wrap_list([wrap_int(43), wrap_int(29)]), wrap_list([wrap_int(1), wrap_int(19)]), wrap_list([wrap_int(27), wrap_int(27)]), wrap_list([wrap_int(4), wrap_int(42)]), wrap_list([wrap_int(0), wrap_int(16)]), wrap_list([wrap_int(16), wrap_int(14)]), wrap_list([wrap_int(40), wrap_int(22)]), wrap_list([wrap_int(22), wrap_int(22)]), wrap_list([wrap_int(38), wrap_int(16)]), wrap_list([wrap_int(3), wrap_int(34)]), wrap_list([wrap_int(33), wrap_int(23)]), wrap_list([wrap_int(2), wrap_int(18)]), wrap_list([wrap_int(3), wrap_int(11)]), wrap_list([wrap_int(4), wrap_int(5)]), wrap_list([wrap_int(18), wrap_int(3)]), wrap_list([wrap_int(23), wrap_int(11)]), wrap_list([wrap_int(41), wrap_int(22)]), wrap_list([wrap_int(7), wrap_int(26)]), wrap_list([wrap_int(31), wrap_int(42)]), wrap_list([wrap_int(35), wrap_int(33)]), wrap_list([wrap_int(15), wrap_int(28)]), wrap_list([wrap_int(34), wrap_int(10)]), wrap_list([wrap_int(36), wrap_int(3)]), wrap_list([wrap_int(9), wrap_int(38)]), wrap_list([wrap_int(17), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(9)]), wrap_list([wrap_int(37), wrap_int(21)]), wrap_list([wrap_int(36), wrap_int(1)]), wrap_list([wrap_int(25), wrap_int(6)]), wrap_list([wrap_int(22), wrap_int(12)]), wrap_list([wrap_int(42), wrap_int(3)]), wrap_list([wrap_int(16), wrap_int(32)]), wrap_list([wrap_int(0), wrap_int(11)]), wrap_list([wrap_int(24), wrap_int(33)]), wrap_list([wrap_int(15), wrap_int(31)]), wrap_list([wrap_int(18), wrap_int(34)]), wrap_list([wrap_int(11), wrap_int(8)]), wrap_list([wrap_int(30), wrap_int(41)]), wrap_list([wrap_int(19), wrap_int(19)]), wrap_list([wrap_int(4), wrap_int(11)]), wrap_list([wrap_int(22), wrap_int(16)]), wrap_list([wrap_int(1), wrap_int(13)]), wrap_list([wrap_int(6), wrap_int(22)]), wrap_list([wrap_int(12), wrap_int(30)]), wrap_list([wrap_int(19), wrap_int(15)]), wrap_list([wrap_int(3), wrap_int(21)]), wrap_list([wrap_int(38), wrap_int(29)]), wrap_list([wrap_int(32), wrap_int(39)]), wrap_list([wrap_int(1), wrap_int(17)]), wrap_list([wrap_int(16), wrap_int(20)]), wrap_list([wrap_int(10), wrap_int(39)]), wrap_list([wrap_int(32), wrap_int(27)]), wrap_list([wrap_int(37), wrap_int(6)]), wrap_list([wrap_int(18), wrap_int(18)]), wrap_list([wrap_int(22), wrap_int(32)]), wrap_list([wrap_int(31), wrap_int(32)]), wrap_list([wrap_int(24), wrap_int(32)]), wrap_list([wrap_int(22), wrap_int(25)]), wrap_list([wrap_int(38), wrap_int(18)]), wrap_list([wrap_int(38), wrap_int(21)]), wrap_list([wrap_int(39), wrap_int(12)]), wrap_list([wrap_int(9), wrap_int(17)]), wrap_list([wrap_int(10), wrap_int(42)]), wrap_list([wrap_int(29), wrap_int(36)]), wrap_list([wrap_int(34), wrap_int(23)]), wrap_list([wrap_int(27), wrap_int(29)]), wrap_list([wrap_int(17), wrap_int(24)]), wrap_list([wrap_int(24), wrap_int(28)]), wrap_list([wrap_int(31), wrap_int(23)]), wrap_list([wrap_int(28), wrap_int(7)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(24), wrap_int(26)]), wrap_list([wrap_int(27), wrap_int(13)]), wrap_list([wrap_int(43), wrap_int(19)]), wrap_list([wrap_int(37), wrap_int(36)]), wrap_list([wrap_int(2), wrap_int(13)]), wrap_list([wrap_int(10), wrap_int(11)]), wrap_list([wrap_int(30), wrap_int(11)]), wrap_list([wrap_int(29), wrap_int(32)]), wrap_list([wrap_int(4), wrap_int(24)]), wrap_list([wrap_int(17), wrap_int(27)]), wrap_list([wrap_int(21), wrap_int(2)]), wrap_list([wrap_int(24), wrap_int(43)]), wrap_list([wrap_int(26), wrap_int(37)]), wrap_list([wrap_int(16), wrap_int(6)]), wrap_list([wrap_int(43), wrap_int(35)]), wrap_list([wrap_int(42), wrap_int(27)]), wrap_list([wrap_int(26), wrap_int(12)]), wrap_list([wrap_int(39), wrap_int(3)]), wrap_list([wrap_int(38), wrap_int(25)]), wrap_list([wrap_int(20), wrap_int(5)]), wrap_list([wrap_int(36), wrap_int(8)]), wrap_list([wrap_int(25), wrap_int(42)]), wrap_list([wrap_int(27), wrap_int(40)]), wrap_list([wrap_int(39), wrap_int(23)]), wrap_list([wrap_int(6), wrap_int(12)]), wrap_list([wrap_int(27), wrap_int(32)]), wrap_list([wrap_int(12), wrap_int(34)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(40), wrap_int(35)]), wrap_list([wrap_int(15), wrap_int(12)]), wrap_list([wrap_int(22), wrap_int(29)]), wrap_list([wrap_int(21), wrap_int(11)]), wrap_list([wrap_int(0), wrap_int(22)]), wrap_list([wrap_int(13), wrap_int(23)]), wrap_list([wrap_int(27), wrap_int(4)]), wrap_list([wrap_int(35), wrap_int(24)]), wrap_list([wrap_int(32), wrap_int(29)]), wrap_list([wrap_int(4), wrap_int(14)]), wrap_list([wrap_int(9), wrap_int(7)]), wrap_list([wrap_int(32), wrap_int(11)]), wrap_list([wrap_int(11), wrap_int(26)]), wrap_list([wrap_int(26), wrap_int(41)]), wrap_list([wrap_int(2), wrap_int(16)]), wrap_list([wrap_int(38), wrap_int(23)]), wrap_list([wrap_int(30), wrap_int(29)]), wrap_list([wrap_int(6), wrap_int(31)]), wrap_list([wrap_int(1), wrap_int(34)]), wrap_list([wrap_int(4), wrap_int(39)]), wrap_list([wrap_int(24), wrap_int(3)]), wrap_list([wrap_int(25), wrap_int(22)]), wrap_list([wrap_int(9), wrap_int(14)]), wrap_list([wrap_int(33), wrap_int(26)]), wrap_list([wrap_int(34), wrap_int(38)]), wrap_list([wrap_int(35), wrap_int(29)]), wrap_list([wrap_int(32), wrap_int(38)]), wrap_list([wrap_int(5), wrap_int(42)]), wrap_list([wrap_int(42), wrap_int(24)]), wrap_list([wrap_int(15), wrap_int(38)]), wrap_list([wrap_int(41), wrap_int(14)]), wrap_list([wrap_int(39), wrap_int(9)]), wrap_list([wrap_int(4), wrap_int(36)]), wrap_list([wrap_int(21), wrap_int(24)]), wrap_list([wrap_int(36), wrap_int(9)])]), u=wrap_int(14), v=wrap_int(1), bound=wrap_int(4)):
    _assert((path[wrap_int(0)] == u).__and__(path[-wrap_int(1)] == v).__and__(all(sym_generator((sym_in(wrap_list([i, j]), edges) for i, j in sym_zip(path, path[1:]))))))
    return sym_len(path) <= bound
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 14) (= (list.get.int x -1) 1)) true))
(assert (<= (list.length.int x) 4))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle UnweightedShortestPath:1
Too many constants for extrapolation

Solving puzzle 607/732: UnweightedShortestPath:2
sat_func def sat(path: List[int], edges=[[2, 6], [6, 2], [2, 5], [4, 7], [4, 1], [0, 2], [3, 3], [6, 1], [4, 0], [1, 3], [5, 2], [4, 2], [6, 7], [2, 2], [2, 3], [4, 4], [5, 0], [0, 7], [4, 3], [6, 4], [0, 0], [3, 0], [2, 7], [1, 7], [3, 2], [1, 2], [2, 4], [7, 5]], u=1, v=2, bound=2):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(2), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(4), wrap_int(7)]), wrap_list([wrap_int(4), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(3), wrap_int(3)]), wrap_list([wrap_int(6), wrap_int(1)]), wrap_list([wrap_int(4), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(4), wrap_int(2)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(2), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(4)]), wrap_list([wrap_int(5), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(7)]), wrap_list([wrap_int(4), wrap_int(3)]), wrap_list([wrap_int(6), wrap_int(4)]), wrap_list([wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(7)]), wrap_list([wrap_int(3), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(4)]), wrap_list([wrap_int(7), wrap_int(5)])]), u=wrap_int(1), v=wrap_int(2), bound=wrap_int(2)):
    _assert((path[wrap_int(0)] == u).__and__(path[-wrap_int(1)] == v).__and__(all(sym_generator((sym_in(wrap_list([i, j]), edges) for i, j in sym_zip(path, path[1:]))))))
    return sym_len(path) <= bound
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 1) (= (list.get.int x -1) 2)) true))
(assert (<= (list.length.int x) 2))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle UnweightedShortestPath:2
Too many constants for extrapolation

Solving puzzle 608/732: UnweightedShortestPath:3
sat_func def sat(path: List[int], edges=[[6, 0], [6, 2], [6, 5], [6, 4], [1, 4], [4, 3], [5, 3], [4, 4], [3, 1], [4, 6], [4, 2], [0, 2], [6, 6], [2, 3], [1, 0], [1, 5], [0, 0], [5, 4], [0, 1], [1, 2], [0, 4], [2, 5], [3, 0]], u=4, v=2, bound=2):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(6), wrap_int(0)]), wrap_list([wrap_int(6), wrap_int(2)]), wrap_list([wrap_int(6), wrap_int(5)]), wrap_list([wrap_int(6), wrap_int(4)]), wrap_list([wrap_int(1), wrap_int(4)]), wrap_list([wrap_int(4), wrap_int(3)]), wrap_list([wrap_int(5), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(4)]), wrap_list([wrap_int(3), wrap_int(1)]), wrap_list([wrap_int(4), wrap_int(6)]), wrap_list([wrap_int(4), wrap_int(2)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(6), wrap_int(6)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(5), wrap_int(4)]), wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(0), wrap_int(4)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(0)])]), u=wrap_int(4), v=wrap_int(2), bound=wrap_int(2)):
    _assert((path[wrap_int(0)] == u).__and__(path[-wrap_int(1)] == v).__and__(all(sym_generator((sym_in(wrap_list([i, j]), edges) for i, j in sym_zip(path, path[1:]))))))
    return sym_len(path) <= bound
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 4) (= (list.get.int x -1) 2)) true))
(assert (<= (list.length.int x) 2))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle UnweightedShortestPath:3
Too many constants for extrapolation

Solving puzzle 609/732: UnweightedShortestPath:4
sat_func def sat(path: List[int], edges=[[1, 1], [2, 0], [1, 0], [2, 2]], u=1, v=1, bound=1):
    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))
    return len(path) <= bound
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(1), wrap_int(1)]), wrap_list([wrap_int(2), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(2)])]), u=wrap_int(1), v=wrap_int(1), bound=wrap_int(1)):
    _assert((path[wrap_int(0)] == u).__and__(path[-wrap_int(1)] == v).__and__(all(sym_generator((sym_in(wrap_list([i, j]), edges) for i, j in sym_zip(path, path[1:]))))))
    return sym_len(path) <= bound
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 1) (= (list.get.int x -1) 1)) true))
(assert (<= (list.length.int x) 1))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) (as nil (List Int)))
)

Found solution []
Exception in checking result: list index out of range
WARNING: Solution verification failed for puzzle UnweightedShortestPath:4
Too many constants for extrapolation

Solving puzzle 610/732: AnyPath:0
sat_func def sat(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(4)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(5), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(2)])])):
    for i in sym_range(sym_len(path) - 1):
        _assert(sym_in(wrap_list([path[i], path[i + wrap_int(1)]]), edges))
    _assert(path[wrap_int(0)] == wrap_int(0))
    _assert(path[-wrap_int(1)] == max(sym_generator((max(edge) for edge in edges))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) false)))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x 0) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x -1) 7))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle AnyPath:0
Too many constants for extrapolation

Solving puzzle 611/732: AnyPath:1
sat_func def sat(path: List[int], edges=[[16, 8], [13, 33], [29, 37], [25, 10], [3, 33], [43, 10], [19, 9], [26, 16], [0, 9], [18, 36], [40, 32], [24, 10], [25, 35], [15, 14], [18, 2], [17, 5], [15, 26], [28, 28], [4, 39], [26, 9], [35, 22], [42, 11], [44, 13], [6, 34], [33, 0], [36, 34], [41, 34], [31, 1], [41, 27], [20, 43], [30, 33], [15, 18], [8, 20], [31, 14], [21, 33], [40, 28], [35, 39], [19, 14], [35, 10], [3, 34], [14, 11], [34, 36], [29, 3], [20, 33], [27, 14], [5, 29], [15, 6], [21, 20], [36, 1], [30, 40], [44, 6], [24, 43], [24, 30], [3, 16], [8, 34], [15, 36], [33, 36], [19, 17], [35, 17], [20, 29], [0, 27], [36, 38], [1, 0], [43, 18], [5, 36], [22, 10], [5, 32], [11, 34], [4, 15], [4, 9], [4, 6], [24, 12], [8, 27], [42, 38], [25, 2], [2, 12], [1, 34], [36, 22], [24, 42], [4, 18], [30, 13], [16, 44], [4, 21], [22, 35], [33, 32], [24, 26], [21, 44]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(16), wrap_int(8)]), wrap_list([wrap_int(13), wrap_int(33)]), wrap_list([wrap_int(29), wrap_int(37)]), wrap_list([wrap_int(25), wrap_int(10)]), wrap_list([wrap_int(3), wrap_int(33)]), wrap_list([wrap_int(43), wrap_int(10)]), wrap_list([wrap_int(19), wrap_int(9)]), wrap_list([wrap_int(26), wrap_int(16)]), wrap_list([wrap_int(0), wrap_int(9)]), wrap_list([wrap_int(18), wrap_int(36)]), wrap_list([wrap_int(40), wrap_int(32)]), wrap_list([wrap_int(24), wrap_int(10)]), wrap_list([wrap_int(25), wrap_int(35)]), wrap_list([wrap_int(15), wrap_int(14)]), wrap_list([wrap_int(18), wrap_int(2)]), wrap_list([wrap_int(17), wrap_int(5)]), wrap_list([wrap_int(15), wrap_int(26)]), wrap_list([wrap_int(28), wrap_int(28)]), wrap_list([wrap_int(4), wrap_int(39)]), wrap_list([wrap_int(26), wrap_int(9)]), wrap_list([wrap_int(35), wrap_int(22)]), wrap_list([wrap_int(42), wrap_int(11)]), wrap_list([wrap_int(44), wrap_int(13)]), wrap_list([wrap_int(6), wrap_int(34)]), wrap_list([wrap_int(33), wrap_int(0)]), wrap_list([wrap_int(36), wrap_int(34)]), wrap_list([wrap_int(41), wrap_int(34)]), wrap_list([wrap_int(31), wrap_int(1)]), wrap_list([wrap_int(41), wrap_int(27)]), wrap_list([wrap_int(20), wrap_int(43)]), wrap_list([wrap_int(30), wrap_int(33)]), wrap_list([wrap_int(15), wrap_int(18)]), wrap_list([wrap_int(8), wrap_int(20)]), wrap_list([wrap_int(31), wrap_int(14)]), wrap_list([wrap_int(21), wrap_int(33)]), wrap_list([wrap_int(40), wrap_int(28)]), wrap_list([wrap_int(35), wrap_int(39)]), wrap_list([wrap_int(19), wrap_int(14)]), wrap_list([wrap_int(35), wrap_int(10)]), wrap_list([wrap_int(3), wrap_int(34)]), wrap_list([wrap_int(14), wrap_int(11)]), wrap_list([wrap_int(34), wrap_int(36)]), wrap_list([wrap_int(29), wrap_int(3)]), wrap_list([wrap_int(20), wrap_int(33)]), wrap_list([wrap_int(27), wrap_int(14)]), wrap_list([wrap_int(5), wrap_int(29)]), wrap_list([wrap_int(15), wrap_int(6)]), wrap_list([wrap_int(21), wrap_int(20)]), wrap_list([wrap_int(36), wrap_int(1)]), wrap_list([wrap_int(30), wrap_int(40)]), wrap_list([wrap_int(44), wrap_int(6)]), wrap_list([wrap_int(24), wrap_int(43)]), wrap_list([wrap_int(24), wrap_int(30)]), wrap_list([wrap_int(3), wrap_int(16)]), wrap_list([wrap_int(8), wrap_int(34)]), wrap_list([wrap_int(15), wrap_int(36)]), wrap_list([wrap_int(33), wrap_int(36)]), wrap_list([wrap_int(19), wrap_int(17)]), wrap_list([wrap_int(35), wrap_int(17)]), wrap_list([wrap_int(20), wrap_int(29)]), wrap_list([wrap_int(0), wrap_int(27)]), wrap_list([wrap_int(36), wrap_int(38)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(43), wrap_int(18)]), wrap_list([wrap_int(5), wrap_int(36)]), wrap_list([wrap_int(22), wrap_int(10)]), wrap_list([wrap_int(5), wrap_int(32)]), wrap_list([wrap_int(11), wrap_int(34)]), wrap_list([wrap_int(4), wrap_int(15)]), wrap_list([wrap_int(4), wrap_int(9)]), wrap_list([wrap_int(4), wrap_int(6)]), wrap_list([wrap_int(24), wrap_int(12)]), wrap_list([wrap_int(8), wrap_int(27)]), wrap_list([wrap_int(42), wrap_int(38)]), wrap_list([wrap_int(25), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(12)]), wrap_list([wrap_int(1), wrap_int(34)]), wrap_list([wrap_int(36), wrap_int(22)]), wrap_list([wrap_int(24), wrap_int(42)]), wrap_list([wrap_int(4), wrap_int(18)]), wrap_list([wrap_int(30), wrap_int(13)]), wrap_list([wrap_int(16), wrap_int(44)]), wrap_list([wrap_int(4), wrap_int(21)]), wrap_list([wrap_int(22), wrap_int(35)]), wrap_list([wrap_int(33), wrap_int(32)]), wrap_list([wrap_int(24), wrap_int(26)]), wrap_list([wrap_int(21), wrap_int(44)])])):
    for i in sym_range(sym_len(path) - 1):
        _assert(sym_in(wrap_list([path[i], path[i + wrap_int(1)]]), edges))
    _assert(path[wrap_int(0)] == wrap_int(0))
    _assert(path[-wrap_int(1)] == max(sym_generator((max(edge) for edge in edges))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) false)))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x 0) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x -1) 44))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle AnyPath:1
Too many constants for extrapolation

Solving puzzle 612/732: AnyPath:2
sat_func def sat(path: List[int], edges=[[0, 0]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(0), wrap_int(0)])])):
    for i in sym_range(sym_len(path) - 1):
        _assert(sym_in(wrap_list([path[i], path[i + wrap_int(1)]]), edges))
    _assert(path[wrap_int(0)] == wrap_int(0))
    _assert(path[-wrap_int(1)] == max(sym_generator((max(edge) for edge in edges))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) false)))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x 0) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x -1) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle AnyPath:2
Too many constants for extrapolation

Solving puzzle 613/732: AnyPath:3
sat_func def sat(path: List[int], edges=[[2, 33], [39, 59], [22, 21], [55, 39], [34, 13], [28, 62], [34, 56], [41, 23], [52, 39], [27, 62], [19, 12], [14, 63], [48, 1], [53, 1], [47, 55], [43, 35], [13, 51], [18, 30], [7, 17], [25, 52], [35, 46], [16, 45], [7, 22], [42, 40], [35, 41], [21, 52], [35, 43], [22, 30], [20, 47], [48, 25], [32, 11], [38, 35], [39, 35], [34, 62], [19, 32], [15, 51], [62, 29], [54, 26], [1, 6], [42, 51], [26, 62], [18, 8], [47, 40], [30, 41], [42, 15], [35, 36], [12, 55], [38, 53], [52, 37], [4, 44], [13, 61], [2, 58], [9, 48], [2, 11], [52, 0], [11, 35], [33, 7], [49, 40], [21, 46], [1, 30], [60, 34], [36, 46], [8, 52], [43, 58], [53, 63], [61, 16], [50, 16], [33, 44], [23, 26], [27, 16], [52, 18], [59, 1], [29, 44], [37, 57], [25, 2], [3, 15], [33, 19], [22, 6], [59, 51], [58, 32], [46, 37], [15, 9], [1, 35], [48, 6], [15, 59], [58, 28], [6, 24], [4, 38], [37, 20], [52, 28], [43, 40], [28, 39], [58, 31], [62, 35], [63, 11], [24, 40], [44, 38], [0, 44], [57, 11], [0, 16], [41, 1], [62, 55], [8, 51], [5, 8], [46, 26], [40, 6], [45, 42], [24, 32], [19, 31], [6, 55], [30, 2], [43, 57], [25, 48], [53, 31], [29, 13], [63, 39], [37, 46], [32, 40], [16, 16], [53, 59], [11, 57], [33, 20], [19, 11], [47, 51], [50, 15], [19, 36]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(2), wrap_int(33)]), wrap_list([wrap_int(39), wrap_int(59)]), wrap_list([wrap_int(22), wrap_int(21)]), wrap_list([wrap_int(55), wrap_int(39)]), wrap_list([wrap_int(34), wrap_int(13)]), wrap_list([wrap_int(28), wrap_int(62)]), wrap_list([wrap_int(34), wrap_int(56)]), wrap_list([wrap_int(41), wrap_int(23)]), wrap_list([wrap_int(52), wrap_int(39)]), wrap_list([wrap_int(27), wrap_int(62)]), wrap_list([wrap_int(19), wrap_int(12)]), wrap_list([wrap_int(14), wrap_int(63)]), wrap_list([wrap_int(48), wrap_int(1)]), wrap_list([wrap_int(53), wrap_int(1)]), wrap_list([wrap_int(47), wrap_int(55)]), wrap_list([wrap_int(43), wrap_int(35)]), wrap_list([wrap_int(13), wrap_int(51)]), wrap_list([wrap_int(18), wrap_int(30)]), wrap_list([wrap_int(7), wrap_int(17)]), wrap_list([wrap_int(25), wrap_int(52)]), wrap_list([wrap_int(35), wrap_int(46)]), wrap_list([wrap_int(16), wrap_int(45)]), wrap_list([wrap_int(7), wrap_int(22)]), wrap_list([wrap_int(42), wrap_int(40)]), wrap_list([wrap_int(35), wrap_int(41)]), wrap_list([wrap_int(21), wrap_int(52)]), wrap_list([wrap_int(35), wrap_int(43)]), wrap_list([wrap_int(22), wrap_int(30)]), wrap_list([wrap_int(20), wrap_int(47)]), wrap_list([wrap_int(48), wrap_int(25)]), wrap_list([wrap_int(32), wrap_int(11)]), wrap_list([wrap_int(38), wrap_int(35)]), wrap_list([wrap_int(39), wrap_int(35)]), wrap_list([wrap_int(34), wrap_int(62)]), wrap_list([wrap_int(19), wrap_int(32)]), wrap_list([wrap_int(15), wrap_int(51)]), wrap_list([wrap_int(62), wrap_int(29)]), wrap_list([wrap_int(54), wrap_int(26)]), wrap_list([wrap_int(1), wrap_int(6)]), wrap_list([wrap_int(42), wrap_int(51)]), wrap_list([wrap_int(26), wrap_int(62)]), wrap_list([wrap_int(18), wrap_int(8)]), wrap_list([wrap_int(47), wrap_int(40)]), wrap_list([wrap_int(30), wrap_int(41)]), wrap_list([wrap_int(42), wrap_int(15)]), wrap_list([wrap_int(35), wrap_int(36)]), wrap_list([wrap_int(12), wrap_int(55)]), wrap_list([wrap_int(38), wrap_int(53)]), wrap_list([wrap_int(52), wrap_int(37)]), wrap_list([wrap_int(4), wrap_int(44)]), wrap_list([wrap_int(13), wrap_int(61)]), wrap_list([wrap_int(2), wrap_int(58)]), wrap_list([wrap_int(9), wrap_int(48)]), wrap_list([wrap_int(2), wrap_int(11)]), wrap_list([wrap_int(52), wrap_int(0)]), wrap_list([wrap_int(11), wrap_int(35)]), wrap_list([wrap_int(33), wrap_int(7)]), wrap_list([wrap_int(49), wrap_int(40)]), wrap_list([wrap_int(21), wrap_int(46)]), wrap_list([wrap_int(1), wrap_int(30)]), wrap_list([wrap_int(60), wrap_int(34)]), wrap_list([wrap_int(36), wrap_int(46)]), wrap_list([wrap_int(8), wrap_int(52)]), wrap_list([wrap_int(43), wrap_int(58)]), wrap_list([wrap_int(53), wrap_int(63)]), wrap_list([wrap_int(61), wrap_int(16)]), wrap_list([wrap_int(50), wrap_int(16)]), wrap_list([wrap_int(33), wrap_int(44)]), wrap_list([wrap_int(23), wrap_int(26)]), wrap_list([wrap_int(27), wrap_int(16)]), wrap_list([wrap_int(52), wrap_int(18)]), wrap_list([wrap_int(59), wrap_int(1)]), wrap_list([wrap_int(29), wrap_int(44)]), wrap_list([wrap_int(37), wrap_int(57)]), wrap_list([wrap_int(25), wrap_int(2)]), wrap_list([wrap_int(3), wrap_int(15)]), wrap_list([wrap_int(33), wrap_int(19)]), wrap_list([wrap_int(22), wrap_int(6)]), wrap_list([wrap_int(59), wrap_int(51)]), wrap_list([wrap_int(58), wrap_int(32)]), wrap_list([wrap_int(46), wrap_int(37)]), wrap_list([wrap_int(15), wrap_int(9)]), wrap_list([wrap_int(1), wrap_int(35)]), wrap_list([wrap_int(48), wrap_int(6)]), wrap_list([wrap_int(15), wrap_int(59)]), wrap_list([wrap_int(58), wrap_int(28)]), wrap_list([wrap_int(6), wrap_int(24)]), wrap_list([wrap_int(4), wrap_int(38)]), wrap_list([wrap_int(37), wrap_int(20)]), wrap_list([wrap_int(52), wrap_int(28)]), wrap_list([wrap_int(43), wrap_int(40)]), wrap_list([wrap_int(28), wrap_int(39)]), wrap_list([wrap_int(58), wrap_int(31)]), wrap_list([wrap_int(62), wrap_int(35)]), wrap_list([wrap_int(63), wrap_int(11)]), wrap_list([wrap_int(24), wrap_int(40)]), wrap_list([wrap_int(44), wrap_int(38)]), wrap_list([wrap_int(0), wrap_int(44)]), wrap_list([wrap_int(57), wrap_int(11)]), wrap_list([wrap_int(0), wrap_int(16)]), wrap_list([wrap_int(41), wrap_int(1)]), wrap_list([wrap_int(62), wrap_int(55)]), wrap_list([wrap_int(8), wrap_int(51)]), wrap_list([wrap_int(5), wrap_int(8)]), wrap_list([wrap_int(46), wrap_int(26)]), wrap_list([wrap_int(40), wrap_int(6)]), wrap_list([wrap_int(45), wrap_int(42)]), wrap_list([wrap_int(24), wrap_int(32)]), wrap_list([wrap_int(19), wrap_int(31)]), wrap_list([wrap_int(6), wrap_int(55)]), wrap_list([wrap_int(30), wrap_int(2)]), wrap_list([wrap_int(43), wrap_int(57)]), wrap_list([wrap_int(25), wrap_int(48)]), wrap_list([wrap_int(53), wrap_int(31)]), wrap_list([wrap_int(29), wrap_int(13)]), wrap_list([wrap_int(63), wrap_int(39)]), wrap_list([wrap_int(37), wrap_int(46)]), wrap_list([wrap_int(32), wrap_int(40)]), wrap_list([wrap_int(16), wrap_int(16)]), wrap_list([wrap_int(53), wrap_int(59)]), wrap_list([wrap_int(11), wrap_int(57)]), wrap_list([wrap_int(33), wrap_int(20)]), wrap_list([wrap_int(19), wrap_int(11)]), wrap_list([wrap_int(47), wrap_int(51)]), wrap_list([wrap_int(50), wrap_int(15)]), wrap_list([wrap_int(19), wrap_int(36)])])):
    for i in sym_range(sym_len(path) - 1):
        _assert(sym_in(wrap_list([path[i], path[i + wrap_int(1)]]), edges))
    _assert(path[wrap_int(0)] == wrap_int(0))
    _assert(path[-wrap_int(1)] == max(sym_generator((max(edge) for edge in edges))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) false)))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x 0) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x -1) 63))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle AnyPath:3
Too many constants for extrapolation

Solving puzzle 614/732: AnyPath:4
sat_func def sat(path: List[int], edges=[[3, 5], [2, 1], [4, 5], [3, 6], [6, 7], [5, 3], [4, 3], [6, 2], [5, 2], [7, 0], [3, 4], [0, 5], [0, 0], [1, 0], [0, 2], [3, 1]]):
    for i in range(len(path) - 1):
        assert [path[i], path[i + 1]] in edges
    assert path[0] == 0
    assert path[-1] == max(max(edge) for edge in edges)
    return True
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(1)]), wrap_list([wrap_int(4), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(5), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(3)]), wrap_list([wrap_int(6), wrap_int(2)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(7), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(0), wrap_int(5)]), wrap_list([wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(3), wrap_int(1)])])):
    for i in sym_range(sym_len(path) - 1):
        _assert(sym_in(wrap_list([path[i], path[i + wrap_int(1)]]), edges))
    _assert(path[wrap_int(0)] == wrap_int(0))
    _assert(path[-wrap_int(1)] == max(sym_generator((max(edge) for edge in edges))))
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) false)))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x 0) 0))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) (= (list.get.int x -1) 7))))
(assert (forall ((i_0 Int)) (=> (and (>= i_0 0) (< i_0 (- (list.length.int x) 1))) true)))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle AnyPath:4
Too many constants for extrapolation

Solving puzzle 615/732: EvenPath:0
sat_func def sat(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(4)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(5), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(2)])])):
    _assert((path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == max(sym_generator((max(e) for e in edges)))))
    _assert(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(path, path[1:])]))
    return sym_len(path) % wrap_int(2) == wrap_int(0)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (= (list.get.int x 0) 0) (= (list.get.int x -1) 7)))
(assert false)
(assert (= (mod (list.length.int x) 2) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle EvenPath:0
Too many constants for extrapolation

Solving puzzle 616/732: EvenPath:1
sat_func def sat(path: List[int], edges=[[3, 2], [2, 1], [0, 2], [1, 0], [2, 2], [2, 3], [2, 0]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(3), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(2), wrap_int(0)])])):
    _assert((path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == max(sym_generator((max(e) for e in edges)))))
    _assert(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(path, path[1:])]))
    return sym_len(path) % wrap_int(2) == wrap_int(0)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (= (list.get.int x 0) 0) (= (list.get.int x -1) 3)))
(assert false)
(assert (= (mod (list.length.int x) 2) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle EvenPath:1
Too many constants for extrapolation

Solving puzzle 617/732: EvenPath:2
sat_func def sat(path: List[int], edges=[[5, 15], [51, 42], [23, 5], [36, 2], [18, 43], [8, 47], [37, 6], [20, 25], [13, 25], [17, 2], [53, 30], [4, 50], [25, 47], [27, 5], [47, 7], [6, 18], [16, 30], [51, 3], [6, 13], [3, 12], [30, 13], [14, 43], [0, 5], [20, 7], [8, 3], [29, 55], [13, 11], [18, 39], [37, 13], [25, 8], [45, 30], [32, 8], [55, 43], [34, 42], [31, 21], [26, 19], [18, 1], [51, 35], [51, 51], [53, 22], [8, 23], [29, 21], [0, 44], [16, 38], [7, 16], [22, 45], [37, 16], [54, 20], [24, 13], [47, 37], [11, 10], [31, 31], [37, 55], [18, 6], [27, 43], [51, 38], [33, 38], [31, 3], [15, 35], [42, 11], [53, 4], [51, 24], [14, 27], [13, 18], [9, 55], [29, 0], [50, 31], [16, 18], [46, 3], [42, 44], [25, 12], [50, 10], [28, 51], [3, 25], [18, 26], [16, 0], [15, 37], [45, 48], [23, 50], [1, 15], [29, 35], [48, 32], [27, 10], [39, 49], [0, 36], [46, 2], [51, 29], [39, 6], [51, 33], [30, 54], [53, 2], [26, 6], [6, 4], [15, 2], [35, 27], [6, 36], [53, 19], [49, 54], [4, 44], [53, 6], [47, 41], [37, 21], [50, 48], [42, 47], [6, 2], [5, 46], [2, 50], [39, 29], [11, 42], [46, 33], [11, 22]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(5), wrap_int(15)]), wrap_list([wrap_int(51), wrap_int(42)]), wrap_list([wrap_int(23), wrap_int(5)]), wrap_list([wrap_int(36), wrap_int(2)]), wrap_list([wrap_int(18), wrap_int(43)]), wrap_list([wrap_int(8), wrap_int(47)]), wrap_list([wrap_int(37), wrap_int(6)]), wrap_list([wrap_int(20), wrap_int(25)]), wrap_list([wrap_int(13), wrap_int(25)]), wrap_list([wrap_int(17), wrap_int(2)]), wrap_list([wrap_int(53), wrap_int(30)]), wrap_list([wrap_int(4), wrap_int(50)]), wrap_list([wrap_int(25), wrap_int(47)]), wrap_list([wrap_int(27), wrap_int(5)]), wrap_list([wrap_int(47), wrap_int(7)]), wrap_list([wrap_int(6), wrap_int(18)]), wrap_list([wrap_int(16), wrap_int(30)]), wrap_list([wrap_int(51), wrap_int(3)]), wrap_list([wrap_int(6), wrap_int(13)]), wrap_list([wrap_int(3), wrap_int(12)]), wrap_list([wrap_int(30), wrap_int(13)]), wrap_list([wrap_int(14), wrap_int(43)]), wrap_list([wrap_int(0), wrap_int(5)]), wrap_list([wrap_int(20), wrap_int(7)]), wrap_list([wrap_int(8), wrap_int(3)]), wrap_list([wrap_int(29), wrap_int(55)]), wrap_list([wrap_int(13), wrap_int(11)]), wrap_list([wrap_int(18), wrap_int(39)]), wrap_list([wrap_int(37), wrap_int(13)]), wrap_list([wrap_int(25), wrap_int(8)]), wrap_list([wrap_int(45), wrap_int(30)]), wrap_list([wrap_int(32), wrap_int(8)]), wrap_list([wrap_int(55), wrap_int(43)]), wrap_list([wrap_int(34), wrap_int(42)]), wrap_list([wrap_int(31), wrap_int(21)]), wrap_list([wrap_int(26), wrap_int(19)]), wrap_list([wrap_int(18), wrap_int(1)]), wrap_list([wrap_int(51), wrap_int(35)]), wrap_list([wrap_int(51), wrap_int(51)]), wrap_list([wrap_int(53), wrap_int(22)]), wrap_list([wrap_int(8), wrap_int(23)]), wrap_list([wrap_int(29), wrap_int(21)]), wrap_list([wrap_int(0), wrap_int(44)]), wrap_list([wrap_int(16), wrap_int(38)]), wrap_list([wrap_int(7), wrap_int(16)]), wrap_list([wrap_int(22), wrap_int(45)]), wrap_list([wrap_int(37), wrap_int(16)]), wrap_list([wrap_int(54), wrap_int(20)]), wrap_list([wrap_int(24), wrap_int(13)]), wrap_list([wrap_int(47), wrap_int(37)]), wrap_list([wrap_int(11), wrap_int(10)]), wrap_list([wrap_int(31), wrap_int(31)]), wrap_list([wrap_int(37), wrap_int(55)]), wrap_list([wrap_int(18), wrap_int(6)]), wrap_list([wrap_int(27), wrap_int(43)]), wrap_list([wrap_int(51), wrap_int(38)]), wrap_list([wrap_int(33), wrap_int(38)]), wrap_list([wrap_int(31), wrap_int(3)]), wrap_list([wrap_int(15), wrap_int(35)]), wrap_list([wrap_int(42), wrap_int(11)]), wrap_list([wrap_int(53), wrap_int(4)]), wrap_list([wrap_int(51), wrap_int(24)]), wrap_list([wrap_int(14), wrap_int(27)]), wrap_list([wrap_int(13), wrap_int(18)]), wrap_list([wrap_int(9), wrap_int(55)]), wrap_list([wrap_int(29), wrap_int(0)]), wrap_list([wrap_int(50), wrap_int(31)]), wrap_list([wrap_int(16), wrap_int(18)]), wrap_list([wrap_int(46), wrap_int(3)]), wrap_list([wrap_int(42), wrap_int(44)]), wrap_list([wrap_int(25), wrap_int(12)]), wrap_list([wrap_int(50), wrap_int(10)]), wrap_list([wrap_int(28), wrap_int(51)]), wrap_list([wrap_int(3), wrap_int(25)]), wrap_list([wrap_int(18), wrap_int(26)]), wrap_list([wrap_int(16), wrap_int(0)]), wrap_list([wrap_int(15), wrap_int(37)]), wrap_list([wrap_int(45), wrap_int(48)]), wrap_list([wrap_int(23), wrap_int(50)]), wrap_list([wrap_int(1), wrap_int(15)]), wrap_list([wrap_int(29), wrap_int(35)]), wrap_list([wrap_int(48), wrap_int(32)]), wrap_list([wrap_int(27), wrap_int(10)]), wrap_list([wrap_int(39), wrap_int(49)]), wrap_list([wrap_int(0), wrap_int(36)]), wrap_list([wrap_int(46), wrap_int(2)]), wrap_list([wrap_int(51), wrap_int(29)]), wrap_list([wrap_int(39), wrap_int(6)]), wrap_list([wrap_int(51), wrap_int(33)]), wrap_list([wrap_int(30), wrap_int(54)]), wrap_list([wrap_int(53), wrap_int(2)]), wrap_list([wrap_int(26), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(4)]), wrap_list([wrap_int(15), wrap_int(2)]), wrap_list([wrap_int(35), wrap_int(27)]), wrap_list([wrap_int(6), wrap_int(36)]), wrap_list([wrap_int(53), wrap_int(19)]), wrap_list([wrap_int(49), wrap_int(54)]), wrap_list([wrap_int(4), wrap_int(44)]), wrap_list([wrap_int(53), wrap_int(6)]), wrap_list([wrap_int(47), wrap_int(41)]), wrap_list([wrap_int(37), wrap_int(21)]), wrap_list([wrap_int(50), wrap_int(48)]), wrap_list([wrap_int(42), wrap_int(47)]), wrap_list([wrap_int(6), wrap_int(2)]), wrap_list([wrap_int(5), wrap_int(46)]), wrap_list([wrap_int(2), wrap_int(50)]), wrap_list([wrap_int(39), wrap_int(29)]), wrap_list([wrap_int(11), wrap_int(42)]), wrap_list([wrap_int(46), wrap_int(33)]), wrap_list([wrap_int(11), wrap_int(22)])])):
    _assert((path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == max(sym_generator((max(e) for e in edges)))))
    _assert(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(path, path[1:])]))
    return sym_len(path) % wrap_int(2) == wrap_int(0)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (= (list.get.int x 0) 0) (= (list.get.int x -1) 55)))
(assert false)
(assert (= (mod (list.length.int x) 2) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle EvenPath:2
Too many constants for extrapolation

Solving puzzle 618/732: EvenPath:3
sat_func def sat(path: List[int], edges=[[13, 29], [70, 66], [46, 37], [1, 57], [37, 1], [43, 0], [71, 49], [49, 49], [1, 0], [13, 38], [34, 7], [56, 74], [44, 74], [35, 54], [41, 59], [53, 47], [48, 28], [52, 46], [36, 22], [74, 72], [43, 36], [65, 24], [14, 67], [64, 28], [8, 39], [71, 14], [22, 24], [20, 43], [67, 21], [12, 39], [40, 41], [54, 19], [26, 69], [48, 14], [24, 25], [24, 16], [45, 62], [43, 57], [71, 1], [31, 24], [27, 66], [64, 18], [73, 33], [25, 22], [31, 60], [67, 3], [4, 44], [41, 55], [0, 23], [7, 14], [46, 50], [40, 53], [4, 33], [8, 12], [64, 55], [19, 52], [52, 62], [3, 42], [33, 10], [67, 10], [1, 33], [39, 18], [18, 7], [2, 47], [29, 55], [29, 42], [44, 67], [55, 55], [25, 42], [39, 53], [59, 21], [44, 50], [31, 30], [60, 71], [49, 9], [20, 16], [37, 68], [58, 73], [41, 7], [30, 74], [61, 31], [71, 42], [72, 19], [66, 33], [24, 33], [57, 40], [3, 28], [59, 64], [16, 12], [72, 20], [3, 5], [59, 52], [70, 8], [71, 13], [20, 71], [64, 31], [22, 27], [53, 36], [49, 23], [40, 4], [55, 68], [32, 12], [21, 15], [57, 63], [8, 70], [72, 56], [33, 3], [41, 28], [4, 0], [44, 10], [33, 2], [36, 24], [59, 58], [45, 33], [61, 66], [21, 48], [10, 54], [46, 13], [40, 25], [28, 6], [65, 53], [0, 53], [51, 22], [71, 17], [52, 9], [30, 34], [68, 64], [54, 8], [35, 13], [64, 54], [45, 67], [47, 22], [69, 52], [18, 73], [21, 60], [72, 29], [7, 36], [68, 56], [17, 14], [44, 54], [46, 29], [72, 67], [17, 53], [54, 51], [26, 46], [65, 21], [27, 3], [50, 5]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(13), wrap_int(29)]), wrap_list([wrap_int(70), wrap_int(66)]), wrap_list([wrap_int(46), wrap_int(37)]), wrap_list([wrap_int(1), wrap_int(57)]), wrap_list([wrap_int(37), wrap_int(1)]), wrap_list([wrap_int(43), wrap_int(0)]), wrap_list([wrap_int(71), wrap_int(49)]), wrap_list([wrap_int(49), wrap_int(49)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(13), wrap_int(38)]), wrap_list([wrap_int(34), wrap_int(7)]), wrap_list([wrap_int(56), wrap_int(74)]), wrap_list([wrap_int(44), wrap_int(74)]), wrap_list([wrap_int(35), wrap_int(54)]), wrap_list([wrap_int(41), wrap_int(59)]), wrap_list([wrap_int(53), wrap_int(47)]), wrap_list([wrap_int(48), wrap_int(28)]), wrap_list([wrap_int(52), wrap_int(46)]), wrap_list([wrap_int(36), wrap_int(22)]), wrap_list([wrap_int(74), wrap_int(72)]), wrap_list([wrap_int(43), wrap_int(36)]), wrap_list([wrap_int(65), wrap_int(24)]), wrap_list([wrap_int(14), wrap_int(67)]), wrap_list([wrap_int(64), wrap_int(28)]), wrap_list([wrap_int(8), wrap_int(39)]), wrap_list([wrap_int(71), wrap_int(14)]), wrap_list([wrap_int(22), wrap_int(24)]), wrap_list([wrap_int(20), wrap_int(43)]), wrap_list([wrap_int(67), wrap_int(21)]), wrap_list([wrap_int(12), wrap_int(39)]), wrap_list([wrap_int(40), wrap_int(41)]), wrap_list([wrap_int(54), wrap_int(19)]), wrap_list([wrap_int(26), wrap_int(69)]), wrap_list([wrap_int(48), wrap_int(14)]), wrap_list([wrap_int(24), wrap_int(25)]), wrap_list([wrap_int(24), wrap_int(16)]), wrap_list([wrap_int(45), wrap_int(62)]), wrap_list([wrap_int(43), wrap_int(57)]), wrap_list([wrap_int(71), wrap_int(1)]), wrap_list([wrap_int(31), wrap_int(24)]), wrap_list([wrap_int(27), wrap_int(66)]), wrap_list([wrap_int(64), wrap_int(18)]), wrap_list([wrap_int(73), wrap_int(33)]), wrap_list([wrap_int(25), wrap_int(22)]), wrap_list([wrap_int(31), wrap_int(60)]), wrap_list([wrap_int(67), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(44)]), wrap_list([wrap_int(41), wrap_int(55)]), wrap_list([wrap_int(0), wrap_int(23)]), wrap_list([wrap_int(7), wrap_int(14)]), wrap_list([wrap_int(46), wrap_int(50)]), wrap_list([wrap_int(40), wrap_int(53)]), wrap_list([wrap_int(4), wrap_int(33)]), wrap_list([wrap_int(8), wrap_int(12)]), wrap_list([wrap_int(64), wrap_int(55)]), wrap_list([wrap_int(19), wrap_int(52)]), wrap_list([wrap_int(52), wrap_int(62)]), wrap_list([wrap_int(3), wrap_int(42)]), wrap_list([wrap_int(33), wrap_int(10)]), wrap_list([wrap_int(67), wrap_int(10)]), wrap_list([wrap_int(1), wrap_int(33)]), wrap_list([wrap_int(39), wrap_int(18)]), wrap_list([wrap_int(18), wrap_int(7)]), wrap_list([wrap_int(2), wrap_int(47)]), wrap_list([wrap_int(29), wrap_int(55)]), wrap_list([wrap_int(29), wrap_int(42)]), wrap_list([wrap_int(44), wrap_int(67)]), wrap_list([wrap_int(55), wrap_int(55)]), wrap_list([wrap_int(25), wrap_int(42)]), wrap_list([wrap_int(39), wrap_int(53)]), wrap_list([wrap_int(59), wrap_int(21)]), wrap_list([wrap_int(44), wrap_int(50)]), wrap_list([wrap_int(31), wrap_int(30)]), wrap_list([wrap_int(60), wrap_int(71)]), wrap_list([wrap_int(49), wrap_int(9)]), wrap_list([wrap_int(20), wrap_int(16)]), wrap_list([wrap_int(37), wrap_int(68)]), wrap_list([wrap_int(58), wrap_int(73)]), wrap_list([wrap_int(41), wrap_int(7)]), wrap_list([wrap_int(30), wrap_int(74)]), wrap_list([wrap_int(61), wrap_int(31)]), wrap_list([wrap_int(71), wrap_int(42)]), wrap_list([wrap_int(72), wrap_int(19)]), wrap_list([wrap_int(66), wrap_int(33)]), wrap_list([wrap_int(24), wrap_int(33)]), wrap_list([wrap_int(57), wrap_int(40)]), wrap_list([wrap_int(3), wrap_int(28)]), wrap_list([wrap_int(59), wrap_int(64)]), wrap_list([wrap_int(16), wrap_int(12)]), wrap_list([wrap_int(72), wrap_int(20)]), wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(59), wrap_int(52)]), wrap_list([wrap_int(70), wrap_int(8)]), wrap_list([wrap_int(71), wrap_int(13)]), wrap_list([wrap_int(20), wrap_int(71)]), wrap_list([wrap_int(64), wrap_int(31)]), wrap_list([wrap_int(22), wrap_int(27)]), wrap_list([wrap_int(53), wrap_int(36)]), wrap_list([wrap_int(49), wrap_int(23)]), wrap_list([wrap_int(40), wrap_int(4)]), wrap_list([wrap_int(55), wrap_int(68)]), wrap_list([wrap_int(32), wrap_int(12)]), wrap_list([wrap_int(21), wrap_int(15)]), wrap_list([wrap_int(57), wrap_int(63)]), wrap_list([wrap_int(8), wrap_int(70)]), wrap_list([wrap_int(72), wrap_int(56)]), wrap_list([wrap_int(33), wrap_int(3)]), wrap_list([wrap_int(41), wrap_int(28)]), wrap_list([wrap_int(4), wrap_int(0)]), wrap_list([wrap_int(44), wrap_int(10)]), wrap_list([wrap_int(33), wrap_int(2)]), wrap_list([wrap_int(36), wrap_int(24)]), wrap_list([wrap_int(59), wrap_int(58)]), wrap_list([wrap_int(45), wrap_int(33)]), wrap_list([wrap_int(61), wrap_int(66)]), wrap_list([wrap_int(21), wrap_int(48)]), wrap_list([wrap_int(10), wrap_int(54)]), wrap_list([wrap_int(46), wrap_int(13)]), wrap_list([wrap_int(40), wrap_int(25)]), wrap_list([wrap_int(28), wrap_int(6)]), wrap_list([wrap_int(65), wrap_int(53)]), wrap_list([wrap_int(0), wrap_int(53)]), wrap_list([wrap_int(51), wrap_int(22)]), wrap_list([wrap_int(71), wrap_int(17)]), wrap_list([wrap_int(52), wrap_int(9)]), wrap_list([wrap_int(30), wrap_int(34)]), wrap_list([wrap_int(68), wrap_int(64)]), wrap_list([wrap_int(54), wrap_int(8)]), wrap_list([wrap_int(35), wrap_int(13)]), wrap_list([wrap_int(64), wrap_int(54)]), wrap_list([wrap_int(45), wrap_int(67)]), wrap_list([wrap_int(47), wrap_int(22)]), wrap_list([wrap_int(69), wrap_int(52)]), wrap_list([wrap_int(18), wrap_int(73)]), wrap_list([wrap_int(21), wrap_int(60)]), wrap_list([wrap_int(72), wrap_int(29)]), wrap_list([wrap_int(7), wrap_int(36)]), wrap_list([wrap_int(68), wrap_int(56)]), wrap_list([wrap_int(17), wrap_int(14)]), wrap_list([wrap_int(44), wrap_int(54)]), wrap_list([wrap_int(46), wrap_int(29)]), wrap_list([wrap_int(72), wrap_int(67)]), wrap_list([wrap_int(17), wrap_int(53)]), wrap_list([wrap_int(54), wrap_int(51)]), wrap_list([wrap_int(26), wrap_int(46)]), wrap_list([wrap_int(65), wrap_int(21)]), wrap_list([wrap_int(27), wrap_int(3)]), wrap_list([wrap_int(50), wrap_int(5)])])):
    _assert((path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == max(sym_generator((max(e) for e in edges)))))
    _assert(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(path, path[1:])]))
    return sym_len(path) % wrap_int(2) == wrap_int(0)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (= (list.get.int x 0) 0) (= (list.get.int x -1) 74)))
(assert false)
(assert (= (mod (list.length.int x) 2) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle EvenPath:3
Too many constants for extrapolation

Solving puzzle 619/732: EvenPath:4
sat_func def sat(path: List[int], edges=[[67, 92], [18, 52], [25, 21], [83, 58], [36, 36], [26, 63], [48, 15], [53, 32], [62, 30], [41, 21], [91, 25], [82, 79], [33, 58], [65, 81], [57, 57], [62, 36], [85, 24], [14, 19], [58, 11], [20, 31], [76, 82], [92, 37], [73, 88], [90, 37], [68, 18], [70, 18], [45, 65], [45, 78], [87, 36], [41, 72], [66, 4], [25, 58], [18, 16], [72, 68], [21, 0], [44, 8], [51, 21], [30, 15], [18, 90], [75, 47], [42, 7], [13, 13], [27, 46], [78, 39], [71, 28], [85, 39], [56, 52], [60, 37], [37, 18], [82, 83], [84, 9], [31, 54], [81, 32], [46, 82], [10, 66], [85, 71], [3, 5], [15, 18], [83, 64], [9, 50], [60, 70], [7, 13], [81, 63], [32, 6], [18, 80], [22, 34], [60, 0], [88, 72], [9, 19], [74, 0], [87, 22], [41, 17], [66, 80], [33, 9], [71, 46], [23, 79], [64, 44], [40, 67], [78, 4], [8, 31], [15, 41], [42, 92], [22, 28], [57, 84], [69, 65], [35, 16], [1, 10], [7, 82], [62, 52], [8, 12], [51, 12], [5, 2], [83, 30], [76, 83], [0, 27], [30, 80], [33, 14], [39, 12], [51, 78], [30, 47], [25, 26], [11, 63], [52, 24], [32, 49], [0, 74], [51, 16], [1, 16], [14, 90], [49, 74], [69, 14], [72, 30], [61, 31], [54, 20], [46, 78], [4, 50], [13, 37], [61, 1], [4, 35], [29, 70], [20, 89], [28, 6], [74, 9], [86, 53], [58, 6], [57, 91], [10, 40], [15, 74], [23, 60], [5, 37], [50, 68], [78, 22], [90, 59], [74, 21], [80, 71], [92, 82], [42, 43], [68, 74], [43, 55], [67, 90], [87, 68], [40, 2], [55, 68], [52, 30], [10, 21], [44, 1], [39, 9], [12, 18], [61, 38], [65, 37], [10, 12], [21, 10], [81, 3], [65, 20], [31, 25], [59, 77], [43, 59], [75, 75], [71, 13], [17, 37], [31, 13], [6, 33], [24, 40], [52, 70], [70, 5], [4, 8], [20, 29], [11, 10], [43, 67], [11, 80], [49, 19], [81, 64], [44, 28], [18, 20], [91, 91], [90, 92], [81, 16], [31, 81], [7, 81], [54, 53], [65, 16], [91, 32]]):
    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)
    assert all([[a, b] in edges for a, b in zip(path, path[1:])])
    return len(path) % 2 == 0
modified_func def sat(path: List[int], edges=wrap_list([wrap_list([wrap_int(67), wrap_int(92)]), wrap_list([wrap_int(18), wrap_int(52)]), wrap_list([wrap_int(25), wrap_int(21)]), wrap_list([wrap_int(83), wrap_int(58)]), wrap_list([wrap_int(36), wrap_int(36)]), wrap_list([wrap_int(26), wrap_int(63)]), wrap_list([wrap_int(48), wrap_int(15)]), wrap_list([wrap_int(53), wrap_int(32)]), wrap_list([wrap_int(62), wrap_int(30)]), wrap_list([wrap_int(41), wrap_int(21)]), wrap_list([wrap_int(91), wrap_int(25)]), wrap_list([wrap_int(82), wrap_int(79)]), wrap_list([wrap_int(33), wrap_int(58)]), wrap_list([wrap_int(65), wrap_int(81)]), wrap_list([wrap_int(57), wrap_int(57)]), wrap_list([wrap_int(62), wrap_int(36)]), wrap_list([wrap_int(85), wrap_int(24)]), wrap_list([wrap_int(14), wrap_int(19)]), wrap_list([wrap_int(58), wrap_int(11)]), wrap_list([wrap_int(20), wrap_int(31)]), wrap_list([wrap_int(76), wrap_int(82)]), wrap_list([wrap_int(92), wrap_int(37)]), wrap_list([wrap_int(73), wrap_int(88)]), wrap_list([wrap_int(90), wrap_int(37)]), wrap_list([wrap_int(68), wrap_int(18)]), wrap_list([wrap_int(70), wrap_int(18)]), wrap_list([wrap_int(45), wrap_int(65)]), wrap_list([wrap_int(45), wrap_int(78)]), wrap_list([wrap_int(87), wrap_int(36)]), wrap_list([wrap_int(41), wrap_int(72)]), wrap_list([wrap_int(66), wrap_int(4)]), wrap_list([wrap_int(25), wrap_int(58)]), wrap_list([wrap_int(18), wrap_int(16)]), wrap_list([wrap_int(72), wrap_int(68)]), wrap_list([wrap_int(21), wrap_int(0)]), wrap_list([wrap_int(44), wrap_int(8)]), wrap_list([wrap_int(51), wrap_int(21)]), wrap_list([wrap_int(30), wrap_int(15)]), wrap_list([wrap_int(18), wrap_int(90)]), wrap_list([wrap_int(75), wrap_int(47)]), wrap_list([wrap_int(42), wrap_int(7)]), wrap_list([wrap_int(13), wrap_int(13)]), wrap_list([wrap_int(27), wrap_int(46)]), wrap_list([wrap_int(78), wrap_int(39)]), wrap_list([wrap_int(71), wrap_int(28)]), wrap_list([wrap_int(85), wrap_int(39)]), wrap_list([wrap_int(56), wrap_int(52)]), wrap_list([wrap_int(60), wrap_int(37)]), wrap_list([wrap_int(37), wrap_int(18)]), wrap_list([wrap_int(82), wrap_int(83)]), wrap_list([wrap_int(84), wrap_int(9)]), wrap_list([wrap_int(31), wrap_int(54)]), wrap_list([wrap_int(81), wrap_int(32)]), wrap_list([wrap_int(46), wrap_int(82)]), wrap_list([wrap_int(10), wrap_int(66)]), wrap_list([wrap_int(85), wrap_int(71)]), wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(15), wrap_int(18)]), wrap_list([wrap_int(83), wrap_int(64)]), wrap_list([wrap_int(9), wrap_int(50)]), wrap_list([wrap_int(60), wrap_int(70)]), wrap_list([wrap_int(7), wrap_int(13)]), wrap_list([wrap_int(81), wrap_int(63)]), wrap_list([wrap_int(32), wrap_int(6)]), wrap_list([wrap_int(18), wrap_int(80)]), wrap_list([wrap_int(22), wrap_int(34)]), wrap_list([wrap_int(60), wrap_int(0)]), wrap_list([wrap_int(88), wrap_int(72)]), wrap_list([wrap_int(9), wrap_int(19)]), wrap_list([wrap_int(74), wrap_int(0)]), wrap_list([wrap_int(87), wrap_int(22)]), wrap_list([wrap_int(41), wrap_int(17)]), wrap_list([wrap_int(66), wrap_int(80)]), wrap_list([wrap_int(33), wrap_int(9)]), wrap_list([wrap_int(71), wrap_int(46)]), wrap_list([wrap_int(23), wrap_int(79)]), wrap_list([wrap_int(64), wrap_int(44)]), wrap_list([wrap_int(40), wrap_int(67)]), wrap_list([wrap_int(78), wrap_int(4)]), wrap_list([wrap_int(8), wrap_int(31)]), wrap_list([wrap_int(15), wrap_int(41)]), wrap_list([wrap_int(42), wrap_int(92)]), wrap_list([wrap_int(22), wrap_int(28)]), wrap_list([wrap_int(57), wrap_int(84)]), wrap_list([wrap_int(69), wrap_int(65)]), wrap_list([wrap_int(35), wrap_int(16)]), wrap_list([wrap_int(1), wrap_int(10)]), wrap_list([wrap_int(7), wrap_int(82)]), wrap_list([wrap_int(62), wrap_int(52)]), wrap_list([wrap_int(8), wrap_int(12)]), wrap_list([wrap_int(51), wrap_int(12)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(83), wrap_int(30)]), wrap_list([wrap_int(76), wrap_int(83)]), wrap_list([wrap_int(0), wrap_int(27)]), wrap_list([wrap_int(30), wrap_int(80)]), wrap_list([wrap_int(33), wrap_int(14)]), wrap_list([wrap_int(39), wrap_int(12)]), wrap_list([wrap_int(51), wrap_int(78)]), wrap_list([wrap_int(30), wrap_int(47)]), wrap_list([wrap_int(25), wrap_int(26)]), wrap_list([wrap_int(11), wrap_int(63)]), wrap_list([wrap_int(52), wrap_int(24)]), wrap_list([wrap_int(32), wrap_int(49)]), wrap_list([wrap_int(0), wrap_int(74)]), wrap_list([wrap_int(51), wrap_int(16)]), wrap_list([wrap_int(1), wrap_int(16)]), wrap_list([wrap_int(14), wrap_int(90)]), wrap_list([wrap_int(49), wrap_int(74)]), wrap_list([wrap_int(69), wrap_int(14)]), wrap_list([wrap_int(72), wrap_int(30)]), wrap_list([wrap_int(61), wrap_int(31)]), wrap_list([wrap_int(54), wrap_int(20)]), wrap_list([wrap_int(46), wrap_int(78)]), wrap_list([wrap_int(4), wrap_int(50)]), wrap_list([wrap_int(13), wrap_int(37)]), wrap_list([wrap_int(61), wrap_int(1)]), wrap_list([wrap_int(4), wrap_int(35)]), wrap_list([wrap_int(29), wrap_int(70)]), wrap_list([wrap_int(20), wrap_int(89)]), wrap_list([wrap_int(28), wrap_int(6)]), wrap_list([wrap_int(74), wrap_int(9)]), wrap_list([wrap_int(86), wrap_int(53)]), wrap_list([wrap_int(58), wrap_int(6)]), wrap_list([wrap_int(57), wrap_int(91)]), wrap_list([wrap_int(10), wrap_int(40)]), wrap_list([wrap_int(15), wrap_int(74)]), wrap_list([wrap_int(23), wrap_int(60)]), wrap_list([wrap_int(5), wrap_int(37)]), wrap_list([wrap_int(50), wrap_int(68)]), wrap_list([wrap_int(78), wrap_int(22)]), wrap_list([wrap_int(90), wrap_int(59)]), wrap_list([wrap_int(74), wrap_int(21)]), wrap_list([wrap_int(80), wrap_int(71)]), wrap_list([wrap_int(92), wrap_int(82)]), wrap_list([wrap_int(42), wrap_int(43)]), wrap_list([wrap_int(68), wrap_int(74)]), wrap_list([wrap_int(43), wrap_int(55)]), wrap_list([wrap_int(67), wrap_int(90)]), wrap_list([wrap_int(87), wrap_int(68)]), wrap_list([wrap_int(40), wrap_int(2)]), wrap_list([wrap_int(55), wrap_int(68)]), wrap_list([wrap_int(52), wrap_int(30)]), wrap_list([wrap_int(10), wrap_int(21)]), wrap_list([wrap_int(44), wrap_int(1)]), wrap_list([wrap_int(39), wrap_int(9)]), wrap_list([wrap_int(12), wrap_int(18)]), wrap_list([wrap_int(61), wrap_int(38)]), wrap_list([wrap_int(65), wrap_int(37)]), wrap_list([wrap_int(10), wrap_int(12)]), wrap_list([wrap_int(21), wrap_int(10)]), wrap_list([wrap_int(81), wrap_int(3)]), wrap_list([wrap_int(65), wrap_int(20)]), wrap_list([wrap_int(31), wrap_int(25)]), wrap_list([wrap_int(59), wrap_int(77)]), wrap_list([wrap_int(43), wrap_int(59)]), wrap_list([wrap_int(75), wrap_int(75)]), wrap_list([wrap_int(71), wrap_int(13)]), wrap_list([wrap_int(17), wrap_int(37)]), wrap_list([wrap_int(31), wrap_int(13)]), wrap_list([wrap_int(6), wrap_int(33)]), wrap_list([wrap_int(24), wrap_int(40)]), wrap_list([wrap_int(52), wrap_int(70)]), wrap_list([wrap_int(70), wrap_int(5)]), wrap_list([wrap_int(4), wrap_int(8)]), wrap_list([wrap_int(20), wrap_int(29)]), wrap_list([wrap_int(11), wrap_int(10)]), wrap_list([wrap_int(43), wrap_int(67)]), wrap_list([wrap_int(11), wrap_int(80)]), wrap_list([wrap_int(49), wrap_int(19)]), wrap_list([wrap_int(81), wrap_int(64)]), wrap_list([wrap_int(44), wrap_int(28)]), wrap_list([wrap_int(18), wrap_int(20)]), wrap_list([wrap_int(91), wrap_int(91)]), wrap_list([wrap_int(90), wrap_int(92)]), wrap_list([wrap_int(81), wrap_int(16)]), wrap_list([wrap_int(31), wrap_int(81)]), wrap_list([wrap_int(7), wrap_int(81)]), wrap_list([wrap_int(54), wrap_int(53)]), wrap_list([wrap_int(65), wrap_int(16)]), wrap_list([wrap_int(91), wrap_int(32)])])):
    _assert((path[wrap_int(0)] == wrap_int(0)).__and__(path[-wrap_int(1)] == max(sym_generator((max(e) for e in edges)))))
    _assert(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(path, path[1:])]))
    return sym_len(path) % wrap_int(2) == wrap_int(0)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (= (list.get.int x 0) 0) (= (list.get.int x -1) 92)))
(assert false)
(assert (= (mod (list.length.int x) 2) 0))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle EvenPath:4
Too many constants for extrapolation

Solving puzzle 620/732: OddPath:0
sat_func def sat(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
modified_func def sat(p: List[int], edges=wrap_list([wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(4)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(5), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(6), wrap_int(1)])])):
    return (p[wrap_int(0)] == wrap_int(0)).__and__((p[-wrap_int(1)] == wrap_int(1)).__and__(wrap_int(1) == sym_len(p) % wrap_int(2))).__and__(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(p, p[1:])]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 0) (and (= (list.get.int x -1) 1) (= 1 (mod (list.length.int x) 2)))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle OddPath:0
Too many constants for extrapolation

Solving puzzle 621/732: OddPath:1
sat_func def sat(p: List[int], edges=[[1, 6], [2, 3], [2, 7], [0, 8], [7, 8], [7, 2], [1, 5], [8, 7], [7, 0], [0, 0], [8, 1], [5, 7], [4, 7], [6, 1], [4, 4], [7, 4]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
modified_func def sat(p: List[int], edges=wrap_list([wrap_list([wrap_int(1), wrap_int(6)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(2), wrap_int(7)]), wrap_list([wrap_int(0), wrap_int(8)]), wrap_list([wrap_int(7), wrap_int(8)]), wrap_list([wrap_int(7), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(8), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(8), wrap_int(1)]), wrap_list([wrap_int(5), wrap_int(7)]), wrap_list([wrap_int(4), wrap_int(7)]), wrap_list([wrap_int(6), wrap_int(1)]), wrap_list([wrap_int(4), wrap_int(4)]), wrap_list([wrap_int(7), wrap_int(4)])])):
    return (p[wrap_int(0)] == wrap_int(0)).__and__((p[-wrap_int(1)] == wrap_int(1)).__and__(wrap_int(1) == sym_len(p) % wrap_int(2))).__and__(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(p, p[1:])]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 0) (and (= (list.get.int x -1) 1) (= 1 (mod (list.length.int x) 2)))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle OddPath:1
Too many constants for extrapolation

Solving puzzle 622/732: OddPath:2
sat_func def sat(p: List[int], edges=[[40, 31], [16, 32], [41, 10], [14, 9], [36, 26], [14, 12], [22, 6], [36, 6], [13, 22], [0, 34], [6, 28], [27, 22], [31, 5], [2, 3], [34, 37], [17, 14], [1, 4], [22, 26], [32, 18], [20, 10], [28, 17], [2, 22], [22, 30], [36, 41], [7, 35], [24, 29], [31, 31], [26, 39], [14, 32], [33, 27], [33, 9], [30, 37], [40, 14], [19, 17], [15, 11], [7, 40], [6, 36], [20, 19], [7, 12], [17, 25], [14, 24], [34, 25], [27, 34], [35, 41], [34, 3], [25, 12], [34, 29], [21, 23], [2, 12], [25, 26], [28, 16], [17, 2], [15, 28], [29, 0], [32, 16], [13, 29], [23, 26], [3, 11], [39, 3], [40, 16], [22, 39], [12, 30], [12, 24], [38, 24], [5, 1], [21, 39], [33, 39], [29, 36], [23, 40], [34, 20], [35, 10], [13, 7], [10, 2], [32, 26], [37, 4], [36, 21], [1, 18], [23, 11], [19, 11], [35, 5], [10, 32], [9, 17], [21, 2]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
modified_func def sat(p: List[int], edges=wrap_list([wrap_list([wrap_int(40), wrap_int(31)]), wrap_list([wrap_int(16), wrap_int(32)]), wrap_list([wrap_int(41), wrap_int(10)]), wrap_list([wrap_int(14), wrap_int(9)]), wrap_list([wrap_int(36), wrap_int(26)]), wrap_list([wrap_int(14), wrap_int(12)]), wrap_list([wrap_int(22), wrap_int(6)]), wrap_list([wrap_int(36), wrap_int(6)]), wrap_list([wrap_int(13), wrap_int(22)]), wrap_list([wrap_int(0), wrap_int(34)]), wrap_list([wrap_int(6), wrap_int(28)]), wrap_list([wrap_int(27), wrap_int(22)]), wrap_list([wrap_int(31), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(34), wrap_int(37)]), wrap_list([wrap_int(17), wrap_int(14)]), wrap_list([wrap_int(1), wrap_int(4)]), wrap_list([wrap_int(22), wrap_int(26)]), wrap_list([wrap_int(32), wrap_int(18)]), wrap_list([wrap_int(20), wrap_int(10)]), wrap_list([wrap_int(28), wrap_int(17)]), wrap_list([wrap_int(2), wrap_int(22)]), wrap_list([wrap_int(22), wrap_int(30)]), wrap_list([wrap_int(36), wrap_int(41)]), wrap_list([wrap_int(7), wrap_int(35)]), wrap_list([wrap_int(24), wrap_int(29)]), wrap_list([wrap_int(31), wrap_int(31)]), wrap_list([wrap_int(26), wrap_int(39)]), wrap_list([wrap_int(14), wrap_int(32)]), wrap_list([wrap_int(33), wrap_int(27)]), wrap_list([wrap_int(33), wrap_int(9)]), wrap_list([wrap_int(30), wrap_int(37)]), wrap_list([wrap_int(40), wrap_int(14)]), wrap_list([wrap_int(19), wrap_int(17)]), wrap_list([wrap_int(15), wrap_int(11)]), wrap_list([wrap_int(7), wrap_int(40)]), wrap_list([wrap_int(6), wrap_int(36)]), wrap_list([wrap_int(20), wrap_int(19)]), wrap_list([wrap_int(7), wrap_int(12)]), wrap_list([wrap_int(17), wrap_int(25)]), wrap_list([wrap_int(14), wrap_int(24)]), wrap_list([wrap_int(34), wrap_int(25)]), wrap_list([wrap_int(27), wrap_int(34)]), wrap_list([wrap_int(35), wrap_int(41)]), wrap_list([wrap_int(34), wrap_int(3)]), wrap_list([wrap_int(25), wrap_int(12)]), wrap_list([wrap_int(34), wrap_int(29)]), wrap_list([wrap_int(21), wrap_int(23)]), wrap_list([wrap_int(2), wrap_int(12)]), wrap_list([wrap_int(25), wrap_int(26)]), wrap_list([wrap_int(28), wrap_int(16)]), wrap_list([wrap_int(17), wrap_int(2)]), wrap_list([wrap_int(15), wrap_int(28)]), wrap_list([wrap_int(29), wrap_int(0)]), wrap_list([wrap_int(32), wrap_int(16)]), wrap_list([wrap_int(13), wrap_int(29)]), wrap_list([wrap_int(23), wrap_int(26)]), wrap_list([wrap_int(3), wrap_int(11)]), wrap_list([wrap_int(39), wrap_int(3)]), wrap_list([wrap_int(40), wrap_int(16)]), wrap_list([wrap_int(22), wrap_int(39)]), wrap_list([wrap_int(12), wrap_int(30)]), wrap_list([wrap_int(12), wrap_int(24)]), wrap_list([wrap_int(38), wrap_int(24)]), wrap_list([wrap_int(5), wrap_int(1)]), wrap_list([wrap_int(21), wrap_int(39)]), wrap_list([wrap_int(33), wrap_int(39)]), wrap_list([wrap_int(29), wrap_int(36)]), wrap_list([wrap_int(23), wrap_int(40)]), wrap_list([wrap_int(34), wrap_int(20)]), wrap_list([wrap_int(35), wrap_int(10)]), wrap_list([wrap_int(13), wrap_int(7)]), wrap_list([wrap_int(10), wrap_int(2)]), wrap_list([wrap_int(32), wrap_int(26)]), wrap_list([wrap_int(37), wrap_int(4)]), wrap_list([wrap_int(36), wrap_int(21)]), wrap_list([wrap_int(1), wrap_int(18)]), wrap_list([wrap_int(23), wrap_int(11)]), wrap_list([wrap_int(19), wrap_int(11)]), wrap_list([wrap_int(35), wrap_int(5)]), wrap_list([wrap_int(10), wrap_int(32)]), wrap_list([wrap_int(9), wrap_int(17)]), wrap_list([wrap_int(21), wrap_int(2)])])):
    return (p[wrap_int(0)] == wrap_int(0)).__and__((p[-wrap_int(1)] == wrap_int(1)).__and__(wrap_int(1) == sym_len(p) % wrap_int(2))).__and__(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(p, p[1:])]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 0) (and (= (list.get.int x -1) 1) (= 1 (mod (list.length.int x) 2)))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle OddPath:2
Too many constants for extrapolation

Solving puzzle 623/732: OddPath:3
sat_func def sat(p: List[int], edges=[[6, 6], [3, 6], [5, 0], [7, 16], [9, 12], [10, 3], [3, 5], [14, 17], [10, 14], [15, 3], [17, 15], [8, 18], [1, 12], [3, 7], [12, 17], [15, 15], [6, 2], [10, 9], [5, 13], [2, 15], [8, 5], [9, 15], [10, 6], [10, 17], [3, 9], [2, 6], [4, 1], [7, 12], [13, 1], [15, 17], [13, 5], [14, 10], [0, 17], [0, 11], [4, 17], [1, 11], [12, 18]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
modified_func def sat(p: List[int], edges=wrap_list([wrap_list([wrap_int(6), wrap_int(6)]), wrap_list([wrap_int(3), wrap_int(6)]), wrap_list([wrap_int(5), wrap_int(0)]), wrap_list([wrap_int(7), wrap_int(16)]), wrap_list([wrap_int(9), wrap_int(12)]), wrap_list([wrap_int(10), wrap_int(3)]), wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(14), wrap_int(17)]), wrap_list([wrap_int(10), wrap_int(14)]), wrap_list([wrap_int(15), wrap_int(3)]), wrap_list([wrap_int(17), wrap_int(15)]), wrap_list([wrap_int(8), wrap_int(18)]), wrap_list([wrap_int(1), wrap_int(12)]), wrap_list([wrap_int(3), wrap_int(7)]), wrap_list([wrap_int(12), wrap_int(17)]), wrap_list([wrap_int(15), wrap_int(15)]), wrap_list([wrap_int(6), wrap_int(2)]), wrap_list([wrap_int(10), wrap_int(9)]), wrap_list([wrap_int(5), wrap_int(13)]), wrap_list([wrap_int(2), wrap_int(15)]), wrap_list([wrap_int(8), wrap_int(5)]), wrap_list([wrap_int(9), wrap_int(15)]), wrap_list([wrap_int(10), wrap_int(6)]), wrap_list([wrap_int(10), wrap_int(17)]), wrap_list([wrap_int(3), wrap_int(9)]), wrap_list([wrap_int(2), wrap_int(6)]), wrap_list([wrap_int(4), wrap_int(1)]), wrap_list([wrap_int(7), wrap_int(12)]), wrap_list([wrap_int(13), wrap_int(1)]), wrap_list([wrap_int(15), wrap_int(17)]), wrap_list([wrap_int(13), wrap_int(5)]), wrap_list([wrap_int(14), wrap_int(10)]), wrap_list([wrap_int(0), wrap_int(17)]), wrap_list([wrap_int(0), wrap_int(11)]), wrap_list([wrap_int(4), wrap_int(17)]), wrap_list([wrap_int(1), wrap_int(11)]), wrap_list([wrap_int(12), wrap_int(18)])])):
    return (p[wrap_int(0)] == wrap_int(0)).__and__((p[-wrap_int(1)] == wrap_int(1)).__and__(wrap_int(1) == sym_len(p) % wrap_int(2))).__and__(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(p, p[1:])]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 0) (and (= (list.get.int x -1) 1) (= 1 (mod (list.length.int x) 2)))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle OddPath:3
Too many constants for extrapolation

Solving puzzle 624/732: OddPath:4
sat_func def sat(p: List[int], edges=[[4, 8], [7, 6], [2, 0], [3, 2], [6, 3], [4, 5], [11, 5], [11, 0], [1, 5], [12, 12], [12, 1], [4, 11], [3, 3], [2, 10], [10, 6], [0, 7], [2, 7], [6, 11], [2, 9], [7, 7], [8, 9], [2, 1], [4, 6], [9, 4]]):
    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])
modified_func def sat(p: List[int], edges=wrap_list([wrap_list([wrap_int(4), wrap_int(8)]), wrap_list([wrap_int(7), wrap_int(6)]), wrap_list([wrap_int(2), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(2)]), wrap_list([wrap_int(6), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(5)]), wrap_list([wrap_int(11), wrap_int(5)]), wrap_list([wrap_int(11), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(12), wrap_int(12)]), wrap_list([wrap_int(12), wrap_int(1)]), wrap_list([wrap_int(4), wrap_int(11)]), wrap_list([wrap_int(3), wrap_int(3)]), wrap_list([wrap_int(2), wrap_int(10)]), wrap_list([wrap_int(10), wrap_int(6)]), wrap_list([wrap_int(0), wrap_int(7)]), wrap_list([wrap_int(2), wrap_int(7)]), wrap_list([wrap_int(6), wrap_int(11)]), wrap_list([wrap_int(2), wrap_int(9)]), wrap_list([wrap_int(7), wrap_int(7)]), wrap_list([wrap_int(8), wrap_int(9)]), wrap_list([wrap_int(2), wrap_int(1)]), wrap_list([wrap_int(4), wrap_int(6)]), wrap_list([wrap_int(9), wrap_int(4)])])):
    return (p[wrap_int(0)] == wrap_int(0)).__and__((p[-wrap_int(1)] == wrap_int(1)).__and__(wrap_int(1) == sym_len(p) % wrap_int(2))).__and__(all([sym_in(wrap_list([a, b]), edges) for a, b in sym_zip(p, p[1:])]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (and (and (= (list.get.int x 0) 0) (and (= (list.get.int x -1) 1) (= 1 (mod (list.length.int x) 2)))) false))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unsat
(error "cannot get model unless after a SAT or UNKNOWN response.")

Could not find any solution for puzzle OddPath:4
Too many constants for extrapolation

Solving puzzle 625/732: GraphIsomorphism:0
sat_func def sat(bi: List[int], g1=[[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2=[[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):
    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}
modified_func def sat(bi: List[int], g1=wrap_list([wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(2), wrap_int(5)])]), g2=wrap_list([wrap_list([wrap_int(0), wrap_int(4)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(4), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(3)])])):
    return (sym_len(bi) == sym_len(set(bi))).__and__({(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2})
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_719 Int)) (=> (and (>= list_pos_719 0) (< list_pos_719 (list.length.int x))) (and (= (list.length.int x) 1) false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GraphIsomorphism:0
Too many constants for extrapolation

Solving puzzle 626/732: GraphIsomorphism:1
sat_func def sat(bi: List[int], g1=[[0, 6], [0, 8], [0, 10], [0, 11], [1, 3], [1, 5], [1, 7], [1, 10], [2, 4], [2, 5], [2, 7], [2, 8], [2, 9], [3, 5], [3, 7], [3, 10], [4, 4], [5, 1], [5, 2], [5, 7], [5, 8], [5, 10], [6, 1], [6, 2], [6, 3], [6, 4], [6, 6], [6, 7], [6, 8], [6, 9], [6, 10], [6, 11], [7, 0], [7, 2], [7, 9], [8, 4], [8, 6], [8, 9], [8, 10], [9, 1], [9, 3], [9, 4], [9, 5], [9, 6], [9, 7], [9, 9], [9, 10], [9, 11], [10, 1], [10, 3], [10, 6], [10, 8], [11, 1], [11, 2], [11, 4], [11, 8], [11, 9], [11, 11]], g2=[[0, 11], [9, 2], [10, 10], [6, 11], [7, 5], [5, 0], [9, 3], [8, 2], [10, 8], [2, 11], [4, 8], [0, 7], [2, 10], [11, 11], [4, 5], [10, 11], [6, 10], [9, 7], [6, 6], [8, 10], [1, 5], [2, 9], [10, 3], [0, 2], [9, 8], [5, 4], [0, 5], [6, 2], [8, 1], [1, 6], [6, 3], [0, 10], [0, 8], [10, 5], [2, 7], [0, 6], [0, 0], [10, 0], [3, 8], [5, 3], [5, 7], [10, 6], [6, 7], [7, 0], [3, 9], [3, 4], [0, 3], [0, 4], [1, 7], [4, 9], [7, 10], [9, 5], [7, 11], [3, 5], [10, 4], [10, 9], [2, 8], [1, 0]]):
    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}
modified_func def sat(bi: List[int], g1=wrap_list([wrap_list([wrap_int(0), wrap_int(6)]), wrap_list([wrap_int(0), wrap_int(8)]), wrap_list([wrap_int(0), wrap_int(10)]), wrap_list([wrap_int(0), wrap_int(11)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(1), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(10)]), wrap_list([wrap_int(2), wrap_int(4)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(7)]), wrap_list([wrap_int(2), wrap_int(8)]), wrap_list([wrap_int(2), wrap_int(9)]), wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(7)]), wrap_list([wrap_int(3), wrap_int(10)]), wrap_list([wrap_int(4), wrap_int(4)]), wrap_list([wrap_int(5), wrap_int(1)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(5), wrap_int(7)]), wrap_list([wrap_int(5), wrap_int(8)]), wrap_list([wrap_int(5), wrap_int(10)]), wrap_list([wrap_int(6), wrap_int(1)]), wrap_list([wrap_int(6), wrap_int(2)]), wrap_list([wrap_int(6), wrap_int(3)]), wrap_list([wrap_int(6), wrap_int(4)]), wrap_list([wrap_int(6), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(6), wrap_int(8)]), wrap_list([wrap_int(6), wrap_int(9)]), wrap_list([wrap_int(6), wrap_int(10)]), wrap_list([wrap_int(6), wrap_int(11)]), wrap_list([wrap_int(7), wrap_int(0)]), wrap_list([wrap_int(7), wrap_int(2)]), wrap_list([wrap_int(7), wrap_int(9)]), wrap_list([wrap_int(8), wrap_int(4)]), wrap_list([wrap_int(8), wrap_int(6)]), wrap_list([wrap_int(8), wrap_int(9)]), wrap_list([wrap_int(8), wrap_int(10)]), wrap_list([wrap_int(9), wrap_int(1)]), wrap_list([wrap_int(9), wrap_int(3)]), wrap_list([wrap_int(9), wrap_int(4)]), wrap_list([wrap_int(9), wrap_int(5)]), wrap_list([wrap_int(9), wrap_int(6)]), wrap_list([wrap_int(9), wrap_int(7)]), wrap_list([wrap_int(9), wrap_int(9)]), wrap_list([wrap_int(9), wrap_int(10)]), wrap_list([wrap_int(9), wrap_int(11)]), wrap_list([wrap_int(10), wrap_int(1)]), wrap_list([wrap_int(10), wrap_int(3)]), wrap_list([wrap_int(10), wrap_int(6)]), wrap_list([wrap_int(10), wrap_int(8)]), wrap_list([wrap_int(11), wrap_int(1)]), wrap_list([wrap_int(11), wrap_int(2)]), wrap_list([wrap_int(11), wrap_int(4)]), wrap_list([wrap_int(11), wrap_int(8)]), wrap_list([wrap_int(11), wrap_int(9)]), wrap_list([wrap_int(11), wrap_int(11)])]), g2=wrap_list([wrap_list([wrap_int(0), wrap_int(11)]), wrap_list([wrap_int(9), wrap_int(2)]), wrap_list([wrap_int(10), wrap_int(10)]), wrap_list([wrap_int(6), wrap_int(11)]), wrap_list([wrap_int(7), wrap_int(5)]), wrap_list([wrap_int(5), wrap_int(0)]), wrap_list([wrap_int(9), wrap_int(3)]), wrap_list([wrap_int(8), wrap_int(2)]), wrap_list([wrap_int(10), wrap_int(8)]), wrap_list([wrap_int(2), wrap_int(11)]), wrap_list([wrap_int(4), wrap_int(8)]), wrap_list([wrap_int(0), wrap_int(7)]), wrap_list([wrap_int(2), wrap_int(10)]), wrap_list([wrap_int(11), wrap_int(11)]), wrap_list([wrap_int(4), wrap_int(5)]), wrap_list([wrap_int(10), wrap_int(11)]), wrap_list([wrap_int(6), wrap_int(10)]), wrap_list([wrap_int(9), wrap_int(7)]), wrap_list([wrap_int(6), wrap_int(6)]), wrap_list([wrap_int(8), wrap_int(10)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(9)]), wrap_list([wrap_int(10), wrap_int(3)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(9), wrap_int(8)]), wrap_list([wrap_int(5), wrap_int(4)]), wrap_list([wrap_int(0), wrap_int(5)]), wrap_list([wrap_int(6), wrap_int(2)]), wrap_list([wrap_int(8), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(3)]), wrap_list([wrap_int(0), wrap_int(10)]), wrap_list([wrap_int(0), wrap_int(8)]), wrap_list([wrap_int(10), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(7)]), wrap_list([wrap_int(0), wrap_int(6)]), wrap_list([wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(10), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(8)]), wrap_list([wrap_int(5), wrap_int(3)]), wrap_list([wrap_int(5), wrap_int(7)]), wrap_list([wrap_int(10), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(9)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(0), wrap_int(3)]), wrap_list([wrap_int(0), wrap_int(4)]), wrap_list([wrap_int(1), wrap_int(7)]), wrap_list([wrap_int(4), wrap_int(9)]), wrap_list([wrap_int(7), wrap_int(10)]), wrap_list([wrap_int(9), wrap_int(5)]), wrap_list([wrap_int(7), wrap_int(11)]), wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(10), wrap_int(4)]), wrap_list([wrap_int(10), wrap_int(9)]), wrap_list([wrap_int(2), wrap_int(8)]), wrap_list([wrap_int(1), wrap_int(0)])])):
    return (sym_len(bi) == sym_len(set(bi))).__and__({(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2})
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_720 Int)) (=> (and (>= list_pos_720 0) (< list_pos_720 (list.length.int x))) (and (= (list.length.int x) 1) false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GraphIsomorphism:1
Too many constants for extrapolation

Solving puzzle 627/732: GraphIsomorphism:2
sat_func def sat(bi: List[int], g1=[[0, 1], [0, 7], [1, 1], [2, 0], [2, 3], [2, 5], [2, 6], [3, 0], [3, 1], [3, 2], [3, 5], [3, 6], [3, 7], [4, 3], [4, 5], [4, 6], [5, 0], [5, 2], [5, 3], [6, 0], [6, 5], [6, 7], [7, 0], [7, 4], [7, 6]], g2=[[0, 7], [7, 1], [0, 2], [3, 1], [2, 0], [7, 0], [0, 6], [4, 7], [2, 7], [7, 6], [1, 6], [3, 6], [6, 5], [1, 3], [7, 3], [4, 0], [1, 0], [3, 4], [2, 1], [2, 6], [7, 2], [6, 3], [7, 5], [4, 1], [5, 5]]):
    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}
modified_func def sat(bi: List[int], g1=wrap_list([wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(1)]), wrap_list([wrap_int(2), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(3)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(6)]), wrap_list([wrap_int(3), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(1)]), wrap_list([wrap_int(3), wrap_int(2)]), wrap_list([wrap_int(3), wrap_int(5)]), wrap_list([wrap_int(3), wrap_int(6)]), wrap_list([wrap_int(3), wrap_int(7)]), wrap_list([wrap_int(4), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(5)]), wrap_list([wrap_int(4), wrap_int(6)]), wrap_list([wrap_int(5), wrap_int(0)]), wrap_list([wrap_int(5), wrap_int(2)]), wrap_list([wrap_int(5), wrap_int(3)]), wrap_list([wrap_int(6), wrap_int(0)]), wrap_list([wrap_int(6), wrap_int(5)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(0)]), wrap_list([wrap_int(7), wrap_int(4)]), wrap_list([wrap_int(7), wrap_int(6)])]), g2=wrap_list([wrap_list([wrap_int(0), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(1)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(3), wrap_int(1)]), wrap_list([wrap_int(2), wrap_int(0)]), wrap_list([wrap_int(7), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(6)]), wrap_list([wrap_int(4), wrap_int(7)]), wrap_list([wrap_int(2), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(6)]), wrap_list([wrap_int(1), wrap_int(6)]), wrap_list([wrap_int(3), wrap_int(6)]), wrap_list([wrap_int(6), wrap_int(5)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(7), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(2), wrap_int(1)]), wrap_list([wrap_int(2), wrap_int(6)]), wrap_list([wrap_int(7), wrap_int(2)]), wrap_list([wrap_int(6), wrap_int(3)]), wrap_list([wrap_int(7), wrap_int(5)]), wrap_list([wrap_int(4), wrap_int(1)]), wrap_list([wrap_int(5), wrap_int(5)])])):
    return (sym_len(bi) == sym_len(set(bi))).__and__({(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2})
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_721 Int)) (=> (and (>= list_pos_721 0) (< list_pos_721 (list.length.int x))) (and (= (list.length.int x) 1) false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GraphIsomorphism:2
Too many constants for extrapolation

Solving puzzle 628/732: GraphIsomorphism:3
sat_func def sat(bi: List[int], g1=[[0, 0], [0, 5], [0, 6], [0, 9], [1, 1], [1, 2], [1, 3], [1, 5], [1, 7], [1, 8], [2, 1], [2, 4], [2, 8], [2, 9], [3, 0], [3, 4], [3, 7], [3, 9], [4, 2], [4, 3], [4, 5], [4, 9], [5, 6], [5, 7], [5, 8], [5, 9], [6, 0], [6, 4], [6, 7], [7, 5], [7, 6], [7, 8], [8, 1], [8, 7], [9, 1], [9, 4], [9, 8], [9, 9]], g2=[[1, 0], [2, 5], [0, 1], [5, 0], [6, 2], [8, 8], [0, 2], [9, 3], [3, 7], [5, 8], [1, 8], [8, 3], [5, 3], [0, 9], [6, 7], [1, 5], [8, 2], [7, 4], [6, 3], [9, 0], [4, 1], [1, 1], [7, 3], [7, 5], [2, 4], [5, 9], [3, 9], [7, 7], [7, 9], [4, 9], [4, 8], [8, 7], [7, 6], [9, 5], [6, 8], [2, 8], [4, 2], [2, 6]]):
    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}
modified_func def sat(bi: List[int], g1=wrap_list([wrap_list([wrap_int(0), wrap_int(0)]), wrap_list([wrap_int(0), wrap_int(5)]), wrap_list([wrap_int(0), wrap_int(6)]), wrap_list([wrap_int(0), wrap_int(9)]), wrap_list([wrap_int(1), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(1), wrap_int(3)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(1), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(8)]), wrap_list([wrap_int(2), wrap_int(1)]), wrap_list([wrap_int(2), wrap_int(4)]), wrap_list([wrap_int(2), wrap_int(8)]), wrap_list([wrap_int(2), wrap_int(9)]), wrap_list([wrap_int(3), wrap_int(0)]), wrap_list([wrap_int(3), wrap_int(4)]), wrap_list([wrap_int(3), wrap_int(7)]), wrap_list([wrap_int(3), wrap_int(9)]), wrap_list([wrap_int(4), wrap_int(2)]), wrap_list([wrap_int(4), wrap_int(3)]), wrap_list([wrap_int(4), wrap_int(5)]), wrap_list([wrap_int(4), wrap_int(9)]), wrap_list([wrap_int(5), wrap_int(6)]), wrap_list([wrap_int(5), wrap_int(7)]), wrap_list([wrap_int(5), wrap_int(8)]), wrap_list([wrap_int(5), wrap_int(9)]), wrap_list([wrap_int(6), wrap_int(0)]), wrap_list([wrap_int(6), wrap_int(4)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(5)]), wrap_list([wrap_int(7), wrap_int(6)]), wrap_list([wrap_int(7), wrap_int(8)]), wrap_list([wrap_int(8), wrap_int(1)]), wrap_list([wrap_int(8), wrap_int(7)]), wrap_list([wrap_int(9), wrap_int(1)]), wrap_list([wrap_int(9), wrap_int(4)]), wrap_list([wrap_int(9), wrap_int(8)]), wrap_list([wrap_int(9), wrap_int(9)])]), g2=wrap_list([wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(5)]), wrap_list([wrap_int(0), wrap_int(1)]), wrap_list([wrap_int(5), wrap_int(0)]), wrap_list([wrap_int(6), wrap_int(2)]), wrap_list([wrap_int(8), wrap_int(8)]), wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(9), wrap_int(3)]), wrap_list([wrap_int(3), wrap_int(7)]), wrap_list([wrap_int(5), wrap_int(8)]), wrap_list([wrap_int(1), wrap_int(8)]), wrap_list([wrap_int(8), wrap_int(3)]), wrap_list([wrap_int(5), wrap_int(3)]), wrap_list([wrap_int(0), wrap_int(9)]), wrap_list([wrap_int(6), wrap_int(7)]), wrap_list([wrap_int(1), wrap_int(5)]), wrap_list([wrap_int(8), wrap_int(2)]), wrap_list([wrap_int(7), wrap_int(4)]), wrap_list([wrap_int(6), wrap_int(3)]), wrap_list([wrap_int(9), wrap_int(0)]), wrap_list([wrap_int(4), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(1)]), wrap_list([wrap_int(7), wrap_int(3)]), wrap_list([wrap_int(7), wrap_int(5)]), wrap_list([wrap_int(2), wrap_int(4)]), wrap_list([wrap_int(5), wrap_int(9)]), wrap_list([wrap_int(3), wrap_int(9)]), wrap_list([wrap_int(7), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(9)]), wrap_list([wrap_int(4), wrap_int(9)]), wrap_list([wrap_int(4), wrap_int(8)]), wrap_list([wrap_int(8), wrap_int(7)]), wrap_list([wrap_int(7), wrap_int(6)]), wrap_list([wrap_int(9), wrap_int(5)]), wrap_list([wrap_int(6), wrap_int(8)]), wrap_list([wrap_int(2), wrap_int(8)]), wrap_list([wrap_int(4), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(6)])])):
    return (sym_len(bi) == sym_len(set(bi))).__and__({(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2})
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_722 Int)) (=> (and (>= list_pos_722 0) (< list_pos_722 (list.length.int x))) (and (= (list.length.int x) 1) false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GraphIsomorphism:3
Too many constants for extrapolation

Solving puzzle 629/732: GraphIsomorphism:4
sat_func def sat(bi: List[int], g1=[[1, 0], [1, 1], [1, 2], [2, 1]], g2=[[0, 2], [2, 2], [2, 0], [2, 1]]):
    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}
modified_func def sat(bi: List[int], g1=wrap_list([wrap_list([wrap_int(1), wrap_int(0)]), wrap_list([wrap_int(1), wrap_int(1)]), wrap_list([wrap_int(1), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(1)])]), g2=wrap_list([wrap_list([wrap_int(0), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(2)]), wrap_list([wrap_int(2), wrap_int(0)]), wrap_list([wrap_int(2), wrap_int(1)])])):
    return (sym_len(bi) == sym_len(set(bi))).__and__({(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2})
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_723 Int)) (=> (and (>= list_pos_723 0) (< list_pos_723 (list.length.int x))) (and (= (list.length.int x) 1) false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle GraphIsomorphism:4
Too many constants for extrapolation

Solving puzzle 630/732: ShortIntegerPath:0
sat_func def sat(li: List[int]):
    return all(j in {i - 1, i + 1, 3 * i} for i, j in zip([0] + li, li + [128])) and len(li) == 9
modified_func def sat(li: List[int]):
    return all(sym_generator((sym_in(j, {i - wrap_int(1), i + wrap_int(1), wrap_int(3) * i}) for i, j in sym_zip(wrap_list([wrap_int(0)]) + li, li + wrap_list([wrap_int(128)]))))).__and__(sym_len(li) == wrap_int(9))
Exception -- for puzzle ShortIntegerPath:0 'set' object has no attribute 'contains'

Solving puzzle 631/732: OptimalBridges:0
sat_func def sat(indices: List[int], H=60, alpha=18, beta=2, xs=[0, 10, 20, 30, 50, 80, 100, 120, 160, 190, 200], ys=[0, 30, 10, 30, 50, 40, 10, 20, 20, 55, 10], thresh=26020):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
modified_func def sat(indices: List[int], H=wrap_int(60), alpha=wrap_int(18), beta=wrap_int(2), xs=wrap_list([wrap_int(0), wrap_int(10), wrap_int(20), wrap_int(30), wrap_int(50), wrap_int(80), wrap_int(100), wrap_int(120), wrap_int(160), wrap_int(190), wrap_int(200)]), ys=wrap_list([wrap_int(0), wrap_int(30), wrap_int(10), wrap_int(30), wrap_int(50), wrap_int(40), wrap_int(10), wrap_int(20), wrap_int(20), wrap_int(55), wrap_int(10)]), thresh=wrap_int(26020)):
    _assert(sym_sorted({wrap_int(0), sym_len(xs) - wrap_int(1), *indices}) == indices, wrap_str('Ans. should be sorted list [0, ..., ') + sym_str(sym_len(xs) - wrap_int(1)) + wrap_str(']'))
    cost = alpha * (H - ys[wrap_int(0)])
    for i, j in sym_zip(indices, indices[1:]):
        a, b, r = (xs[i], xs[j], (xs[j] - xs[i]) / wrap_int(2))
        _assert(max(ys[i], ys[j]) + r <= H, wrap_str('Bridge too tall'))
        _assert(all(sym_generator((ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in sym_range(i + 1, j)))), wrap_str('Bridge too short'))
        cost += alpha * (H - ys[j]) + beta * (b - a) ** wrap_int(2)
    return cost <= thresh
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) false))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (< (list.get.int x zip_pos_0) 11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (>= (list.get.int x zip_pos_0) -11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (< (list.get.int x zip_pos_0) 11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (>= (list.get.int x zip_pos_0) -11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (< (list.get.int x zip_pos_0) 11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (>= (list.get.int x zip_pos_0) -11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -11)))))
(assert (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -6)) 40 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_p...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (< (- 11 1) (list.get.int x list_pos_724)) (< 0 (- 11 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) false))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (< (list.get.int x zip_pos_2) 11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (>= (list.get.int x zip_pos_2) -11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (< (list.get.int x zip_pos_2) 11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (>= (list.get.int x zip_pos_2) -11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (< (list.get.int x zip_pos_2) 11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (>= (list.get.int x zip_pos_2) -11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -11)))))))))
(assert (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -4)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_725 Int)) (=> (and (>= list_pos_725 0) (< list_pos_725 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_724 Int)) (=> (and (>= list_pos_724 0) (< list_pos_724 (list.length.int x))) (=> (and (not (< (- 11 1) (list.get.int x list_pos_725))) (not (< 0 (- 11 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 10) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 10 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 9) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 55 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 20 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:139.192: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle OptimalBridges:0
Too many constants for extrapolation

Solving puzzle 632/732: OptimalBridges:1
sat_func def sat(indices: List[int], H=100000, alpha=17, beta=6, xs=[0, 3069, 5319, 5373, 5466, 5479, 5519, 6629, 9652, 9919, 11009, 11175, 11348, 12167, 13016, 13109, 13216, 13250, 13253, 14265, 15018, 16389, 20993, 22240, 23259, 23276, 23410, 25158, 27034, 30140, 31404, 31521, 31619, 31683, 31692, 31705, 34207, 55515, 64781, 71416, 76305, 77516, 81021, 85257, 85806, 86243, 91008, 97806, 100000], ys=[81112, 12485, 94379, 88854, 987, 76485, 42941, 64723, 81743, 86552, 93967, 41028, 583, 23986, 45831, 34204, 5856, 40242, 63968, 6777, 16745, 36621, 70993, 45840, 41901, 19003, 56321, 76109, 36482, 43746, 94401, 24752, 56908, 76875, 59498, 38391, 6693, 23419, 73740, 47413, 27170, 34095, 80071, 53942, 76129, 80538, 44026, 72982, 75701], thresh=4786941056):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
modified_func def sat(indices: List[int], H=wrap_int(100000), alpha=wrap_int(17), beta=wrap_int(6), xs=wrap_list([wrap_int(0), wrap_int(3069), wrap_int(5319), wrap_int(5373), wrap_int(5466), wrap_int(5479), wrap_int(5519), wrap_int(6629), wrap_int(9652), wrap_int(9919), wrap_int(11009), wrap_int(11175), wrap_int(11348), wrap_int(12167), wrap_int(13016), wrap_int(13109), wrap_int(13216), wrap_int(13250), wrap_int(13253), wrap_int(14265), wrap_int(15018), wrap_int(16389), wrap_int(20993), wrap_int(22240), wrap_int(23259), wrap_int(23276), wrap_int(23410), wrap_int(25158), wrap_int(27034), wrap_int(30140), wrap_int(31404), wrap_int(31521), wrap_int(31619), wrap_int(31683), wrap_int(31692), wrap_int(31705), wrap_int(34207), wrap_int(55515), wrap_int(64781), wrap_int(71416), wrap_int(76305), wrap_int(77516), wrap_int(81021), wrap_int(85257), wrap_int(85806), wrap_int(86243), wrap_int(91008), wrap_int(97806), wrap_int(100000)]), ys=wrap_list([wrap_int(81112), wrap_int(12485), wrap_int(94379), wrap_int(88854), wrap_int(987), wrap_int(76485), wrap_int(42941), wrap_int(64723), wrap_int(81743), wrap_int(86552), wrap_int(93967), wrap_int(41028), wrap_int(583), wrap_int(23986), wrap_int(45831), wrap_int(34204), wrap_int(5856), wrap_int(40242), wrap_int(63968), wrap_int(6777), wrap_int(16745), wrap_int(36621), wrap_int(70993), wrap_int(45840), wrap_int(41901), wrap_int(19003), wrap_int(56321), wrap_int(76109), wrap_int(36482), wrap_int(43746), wrap_int(94401), wrap_int(24752), wrap_int(56908), wrap_int(76875), wrap_int(59498), wrap_int(38391), wrap_int(6693), wrap_int(23419), wrap_int(73740), wrap_int(47413), wrap_int(27170), wrap_int(34095), wrap_int(80071), wrap_int(53942), wrap_int(76129), wrap_int(80538), wrap_int(44026), wrap_int(72982), wrap_int(75701)]), thresh=wrap_int(4786941056)):
    _assert(sym_sorted({wrap_int(0), sym_len(xs) - wrap_int(1), *indices}) == indices, wrap_str('Ans. should be sorted list [0, ..., ') + sym_str(sym_len(xs) - wrap_int(1)) + wrap_str(']'))
    cost = alpha * (H - ys[wrap_int(0)])
    for i, j in sym_zip(indices, indices[1:]):
        a, b, r = (xs[i], xs[j], (xs[j] - xs[i]) / wrap_int(2))
        _assert(max(ys[i], ys[j]) + r <= H, wrap_str('Bridge too tall'))
        _assert(all(sym_generator((ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in sym_range(i + 1, j)))), wrap_str('Bridge too short'))
        cost += alpha * (H - ys[j]) + beta * (b - a) ** wrap_int(2)
    return cost <= thresh
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) false))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (< (list.get.int x zip_pos_0) 49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (>= (list.get.int x zip_pos_0) -49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (< (list.get.int x zip_pos_0) 49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (>= (list.get.int x zip_pos_0) -49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (< (list.get.int x zip_pos_0) 49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (>= (list.get.int x zip_pos_0) -49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -49)))))
(assert (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 43) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -6)) 53942 (ite (or (= (list.get.int (list.sl...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (< (- 49 1) (list.get.int x list_pos_726)) (< 0 (- 49 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 44) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 76129 (ite (or (= (list.get.int (list.sli...
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) false))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (< (list.get.int x zip_pos_2) 49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (>= (list.get.int x zip_pos_2) -49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (< (list.get.int x zip_pos_2) 49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (>= (list.get.int x zip_pos_2) -49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (< (list.get.int x zip_pos_2) 49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (>= (list.get.int x zip_pos_2) -49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -49)))))))))
(assert (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 45) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -4)) 80538 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zi...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_727 Int)) (=> (and (>= list_pos_727 0) (< list_pos_727 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_726 Int)) (=> (and (>= list_pos_726 0) (< list_pos_726 (list.length.int x))) (=> (and (not (< (- 49 1) (list.get.int x list_pos_727))) (not (< 0 (- 49 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 48) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 75701 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 47) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 72982 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 46) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 44026 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:139.192: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle OptimalBridges:1
Too many constants for extrapolation

Solving puzzle 633/732: OptimalBridges:2
sat_func def sat(indices: List[int], H=100000, alpha=21, beta=40, xs=[0, 8094, 57578, 62776, 83547, 87398, 95828, 100000], ys=[14832, 27072, 77311, 50782, 82688, 11061, 50767, 3696], thresh=143624404582):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
modified_func def sat(indices: List[int], H=wrap_int(100000), alpha=wrap_int(21), beta=wrap_int(40), xs=wrap_list([wrap_int(0), wrap_int(8094), wrap_int(57578), wrap_int(62776), wrap_int(83547), wrap_int(87398), wrap_int(95828), wrap_int(100000)]), ys=wrap_list([wrap_int(14832), wrap_int(27072), wrap_int(77311), wrap_int(50782), wrap_int(82688), wrap_int(11061), wrap_int(50767), wrap_int(3696)]), thresh=wrap_int(143624404582)):
    _assert(sym_sorted({wrap_int(0), sym_len(xs) - wrap_int(1), *indices}) == indices, wrap_str('Ans. should be sorted list [0, ..., ') + sym_str(sym_len(xs) - wrap_int(1)) + wrap_str(']'))
    cost = alpha * (H - ys[wrap_int(0)])
    for i, j in sym_zip(indices, indices[1:]):
        a, b, r = (xs[i], xs[j], (xs[j] - xs[i]) / wrap_int(2))
        _assert(max(ys[i], ys[j]) + r <= H, wrap_str('Bridge too tall'))
        _assert(all(sym_generator((ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in sym_range(i + 1, j)))), wrap_str('Bridge too short'))
        cost += alpha * (H - ys[j]) + beta * (b - a) ** wrap_int(2)
    return cost <= thresh
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) false))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (< (list.get.int x zip_pos_0) 8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (>= (list.get.int x zip_pos_0) -8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (< (list.get.int x zip_pos_0) 8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (>= (list.get.int x zip_pos_0) -8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (< (list.get.int x zip_pos_0) 8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (>= (list.get.int x zip_pos_0) -8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -8)))))
(assert (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -6)) 77311 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (< (- 8 1) (list.get.int x list_pos_728)) (< 0 (- 8 1)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -5)) 50782 (ite (or (= (list.get.int (list.slice.int x...
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) false))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (< (list.get.int x zip_pos_2) 8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (>= (list.get.int x zip_pos_2) -8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (< (list.get.int x zip_pos_2) 8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (>= (list.get.int x zip_pos_2) -8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (< (list.get.int x zip_pos_2) 8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (>= (list.get.int x zip_pos_2) -8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -8)))))))))
(assert (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 4) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -4)) 82688 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_729 Int)) (=> (and (>= list_pos_729 0) (< list_pos_729 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_728 Int)) (=> (and (>= list_pos_728 0) (< list_pos_728 (list.length.int x))) (=> (and (not (< (- 8 1) (list.get.int x list_pos_729))) (not (< 0 (- 8 1))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 7) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 3696 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 6) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 50767 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 5) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 11061 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:139.190: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle OptimalBridges:2
Too many constants for extrapolation

Solving puzzle 634/732: OptimalBridges:3
sat_func def sat(indices: List[int], H=100000, alpha=975, beta=546, xs=[0, 102, 174, 281, 458, 554, 583, 590, 646, 1592, 1795, 1805, 1835, 1839, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1843, 2357, 2683, 3152, 3159, 3167, 3170, 3170, 3171, 3171, 3172, 3172, 3172, 3172, 3172, 3173, 4025, 4274, 4282, 4465, 4520, 4529, 4666, 4676, 4901, 4905, 5003, 5295, 5510, 5553, 5585, 5585, 5638, 5973, 6136, 6317, 6329, 6374, 6400, 6405, 6407, 6407, 6409, 6409, 6409, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6410, 6411, 6456, 6462, 6462, 6469, 6482, 6486, 6881, 6919, 7240, 7510, 7599, 7995, 8173, 8249, 8284, 8296, 8298, 8298, 8299, 8301, 8427, 8701, 8751, 8945, 9141, 9166, 9208, 9308, 9321, 9327, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9332, 9333, 10630, 11062, 11173, 11286, 11294, 11319, 11322, 11367, 11372, 11376, 11398, 11399, 11403, 11409, 11451, 11459, 11519, 11660, 11687, 11691, 11694, 11694, 11697, 12232, 12313, 12314, 12316, 12321, 12322, 12322, 12322, 12323, 13101, 13207, 13274, 13445, 13512, 13687, 13911, 13987, 14251, 14255, 14306, 14570, 14594, 14606, 14606, 14608, 14998, 15232, 15237, 15633, 15795, 15831, 15991, 16176, 16179, 16189, 16228, 16339, 16450, 16540, 16777, 16851, 16889, 17291, 17694, 18333, 18356, 19390, 19449, 19454, 19750, 20562, 22013, 22332, 22374, 22591, 23234, 23276, 23281, 23296, 23351, 23397, 23762, 23844, 23859, 23866, 23894, 23943, 24311, 24379, 24958, 25140, 25160, 25178, 25211, 25219, 25235, 25378, 25929, 26078, 26181, 26474, 26804, 26821, 26838, 26843, 26858, 26894, 26894, 26894, 26895, 27181, 27302, 27329, 27365, 27374, 27380, 27381, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27382, 27383, 27386, 27418, 27450, 27463, 27525, 27529, 27552, 27559, 27562, 27562, 27563, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27564, 27565, 27721, 27801, 27818, 27882, 28083, 28148, 28673, 29079, 29102, 29155, 29158, 29162, 29193, 29256, 29576, 29991, 29992, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29996, 29997, 30025, 30083, 30088, 30146, 30173, 30182, 30305, 30408, 30596, 30905, 31000, 31405, 31558, 31588, 31663, 31664, 31664, 31667, 31670, 31674, 31676, 31703, 32815, 32821, 32949, 33977, 34036, 34403, 34413, 34464, 34505, 34509, 34511, 34772, 34972, 35021, 35068, 35259, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35272, 35273, 35311, 35343, 35611, 35950, 36192, 36400, 36410, 36622, 36820, 36883, 36959, 36960, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36963, 36964, 37010, 37035, 37311, 37660, 37733, 37934, 38287, 38539, 39425, 39441, 39473, 40033, 40124, 40319, 40609, 40643, 40673, 40727, 40741, 40742, 40744, 40750, 41021, 41080, 41311, 41319, 41321, 41335, 41344, 41344, 41345, 41345, 41345, 41345, 41345, 41346, 41532, 41554, 42011, 42164, 42187, 42276, 42566, 42675, 43393, 43473, 43480, 43504, 43504, 43504, 43504, 43504, 43505, 44026, 44718, 45006, 45128, 45193, 45581, 45643, 45679, 45684, 45687, 45858, 45958, 46022, 46126, 46367, 46712, 46849, 47743, 47968, 48262, 49272, 49376, 50058, 50436, 51804, 51966, 52122, 52374, 53401, 53638, 54722, 55797, 55906, 56812, 56839, 57005, 58384, 58720, 58959, 59074, 59209, 59512, 59785, 60798, 61136, 61198, 61505, 62052, 62540, 62555, 62783, 63241, 63829, 64155, 64422, 64520, 65271, 65297, 67452, 67628, 68258, 68379, 69233, 69496, 69613, 69774, 70090, 70092, 70759, 70770, 70809, 71196, 71265, 71529, 72250, 72476, 72523, 72556, 72829, 73209, 73477, 73739, 73843, 74249, 74728, 74988, 75425, 75988, 76032, 76096, 76152, 76222, 76751, 77227, 77631, 77995, 78061, 78169, 78400, 78784, 79499, 80385, 80551, 80627, 80660, 81059, 81143, 81405, 81665, 82904, 83595, 83957, 83996, 84043, 84739, 85031, 85987, 86319, 86864, 86933, 86947, 87127, 87520, 87543, 87848, 88057, 88437, 89195, 89401, 90469, 90756, 90761, 91175, 91975, 92907, 92987, 94337, 94470, 95290, 96267, 96378, 96635, 97113, 97608, 97663, 97721, 98148, 98536, 98629, 98960, 99036, 99763, 99793, 100000], ys=[2773, 47376, 17008, 24785, 21921, 60359, 33137, 72146, 76002, 49654, 25696, 25832, 72474, 2917, 18229, 2385, 66151, 51868, 4760, 69187, 67221, 14320, 24425, 88890, 24553, 78751, 70869, 11279, 12625, 84959, 28885, 87499, 61816, 41222, 81997, 1265, 63632, 12863, 54939, 56081, 35629, 37122, 49133, 24893, 41731, 9182, 34407, 90952, 42360, 43861, 99296, 80331, 78826, 19484, 90699, 30578, 71697, 10304, 61318, 89870, 38599, 71160, 22805, 17850, 60106, 76742, 14571, 74280, 88847, 53537, 84726, 7279, 55376, 47707, 78111, 14855, 20855, 89936, 20706, 98672, 5385, 76357, 90172, 48891, 6243, 82298, 64602, 99637, 83220, 87261, 26190, 39457, 12610, 44567, 54545, 71246, 96608, 5086, 65811, 15907, 21012, 17278, 1139, 54815, 52416, 19440, 44857, 16066, 22379, 73573, 36087, 54255, 60304, 30497, 1202, 95520, 48378, 68296, 14032, 50456, 60555, 80390, 70975, 17531, 3761, 46399, 48927, 96320, 79008, 25360, 67058, 26409, 29891, 324, 67141, 24534, 69987, 11711, 99837, 82260, 8818, 67647, 66046, 76727, 25049, 48694, 96244, 42767, 13120, 53729, 90754, 47498, 40257, 7844, 79665, 35900, 33567, 80332, 68427, 29914, 91621, 38959, 35796, 7435, 65460, 434, 2785, 4710, 80793, 20827, 22155, 90320, 5066, 24178, 18875, 51294, 5222, 95816, 14268, 68478, 96761, 66479, 67335, 51513, 78673, 73143, 11679, 85300, 88785, 1004, 18064, 91085, 18999, 25640, 45379, 74924, 94706, 46916, 32682, 31715, 3086, 49466, 85098, 49913, 44647, 82331, 27219, 13875, 58769, 3667, 10298, 44795, 62204, 21497, 58731, 12965, 62569, 72238, 49525, 22899, 84200, 3845, 98178, 924, 35984, 32417, 22686, 22620, 47458, 87867, 29566, 77085, 10960, 14876, 89730, 21641, 13636, 79167, 53472, 30103, 56335, 39274, 74071, 68958, 66408, 47354, 84728, 28113, 99860, 49955, 79844, 1186, 85981, 39037, 60464, 80363, 89186, 92541, 16343, 48363, 7581, 73306, 68325, 65829, 84163, 74355, 53786, 58715, 98906, 39439, 27860, 76391, 76589, 39834, 27137, 81688, 64132, 49120, 56144, 86941, 95518, 72009, 82728, 96067, 97712, 79469, 44330, 67454, 39941, 97408, 58132, 5066, 93590, 77162, 72882, 39621, 31441, 23172, 65710, 88436, 34469, 86816, 9665, 5643, 68076, 70549, 80805, 94994, 91769, 84542, 62168, 74918, 61406, 45287, 5793, 54563, 3652, 92584, 61367, 28505, 30248, 20120, 86422, 81094, 83631, 58464, 55958, 40896, 81384, 55062, 40915, 58556, 32091, 34368, 54084, 77250, 25828, 15620, 90399, 20250, 73405, 26695, 2032, 83486, 95048, 94554, 30946, 28573, 74157, 43422, 85194, 47436, 36847, 40337, 44865, 44811, 69652, 13169, 41240, 48298, 72630, 51768, 49849, 81558, 51868, 75819, 14511, 36733, 35093, 77864, 36881, 97122, 60008, 48465, 10154, 94832, 12514, 47840, 15591, 65517, 68261, 63597, 80341, 6530, 76786, 97631, 2526, 47318, 83685, 23732, 20477, 36378, 4066, 79691, 93070, 83021, 37168, 52019, 85092, 72854, 20879, 55104, 61225, 87611, 84521, 9011, 27496, 39666, 61677, 49131, 80714, 29320, 98393, 71579, 39547, 34736, 99974, 53333, 26106, 50745, 92975, 84628, 24607, 5133, 38793, 24284, 43324, 50981, 51005, 22088, 10404, 59675, 84882, 52975, 94861, 17852, 74017, 42533, 53763, 1986, 59478, 96769, 77976, 58875, 25744, 68724, 10130, 52144, 73428, 10610, 97509, 64410, 37812, 59809, 8455, 65712, 89789, 87542, 22274, 94253, 59627, 42450, 26524, 12018, 35043, 27433, 94055, 79108, 64297, 39011, 68974, 69586, 87982, 71372, 62430, 43056, 15425, 80083, 68963, 38661, 45853, 44335, 71876, 28982, 2264, 61889, 6454, 58072, 242, 93781, 71755, 66290, 90497, 54071, 55444, 64765, 4058, 79429, 41630, 15024, 64603, 98934, 48326, 56618, 55522, 37470, 57495, 31975, 70970, 31709, 31945, 64378, 12831, 51921, 76994, 31476, 72360, 63265, 35422, 88813, 58864, 74401, 91076, 37836, 55027, 95549, 15618, 34969, 60039, 61528, 3321, 94087, 37316, 81288, 81268, 71368, 95150, 57625, 34979, 60444, 45713, 87417, 17729, 30256, 98375, 2527, 95619, 71929, 47741, 59345, 50186, 73234, 74055, 49179, 14980, 21318, 96240, 9917, 75849, 56534, 85371, 63765, 23611, 47419, 34402, 48943, 26048, 69611, 29375, 29430, 6553, 97428, 97806, 80481, 26953, 42600, 59032, 65854, 66035, 48964, 22269, 52171, 14513, 65468, 66339, 25356, 52393, 7853, 24853, 78187, 83930, 67307, 45091, 41518, 52101, 76047, 40529, 36318, 3755, 62784, 77519, 22200, 70689, 33135, 81934, 72265, 2971, 91369, 53872, 45818, 57790, 21607, 66120, 26696, 92619, 47305, 65861, 60602, 66559, 2054, 57820, 19261, 6596, 56435, 12167, 29581, 17598, 1729, 77111, 26411, 66914, 14722, 39615, 27758, 96587, 69153, 65407, 65952, 52604, 28856, 58297, 94511, 71028, 75000, 60829, 12334, 21754, 20048, 5488, 11184, 80078, 64552, 23655, 75130, 79850, 40299, 92970, 89686, 72265, 49906, 84405, 90304, 74509, 97608, 32383, 77555, 89457, 96493, 25090, 79130, 5238, 44242, 54197, 87027, 77862, 44899, 39596, 50314, 66002, 34789, 83144, 62992, 9580, 89205, 9252, 54862, 53171, 64280, 13361, 17974, 66583, 40129, 4768, 25940, 96021, 80579, 7235, 63726, 87348, 21304, 86007, 94534, 57733, 43068, 31145, 34295, 12128, 97580, 83653, 28797, 69504, 29790, 73946, 59341, 48155, 1463, 80083, 32469, 71782, 20850, 96205, 42015, 73041, 55026, 56528, 41902, 12404, 62462, 81533, 16708, 7415, 68387, 80571, 32027, 35225, 10946, 94144, 4194, 43504, 49796, 50362, 95023, 52994, 95205, 36035, 71247, 41720, 6865, 17427, 36924, 61894, 38538, 67742, 44575, 14625, 79002, 90627, 8841, 84462, 7945, 24927, 82064, 46459, 52759, 31226, 5657, 79441, 64942, 70601, 84159, 3713, 5819, 33208, 82518, 79984, 11805, 65691, 27461, 79491, 31649, 44872, 55358, 59545, 43403, 25937, 57129, 95086, 33073, 66761, 54601, 58418, 97317, 55033, 52664, 98134, 37723, 11301, 82638, 57741, 7107, 3684, 12886, 23805, 51818, 91767, 69982, 49206, 31880, 98404, 66281, 65126, 58401, 7132, 42216, 82869, 16032, 26488, 60581, 34013, 63817, 6519, 89872, 31855, 22997, 69212, 73604, 76079, 64953, 98735, 44812, 4732, 94488, 84054, 42787, 46869, 45010, 20732, 5560, 56309, 77803, 42883, 66324, 49402, 64847, 31627, 94225, 77195, 95635, 68166, 31386, 63128, 31631, 70432, 46143, 52182, 8113, 84606, 51625, 55982, 29418, 64146, 69813, 44592, 79603, 46634, 32362, 62318, 18402, 68531, 53415, 19852, 28919, 62513, 79532, 49718, 33065, 56835, 64306, 60638, 70658, 79161, 27512, 68976, 89331, 29937, 12813, 57173, 27550, 84813, 60721, 11582, 44931, 88702, 7688, 52433, 55498, 95194, 39528, 6913, 6693, 94386, 842, 12398, 45874, 68922, 71749, 4672, 93255, 10276, 30051, 18146, 1369, 34708, 13026, 81431, 18801, 4379, 1238, 53213, 33648, 8064, 76802, 41132, 22338, 2817, 16671, 85926, 86066, 41124, 36200, 37286, 96525, 59693, 83181, 87393, 35298, 17208, 90473, 22239, 61861, 41594, 2519, 54614, 59722, 37429, 49717, 81394, 55456, 64709, 76277, 23690, 55080, 41336, 29750, 97329, 28604, 24728, 76992, 67044, 34563, 32395, 24170, 30848, 56474, 78881, 4772, 23177, 28993, 11230, 77390, 62191, 24747, 29986, 50371, 34979, 66772, 80075, 19549, 78848, 11352, 48373, 96733, 93428, 45892, 86184, 62894, 19948, 70176, 16630, 69200, 28933, 93458, 73504, 54975, 55489, 8787, 47519, 97887, 16335], thresh=44238370995):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
modified_func def sat(indices: List[int], H=wrap_int(100000), alpha=wrap_int(975), beta=wrap_int(546), xs=wrap_list([wrap_int(0), wrap_int(102), wrap_int(174), wrap_int(281), wrap_int(458), wrap_int(554), wrap_int(583), wrap_int(590), wrap_int(646), wrap_int(1592), wrap_int(1795), wrap_int(1805), wrap_int(1835), wrap_int(1839), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1842), wrap_int(1843), wrap_int(2357), wrap_int(2683), wrap_int(3152), wrap_int(3159), wrap_int(3167), wrap_int(3170), wrap_int(3170), wrap_int(3171), wrap_int(3171), wrap_int(3172), wrap_int(3172), wrap_int(3172), wrap_int(3172), wrap_int(3172), wrap_int(3173), wrap_int(4025), wrap_int(4274), wrap_int(4282), wrap_int(4465), wrap_int(4520), wrap_int(4529), wrap_int(4666), wrap_int(4676), wrap_int(4901), wrap_int(4905), wrap_int(5003), wrap_int(5295), wrap_int(5510), wrap_int(5553), wrap_int(5585), wrap_int(5585), wrap_int(5638), wrap_int(5973), wrap_int(6136), wrap_int(6317), wrap_int(6329), wrap_int(6374), wrap_int(6400), wrap_int(6405), wrap_int(6407), wrap_int(6407), wrap_int(6409), wrap_int(6409), wrap_int(6409), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6410), wrap_int(6411), wrap_int(6456), wrap_int(6462), wrap_int(6462), wrap_int(6469), wrap_int(6482), wrap_int(6486), wrap_int(6881), wrap_int(6919), wrap_int(7240), wrap_int(7510), wrap_int(7599), wrap_int(7995), wrap_int(8173), wrap_int(8249), wrap_int(8284), wrap_int(8296), wrap_int(8298), wrap_int(8298), wrap_int(8299), wrap_int(8301), wrap_int(8427), wrap_int(8701), wrap_int(8751), wrap_int(8945), wrap_int(9141), wrap_int(9166), wrap_int(9208), wrap_int(9308), wrap_int(9321), wrap_int(9327), wrap_int(9332), wrap_int(9332), wrap_int(9332), wrap_int(9332), wrap_int(9332), wrap_int(9332), wrap_int(9332), wrap_int(9332), wrap_int(9332), wrap_int(9333), wrap_int(10630), wrap_int(11062), wrap_int(11173), wrap_int(11286), wrap_int(11294), wrap_int(11319), wrap_int(11322), wrap_int(11367), wrap_int(11372), wrap_int(11376), wrap_int(11398), wrap_int(11399), wrap_int(11403), wrap_int(11409), wrap_int(11451), wrap_int(11459), wrap_int(11519), wrap_int(11660), wrap_int(11687), wrap_int(11691), wrap_int(11694), wrap_int(11694), wrap_int(11697), wrap_int(12232), wrap_int(12313), wrap_int(12314), wrap_int(12316), wrap_int(12321), wrap_int(12322), wrap_int(12322), wrap_int(12322), wrap_int(12323), wrap_int(13101), wrap_int(13207), wrap_int(13274), wrap_int(13445), wrap_int(13512), wrap_int(13687), wrap_int(13911), wrap_int(13987), wrap_int(14251), wrap_int(14255), wrap_int(14306), wrap_int(14570), wrap_int(14594), wrap_int(14606), wrap_int(14606), wrap_int(14608), wrap_int(14998), wrap_int(15232), wrap_int(15237), wrap_int(15633), wrap_int(15795), wrap_int(15831), wrap_int(15991), wrap_int(16176), wrap_int(16179), wrap_int(16189), wrap_int(16228), wrap_int(16339), wrap_int(16450), wrap_int(16540), wrap_int(16777), wrap_int(16851), wrap_int(16889), wrap_int(17291), wrap_int(17694), wrap_int(18333), wrap_int(18356), wrap_int(19390), wrap_int(19449), wrap_int(19454), wrap_int(19750), wrap_int(20562), wrap_int(22013), wrap_int(22332), wrap_int(22374), wrap_int(22591), wrap_int(23234), wrap_int(23276), wrap_int(23281), wrap_int(23296), wrap_int(23351), wrap_int(23397), wrap_int(23762), wrap_int(23844), wrap_int(23859), wrap_int(23866), wrap_int(23894), wrap_int(23943), wrap_int(24311), wrap_int(24379), wrap_int(24958), wrap_int(25140), wrap_int(25160), wrap_int(25178), wrap_int(25211), wrap_int(25219), wrap_int(25235), wrap_int(25378), wrap_int(25929), wrap_int(26078), wrap_int(26181), wrap_int(26474), wrap_int(26804), wrap_int(26821), wrap_int(26838), wrap_int(26843), wrap_int(26858), wrap_int(26894), wrap_int(26894), wrap_int(26894), wrap_int(26895), wrap_int(27181), wrap_int(27302), wrap_int(27329), wrap_int(27365), wrap_int(27374), wrap_int(27380), wrap_int(27381), wrap_int(27382), wrap_int(27382), wrap_int(27382), wrap_int(27382), wrap_int(27382), wrap_int(27382), wrap_int(27382), wrap_int(27382), wrap_int(27382), wrap_int(27382), wrap_int(27383), wrap_int(27386), wrap_int(27418), wrap_int(27450), wrap_int(27463), wrap_int(27525), wrap_int(27529), wrap_int(27552), wrap_int(27559), wrap_int(27562), wrap_int(27562), wrap_int(27563), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27564), wrap_int(27565), wrap_int(27721), wrap_int(27801), wrap_int(27818), wrap_int(27882), wrap_int(28083), wrap_int(28148), wrap_int(28673), wrap_int(29079), wrap_int(29102), wrap_int(29155), wrap_int(29158), wrap_int(29162), wrap_int(29193), wrap_int(29256), wrap_int(29576), wrap_int(29991), wrap_int(29992), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29996), wrap_int(29997), wrap_int(30025), wrap_int(30083), wrap_int(30088), wrap_int(30146), wrap_int(30173), wrap_int(30182), wrap_int(30305), wrap_int(30408), wrap_int(30596), wrap_int(30905), wrap_int(31000), wrap_int(31405), wrap_int(31558), wrap_int(31588), wrap_int(31663), wrap_int(31664), wrap_int(31664), wrap_int(31667), wrap_int(31670), wrap_int(31674), wrap_int(31676), wrap_int(31703), wrap_int(32815), wrap_int(32821), wrap_int(32949), wrap_int(33977), wrap_int(34036), wrap_int(34403), wrap_int(34413), wrap_int(34464), wrap_int(34505), wrap_int(34509), wrap_int(34511), wrap_int(34772), wrap_int(34972), wrap_int(35021), wrap_int(35068), wrap_int(35259), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35272), wrap_int(35273), wrap_int(35311), wrap_int(35343), wrap_int(35611), wrap_int(35950), wrap_int(36192), wrap_int(36400), wrap_int(36410), wrap_int(36622), wrap_int(36820), wrap_int(36883), wrap_int(36959), wrap_int(36960), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36963), wrap_int(36964), wrap_int(37010), wrap_int(37035), wrap_int(37311), wrap_int(37660), wrap_int(37733), wrap_int(37934), wrap_int(38287), wrap_int(38539), wrap_int(39425), wrap_int(39441), wrap_int(39473), wrap_int(40033), wrap_int(40124), wrap_int(40319), wrap_int(40609), wrap_int(40643), wrap_int(40673), wrap_int(40727), wrap_int(40741), wrap_int(40742), wrap_int(40744), wrap_int(40750), wrap_int(41021), wrap_int(41080), wrap_int(41311), wrap_int(41319), wrap_int(41321), wrap_int(41335), wrap_int(41344), wrap_int(41344), wrap_int(41345), wrap_int(41345), wrap_int(41345), wrap_int(41345), wrap_int(41345), wrap_int(41346), wrap_int(41532), wrap_int(41554), wrap_int(42011), wrap_int(42164), wrap_int(42187), wrap_int(42276), wrap_int(42566), wrap_int(42675), wrap_int(43393), wrap_int(43473), wrap_int(43480), wrap_int(43504), wrap_int(43504), wrap_int(43504), wrap_int(43504), wrap_int(43504), wrap_int(43505), wrap_int(44026), wrap_int(44718), wrap_int(45006), wrap_int(45128), wrap_int(45193), wrap_int(45581), wrap_int(45643), wrap_int(45679), wrap_int(45684), wrap_int(45687), wrap_int(45858), wrap_int(45958), wrap_int(46022), wrap_int(46126), wrap_int(46367), wrap_int(46712), wrap_int(46849), wrap_int(47743), wrap_int(47968), wrap_int(48262), wrap_int(49272), wrap_int(49376), wrap_int(50058), wrap_int(50436), wrap_int(51804), wrap_int(51966), wrap_int(52122), wrap_int(52374), wrap_int(53401), wrap_int(53638), wrap_int(54722), wrap_int(55797), wrap_int(55906), wrap_int(56812), wrap_int(56839), wrap_int(57005), wrap_int(58384), wrap_int(58720), wrap_int(58959), wrap_int(59074), wrap_int(59209), wrap_int(59512), wrap_int(59785), wrap_int(60798), wrap_int(61136), wrap_int(61198), wrap_int(61505), wrap_int(62052), wrap_int(62540), wrap_int(62555), wrap_int(62783), wrap_int(63241), wrap_int(63829), wrap_int(64155), wrap_int(64422), wrap_int(64520), wrap_int(65271), wrap_int(65297), wrap_int(67452), wrap_int(67628), wrap_int(68258), wrap_int(68379), wrap_int(69233), wrap_int(69496), wrap_int(69613), wrap_int(69774), wrap_int(70090), wrap_int(70092), wrap_int(70759), wrap_int(70770), wrap_int(70809), wrap_int(71196), wrap_int(71265), wrap_int(71529), wrap_int(72250), wrap_int(72476), wrap_int(72523), wrap_int(72556), wrap_int(72829), wrap_int(73209), wrap_int(73477), wrap_int(73739), wrap_int(73843), wrap_int(74249), wrap_int(74728), wrap_int(74988), wrap_int(75425), wrap_int(75988), wrap_int(76032), wrap_int(76096), wrap_int(76152), wrap_int(76222), wrap_int(76751), wrap_int(77227), wrap_int(77631), wrap_int(77995), wrap_int(78061), wrap_int(78169), wrap_int(78400), wrap_int(78784), wrap_int(79499), wrap_int(80385), wrap_int(80551), wrap_int(80627), wrap_int(80660), wrap_int(81059), wrap_int(81143), wrap_int(81405), wrap_int(81665), wrap_int(82904), wrap_int(83595), wrap_int(83957), wrap_int(83996), wrap_int(84043), wrap_int(84739), wrap_int(85031), wrap_int(85987), wrap_int(86319), wrap_int(86864), wrap_int(86933), wrap_int(86947), wrap_int(87127), wrap_int(87520), wrap_int(87543), wrap_int(87848), wrap_int(88057), wrap_int(88437), wrap_int(89195), wrap_int(89401), wrap_int(90469), wrap_int(90756), wrap_int(90761), wrap_int(91175), wrap_int(91975), wrap_int(92907), wrap_int(92987), wrap_int(94337), wrap_int(94470), wrap_int(95290), wrap_int(96267), wrap_int(96378), wrap_int(96635), wrap_int(97113), wrap_int(97608), wrap_int(97663), wrap_int(97721), wrap_int(98148), wrap_int(98536), wrap_int(98629), wrap_int(98960), wrap_int(99036), wrap_int(99763), wrap_int(99793), wrap_int(100000)]), ys=wrap_list([wrap_int(2773), wrap_int(47376), wrap_int(17008), wrap_int(24785), wrap_int(21921), wrap_int(60359), wrap_int(33137), wrap_int(72146), wrap_int(76002), wrap_int(49654), wrap_int(25696), wrap_int(25832), wrap_int(72474), wrap_int(2917), wrap_int(18229), wrap_int(2385), wrap_int(66151), wrap_int(51868), wrap_int(4760), wrap_int(69187), wrap_int(67221), wrap_int(14320), wrap_int(24425), wrap_int(88890), wrap_int(24553), wrap_int(78751), wrap_int(70869), wrap_int(11279), wrap_int(12625), wrap_int(84959), wrap_int(28885), wrap_int(87499), wrap_int(61816), wrap_int(41222), wrap_int(81997), wrap_int(1265), wrap_int(63632), wrap_int(12863), wrap_int(54939), wrap_int(56081), wrap_int(35629), wrap_int(37122), wrap_int(49133), wrap_int(24893), wrap_int(41731), wrap_int(9182), wrap_int(34407), wrap_int(90952), wrap_int(42360), wrap_int(43861), wrap_int(99296), wrap_int(80331), wrap_int(78826), wrap_int(19484), wrap_int(90699), wrap_int(30578), wrap_int(71697), wrap_int(10304), wrap_int(61318), wrap_int(89870), wrap_int(38599), wrap_int(71160), wrap_int(22805), wrap_int(17850), wrap_int(60106), wrap_int(76742), wrap_int(14571), wrap_int(74280), wrap_int(88847), wrap_int(53537), wrap_int(84726), wrap_int(7279), wrap_int(55376), wrap_int(47707), wrap_int(78111), wrap_int(14855), wrap_int(20855), wrap_int(89936), wrap_int(20706), wrap_int(98672), wrap_int(5385), wrap_int(76357), wrap_int(90172), wrap_int(48891), wrap_int(6243), wrap_int(82298), wrap_int(64602), wrap_int(99637), wrap_int(83220), wrap_int(87261), wrap_int(26190), wrap_int(39457), wrap_int(12610), wrap_int(44567), wrap_int(54545), wrap_int(71246), wrap_int(96608), wrap_int(5086), wrap_int(65811), wrap_int(15907), wrap_int(21012), wrap_int(17278), wrap_int(1139), wrap_int(54815), wrap_int(52416), wrap_int(19440), wrap_int(44857), wrap_int(16066), wrap_int(22379), wrap_int(73573), wrap_int(36087), wrap_int(54255), wrap_int(60304), wrap_int(30497), wrap_int(1202), wrap_int(95520), wrap_int(48378), wrap_int(68296), wrap_int(14032), wrap_int(50456), wrap_int(60555), wrap_int(80390), wrap_int(70975), wrap_int(17531), wrap_int(3761), wrap_int(46399), wrap_int(48927), wrap_int(96320), wrap_int(79008), wrap_int(25360), wrap_int(67058), wrap_int(26409), wrap_int(29891), wrap_int(324), wrap_int(67141), wrap_int(24534), wrap_int(69987), wrap_int(11711), wrap_int(99837), wrap_int(82260), wrap_int(8818), wrap_int(67647), wrap_int(66046), wrap_int(76727), wrap_int(25049), wrap_int(48694), wrap_int(96244), wrap_int(42767), wrap_int(13120), wrap_int(53729), wrap_int(90754), wrap_int(47498), wrap_int(40257), wrap_int(7844), wrap_int(79665), wrap_int(35900), wrap_int(33567), wrap_int(80332), wrap_int(68427), wrap_int(29914), wrap_int(91621), wrap_int(38959), wrap_int(35796), wrap_int(7435), wrap_int(65460), wrap_int(434), wrap_int(2785), wrap_int(4710), wrap_int(80793), wrap_int(20827), wrap_int(22155), wrap_int(90320), wrap_int(5066), wrap_int(24178), wrap_int(18875), wrap_int(51294), wrap_int(5222), wrap_int(95816), wrap_int(14268), wrap_int(68478), wrap_int(96761), wrap_int(66479), wrap_int(67335), wrap_int(51513), wrap_int(78673), wrap_int(73143), wrap_int(11679), wrap_int(85300), wrap_int(88785), wrap_int(1004), wrap_int(18064), wrap_int(91085), wrap_int(18999), wrap_int(25640), wrap_int(45379), wrap_int(74924), wrap_int(94706), wrap_int(46916), wrap_int(32682), wrap_int(31715), wrap_int(3086), wrap_int(49466), wrap_int(85098), wrap_int(49913), wrap_int(44647), wrap_int(82331), wrap_int(27219), wrap_int(13875), wrap_int(58769), wrap_int(3667), wrap_int(10298), wrap_int(44795), wrap_int(62204), wrap_int(21497), wrap_int(58731), wrap_int(12965), wrap_int(62569), wrap_int(72238), wrap_int(49525), wrap_int(22899), wrap_int(84200), wrap_int(3845), wrap_int(98178), wrap_int(924), wrap_int(35984), wrap_int(32417), wrap_int(22686), wrap_int(22620), wrap_int(47458), wrap_int(87867), wrap_int(29566), wrap_int(77085), wrap_int(10960), wrap_int(14876), wrap_int(89730), wrap_int(21641), wrap_int(13636), wrap_int(79167), wrap_int(53472), wrap_int(30103), wrap_int(56335), wrap_int(39274), wrap_int(74071), wrap_int(68958), wrap_int(66408), wrap_int(47354), wrap_int(84728), wrap_int(28113), wrap_int(99860), wrap_int(49955), wrap_int(79844), wrap_int(1186), wrap_int(85981), wrap_int(39037), wrap_int(60464), wrap_int(80363), wrap_int(89186), wrap_int(92541), wrap_int(16343), wrap_int(48363), wrap_int(7581), wrap_int(73306), wrap_int(68325), wrap_int(65829), wrap_int(84163), wrap_int(74355), wrap_int(53786), wrap_int(58715), wrap_int(98906), wrap_int(39439), wrap_int(27860), wrap_int(76391), wrap_int(76589), wrap_int(39834), wrap_int(27137), wrap_int(81688), wrap_int(64132), wrap_int(49120), wrap_int(56144), wrap_int(86941), wrap_int(95518), wrap_int(72009), wrap_int(82728), wrap_int(96067), wrap_int(97712), wrap_int(79469), wrap_int(44330), wrap_int(67454), wrap_int(39941), wrap_int(97408), wrap_int(58132), wrap_int(5066), wrap_int(93590), wrap_int(77162), wrap_int(72882), wrap_int(39621), wrap_int(31441), wrap_int(23172), wrap_int(65710), wrap_int(88436), wrap_int(34469), wrap_int(86816), wrap_int(9665), wrap_int(5643), wrap_int(68076), wrap_int(70549), wrap_int(80805), wrap_int(94994), wrap_int(91769), wrap_int(84542), wrap_int(62168), wrap_int(74918), wrap_int(61406), wrap_int(45287), wrap_int(5793), wrap_int(54563), wrap_int(3652), wrap_int(92584), wrap_int(61367), wrap_int(28505), wrap_int(30248), wrap_int(20120), wrap_int(86422), wrap_int(81094), wrap_int(83631), wrap_int(58464), wrap_int(55958), wrap_int(40896), wrap_int(81384), wrap_int(55062), wrap_int(40915), wrap_int(58556), wrap_int(32091), wrap_int(34368), wrap_int(54084), wrap_int(77250), wrap_int(25828), wrap_int(15620), wrap_int(90399), wrap_int(20250), wrap_int(73405), wrap_int(26695), wrap_int(2032), wrap_int(83486), wrap_int(95048), wrap_int(94554), wrap_int(30946), wrap_int(28573), wrap_int(74157), wrap_int(43422), wrap_int(85194), wrap_int(47436), wrap_int(36847), wrap_int(40337), wrap_int(44865), wrap_int(44811), wrap_int(69652), wrap_int(13169), wrap_int(41240), wrap_int(48298), wrap_int(72630), wrap_int(51768), wrap_int(49849), wrap_int(81558), wrap_int(51868), wrap_int(75819), wrap_int(14511), wrap_int(36733), wrap_int(35093), wrap_int(77864), wrap_int(36881), wrap_int(97122), wrap_int(60008), wrap_int(48465), wrap_int(10154), wrap_int(94832), wrap_int(12514), wrap_int(47840), wrap_int(15591), wrap_int(65517), wrap_int(68261), wrap_int(63597), wrap_int(80341), wrap_int(6530), wrap_int(76786), wrap_int(97631), wrap_int(2526), wrap_int(47318), wrap_int(83685), wrap_int(23732), wrap_int(20477), wrap_int(36378), wrap_int(4066), wrap_int(79691), wrap_int(93070), wrap_int(83021), wrap_int(37168), wrap_int(52019), wrap_int(85092), wrap_int(72854), wrap_int(20879), wrap_int(55104), wrap_int(61225), wrap_int(87611), wrap_int(84521), wrap_int(9011), wrap_int(27496), wrap_int(39666), wrap_int(61677), wrap_int(49131), wrap_int(80714), wrap_int(29320), wrap_int(98393), wrap_int(71579), wrap_int(39547), wrap_int(34736), wrap_int(99974), wrap_int(53333), wrap_int(26106), wrap_int(50745), wrap_int(92975), wrap_int(84628), wrap_int(24607), wrap_int(5133), wrap_int(38793), wrap_int(24284), wrap_int(43324), wrap_int(50981), wrap_int(51005), wrap_int(22088), wrap_int(10404), wrap_int(59675), wrap_int(84882), wrap_int(52975), wrap_int(94861), wrap_int(17852), wrap_int(74017), wrap_int(42533), wrap_int(53763), wrap_int(1986), wrap_int(59478), wrap_int(96769), wrap_int(77976), wrap_int(58875), wrap_int(25744), wrap_int(68724), wrap_int(10130), wrap_int(52144), wrap_int(73428), wrap_int(10610), wrap_int(97509), wrap_int(64410), wrap_int(37812), wrap_int(59809), wrap_int(8455), wrap_int(65712), wrap_int(89789), wrap_int(87542), wrap_int(22274), wrap_int(94253), wrap_int(59627), wrap_int(42450), wrap_int(26524), wrap_int(12018), wrap_int(35043), wrap_int(27433), wrap_int(94055), wrap_int(79108), wrap_int(64297), wrap_int(39011), wrap_int(68974), wrap_int(69586), wrap_int(87982), wrap_int(71372), wrap_int(62430), wrap_int(43056), wrap_int(15425), wrap_int(80083), wrap_int(68963), wrap_int(38661), wrap_int(45853), wrap_int(44335), wrap_int(71876), wrap_int(28982), wrap_int(2264), wrap_int(61889), wrap_int(6454), wrap_int(58072), wrap_int(242), wrap_int(93781), wrap_int(71755), wrap_int(66290), wrap_int(90497), wrap_int(54071), wrap_int(55444), wrap_int(64765), wrap_int(4058), wrap_int(79429), wrap_int(41630), wrap_int(15024), wrap_int(64603), wrap_int(98934), wrap_int(48326), wrap_int(56618), wrap_int(55522), wrap_int(37470), wrap_int(57495), wrap_int(31975), wrap_int(70970), wrap_int(31709), wrap_int(31945), wrap_int(64378), wrap_int(12831), wrap_int(51921), wrap_int(76994), wrap_int(31476), wrap_int(72360), wrap_int(63265), wrap_int(35422), wrap_int(88813), wrap_int(58864), wrap_int(74401), wrap_int(91076), wrap_int(37836), wrap_int(55027), wrap_int(95549), wrap_int(15618), wrap_int(34969), wrap_int(60039), wrap_int(61528), wrap_int(3321), wrap_int(94087), wrap_int(37316), wrap_int(81288), wrap_int(81268), wrap_int(71368), wrap_int(95150), wrap_int(57625), wrap_int(34979), wrap_int(60444), wrap_int(45713), wrap_int(87417), wrap_int(17729), wrap_int(30256), wrap_int(98375), wrap_int(2527), wrap_int(95619), wrap_int(71929), wrap_int(47741), wrap_int(59345), wrap_int(50186), wrap_int(73234), wrap_int(74055), wrap_int(49179), wrap_int(14980), wrap_int(21318), wrap_int(96240), wrap_int(9917), wrap_int(75849), wrap_int(56534), wrap_int(85371), wrap_int(63765), wrap_int(23611), wrap_int(47419), wrap_int(34402), wrap_int(48943), wrap_int(26048), wrap_int(69611), wrap_int(29375), wrap_int(29430), wrap_int(6553), wrap_int(97428), wrap_int(97806), wrap_int(80481), wrap_int(26953), wrap_int(42600), wrap_int(59032), wrap_int(65854), wrap_int(66035), wrap_int(48964), wrap_int(22269), wrap_int(52171), wrap_int(14513), wrap_int(65468), wrap_int(66339), wrap_int(25356), wrap_int(52393), wrap_int(7853), wrap_int(24853), wrap_int(78187), wrap_int(83930), wrap_int(67307), wrap_int(45091), wrap_int(41518), wrap_int(52101), wrap_int(76047), wrap_int(40529), wrap_int(36318), wrap_int(3755), wrap_int(62784), wrap_int(77519), wrap_int(22200), wrap_int(70689), wrap_int(33135), wrap_int(81934), wrap_int(72265), wrap_int(2971), wrap_int(91369), wrap_int(53872), wrap_int(45818), wrap_int(57790), wrap_int(21607), wrap_int(66120), wrap_int(26696), wrap_int(92619), wrap_int(47305), wrap_int(65861), wrap_int(60602), wrap_int(66559), wrap_int(2054), wrap_int(57820), wrap_int(19261), wrap_int(6596), wrap_int(56435), wrap_int(12167), wrap_int(29581), wrap_int(17598), wrap_int(1729), wrap_int(77111), wrap_int(26411), wrap_int(66914), wrap_int(14722), wrap_int(39615), wrap_int(27758), wrap_int(96587), wrap_int(69153), wrap_int(65407), wrap_int(65952), wrap_int(52604), wrap_int(28856), wrap_int(58297), wrap_int(94511), wrap_int(71028), wrap_int(75000), wrap_int(60829), wrap_int(12334), wrap_int(21754), wrap_int(20048), wrap_int(5488), wrap_int(11184), wrap_int(80078), wrap_int(64552), wrap_int(23655), wrap_int(75130), wrap_int(79850), wrap_int(40299), wrap_int(92970), wrap_int(89686), wrap_int(72265), wrap_int(49906), wrap_int(84405), wrap_int(90304), wrap_int(74509), wrap_int(97608), wrap_int(32383), wrap_int(77555), wrap_int(89457), wrap_int(96493), wrap_int(25090), wrap_int(79130), wrap_int(5238), wrap_int(44242), wrap_int(54197), wrap_int(87027), wrap_int(77862), wrap_int(44899), wrap_int(39596), wrap_int(50314), wrap_int(66002), wrap_int(34789), wrap_int(83144), wrap_int(62992), wrap_int(9580), wrap_int(89205), wrap_int(9252), wrap_int(54862), wrap_int(53171), wrap_int(64280), wrap_int(13361), wrap_int(17974), wrap_int(66583), wrap_int(40129), wrap_int(4768), wrap_int(25940), wrap_int(96021), wrap_int(80579), wrap_int(7235), wrap_int(63726), wrap_int(87348), wrap_int(21304), wrap_int(86007), wrap_int(94534), wrap_int(57733), wrap_int(43068), wrap_int(31145), wrap_int(34295), wrap_int(12128), wrap_int(97580), wrap_int(83653), wrap_int(28797), wrap_int(69504), wrap_int(29790), wrap_int(73946), wrap_int(59341), wrap_int(48155), wrap_int(1463), wrap_int(80083), wrap_int(32469), wrap_int(71782), wrap_int(20850), wrap_int(96205), wrap_int(42015), wrap_int(73041), wrap_int(55026), wrap_int(56528), wrap_int(41902), wrap_int(12404), wrap_int(62462), wrap_int(81533), wrap_int(16708), wrap_int(7415), wrap_int(68387), wrap_int(80571), wrap_int(32027), wrap_int(35225), wrap_int(10946), wrap_int(94144), wrap_int(4194), wrap_int(43504), wrap_int(49796), wrap_int(50362), wrap_int(95023), wrap_int(52994), wrap_int(95205), wrap_int(36035), wrap_int(71247), wrap_int(41720), wrap_int(6865), wrap_int(17427), wrap_int(36924), wrap_int(61894), wrap_int(38538), wrap_int(67742), wrap_int(44575), wrap_int(14625), wrap_int(79002), wrap_int(90627), wrap_int(8841), wrap_int(84462), wrap_int(7945), wrap_int(24927), wrap_int(82064), wrap_int(46459), wrap_int(52759), wrap_int(31226), wrap_int(5657), wrap_int(79441), wrap_int(64942), wrap_int(70601), wrap_int(84159), wrap_int(3713), wrap_int(5819), wrap_int(33208), wrap_int(82518), wrap_int(79984), wrap_int(11805), wrap_int(65691), wrap_int(27461), wrap_int(79491), wrap_int(31649), wrap_int(44872), wrap_int(55358), wrap_int(59545), wrap_int(43403), wrap_int(25937), wrap_int(57129), wrap_int(95086), wrap_int(33073), wrap_int(66761), wrap_int(54601), wrap_int(58418), wrap_int(97317), wrap_int(55033), wrap_int(52664), wrap_int(98134), wrap_int(37723), wrap_int(11301), wrap_int(82638), wrap_int(57741), wrap_int(7107), wrap_int(3684), wrap_int(12886), wrap_int(23805), wrap_int(51818), wrap_int(91767), wrap_int(69982), wrap_int(49206), wrap_int(31880), wrap_int(98404), wrap_int(66281), wrap_int(65126), wrap_int(58401), wrap_int(7132), wrap_int(42216), wrap_int(82869), wrap_int(16032), wrap_int(26488), wrap_int(60581), wrap_int(34013), wrap_int(63817), wrap_int(6519), wrap_int(89872), wrap_int(31855), wrap_int(22997), wrap_int(69212), wrap_int(73604), wrap_int(76079), wrap_int(64953), wrap_int(98735), wrap_int(44812), wrap_int(4732), wrap_int(94488), wrap_int(84054), wrap_int(42787), wrap_int(46869), wrap_int(45010), wrap_int(20732), wrap_int(5560), wrap_int(56309), wrap_int(77803), wrap_int(42883), wrap_int(66324), wrap_int(49402), wrap_int(64847), wrap_int(31627), wrap_int(94225), wrap_int(77195), wrap_int(95635), wrap_int(68166), wrap_int(31386), wrap_int(63128), wrap_int(31631), wrap_int(70432), wrap_int(46143), wrap_int(52182), wrap_int(8113), wrap_int(84606), wrap_int(51625), wrap_int(55982), wrap_int(29418), wrap_int(64146), wrap_int(69813), wrap_int(44592), wrap_int(79603), wrap_int(46634), wrap_int(32362), wrap_int(62318), wrap_int(18402), wrap_int(68531), wrap_int(53415), wrap_int(19852), wrap_int(28919), wrap_int(62513), wrap_int(79532), wrap_int(49718), wrap_int(33065), wrap_int(56835), wrap_int(64306), wrap_int(60638), wrap_int(70658), wrap_int(79161), wrap_int(27512), wrap_int(68976), wrap_int(89331), wrap_int(29937), wrap_int(12813), wrap_int(57173), wrap_int(27550), wrap_int(84813), wrap_int(60721), wrap_int(11582), wrap_int(44931), wrap_int(88702), wrap_int(7688), wrap_int(52433), wrap_int(55498), wrap_int(95194), wrap_int(39528), wrap_int(6913), wrap_int(6693), wrap_int(94386), wrap_int(842), wrap_int(12398), wrap_int(45874), wrap_int(68922), wrap_int(71749), wrap_int(4672), wrap_int(93255), wrap_int(10276), wrap_int(30051), wrap_int(18146), wrap_int(1369), wrap_int(34708), wrap_int(13026), wrap_int(81431), wrap_int(18801), wrap_int(4379), wrap_int(1238), wrap_int(53213), wrap_int(33648), wrap_int(8064), wrap_int(76802), wrap_int(41132), wrap_int(22338), wrap_int(2817), wrap_int(16671), wrap_int(85926), wrap_int(86066), wrap_int(41124), wrap_int(36200), wrap_int(37286), wrap_int(96525), wrap_int(59693), wrap_int(83181), wrap_int(87393), wrap_int(35298), wrap_int(17208), wrap_int(90473), wrap_int(22239), wrap_int(61861), wrap_int(41594), wrap_int(2519), wrap_int(54614), wrap_int(59722), wrap_int(37429), wrap_int(49717), wrap_int(81394), wrap_int(55456), wrap_int(64709), wrap_int(76277), wrap_int(23690), wrap_int(55080), wrap_int(41336), wrap_int(29750), wrap_int(97329), wrap_int(28604), wrap_int(24728), wrap_int(76992), wrap_int(67044), wrap_int(34563), wrap_int(32395), wrap_int(24170), wrap_int(30848), wrap_int(56474), wrap_int(78881), wrap_int(4772), wrap_int(23177), wrap_int(28993), wrap_int(11230), wrap_int(77390), wrap_int(62191), wrap_int(24747), wrap_int(29986), wrap_int(50371), wrap_int(34979), wrap_int(66772), wrap_int(80075), wrap_int(19549), wrap_int(78848), wrap_int(11352), wrap_int(48373), wrap_int(96733), wrap_int(93428), wrap_int(45892), wrap_int(86184), wrap_int(62894), wrap_int(19948), wrap_int(70176), wrap_int(16630), wrap_int(69200), wrap_int(28933), wrap_int(93458), wrap_int(73504), wrap_int(54975), wrap_int(55489), wrap_int(8787), wrap_int(47519), wrap_int(97887), wrap_int(16335)]), thresh=wrap_int(44238370995)):
    _assert(sym_sorted({wrap_int(0), sym_len(xs) - wrap_int(1), *indices}) == indices, wrap_str('Ans. should be sorted list [0, ..., ') + sym_str(sym_len(xs) - wrap_int(1)) + wrap_str(']'))
    cost = alpha * (H - ys[wrap_int(0)])
    for i, j in sym_zip(indices, indices[1:]):
        a, b, r = (xs[i], xs[j], (xs[j] - xs[i]) / wrap_int(2))
        _assert(max(ys[i], ys[j]) + r <= H, wrap_str('Bridge too tall'))
        _assert(all(sym_generator((ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in sym_range(i + 1, j)))), wrap_str('Bridge too short'))
        cost += alpha * (H - ys[j]) + beta * (b - a) ** wrap_int(2)
    return cost <= thresh
Exception -- for puzzle OptimalBridges:3 maximum recursion depth exceeded

Solving puzzle 635/732: OptimalBridges:4
sat_func def sat(indices: List[int], H=100000, alpha=6, beta=2, xs=[0, 75202, 97997, 100000], ys=[24586, 7488, 4413, 30235], thresh=12359929344):
    assert sorted({0, len(xs) - 1, *indices}) == indices, f"Ans. should be sorted list [0, ..., {len(xs) - 1}]"
    cost = alpha * (H - ys[0])
    for i, j in zip(indices, indices[1:]):
        a, b, r = xs[i], xs[j], (xs[j] - xs[i]) / 2
        assert max(ys[i], ys[j]) + r <= H, "Bridge too tall"
        assert all(ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in range(i + 1, j)), \
            "Bridge too short"
        cost += alpha * (H - ys[j]) + beta * (b - a) ** 2
    return cost <= thresh
modified_func def sat(indices: List[int], H=wrap_int(100000), alpha=wrap_int(6), beta=wrap_int(2), xs=wrap_list([wrap_int(0), wrap_int(75202), wrap_int(97997), wrap_int(100000)]), ys=wrap_list([wrap_int(24586), wrap_int(7488), wrap_int(4413), wrap_int(30235)]), thresh=wrap_int(12359929344)):
    _assert(sym_sorted({wrap_int(0), sym_len(xs) - wrap_int(1), *indices}) == indices, wrap_str('Ans. should be sorted list [0, ..., ') + sym_str(sym_len(xs) - wrap_int(1)) + wrap_str(']'))
    cost = alpha * (H - ys[wrap_int(0)])
    for i, j in sym_zip(indices, indices[1:]):
        a, b, r = (xs[i], xs[j], (xs[j] - xs[i]) / wrap_int(2))
        _assert(max(ys[i], ys[j]) + r <= H, wrap_str('Bridge too tall'))
        _assert(all(sym_generator((ys[k] <= H - r + ((b - xs[k]) * (xs[k] - a)) ** 0.5 for k in sym_range(i + 1, j)))), wrap_str('Bridge too short'))
        cost += alpha * (H - ys[j]) + beta * (b - a) ** wrap_int(2)
    return cost <= thresh
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) false))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (< (list.get.int x zip_pos_0) 4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (>= (list.get.int x zip_pos_0) -4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (< (list.get.int x zip_pos_0) 4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (>= (list.get.int x zip_pos_0) -4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (< (list.get.int x zip_pos_0) 4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (>= (list.get.int x zip_pos_0) -4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -4)))))
(assert (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (<= (+ (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (< i_1 4)))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (>= i_1 -4)))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (< i_1 4)))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (>= i_1 -4)))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (< i_1 4)))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (>= i_1 -4)))))))
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (<= (ite (or (= i...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (< (list.get.int ...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (>= (list.get.int...
(assert (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (< (list.get.int x list_pos_731) (- 4 1)) (< 0 (list.get.int x list_pos_731)) (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_0) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_0) 3) (= (list.get.int x zip_pos_0) -1)) 30235 (ite (or (= (list.get.int x zip_pos_0) 2) (= (list.get.int x zip_pos_0) -2)) 4413 (ite (or (= (list.get.int x zip_pos_0) 1) (= (list.get.int x zip_pos_0) -3)) 7488 24586))))) (<= (+ 452484 (+ ...
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) false))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (< (list.get.int x zip_pos_2) 4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (>= (list.get.int x zip_pos_2) -4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (< (list.get.int x zip_pos_2) 4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (>= (list.get.int x zip_pos_2) -4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (< (list.get.int x zip_pos_2) 4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (>= (list.get.int x zip_pos_2) -4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (< (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732)))) (>= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -4)))))))))
(assert (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip_pos_2) 3) (= (list.get.int x zip_pos_2) -1)) 30235 (ite (or (= (list.get.int x zip_pos_2) 2) (= (list.get.int x zip_pos_2) -2)) 44...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(assert (forall ((i_3 Int)) (=> (and (>= i_3 (+ (list.get.int x zip_pos_2) 1)) (< i_3 (list.get.int (list.slice.int x 1 -1 1) zip_pos_2))) (forall ((list_pos_732 Int)) (=> (and (>= list_pos_732 0) (< list_pos_732 (list.length.int x))) (forall ((i_1 Int)) (=> (and (>= i_1 (+ (list.get.int x zip_pos_0) 1)) (< i_1 (list.get.int (list.slice.int x 1 -1 1) zip_pos_0))) (forall ((list_pos_731 Int)) (=> (and (>= list_pos_731 0) (< list_pos_731 (list.length.int x))) (=> (and (not (< (list.get.int x list_pos_732) (- 4 1))) (not (< 0 (list.get.int x list_pos_732))) (not (> (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 3) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -1)) 30235 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 2) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -2)) 4413 (ite (or (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) 1) (= (list.get.int (list.slice.int x 1 -1 1) zip_pos_2) -3)) 7488 24586))) (ite (or (= (list.get.int x zip...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:139.212: Symbol 'zip_pos_0' not declared as a variable")

Could not find any solution for puzzle OptimalBridges:4
Too many constants for extrapolation

Solving puzzle 636/732: NoRelativePrimes:0
sat_func def sat(nums: List[int], b=7, m=6):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
modified_func def sat(nums: List[int], b=wrap_int(7), m=wrap_int(6)):
    _assert((sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == m).__and__(min(nums) >= wrap_int(0)))

    def gcd(i, j):
        r, s = (max(i, j), min(i, j))
        while s >= wrap_int(1):
            r, s = (s, r % s)
        return r
    for a in nums:
        nums = [(a + i + wrap_int(1)) ** wrap_int(2) + (a + i + wrap_int(1)) + wrap_int(1) for i in sym_range(b)]
        _assert(all(sym_generator((any(sym_generator(((i != j).__and__(gcd(i, j) > wrap_int(1)) for j in nums))) for i in nums))))
    return True
Timed out for puzzle NoRelativePrimes:0

Solving puzzle 637/732: NoRelativePrimes:1
sat_func def sat(nums: List[int], b=7, m=26):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
modified_func def sat(nums: List[int], b=wrap_int(7), m=wrap_int(26)):
    _assert((sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == m).__and__(min(nums) >= wrap_int(0)))

    def gcd(i, j):
        r, s = (max(i, j), min(i, j))
        while s >= wrap_int(1):
            r, s = (s, r % s)
        return r
    for a in nums:
        nums = [(a + i + wrap_int(1)) ** wrap_int(2) + (a + i + wrap_int(1)) + wrap_int(1) for i in sym_range(b)]
        _assert(all(sym_generator((any(sym_generator(((i != j).__and__(gcd(i, j) > wrap_int(1)) for j in nums))) for i in nums))))
    return True
Timed out for puzzle NoRelativePrimes:1

Solving puzzle 638/732: NoRelativePrimes:2
sat_func def sat(nums: List[int], b=6, m=73):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
modified_func def sat(nums: List[int], b=wrap_int(6), m=wrap_int(73)):
    _assert((sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == m).__and__(min(nums) >= wrap_int(0)))

    def gcd(i, j):
        r, s = (max(i, j), min(i, j))
        while s >= wrap_int(1):
            r, s = (s, r % s)
        return r
    for a in nums:
        nums = [(a + i + wrap_int(1)) ** wrap_int(2) + (a + i + wrap_int(1)) + wrap_int(1) for i in sym_range(b)]
        _assert(all(sym_generator((any(sym_generator(((i != j).__and__(gcd(i, j) > wrap_int(1)) for j in nums))) for i in nums))))
    return True
Timed out for puzzle NoRelativePrimes:2

Solving puzzle 639/732: NoRelativePrimes:3
sat_func def sat(nums: List[int], b=17, m=37):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
modified_func def sat(nums: List[int], b=wrap_int(17), m=wrap_int(37)):
    _assert((sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == m).__and__(min(nums) >= wrap_int(0)))

    def gcd(i, j):
        r, s = (max(i, j), min(i, j))
        while s >= wrap_int(1):
            r, s = (s, r % s)
        return r
    for a in nums:
        nums = [(a + i + wrap_int(1)) ** wrap_int(2) + (a + i + wrap_int(1)) + wrap_int(1) for i in sym_range(b)]
        _assert(all(sym_generator((any(sym_generator(((i != j).__and__(gcd(i, j) > wrap_int(1)) for j in nums))) for i in nums))))
    return True
Timed out for puzzle NoRelativePrimes:3

Solving puzzle 640/732: NoRelativePrimes:4
sat_func def sat(nums: List[int], b=7, m=92):
    assert len(nums) == len(set(nums)) == m and min(nums) >= 0

    def gcd(i, j):
        r, s = max(i, j), min(i, j)
        while s >= 1:
            r, s = s, (r % s)
        return r

    for a in nums:
        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]
        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)

    return True
modified_func def sat(nums: List[int], b=wrap_int(7), m=wrap_int(92)):
    _assert((sym_len(nums) == sym_len(set(nums))).__and__(sym_len(set(nums)) == m).__and__(min(nums) >= wrap_int(0)))

    def gcd(i, j):
        r, s = (max(i, j), min(i, j))
        while s >= wrap_int(1):
            r, s = (s, r % s)
        return r
    for a in nums:
        nums = [(a + i + wrap_int(1)) ** wrap_int(2) + (a + i + wrap_int(1)) + wrap_int(1) for i in sym_range(b)]
        _assert(all(sym_generator((any(sym_generator(((i != j).__and__(gcd(i, j) > wrap_int(1)) for j in nums))) for i in nums))))
    return True
Timed out for puzzle NoRelativePrimes:4

Solving puzzle 641/732: FindRepeats:0
sat_func def sat(indices: List[int], a0=123):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
modified_func def sat(indices: List[int], a0=wrap_int(123)):
    _assert((a0 >= wrap_int(0)).__and__(a0 % wrap_int(3) == wrap_int(0)), wrap_str('Hint: a_0 is a multiple of 3.'))
    s = wrap_list([a0])
    for i in sym_range(max(indices)):
        s.append(sym_int(s[-wrap_int(1)] ** 0.5) if sym_int(s[-wrap_int(1)] ** 0.5) ** wrap_int(2) == s[-wrap_int(1)] else s[-wrap_int(1)] + wrap_int(3))
    return (sym_len(indices) == sym_len(set(indices))).__and__(sym_len(set(indices)) == wrap_int(1000)).__and__(min(indices) >= wrap_int(0)).__and__(sym_len({s[i] for i in indices}) == wrap_int(1))
Exception -- for puzzle FindRepeats:0 'SymbolicList' object has no attribute 'append'

Solving puzzle 642/732: FindRepeats:1
sat_func def sat(indices: List[int], a0=2827347):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
modified_func def sat(indices: List[int], a0=wrap_int(2827347)):
    _assert((a0 >= wrap_int(0)).__and__(a0 % wrap_int(3) == wrap_int(0)), wrap_str('Hint: a_0 is a multiple of 3.'))
    s = wrap_list([a0])
    for i in sym_range(max(indices)):
        s.append(sym_int(s[-wrap_int(1)] ** 0.5) if sym_int(s[-wrap_int(1)] ** 0.5) ** wrap_int(2) == s[-wrap_int(1)] else s[-wrap_int(1)] + wrap_int(3))
    return (sym_len(indices) == sym_len(set(indices))).__and__(sym_len(set(indices)) == wrap_int(1000)).__and__(min(indices) >= wrap_int(0)).__and__(sym_len({s[i] for i in indices}) == wrap_int(1))
Exception -- for puzzle FindRepeats:1 'SymbolicList' object has no attribute 'append'

Solving puzzle 643/732: FindRepeats:2
sat_func def sat(indices: List[int], a0=2362263):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
modified_func def sat(indices: List[int], a0=wrap_int(2362263)):
    _assert((a0 >= wrap_int(0)).__and__(a0 % wrap_int(3) == wrap_int(0)), wrap_str('Hint: a_0 is a multiple of 3.'))
    s = wrap_list([a0])
    for i in sym_range(max(indices)):
        s.append(sym_int(s[-wrap_int(1)] ** 0.5) if sym_int(s[-wrap_int(1)] ** 0.5) ** wrap_int(2) == s[-wrap_int(1)] else s[-wrap_int(1)] + wrap_int(3))
    return (sym_len(indices) == sym_len(set(indices))).__and__(sym_len(set(indices)) == wrap_int(1000)).__and__(min(indices) >= wrap_int(0)).__and__(sym_len({s[i] for i in indices}) == wrap_int(1))
Exception -- for puzzle FindRepeats:2 'SymbolicList' object has no attribute 'append'

Solving puzzle 644/732: FindRepeats:3
sat_func def sat(indices: List[int], a0=1703235):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
modified_func def sat(indices: List[int], a0=wrap_int(1703235)):
    _assert((a0 >= wrap_int(0)).__and__(a0 % wrap_int(3) == wrap_int(0)), wrap_str('Hint: a_0 is a multiple of 3.'))
    s = wrap_list([a0])
    for i in sym_range(max(indices)):
        s.append(sym_int(s[-wrap_int(1)] ** 0.5) if sym_int(s[-wrap_int(1)] ** 0.5) ** wrap_int(2) == s[-wrap_int(1)] else s[-wrap_int(1)] + wrap_int(3))
    return (sym_len(indices) == sym_len(set(indices))).__and__(sym_len(set(indices)) == wrap_int(1000)).__and__(min(indices) >= wrap_int(0)).__and__(sym_len({s[i] for i in indices}) == wrap_int(1))
Exception -- for puzzle FindRepeats:3 'SymbolicList' object has no attribute 'append'

Solving puzzle 645/732: FindRepeats:4
sat_func def sat(indices: List[int], a0=962856):
    assert a0 >= 0 and a0 % 3 == 0, "Hint: a_0 is a multiple of 3."
    s = [a0]
    for i in range(max(indices)):
        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)
    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1
modified_func def sat(indices: List[int], a0=wrap_int(962856)):
    _assert((a0 >= wrap_int(0)).__and__(a0 % wrap_int(3) == wrap_int(0)), wrap_str('Hint: a_0 is a multiple of 3.'))
    s = wrap_list([a0])
    for i in sym_range(max(indices)):
        s.append(sym_int(s[-wrap_int(1)] ** 0.5) if sym_int(s[-wrap_int(1)] ** 0.5) ** wrap_int(2) == s[-wrap_int(1)] else s[-wrap_int(1)] + wrap_int(3))
    return (sym_len(indices) == sym_len(set(indices))).__and__(sym_len(set(indices)) == wrap_int(1000)).__and__(min(indices) >= wrap_int(0)).__and__(sym_len({s[i] for i in indices}) == wrap_int(1))
Exception -- for puzzle FindRepeats:4 'SymbolicList' object has no attribute 'append'

Solving puzzle 646/732: FindProductiveList:0
sat_func def sat(li: List[int], n=18):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
modified_func def sat(li: List[int], n=wrap_int(18)):
    _assert(n % wrap_int(3) == wrap_int(0), wrap_str('Hint: n is a multiple of 3'))
    return (sym_len(li) == n).__and__(all(sym_generator((li[(i + wrap_int(2)) % n] == wrap_int(1) + li[(i + wrap_int(1)) % n] * li[i] for i in sym_range(n)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert true)
(assert (and (= (list.length.int x) 18) (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (list.get.int x 2) (+ 1 (* (list.get.int x 1) (list.get.int x 0)))) (= (list.get.int x 3) (+ 1 (* (list.get.int x 2) (list.get.int x 1))))) (= (list.get.int x 4) (+ 1 (* (list.get.int x 3) (list.get.int x 2))))) (= (list.get.int x 5) (+ 1 (* (list.get.int x 4) (list.get.int x 3))))) (= (list.get.int x 6) (+ 1 (* (list.get.int x 5) (list.get.int x 4))))) (= (list.get.int x 7) (+ 1 (* (list.get.int x 6) (list.get.int x 5))))) (= (list.get.int x 8) (+ 1 (* (list.get.int x 7) (list.get.int x 6))))) (= (list.get.int x 9) (+ 1 (* (list.get.int x 8) (list.get.int x 7))))) (= (list.get.int x 10) (+ 1 (* (list.get.int x 9) (list.get.int x 8))))) (= (list.get.int x 11) (+ 1 (* (list.get.int x 10) (list.get.int x 9))))) (= (list.get.int x 12) (+ 1 (* (list.get.int x 11) (list.get.int x 10))))) (= (list.get.int x 13) (+ 1 (* (list.get.int x 12) (list.get.int x 11))))) (= ...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FindProductiveList:0
Too many constants for extrapolation

Solving puzzle 647/732: FindProductiveList:1
sat_func def sat(li: List[int], n=3):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
modified_func def sat(li: List[int], n=wrap_int(3)):
    _assert(n % wrap_int(3) == wrap_int(0), wrap_str('Hint: n is a multiple of 3'))
    return (sym_len(li) == n).__and__(all(sym_generator((li[(i + wrap_int(2)) % n] == wrap_int(1) + li[(i + wrap_int(1)) % n] * li[i] for i in sym_range(n)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert true)
(assert (and (= (list.length.int x) 3) (and (and (= (list.get.int x 2) (+ 1 (* (list.get.int x 1) (list.get.int x 0)))) (= (list.get.int x 0) (+ 1 (* (list.get.int x 2) (list.get.int x 1))))) (= (list.get.int x 1) (+ 1 (* (list.get.int x 0) (list.get.int x 2)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 2 ((as cons (List Int)) (- 1) ((as cons (List Int)) (- 1) (as nil (List Int))))))
)

Found solution [2, -1, -1]
Yes! Solved for puzzle  FindProductiveList:1

Solving puzzle 648/732: FindProductiveList:2
sat_func def sat(li: List[int], n=6):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
modified_func def sat(li: List[int], n=wrap_int(6)):
    _assert(n % wrap_int(3) == wrap_int(0), wrap_str('Hint: n is a multiple of 3'))
    return (sym_len(li) == n).__and__(all(sym_generator((li[(i + wrap_int(2)) % n] == wrap_int(1) + li[(i + wrap_int(1)) % n] * li[i] for i in sym_range(n)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert true)
(assert (and (= (list.length.int x) 6) (and (and (and (and (and (= (list.get.int x 2) (+ 1 (* (list.get.int x 1) (list.get.int x 0)))) (= (list.get.int x 3) (+ 1 (* (list.get.int x 2) (list.get.int x 1))))) (= (list.get.int x 4) (+ 1 (* (list.get.int x 3) (list.get.int x 2))))) (= (list.get.int x 5) (+ 1 (* (list.get.int x 4) (list.get.int x 3))))) (= (list.get.int x 0) (+ 1 (* (list.get.int x 5) (list.get.int x 4))))) (= (list.get.int x 1) (+ 1 (* (list.get.int x 0) (list.get.int x 5)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 2 ((as cons (List Int)) (- 1) ((as cons (List Int)) (- 1) ((as cons (List Int)) 2 ((as cons (List Int)) (- 1) ((as cons (List Int)) (- 1) (as nil (List Int)))))))))
)

Found solution [2, -1, -1, 2, -1, -1]
Yes! Solved for puzzle  FindProductiveList:2

Solving puzzle 649/732: FindProductiveList:3
sat_func def sat(li: List[int], n=9):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
modified_func def sat(li: List[int], n=wrap_int(9)):
    _assert(n % wrap_int(3) == wrap_int(0), wrap_str('Hint: n is a multiple of 3'))
    return (sym_len(li) == n).__and__(all(sym_generator((li[(i + wrap_int(2)) % n] == wrap_int(1) + li[(i + wrap_int(1)) % n] * li[i] for i in sym_range(n)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert true)
(assert (and (= (list.length.int x) 9) (and (and (and (and (and (and (and (and (= (list.get.int x 2) (+ 1 (* (list.get.int x 1) (list.get.int x 0)))) (= (list.get.int x 3) (+ 1 (* (list.get.int x 2) (list.get.int x 1))))) (= (list.get.int x 4) (+ 1 (* (list.get.int x 3) (list.get.int x 2))))) (= (list.get.int x 5) (+ 1 (* (list.get.int x 4) (list.get.int x 3))))) (= (list.get.int x 6) (+ 1 (* (list.get.int x 5) (list.get.int x 4))))) (= (list.get.int x 7) (+ 1 (* (list.get.int x 6) (list.get.int x 5))))) (= (list.get.int x 8) (+ 1 (* (list.get.int x 7) (list.get.int x 6))))) (= (list.get.int x 0) (+ 1 (* (list.get.int x 8) (list.get.int x 7))))) (= (list.get.int x 1) (+ 1 (* (list.get.int x 0) (list.get.int x 8)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FindProductiveList:3
Too many constants for extrapolation

Solving puzzle 650/732: FindProductiveList:4
sat_func def sat(li: List[int], n=12):
    assert n % 3 == 0, "Hint: n is a multiple of 3"
    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))
modified_func def sat(li: List[int], n=wrap_int(12)):
    _assert(n % wrap_int(3) == wrap_int(0), wrap_str('Hint: n is a multiple of 3'))
    return (sym_len(li) == n).__and__(all(sym_generator((li[(i + wrap_int(2)) % n] == wrap_int(1) + li[(i + wrap_int(1)) % n] * li[i] for i in sym_range(n)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert true)
(assert (and (= (list.length.int x) 12) (and (and (and (and (and (and (and (and (and (and (and (= (list.get.int x 2) (+ 1 (* (list.get.int x 1) (list.get.int x 0)))) (= (list.get.int x 3) (+ 1 (* (list.get.int x 2) (list.get.int x 1))))) (= (list.get.int x 4) (+ 1 (* (list.get.int x 3) (list.get.int x 2))))) (= (list.get.int x 5) (+ 1 (* (list.get.int x 4) (list.get.int x 3))))) (= (list.get.int x 6) (+ 1 (* (list.get.int x 5) (list.get.int x 4))))) (= (list.get.int x 7) (+ 1 (* (list.get.int x 6) (list.get.int x 5))))) (= (list.get.int x 8) (+ 1 (* (list.get.int x 7) (list.get.int x 6))))) (= (list.get.int x 9) (+ 1 (* (list.get.int x 8) (list.get.int x 7))))) (= (list.get.int x 10) (+ 1 (* (list.get.int x 9) (list.get.int x 8))))) (= (list.get.int x 11) (+ 1 (* (list.get.int x 10) (list.get.int x 9))))) (= (list.get.int x 0) (+ 1 (* (list.get.int x 11) (list.get.int x 10))))) (= (list.get.int x 1) (+ 1 (* (list.get.int x 0) (list.get.int x 11)))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle FindProductiveList:4
Too many constants for extrapolation

Solving puzzle 651/732: HalfTag:0
sat_func def sat(li: List[int], tags=[3, 0, 3, 2, 0, 1, 0, 3, 1, 1, 2, 2, 0, 2, 1, 3]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
modified_func def sat(li: List[int], tags=wrap_list([wrap_int(3), wrap_int(0), wrap_int(3), wrap_int(2), wrap_int(0), wrap_int(1), wrap_int(0), wrap_int(3), wrap_int(1), wrap_int(1), wrap_int(2), wrap_int(2), wrap_int(0), wrap_int(2), wrap_int(1), wrap_int(3)])):
    n = max(tags) + wrap_int(1)
    _assert(sym_sorted(tags) == sym_sorted(list(sym_range(n)) * wrap_int(4)), wrap_str('hint: each tag occurs exactly four times'))
    _assert((sym_len(li) == sym_len(set(li))).__and__(min(li) >= wrap_int(0)))
    return (sym_sum(li) * wrap_int(2) == sym_sum(sym_range(4 * n))).__and__(sym_sorted([tags[i] for i in li]) == [i // wrap_int(2) for i in sym_range(2 * n)])
Exception -- for puzzle HalfTag:0 'list' object has no attribute 'concrete'

Solving puzzle 652/732: HalfTag:1
sat_func def sat(li: List[int], tags=[2, 3, 1, 0, 3, 3, 0, 2, 1, 3, 1, 0, 1, 2, 2, 0]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
modified_func def sat(li: List[int], tags=wrap_list([wrap_int(2), wrap_int(3), wrap_int(1), wrap_int(0), wrap_int(3), wrap_int(3), wrap_int(0), wrap_int(2), wrap_int(1), wrap_int(3), wrap_int(1), wrap_int(0), wrap_int(1), wrap_int(2), wrap_int(2), wrap_int(0)])):
    n = max(tags) + wrap_int(1)
    _assert(sym_sorted(tags) == sym_sorted(list(sym_range(n)) * wrap_int(4)), wrap_str('hint: each tag occurs exactly four times'))
    _assert((sym_len(li) == sym_len(set(li))).__and__(min(li) >= wrap_int(0)))
    return (sym_sum(li) * wrap_int(2) == sym_sum(sym_range(4 * n))).__and__(sym_sorted([tags[i] for i in li]) == [i // wrap_int(2) for i in sym_range(2 * n)])
Exception -- for puzzle HalfTag:1 'list' object has no attribute 'concrete'

Solving puzzle 653/732: HalfTag:2
sat_func def sat(li: List[int], tags=[4, 1, 6, 5, 6, 4, 2, 1, 6, 2, 3, 1, 4, 6, 5, 2, 3, 5, 0, 5, 0, 3, 0, 0, 4, 2, 3, 1]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
modified_func def sat(li: List[int], tags=wrap_list([wrap_int(4), wrap_int(1), wrap_int(6), wrap_int(5), wrap_int(6), wrap_int(4), wrap_int(2), wrap_int(1), wrap_int(6), wrap_int(2), wrap_int(3), wrap_int(1), wrap_int(4), wrap_int(6), wrap_int(5), wrap_int(2), wrap_int(3), wrap_int(5), wrap_int(0), wrap_int(5), wrap_int(0), wrap_int(3), wrap_int(0), wrap_int(0), wrap_int(4), wrap_int(2), wrap_int(3), wrap_int(1)])):
    n = max(tags) + wrap_int(1)
    _assert(sym_sorted(tags) == sym_sorted(list(sym_range(n)) * wrap_int(4)), wrap_str('hint: each tag occurs exactly four times'))
    _assert((sym_len(li) == sym_len(set(li))).__and__(min(li) >= wrap_int(0)))
    return (sym_sum(li) * wrap_int(2) == sym_sum(sym_range(4 * n))).__and__(sym_sorted([tags[i] for i in li]) == [i // wrap_int(2) for i in sym_range(2 * n)])
Exception -- for puzzle HalfTag:2 'list' object has no attribute 'concrete'

Solving puzzle 654/732: HalfTag:3
sat_func def sat(li: List[int], tags=[0, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 2]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
modified_func def sat(li: List[int], tags=wrap_list([wrap_int(0), wrap_int(2), wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(1), wrap_int(2), wrap_int(2), wrap_int(0), wrap_int(0), wrap_int(0), wrap_int(2)])):
    n = max(tags) + wrap_int(1)
    _assert(sym_sorted(tags) == sym_sorted(list(sym_range(n)) * wrap_int(4)), wrap_str('hint: each tag occurs exactly four times'))
    _assert((sym_len(li) == sym_len(set(li))).__and__(min(li) >= wrap_int(0)))
    return (sym_sum(li) * wrap_int(2) == sym_sum(sym_range(4 * n))).__and__(sym_sorted([tags[i] for i in li]) == [i // wrap_int(2) for i in sym_range(2 * n)])
Exception -- for puzzle HalfTag:3 'list' object has no attribute 'concrete'

Solving puzzle 655/732: HalfTag:4
sat_func def sat(li: List[int], tags=[1, 2, 6, 0, 6, 2, 4, 7, 4, 0, 0, 5, 0, 3, 2, 1, 7, 5, 5, 3, 1, 7, 2, 7, 6, 6, 3, 3, 1, 4, 4, 5]):
    n = max(tags) + 1
    assert sorted(tags) == sorted(list(range(n)) * 4), "hint: each tag occurs exactly four times"
    assert len(li) == len(set(li)) and min(li) >= 0
    return sum(li) * 2 == sum(range(4 * n)) and sorted([tags[i] for i in li]) == [i // 2 for i in range(2 * n)]
modified_func def sat(li: List[int], tags=wrap_list([wrap_int(1), wrap_int(2), wrap_int(6), wrap_int(0), wrap_int(6), wrap_int(2), wrap_int(4), wrap_int(7), wrap_int(4), wrap_int(0), wrap_int(0), wrap_int(5), wrap_int(0), wrap_int(3), wrap_int(2), wrap_int(1), wrap_int(7), wrap_int(5), wrap_int(5), wrap_int(3), wrap_int(1), wrap_int(7), wrap_int(2), wrap_int(7), wrap_int(6), wrap_int(6), wrap_int(3), wrap_int(3), wrap_int(1), wrap_int(4), wrap_int(4), wrap_int(5)])):
    n = max(tags) + wrap_int(1)
    _assert(sym_sorted(tags) == sym_sorted(list(sym_range(n)) * wrap_int(4)), wrap_str('hint: each tag occurs exactly four times'))
    _assert((sym_len(li) == sym_len(set(li))).__and__(min(li) >= wrap_int(0)))
    return (sym_sum(li) * wrap_int(2) == sym_sum(sym_range(4 * n))).__and__(sym_sorted([tags[i] for i in li]) == [i // wrap_int(2) for i in sym_range(2 * n)])
Exception -- for puzzle HalfTag:4 'list' object has no attribute 'concrete'

Solving puzzle 656/732: LearnParity:0
sat_func def sat(inds: List[int], vecs=[169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(169), wrap_int(203), wrap_int(409), wrap_int(50), wrap_int(37), wrap_int(479), wrap_int(370), wrap_int(133), wrap_int(53), wrap_int(159), wrap_int(161), wrap_int(367), wrap_int(474), wrap_int(107), wrap_int(82), wrap_int(447), wrap_int(385)])):
    return all(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) == wrap_int(1) for v in vecs)))
Exception -- for puzzle LearnParity:0 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 657/732: LearnParity:1
sat_func def sat(inds: List[int], vecs=[1958328232218124020, 1643963198527225549, 7078739564566717736, 5024292785179305436, 7542959674027422755, 7659875763009862123, 1092205956673651924, 1597643013927748621, 8004819259007286467, 4932826233956818838, 6008121031475439847, 8573976126290476773, 5118247667071056636, 2694646426329419247, 7155733006249399377, 5712876295003741481, 4259768476395554763, 1716249993608899326, 4687736672428229301, 6210681778471018663, 9062452952374764930, 3938723877971063326, 1992502139321214948, 583369363030182394, 3457048586868388189, 3089092548449370843, 8968870310908511767, 5874530422138404750, 7922800580005142654, 6443496666193763033, 6602916053749454337, 5035040733581952127, 2475911752718112891, 4473209659299430662, 7743622118433343293, 8456447367870793728, 644758190253851892, 854623538268336285, 4412207913445082380, 1836729508450597237, 8168398572945385599, 8115567202327609458, 6194127909595936682, 5497664877254277127, 3302554889776464399, 169133116278786893, 6157732824159736422, 6607461935760996261, 2653530464165680377, 6097504979385382936, 7193369373130246620, 5417605562101462110, 6648984412934108645, 8700023834459359946, 1861165113396388865, 2257883046437023829, 9079372065509233820, 68562947383617624, 3628292069813906054, 5937308782381616795, 7333187108059679183, 3810197266775096468, 6798325309591425591, 4704339148457093019, 7860858474470684593, 1611780128804878195, 8654679384628229346, 8183430433492711995, 6645671523533669548, 8558081500613788587, 7159783655071677682, 812798558819423092]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(1958328232218124020), wrap_int(1643963198527225549), wrap_int(7078739564566717736), wrap_int(5024292785179305436), wrap_int(7542959674027422755), wrap_int(7659875763009862123), wrap_int(1092205956673651924), wrap_int(1597643013927748621), wrap_int(8004819259007286467), wrap_int(4932826233956818838), wrap_int(6008121031475439847), wrap_int(8573976126290476773), wrap_int(5118247667071056636), wrap_int(2694646426329419247), wrap_int(7155733006249399377), wrap_int(5712876295003741481), wrap_int(4259768476395554763), wrap_int(1716249993608899326), wrap_int(4687736672428229301), wrap_int(6210681778471018663), wrap_int(9062452952374764930), wrap_int(3938723877971063326), wrap_int(1992502139321214948), wrap_int(583369363030182394), wrap_int(3457048586868388189), wrap_int(3089092548449370843), wrap_int(8968870310908511767), wrap_int(5874530422138404750), wrap_int(7922800580005142654), wrap_int(6443496666193763033), wrap_int(6602916053749454337), wrap_int(5035040733581952127), wrap_int(2475911752718112891), wrap_int(4473209659299430662), wrap_int(7743622118433343293), wrap_int(8456447367870793728), wrap_int(644758190253851892), wrap_int(854623538268336285), wrap_int(4412207913445082380), wrap_int(1836729508450597237), wrap_int(8168398572945385599), wrap_int(8115567202327609458), wrap_int(6194127909595936682), wrap_int(5497664877254277127), wrap_int(3302554889776464399), wrap_int(169133116278786893), wrap_int(6157732824159736422), wrap_int(6607461935760996261), wrap_int(2653530464165680377), wrap_int(6097504979385382936), wrap_int(7193369373130246620), wrap_int(5417605562101462110), wrap_int(6648984412934108645), wrap_int(8700023834459359946), wrap_int(1861165113396388865), wrap_int(2257883046437023829), wrap_int(9079372065509233820), wrap_int(68562947383617624), wrap_int(3628292069813906054), wrap_int(5937308782381616795), wrap_int(7333187108059679183), wrap_int(3810197266775096468), wrap_int(6798325309591425591), wrap_int(4704339148457093019), wrap_int(7860858474470684593), wrap_int(1611780128804878195), wrap_int(8654679384628229346), wrap_int(8183430433492711995), wrap_int(6645671523533669548), wrap_int(8558081500613788587), wrap_int(7159783655071677682), wrap_int(812798558819423092)])):
    return all(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) == wrap_int(1) for v in vecs)))
Exception -- for puzzle LearnParity:1 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 658/732: LearnParity:2
sat_func def sat(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(22), wrap_int(30), wrap_int(1), wrap_int(28), wrap_int(28), wrap_int(12), wrap_int(20), wrap_int(28), wrap_int(6), wrap_int(14), wrap_int(14), wrap_int(6), wrap_int(1), wrap_int(12)])):
    return all(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) == wrap_int(1) for v in vecs)))
Exception -- for puzzle LearnParity:2 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 659/732: LearnParity:3
sat_func def sat(inds: List[int], vecs=[5, 6, 9, 55, 6, 31, 6, 16, 24, 41, 48, 28, 52, 23, 27]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(5), wrap_int(6), wrap_int(9), wrap_int(55), wrap_int(6), wrap_int(31), wrap_int(6), wrap_int(16), wrap_int(24), wrap_int(41), wrap_int(48), wrap_int(28), wrap_int(52), wrap_int(23), wrap_int(27)])):
    return all(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) == wrap_int(1) for v in vecs)))
Exception -- for puzzle LearnParity:3 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 660/732: LearnParity:4
sat_func def sat(inds: List[int], vecs=[8516734225993, 8185100182945, 925681191808, 6852758827443, 1647526447482, 7173415494645, 7272627207575, 490684374058, 309453951198, 5010777449329, 3573909388048, 5418552144685, 2354966949738, 3516400490509, 1958065498191, 4517527902759, 8040889847030, 5932888153522, 1902421695527, 1024437640956, 929625005771, 7393117046567, 5563161916036, 217261697321, 6156537114007, 2387336255324, 2725651274113, 8047481621773, 6241870535779, 6997209576680, 7206687196929, 7040183664174, 5422186929747, 8413033840571, 8315880876934, 3242378478727, 7554967308490, 3436019794305, 2038166434726, 276174723638, 4876351900994, 2206273239244, 6687501613941, 6284647259481, 4489528628587, 2300167942640, 1193551771601, 5445384214694, 4685093545143, 1178537925748, 8564249470306, 6913390362890]):
    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(8516734225993), wrap_int(8185100182945), wrap_int(925681191808), wrap_int(6852758827443), wrap_int(1647526447482), wrap_int(7173415494645), wrap_int(7272627207575), wrap_int(490684374058), wrap_int(309453951198), wrap_int(5010777449329), wrap_int(3573909388048), wrap_int(5418552144685), wrap_int(2354966949738), wrap_int(3516400490509), wrap_int(1958065498191), wrap_int(4517527902759), wrap_int(8040889847030), wrap_int(5932888153522), wrap_int(1902421695527), wrap_int(1024437640956), wrap_int(929625005771), wrap_int(7393117046567), wrap_int(5563161916036), wrap_int(217261697321), wrap_int(6156537114007), wrap_int(2387336255324), wrap_int(2725651274113), wrap_int(8047481621773), wrap_int(6241870535779), wrap_int(6997209576680), wrap_int(7206687196929), wrap_int(7040183664174), wrap_int(5422186929747), wrap_int(8413033840571), wrap_int(8315880876934), wrap_int(3242378478727), wrap_int(7554967308490), wrap_int(3436019794305), wrap_int(2038166434726), wrap_int(276174723638), wrap_int(4876351900994), wrap_int(2206273239244), wrap_int(6687501613941), wrap_int(6284647259481), wrap_int(4489528628587), wrap_int(2300167942640), wrap_int(1193551771601), wrap_int(5445384214694), wrap_int(4685093545143), wrap_int(1178537925748), wrap_int(8564249470306), wrap_int(6913390362890)])):
    return all(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) == wrap_int(1) for v in vecs)))
Exception -- for puzzle LearnParity:4 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 661/732: LearnParityWithNoise:0
sat_func def sat(inds: List[int], vecs=[26, 5, 32, 3, 15, 18, 31, 13, 24, 25, 34, 5, 15, 24, 16, 13, 0, 27, 37]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(26), wrap_int(5), wrap_int(32), wrap_int(3), wrap_int(15), wrap_int(18), wrap_int(31), wrap_int(13), wrap_int(24), wrap_int(25), wrap_int(34), wrap_int(5), wrap_int(15), wrap_int(24), wrap_int(16), wrap_int(13), wrap_int(0), wrap_int(27), wrap_int(37)])):
    return sym_sum(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) for v in vecs))) >= sym_len(vecs) * wrap_int(3) / wrap_int(4)
Exception -- for puzzle LearnParityWithNoise:0 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 662/732: LearnParityWithNoise:1
sat_func def sat(inds: List[int], vecs=[3026078031409368634, 7146400157417466997, 5230715399550451735, 5711439032267145442, 7548327835869100414, 6708827919346401215, 3738394021903457634, 8572217357536520619, 2068990701252216912, 2527297846676040375, 8268732787978254795, 61203570143025212, 7342810871883169101, 5130109338028331308, 7559050022362805022, 4688300453824606274, 6132540541907873970, 4336830827866175311, 4658177358737495247, 5084071062462878715, 189501720066641238, 8940114256708424722, 5113924146720829221, 4787179834139114336, 4911869756119486218, 8254870450128749041, 4438177035195637074, 5842829643884011320, 4053162460261950208, 2418313591679938260, 3183962173259338720, 5424349679395645015, 8721363683850881601, 4309489519137374818, 4668810188571429750, 1619719991930582198, 7466888377266384808, 9012877516210312432, 5806707934012633661, 4901689063540216433, 5129789419720858519, 5461292526835029654, 8002292066627476387, 22896265023092245, 6377528370731564059, 8326396311104510171, 6275763356808207618, 5855722006919947060, 5284812396814908585, 4183862905187398029, 961125315693824082, 3066435959716339320, 4359457050975539676, 3745610113055211253, 5616892323431402644, 2423996313938618029, 3342319460472332063, 4574429521762476750, 530929890003939982, 6518361635319838485, 4705876417632921613, 8702130161668730198, 7903182592921575528, 141670616557704814, 6302770439830462635, 8261043567365748099, 438838480425402424, 5938030420618506624, 6388919631545923446, 6289510808724564483, 6268010263591290952, 14114260020922590, 7967256030154091406, 7834360030773781051, 7195168470041102120, 2144111587187695127, 4188284497153593189, 7490392562013822833, 2395367579472417027, 1234942756280497811, 149618691938860164, 7115847656533661705, 2829618956277039440, 2931490206384957203, 6476287337767581762, 945977554281930779, 8036974190540567032, 5620546732979542987, 7534852936547208732, 3612963124933737363, 3304259407192763500, 6531357621325258614, 2061695547096959296, 3891046108540743566, 3659303839675510400, 2840571068268977729, 6021300208671005128, 5523531622352728473, 3164481775218709281, 1433373373144701739, 5040760773694741353, 8699918547789986541, 9211723439219092053, 3601466436760036882, 7470213384180375061, 1117614654415514338, 6489709663619239074, 5606821764793080769, 5533040684385323261, 1663669870068057261, 117658820550690687, 5802967177524872313, 824677791803551085, 8130960541536503068, 7941328653734718836, 3551730520657107195, 3183297803310667173, 1744452363855034208, 2206249608643212372, 6805671707252313743, 3765414947444962371, 6871722428624542946, 5429903326499666841, 9118768768355899725, 2775018401536039120, 2838922854846376990, 3633686101842554817, 7756171914139767657, 1797750566355726798, 1145745704236160436, 7192058872525801155]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(3026078031409368634), wrap_int(7146400157417466997), wrap_int(5230715399550451735), wrap_int(5711439032267145442), wrap_int(7548327835869100414), wrap_int(6708827919346401215), wrap_int(3738394021903457634), wrap_int(8572217357536520619), wrap_int(2068990701252216912), wrap_int(2527297846676040375), wrap_int(8268732787978254795), wrap_int(61203570143025212), wrap_int(7342810871883169101), wrap_int(5130109338028331308), wrap_int(7559050022362805022), wrap_int(4688300453824606274), wrap_int(6132540541907873970), wrap_int(4336830827866175311), wrap_int(4658177358737495247), wrap_int(5084071062462878715), wrap_int(189501720066641238), wrap_int(8940114256708424722), wrap_int(5113924146720829221), wrap_int(4787179834139114336), wrap_int(4911869756119486218), wrap_int(8254870450128749041), wrap_int(4438177035195637074), wrap_int(5842829643884011320), wrap_int(4053162460261950208), wrap_int(2418313591679938260), wrap_int(3183962173259338720), wrap_int(5424349679395645015), wrap_int(8721363683850881601), wrap_int(4309489519137374818), wrap_int(4668810188571429750), wrap_int(1619719991930582198), wrap_int(7466888377266384808), wrap_int(9012877516210312432), wrap_int(5806707934012633661), wrap_int(4901689063540216433), wrap_int(5129789419720858519), wrap_int(5461292526835029654), wrap_int(8002292066627476387), wrap_int(22896265023092245), wrap_int(6377528370731564059), wrap_int(8326396311104510171), wrap_int(6275763356808207618), wrap_int(5855722006919947060), wrap_int(5284812396814908585), wrap_int(4183862905187398029), wrap_int(961125315693824082), wrap_int(3066435959716339320), wrap_int(4359457050975539676), wrap_int(3745610113055211253), wrap_int(5616892323431402644), wrap_int(2423996313938618029), wrap_int(3342319460472332063), wrap_int(4574429521762476750), wrap_int(530929890003939982), wrap_int(6518361635319838485), wrap_int(4705876417632921613), wrap_int(8702130161668730198), wrap_int(7903182592921575528), wrap_int(141670616557704814), wrap_int(6302770439830462635), wrap_int(8261043567365748099), wrap_int(438838480425402424), wrap_int(5938030420618506624), wrap_int(6388919631545923446), wrap_int(6289510808724564483), wrap_int(6268010263591290952), wrap_int(14114260020922590), wrap_int(7967256030154091406), wrap_int(7834360030773781051), wrap_int(7195168470041102120), wrap_int(2144111587187695127), wrap_int(4188284497153593189), wrap_int(7490392562013822833), wrap_int(2395367579472417027), wrap_int(1234942756280497811), wrap_int(149618691938860164), wrap_int(7115847656533661705), wrap_int(2829618956277039440), wrap_int(2931490206384957203), wrap_int(6476287337767581762), wrap_int(945977554281930779), wrap_int(8036974190540567032), wrap_int(5620546732979542987), wrap_int(7534852936547208732), wrap_int(3612963124933737363), wrap_int(3304259407192763500), wrap_int(6531357621325258614), wrap_int(2061695547096959296), wrap_int(3891046108540743566), wrap_int(3659303839675510400), wrap_int(2840571068268977729), wrap_int(6021300208671005128), wrap_int(5523531622352728473), wrap_int(3164481775218709281), wrap_int(1433373373144701739), wrap_int(5040760773694741353), wrap_int(8699918547789986541), wrap_int(9211723439219092053), wrap_int(3601466436760036882), wrap_int(7470213384180375061), wrap_int(1117614654415514338), wrap_int(6489709663619239074), wrap_int(5606821764793080769), wrap_int(5533040684385323261), wrap_int(1663669870068057261), wrap_int(117658820550690687), wrap_int(5802967177524872313), wrap_int(824677791803551085), wrap_int(8130960541536503068), wrap_int(7941328653734718836), wrap_int(3551730520657107195), wrap_int(3183297803310667173), wrap_int(1744452363855034208), wrap_int(2206249608643212372), wrap_int(6805671707252313743), wrap_int(3765414947444962371), wrap_int(6871722428624542946), wrap_int(5429903326499666841), wrap_int(9118768768355899725), wrap_int(2775018401536039120), wrap_int(2838922854846376990), wrap_int(3633686101842554817), wrap_int(7756171914139767657), wrap_int(1797750566355726798), wrap_int(1145745704236160436), wrap_int(7192058872525801155)])):
    return sym_sum(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) for v in vecs))) >= sym_len(vecs) * wrap_int(3) / wrap_int(4)
Exception -- for puzzle LearnParityWithNoise:1 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 663/732: LearnParityWithNoise:2
sat_func def sat(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(576), wrap_int(823), wrap_int(480), wrap_int(899), wrap_int(652), wrap_int(1017), wrap_int(830), wrap_int(125), wrap_int(627), wrap_int(889), wrap_int(312), wrap_int(663), wrap_int(232), wrap_int(856), wrap_int(664), wrap_int(594), wrap_int(423), wrap_int(810), wrap_int(740), wrap_int(828), wrap_int(605), wrap_int(580), wrap_int(450), wrap_int(905), wrap_int(348)])):
    return sym_sum(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) for v in vecs))) >= sym_len(vecs) * wrap_int(3) / wrap_int(4)
Exception -- for puzzle LearnParityWithNoise:2 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 664/732: LearnParityWithNoise:3
sat_func def sat(inds: List[int], vecs=[378, 819, 695, 649, 492, 277, 471, 241, 159, 733, 625, 355, 300, 241, 683, 445, 769, 167, 985, 346, 243, 546, 851, 476, 309]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(378), wrap_int(819), wrap_int(695), wrap_int(649), wrap_int(492), wrap_int(277), wrap_int(471), wrap_int(241), wrap_int(159), wrap_int(733), wrap_int(625), wrap_int(355), wrap_int(300), wrap_int(241), wrap_int(683), wrap_int(445), wrap_int(769), wrap_int(167), wrap_int(985), wrap_int(346), wrap_int(243), wrap_int(546), wrap_int(851), wrap_int(476), wrap_int(309)])):
    return sym_sum(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) for v in vecs))) >= sym_len(vecs) * wrap_int(3) / wrap_int(4)
Exception -- for puzzle LearnParityWithNoise:3 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 665/732: LearnParityWithNoise:4
sat_func def sat(inds: List[int], vecs=[5, 7, 4, 5, 4, 3, 6, 5, 5, 0, 7]):
    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4
modified_func def sat(inds: List[int], vecs=wrap_list([wrap_int(5), wrap_int(7), wrap_int(4), wrap_int(5), wrap_int(4), wrap_int(3), wrap_int(6), wrap_int(5), wrap_int(5), wrap_int(0), wrap_int(7)])):
    return sym_sum(sym_generator((sym_sum(sym_generator((v >> i & wrap_int(1) for i in inds))) % wrap_int(2) for v in vecs))) >= sym_len(vecs) * wrap_int(3) / wrap_int(4)
Exception -- for puzzle LearnParityWithNoise:4 unsupported operand type(s) for ** or pow(): 'int' and 'MockExpr'

Solving puzzle 666/732: FermatsLastTheorem:0
sat_func def sat(nums: List[int]):
    a, b, c, n = nums
    return (a ** n + b ** n == c ** n) and min(a, b, c) > 0 and n > 2
modified_func def sat(nums: List[int]):
    a, b, c, n = nums
    return (a ** n + b ** n == c ** n).__and__(min(a, b, c) > wrap_int(0)).__and__(n > wrap_int(2))
Exception -- for puzzle FermatsLastTheorem:0 not enough values to unpack (expected 4, got 1)

Solving puzzle 667/732: ThreeCubes:0
sat_func def sat(nums: List[int], target=983):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(983)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_769 Int)) (=> (and (>= list_pos_769 0) (< list_pos_769 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_769) 3) 0) 983)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:0
One large constant for extrapolation
Solving simpler variation replaced 983 with 3
sat_func def sat(nums: List[int], target=3):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(3)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_770 Int)) (=> (and (>= list_pos_770 0) (< list_pos_770 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_770) 3) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:0

Solving puzzle 668/732: ThreeCubes:1
sat_func def sat(nums: List[int], target=114):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(114)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_771 Int)) (=> (and (>= list_pos_771 0) (< list_pos_771 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_771) 3) 0) 114)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:1
One large constant for extrapolation
Solving simpler variation replaced 114 with 3
sat_func def sat(nums: List[int], target=3):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(3)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_772 Int)) (=> (and (>= list_pos_772 0) (< list_pos_772 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_772) 3) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:1

Solving puzzle 669/732: ThreeCubes:2
sat_func def sat(nums: List[int], target=390):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(390)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_773 Int)) (=> (and (>= list_pos_773 0) (< list_pos_773 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_773) 3) 0) 390)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:2
One large constant for extrapolation
Solving simpler variation replaced 390 with 3
sat_func def sat(nums: List[int], target=3):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(3)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_774 Int)) (=> (and (>= list_pos_774 0) (< list_pos_774 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_774) 3) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:2

Solving puzzle 670/732: ThreeCubes:3
sat_func def sat(nums: List[int], target=579):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(579)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_775 Int)) (=> (and (>= list_pos_775 0) (< list_pos_775 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_775) 3) 0) 579)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:3
One large constant for extrapolation
Solving simpler variation replaced 579 with 3
sat_func def sat(nums: List[int], target=3):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(3)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_776 Int)) (=> (and (>= list_pos_776 0) (< list_pos_776 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_776) 3) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:3

Solving puzzle 671/732: ThreeCubes:4
sat_func def sat(nums: List[int], target=69294):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(69294)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_777 Int)) (=> (and (>= list_pos_777 0) (< list_pos_777 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_777) 3) 0) 69294)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:4
One large constant for extrapolation
Solving simpler variation replaced 69294 with 3
sat_func def sat(nums: List[int], target=3):
    assert target % 9 not in [4, 5], "Hint"
    return len(nums) == 3 and sum([i ** 3 for i in nums]) == target
modified_func def sat(nums: List[int], target=wrap_int(3)):
    _assert(target % wrap_int(9) not in wrap_list([wrap_int(4), wrap_int(5)]), wrap_str('Hint'))
    return (sym_len(nums) == wrap_int(3)).__and__(sym_sum([i ** wrap_int(3) for i in nums]) == target)
Skipping constant true constraint
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_778 Int)) (=> (and (>= list_pos_778 0) (< list_pos_778 (list.length.int x))) (and (= (list.length.int x) 3) (= (+ (^ (list.get.int x list_pos_778) 3) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ThreeCubes:4

Solving puzzle 672/732: FourSquares:0
sat_func def sat(nums: List[int], n=12345):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
modified_func def sat(nums: List[int], n=wrap_int(12345)):
    return (sym_len(nums) <= wrap_int(4)).__and__(sym_sum(sym_generator((i ** wrap_int(2) for i in nums))) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_779 Int)) (=> (and (>= list_pos_779 0) (< list_pos_779 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (^ (list.get.int x list_pos_779) 2) 0) 12345)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FourSquares:0
One large constant for extrapolation
Solving simpler variation replaced 12345 with 3
sat_func def sat(nums: List[int], n=3):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
modified_func def sat(nums: List[int], n=wrap_int(3)):
    return (sym_len(nums) <= wrap_int(4)).__and__(sym_sum(sym_generator((i ** wrap_int(2) for i in nums))) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_780 Int)) (=> (and (>= list_pos_780 0) (< list_pos_780 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (^ (list.get.int x list_pos_780) 2) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FourSquares:0

Solving puzzle 673/732: FourSquares:1
sat_func def sat(nums: List[int], n=1):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
modified_func def sat(nums: List[int], n=wrap_int(1)):
    return (sym_len(nums) <= wrap_int(4)).__and__(sym_sum(sym_generator((i ** wrap_int(2) for i in nums))) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_781 Int)) (=> (and (>= list_pos_781 0) (< list_pos_781 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (^ (list.get.int x list_pos_781) 2) 0) 1)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FourSquares:1
Too many constants for extrapolation

Solving puzzle 674/732: FourSquares:2
sat_func def sat(nums: List[int], n=0):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
modified_func def sat(nums: List[int], n=wrap_int(0)):
    return (sym_len(nums) <= wrap_int(4)).__and__(sym_sum(sym_generator((i ** wrap_int(2) for i in nums))) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_782 Int)) (=> (and (>= list_pos_782 0) (< list_pos_782 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (^ (list.get.int x list_pos_782) 2) 0) 0)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FourSquares:2
Too many constants for extrapolation

Solving puzzle 675/732: FourSquares:3
sat_func def sat(nums: List[int], n=1321806837666853665854863414407013350963513):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
modified_func def sat(nums: List[int], n=wrap_int(1321806837666853665854863414407013350963513)):
    return (sym_len(nums) <= wrap_int(4)).__and__(sym_sum(sym_generator((i ** wrap_int(2) for i in nums))) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_783 Int)) (=> (and (>= list_pos_783 0) (< list_pos_783 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (^ (list.get.int x list_pos_783) 2) 0) 1321806837666853665854863414407013350963513)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FourSquares:3
One large constant for extrapolation
Solving simpler variation replaced 1321806837666853665854863414407013350963513 with 3
sat_func def sat(nums: List[int], n=3):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
modified_func def sat(nums: List[int], n=wrap_int(3)):
    return (sym_len(nums) <= wrap_int(4)).__and__(sym_sum(sym_generator((i ** wrap_int(2) for i in nums))) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_784 Int)) (=> (and (>= list_pos_784 0) (< list_pos_784 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (^ (list.get.int x list_pos_784) 2) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FourSquares:3

Solving puzzle 676/732: FourSquares:4
sat_func def sat(nums: List[int], n=254723967601711775999551029856500295000994603):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
modified_func def sat(nums: List[int], n=wrap_int(254723967601711775999551029856500295000994603)):
    return (sym_len(nums) <= wrap_int(4)).__and__(sym_sum(sym_generator((i ** wrap_int(2) for i in nums))) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_785 Int)) (=> (and (>= list_pos_785 0) (< list_pos_785 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (^ (list.get.int x list_pos_785) 2) 0) 254723967601711775999551029856500295000994603)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FourSquares:4
One large constant for extrapolation
Solving simpler variation replaced 254723967601711775999551029856500295000994603 with 3
sat_func def sat(nums: List[int], n=3):
    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n
modified_func def sat(nums: List[int], n=wrap_int(3)):
    return (sym_len(nums) <= wrap_int(4)).__and__(sym_sum(sym_generator((i ** wrap_int(2) for i in nums))) == n)
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_786 Int)) (=> (and (>= list_pos_786 0) (< list_pos_786 (list.length.int x))) (and (<= (list.length.int x) 4) (= (+ (^ (list.get.int x list_pos_786) 2) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle FourSquares:4

Solving puzzle 677/732: Znam:0
sat_func def sat(li: List[int], k=5):
    def prod(nums):
        ans = 1
        for i in nums:
            ans *= i
        return ans

    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))
modified_func def sat(li: List[int], k=wrap_int(5)):

    def prod(nums):
        ans = wrap_int(1)
        for i in nums:
            ans *= i
        return ans
    return (min(li) > wrap_int(1)).__and__(sym_len(li) == k).__and__(all(sym_generator(((wrap_int(1) + prod(li[:i] + li[i + 1:])) % li[i] == wrap_int(0) for i in sym_range(k)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_792 Int)) (=> (and (>= list_pos_792 0) (< list_pos_792 (list.length.int (list.append.int (list.slice.int x 0 4 1) (list.slice.int x 5 -1 1))))) (forall ((list_pos_791 Int)) (=> (and (>= list_pos_791 0) (< list_pos_791 (list.length.int (list.append.int (list.slice.int x 0 3 1) (list.slice.int x 4 -1 1))))) (forall ((list_pos_790 Int)) (=> (and (>= list_pos_790 0) (< list_pos_790 (list.length.int (list.append.int (list.slice.int x 0 2 1) (list.slice.int x 3 -1 1))))) (forall ((list_pos_789 Int)) (=> (and (>= list_pos_789 0) (< list_pos_789 (list.length.int (list.append.int (list.slice.int x 0 1 1) (list.slice.int x 2 -1 1))))) (forall ((list_pos_788 Int)) (=> (and (>= list_pos_788 0) (< list_pos_788 (list.length.int (list.append.int (list.slice.int x 0 -1 1) (list.slice.int x 1 -1 1))))) (forall ((list_pos_787 Int)) (=> (and (>= list_pos_787 0) (< list_pos_787 (list.length.int x))) (and (and (> (list.get.int x list_pos_787) 1) (= (list.length.int x) 5)) (and (a...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Znam:0
Too many constants for extrapolation

Solving puzzle 678/732: Znam:1
sat_func def sat(li: List[int], k=6):
    def prod(nums):
        ans = 1
        for i in nums:
            ans *= i
        return ans

    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))
modified_func def sat(li: List[int], k=wrap_int(6)):

    def prod(nums):
        ans = wrap_int(1)
        for i in nums:
            ans *= i
        return ans
    return (min(li) > wrap_int(1)).__and__(sym_len(li) == k).__and__(all(sym_generator(((wrap_int(1) + prod(li[:i] + li[i + 1:])) % li[i] == wrap_int(0) for i in sym_range(k)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_799 Int)) (=> (and (>= list_pos_799 0) (< list_pos_799 (list.length.int (list.append.int (list.slice.int x 0 5 1) (list.slice.int x 6 -1 1))))) (forall ((list_pos_798 Int)) (=> (and (>= list_pos_798 0) (< list_pos_798 (list.length.int (list.append.int (list.slice.int x 0 4 1) (list.slice.int x 5 -1 1))))) (forall ((list_pos_797 Int)) (=> (and (>= list_pos_797 0) (< list_pos_797 (list.length.int (list.append.int (list.slice.int x 0 3 1) (list.slice.int x 4 -1 1))))) (forall ((list_pos_796 Int)) (=> (and (>= list_pos_796 0) (< list_pos_796 (list.length.int (list.append.int (list.slice.int x 0 2 1) (list.slice.int x 3 -1 1))))) (forall ((list_pos_795 Int)) (=> (and (>= list_pos_795 0) (< list_pos_795 (list.length.int (list.append.int (list.slice.int x 0 1 1) (list.slice.int x 2 -1 1))))) (forall ((list_pos_794 Int)) (=> (and (>= list_pos_794 0) (< list_pos_794 (list.length.int (list.append.int (list.slice.int x 0 -1 1) (list.slice.int x 1 -1 1))))) (forall ((lis...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Znam:1
Too many constants for extrapolation

Solving puzzle 679/732: Znam:2
sat_func def sat(li: List[int], k=7):
    def prod(nums):
        ans = 1
        for i in nums:
            ans *= i
        return ans

    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))
modified_func def sat(li: List[int], k=wrap_int(7)):

    def prod(nums):
        ans = wrap_int(1)
        for i in nums:
            ans *= i
        return ans
    return (min(li) > wrap_int(1)).__and__(sym_len(li) == k).__and__(all(sym_generator(((wrap_int(1) + prod(li[:i] + li[i + 1:])) % li[i] == wrap_int(0) for i in sym_range(k)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_807 Int)) (=> (and (>= list_pos_807 0) (< list_pos_807 (list.length.int (list.append.int (list.slice.int x 0 6 1) (list.slice.int x 7 -1 1))))) (forall ((list_pos_806 Int)) (=> (and (>= list_pos_806 0) (< list_pos_806 (list.length.int (list.append.int (list.slice.int x 0 5 1) (list.slice.int x 6 -1 1))))) (forall ((list_pos_805 Int)) (=> (and (>= list_pos_805 0) (< list_pos_805 (list.length.int (list.append.int (list.slice.int x 0 4 1) (list.slice.int x 5 -1 1))))) (forall ((list_pos_804 Int)) (=> (and (>= list_pos_804 0) (< list_pos_804 (list.length.int (list.append.int (list.slice.int x 0 3 1) (list.slice.int x 4 -1 1))))) (forall ((list_pos_803 Int)) (=> (and (>= list_pos_803 0) (< list_pos_803 (list.length.int (list.append.int (list.slice.int x 0 2 1) (list.slice.int x 3 -1 1))))) (forall ((list_pos_802 Int)) (=> (and (>= list_pos_802 0) (< list_pos_802 (list.length.int (list.append.int (list.slice.int x 0 1 1) (list.slice.int x 2 -1 1))))) (forall ((list...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Znam:2
Too many constants for extrapolation

Solving puzzle 680/732: Znam:3
sat_func def sat(li: List[int], k=8):
    def prod(nums):
        ans = 1
        for i in nums:
            ans *= i
        return ans

    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))
modified_func def sat(li: List[int], k=wrap_int(8)):

    def prod(nums):
        ans = wrap_int(1)
        for i in nums:
            ans *= i
        return ans
    return (min(li) > wrap_int(1)).__and__(sym_len(li) == k).__and__(all(sym_generator(((wrap_int(1) + prod(li[:i] + li[i + 1:])) % li[i] == wrap_int(0) for i in sym_range(k)))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun list.adjust_index ((idx Int) (len Int)) Int
  (ite (< idx 0)
       (+ len idx)
       idx))
(define-fun list.valid_index.int ((l (List Int)) (idx Int)) Bool
  (and (>= idx 0) (< idx (list.length.int l))))

(define-fun-rec list.slice.int.helper ((l (List Int)) (curr Int) (stop Int) (step Int) (result (List Int))) (List Int)
  (ite (or (and (> step 0) (>= curr stop))     ;; Positive step and reached/passed stop
           (and (< step 0) (<= curr stop))     ;; Negative step and reached/passed stop
           (not (list.valid_index.int l curr))) ;; Index out of bounds
       result
       (let ((new_result (cons (list.get.int l curr) result)))
         (list.slice.int.helper l (+ curr step) stop step new_result))))

(define-fun-rec list.reverse.int ((l (List Int)) (acc (List Int))) (List Int)
  (ite (= l (as nil (List Int)))
       acc
       (list.reverse.int (tail l) (cons (head l) acc))))

(define-fun list.slice.int ((l (List Int)) (start Int) (stop Int) (step Int)) (List Int)
  (let ((len (list.length.int l)))
    (ite (= step 0)
         (as nil (List Int))  ;; Invalid step, return empty list
         (let ((adj_start (list.adjust_index start len))
               (adj_stop (list.adjust_index stop len)))
           (ite (> step 0)
                ;; For positive step
                (list.reverse.int 
                  (list.slice.int.helper l adj_start adj_stop step (as nil (List Int)))
                  (as nil (List Int)))
                ;; For negative step, reverse parameters
                (let ((real_start (- len 1 adj_start))
                      (real_stop (- len 1 adj_stop)))
                  (list.reverse.int 
                    (list.slice.int.helper l real_start real_stop (ite (< step 0) (- 0 step) step) (as nil (List Int)))
                    (as nil (List Int)))))))))

(declare-const x (List Int))
(assert (forall ((list_pos_816 Int)) (=> (and (>= list_pos_816 0) (< list_pos_816 (list.length.int (list.append.int (list.slice.int x 0 7 1) (list.slice.int x 8 -1 1))))) (forall ((list_pos_815 Int)) (=> (and (>= list_pos_815 0) (< list_pos_815 (list.length.int (list.append.int (list.slice.int x 0 6 1) (list.slice.int x 7 -1 1))))) (forall ((list_pos_814 Int)) (=> (and (>= list_pos_814 0) (< list_pos_814 (list.length.int (list.append.int (list.slice.int x 0 5 1) (list.slice.int x 6 -1 1))))) (forall ((list_pos_813 Int)) (=> (and (>= list_pos_813 0) (< list_pos_813 (list.length.int (list.append.int (list.slice.int x 0 4 1) (list.slice.int x 5 -1 1))))) (forall ((list_pos_812 Int)) (=> (and (>= list_pos_812 0) (< list_pos_812 (list.length.int (list.append.int (list.slice.int x 0 3 1) (list.slice.int x 4 -1 1))))) (forall ((list_pos_811 Int)) (=> (and (>= list_pos_811 0) (< list_pos_811 (list.length.int (list.append.int (list.slice.int x 0 2 1) (list.slice.int x 3 -1 1))))) (forall ((list...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Znam:3
Too many constants for extrapolation

Solving puzzle 681/732: BallotProblem:0
sat_func def sat(counts: List[int], target_prob=0.5):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
modified_func def sat(counts: List[int], target_prob=0.5):
    m, n = counts
    probs = wrap_list([1.0]) + wrap_list([0.0]) * n
    for i in sym_range(2, m + 1):
        old_probs = probs
        probs = wrap_list([1.0]) + wrap_list([0.0]) * n
        for j in sym_range(1, min(n + 1, i)):
            probs[j] = j / (i + j) * probs[j - wrap_int(1)] + i / (i + j) * old_probs[j]
    return abs(probs[n] - target_prob) < 1e-06
Exception -- for puzzle BallotProblem:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 682/732: BallotProblem:1
sat_func def sat(counts: List[int], target_prob=0.1791044776119403):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
modified_func def sat(counts: List[int], target_prob=0.1791044776119403):
    m, n = counts
    probs = wrap_list([1.0]) + wrap_list([0.0]) * n
    for i in sym_range(2, m + 1):
        old_probs = probs
        probs = wrap_list([1.0]) + wrap_list([0.0]) * n
        for j in sym_range(1, min(n + 1, i)):
            probs[j] = j / (i + j) * probs[j - wrap_int(1)] + i / (i + j) * old_probs[j]
    return abs(probs[n] - target_prob) < 1e-06
Exception -- for puzzle BallotProblem:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 683/732: BallotProblem:2
sat_func def sat(counts: List[int], target_prob=0.03125):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
modified_func def sat(counts: List[int], target_prob=0.03125):
    m, n = counts
    probs = wrap_list([1.0]) + wrap_list([0.0]) * n
    for i in sym_range(2, m + 1):
        old_probs = probs
        probs = wrap_list([1.0]) + wrap_list([0.0]) * n
        for j in sym_range(1, min(n + 1, i)):
            probs[j] = j / (i + j) * probs[j - wrap_int(1)] + i / (i + j) * old_probs[j]
    return abs(probs[n] - target_prob) < 1e-06
Exception -- for puzzle BallotProblem:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 684/732: BallotProblem:3
sat_func def sat(counts: List[int], target_prob=0.5803571428571429):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
modified_func def sat(counts: List[int], target_prob=0.5803571428571429):
    m, n = counts
    probs = wrap_list([1.0]) + wrap_list([0.0]) * n
    for i in sym_range(2, m + 1):
        old_probs = probs
        probs = wrap_list([1.0]) + wrap_list([0.0]) * n
        for j in sym_range(1, min(n + 1, i)):
            probs[j] = j / (i + j) * probs[j - wrap_int(1)] + i / (i + j) * old_probs[j]
    return abs(probs[n] - target_prob) < 1e-06
Exception -- for puzzle BallotProblem:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 685/732: BallotProblem:4
sat_func def sat(counts: List[int], target_prob=0.7142857142857143):
    m, n = counts  # m = num 1's, n = num -1's
    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1
    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i
        old_probs = probs
        probs = [1.0] + [0.0] * n
        for j in range(1, min(n + 1, i)):
            probs[j] = (
                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs
                    +
                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1
            )
    return abs(probs[n] - target_prob) < 1e-6
modified_func def sat(counts: List[int], target_prob=0.7142857142857143):
    m, n = counts
    probs = wrap_list([1.0]) + wrap_list([0.0]) * n
    for i in sym_range(2, m + 1):
        old_probs = probs
        probs = wrap_list([1.0]) + wrap_list([0.0]) * n
        for j in sym_range(1, min(n + 1, i)):
            probs[j] = j / (i + j) * probs[j - wrap_int(1)] + i / (i + j) * old_probs[j]
    return abs(probs[n] - target_prob) < 1e-06
Exception -- for puzzle BallotProblem:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 686/732: BinomialProbabilities:0
sat_func def sat(counts: List[int], p=0.5, target_prob=0.0625):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
modified_func def sat(counts: List[int], p=0.5, target_prob=0.0625):
    from itertools import product
    a, b = counts
    n = a + b
    prob = p ** a * (wrap_int(1) - p) ** b
    tot = sym_sum([prob for sample in product(wrap_list([wrap_int(0), wrap_int(1)]), repeat=n) if sym_sum(sample) == a])
    return abs(tot - target_prob) < 1e-06
Exception -- for puzzle BinomialProbabilities:0 not enough values to unpack (expected 2, got 1)

Solving puzzle 687/732: BinomialProbabilities:1
sat_func def sat(counts: List[int], p=0.7588822808660473, target_prob=0.41658075878732215):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
modified_func def sat(counts: List[int], p=0.7588822808660473, target_prob=0.41658075878732215):
    from itertools import product
    a, b = counts
    n = a + b
    prob = p ** a * (wrap_int(1) - p) ** b
    tot = sym_sum([prob for sample in product(wrap_list([wrap_int(0), wrap_int(1)]), repeat=n) if sym_sum(sample) == a])
    return abs(tot - target_prob) < 1e-06
Exception -- for puzzle BinomialProbabilities:1 not enough values to unpack (expected 2, got 1)

Solving puzzle 688/732: BinomialProbabilities:2
sat_func def sat(counts: List[int], p=0.6569421516251613, target_prob=0.01872902529162693):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
modified_func def sat(counts: List[int], p=0.6569421516251613, target_prob=0.01872902529162693):
    from itertools import product
    a, b = counts
    n = a + b
    prob = p ** a * (wrap_int(1) - p) ** b
    tot = sym_sum([prob for sample in product(wrap_list([wrap_int(0), wrap_int(1)]), repeat=n) if sym_sum(sample) == a])
    return abs(tot - target_prob) < 1e-06
Exception -- for puzzle BinomialProbabilities:2 not enough values to unpack (expected 2, got 1)

Solving puzzle 689/732: BinomialProbabilities:3
sat_func def sat(counts: List[int], p=0.20001220211746595, target_prob=0.13419930454361995):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
modified_func def sat(counts: List[int], p=0.20001220211746595, target_prob=0.13419930454361995):
    from itertools import product
    a, b = counts
    n = a + b
    prob = p ** a * (wrap_int(1) - p) ** b
    tot = sym_sum([prob for sample in product(wrap_list([wrap_int(0), wrap_int(1)]), repeat=n) if sym_sum(sample) == a])
    return abs(tot - target_prob) < 1e-06
Exception -- for puzzle BinomialProbabilities:3 not enough values to unpack (expected 2, got 1)

Solving puzzle 690/732: BinomialProbabilities:4
sat_func def sat(counts: List[int], p=0.004837079863490135, target_prob=3.5517791266002235e-13):
    from itertools import product
    a, b = counts
    n = a + b
    prob = (p ** a) * ((1-p) ** b)
    tot = sum([prob for sample in product([0, 1], repeat=n) if sum(sample) == a])
    return abs(tot - target_prob) < 1e-6
modified_func def sat(counts: List[int], p=0.004837079863490135, target_prob=3.5517791266002235e-13):
    from itertools import product
    a, b = counts
    n = a + b
    prob = p ** a * (wrap_int(1) - p) ** b
    tot = sym_sum([prob for sample in product(wrap_list([wrap_int(0), wrap_int(1)]), repeat=n) if sym_sum(sample) == a])
    return abs(tot - target_prob) < 1e-06
Exception -- for puzzle BinomialProbabilities:4 not enough values to unpack (expected 2, got 1)

Solving puzzle 691/732: StrSlice:0
sat_func def sat(inds: List[int], s="hello world", target="do"):
    i, j, k = inds
    return s[i:j:k] == target
modified_func def sat(inds: List[int], s=wrap_str('hello world'), target=wrap_str('do')):
    i, j, k = inds
    return s[i:j:k] == target
Exception -- for puzzle StrSlice:0 not enough values to unpack (expected 3, got 1)

Solving puzzle 692/732: StrSlice:1
sat_func def sat(inds: List[int], s="ninykofiwimninykofiwim", target=""):
    i, j, k = inds
    return s[i:j:k] == target
modified_func def sat(inds: List[int], s=wrap_str('ninykofiwimninykofiwim'), target=wrap_str('')):
    i, j, k = inds
    return s[i:j:k] == target
Exception -- for puzzle StrSlice:1 not enough values to unpack (expected 3, got 1)

Solving puzzle 693/732: StrSlice:2
sat_func def sat(inds: List[int], s="limerybinylimerybiny", target="n"):
    i, j, k = inds
    return s[i:j:k] == target
modified_func def sat(inds: List[int], s=wrap_str('limerybinylimerybiny'), target=wrap_str('n')):
    i, j, k = inds
    return s[i:j:k] == target
Exception -- for puzzle StrSlice:2 not enough values to unpack (expected 3, got 1)

Solving puzzle 694/732: StrSlice:3
sat_func def sat(inds: List[int], s="fyzihurothevirechahfyzihurothevirechah", target=""):
    i, j, k = inds
    return s[i:j:k] == target
modified_func def sat(inds: List[int], s=wrap_str('fyzihurothevirechahfyzihurothevirechah'), target=wrap_str('')):
    i, j, k = inds
    return s[i:j:k] == target
Exception -- for puzzle StrSlice:3 not enough values to unpack (expected 3, got 1)

Solving puzzle 695/732: StrSlice:4
sat_func def sat(inds: List[int], s="kibozekiboze", target=""):
    i, j, k = inds
    return s[i:j:k] == target
modified_func def sat(inds: List[int], s=wrap_str('kibozekiboze'), target=wrap_str('')):
    i, j, k = inds
    return s[i:j:k] == target
Exception -- for puzzle StrSlice:4 not enough values to unpack (expected 3, got 1)

Solving puzzle 696/732: StrIn2:0
sat_func def sat(substrings: List[str], s="hello", count=15):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
modified_func def sat(substrings: List[str], s=wrap_str('hello'), count=wrap_int(15)):
    return (sym_len(substrings) == sym_len(set(substrings))).__and__(sym_len(set(substrings)) >= count).__and__(all(sym_generator((sym_in(sub, s) for sub in substrings))))
Exception -- for puzzle StrIn2:0 Symbolic hash not yet implemented

Solving puzzle 697/732: StrIn2:1
sat_func def sat(substrings: List[str], s="rywixekugagethathulisitextanyp", count=451):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
modified_func def sat(substrings: List[str], s=wrap_str('rywixekugagethathulisitextanyp'), count=wrap_int(451)):
    return (sym_len(substrings) == sym_len(set(substrings))).__and__(sym_len(set(substrings)) >= count).__and__(all(sym_generator((sym_in(sub, s) for sub in substrings))))
Exception -- for puzzle StrIn2:1 Symbolic hash not yet implemented

Solving puzzle 698/732: StrIn2:2
sat_func def sat(substrings: List[str], s="xetyvezitajithiban", count=165):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
modified_func def sat(substrings: List[str], s=wrap_str('xetyvezitajithiban'), count=wrap_int(165)):
    return (sym_len(substrings) == sym_len(set(substrings))).__and__(sym_len(set(substrings)) >= count).__and__(all(sym_generator((sym_in(sub, s) for sub in substrings))))
Exception -- for puzzle StrIn2:2 Symbolic hash not yet implemented

Solving puzzle 699/732: StrIn2:3
sat_func def sat(substrings: List[str], s="rofegakusaquybemydomimibyzodycetextunoce", count=799):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
modified_func def sat(substrings: List[str], s=wrap_str('rofegakusaquybemydomimibyzodycetextunoce'), count=wrap_int(799)):
    return (sym_len(substrings) == sym_len(set(substrings))).__and__(sym_len(set(substrings)) >= count).__and__(all(sym_generator((sym_in(sub, s) for sub in substrings))))
Exception -- for puzzle StrIn2:3 Symbolic hash not yet implemented

Solving puzzle 700/732: StrIn2:4
sat_func def sat(substrings: List[str], s="thacyt", count=21):
    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)
modified_func def sat(substrings: List[str], s=wrap_str('thacyt'), count=wrap_int(21)):
    return (sym_len(substrings) == sym_len(set(substrings))).__and__(sym_len(set(substrings)) >= count).__and__(all(sym_generator((sym_in(sub, s) for sub in substrings))))
Exception -- for puzzle StrIn2:4 Symbolic hash not yet implemented

Solving puzzle 701/732: StrParts:0
sat_func def sat(parts: List[str], sep="!!", string="I!!!!!love!!dumplings!!!!!"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
modified_func def sat(parts: List[str], sep=wrap_str('!!'), string=wrap_str('I!!!!!love!!dumplings!!!!!')):
    return (sep.join(parts) == string).__and__(all(sym_generator((sep not in p for p in parts))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (forall ((list_pos_837 Int)) (=> (and (>= list_pos_837 0) (< list_pos_837 (list.length.string x))) (and (= (python.join x "!!") "I!!!!!love!!dumplings!!!!!") false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle StrParts:0
Too many constants for extrapolation

Solving puzzle 702/732: StrParts:1
sat_func def sat(parts: List[str], sep="jachasurobithu", string="watalachyquujachasurobithuba"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
modified_func def sat(parts: List[str], sep=wrap_str('jachasurobithu'), string=wrap_str('watalachyquujachasurobithuba')):
    return (sep.join(parts) == string).__and__(all(sym_generator((sep not in p for p in parts))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (forall ((list_pos_838 Int)) (=> (and (>= list_pos_838 0) (< list_pos_838 (list.length.string x))) (and (= (python.join x "jachasurobithu") "watalachyquujachasurobithuba") false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle StrParts:1
Too many constants for extrapolation

Solving puzzle 703/732: StrParts:2
sat_func def sat(parts: List[str], sep="xusoquyvamathila", string="bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
modified_func def sat(parts: List[str], sep=wrap_str('xusoquyvamathila'), string=wrap_str('bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji')):
    return (sep.join(parts) == string).__and__(all(sym_generator((sep not in p for p in parts))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (forall ((list_pos_839 Int)) (=> (and (>= list_pos_839 0) (< list_pos_839 (list.length.string x))) (and (= (python.join x "xusoquyvamathila") "bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji") false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle StrParts:2
Too many constants for extrapolation

Solving puzzle 704/732: StrParts:3
sat_func def sat(parts: List[str], sep="chixachal", string=""):
    return sep.join(parts) == string and all(sep not in p for p in parts)
modified_func def sat(parts: List[str], sep=wrap_str('chixachal'), string=wrap_str('')):
    return (sep.join(parts) == string).__and__(all(sym_generator((sep not in p for p in parts))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (forall ((list_pos_840 Int)) (=> (and (>= list_pos_840 0) (< list_pos_840 (list.length.string x))) (and (= (python.join x "chixachal") "") false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle StrParts:3
Too many constants for extrapolation

Solving puzzle 705/732: StrParts:4
sat_func def sat(parts: List[str], sep="lochuv", string="biflochuvzulothanodugedusilochuvlilochuvhobegikofero"):
    return sep.join(parts) == string and all(sep not in p for p in parts)
modified_func def sat(parts: List[str], sep=wrap_str('lochuv'), string=wrap_str('biflochuvzulothanodugedusilochuvlilochuvhobegikofero')):
    return (sep.join(parts) == string).__and__(all(sym_generator((sep not in p for p in parts))))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))


(define-fun-rec python.join ((lst (List String)) (delim String)) String
    (ite (= lst (as nil (List String)))
         ""
         (ite (= (tail lst) (as nil (List String)))
              (head lst)
              (str.++ (head lst) 
                     delim 
                     (python.join (tail lst) delim)))))

(declare-const x (List String))
(assert (forall ((list_pos_841 Int)) (=> (and (>= list_pos_841 0) (< list_pos_841 (list.length.string x))) (and (= (python.join x "lochuv") "biflochuvzulothanodugedusilochuvlilochuvhobegikofero") false))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List String) (as nil (List String)))
)

Could not find any solution for puzzle StrParts:4
Too many constants for extrapolation

Solving puzzle 706/732: ListSetLen:0
sat_func def sat(li: List[int], dups=42155):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(42155)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_842 Int)) (=> (and (>= list_pos_842 0) (< list_pos_842 (list.length.int x))) (= (- (list.length.int x) 42155) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:0
One large constant for extrapolation
Solving simpler variation replaced 42155 with 3
sat_func def sat(li: List[int], dups=3):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(3)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_843 Int)) (=> (and (>= list_pos_843 0) (< list_pos_843 (list.length.int x))) (= (- (list.length.int x) 3) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:0

Solving puzzle 707/732: ListSetLen:1
sat_func def sat(li: List[int], dups=18793):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(18793)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_844 Int)) (=> (and (>= list_pos_844 0) (< list_pos_844 (list.length.int x))) (= (- (list.length.int x) 18793) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:1
One large constant for extrapolation
Solving simpler variation replaced 18793 with 3
sat_func def sat(li: List[int], dups=3):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(3)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_845 Int)) (=> (and (>= list_pos_845 0) (< list_pos_845 (list.length.int x))) (= (- (list.length.int x) 3) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:1

Solving puzzle 708/732: ListSetLen:2
sat_func def sat(li: List[int], dups=70976):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(70976)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_846 Int)) (=> (and (>= list_pos_846 0) (< list_pos_846 (list.length.int x))) (= (- (list.length.int x) 70976) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:2
One large constant for extrapolation
Solving simpler variation replaced 70976 with 3
sat_func def sat(li: List[int], dups=3):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(3)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_847 Int)) (=> (and (>= list_pos_847 0) (< list_pos_847 (list.length.int x))) (= (- (list.length.int x) 3) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:2

Solving puzzle 709/732: ListSetLen:3
sat_func def sat(li: List[int], dups=23476):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(23476)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_848 Int)) (=> (and (>= list_pos_848 0) (< list_pos_848 (list.length.int x))) (= (- (list.length.int x) 23476) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:3
One large constant for extrapolation
Solving simpler variation replaced 23476 with 3
sat_func def sat(li: List[int], dups=3):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(3)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_849 Int)) (=> (and (>= list_pos_849 0) (< list_pos_849 (list.length.int x))) (= (- (list.length.int x) 3) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:3

Solving puzzle 710/732: ListSetLen:4
sat_func def sat(li: List[int], dups=17633):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(17633)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_850 Int)) (=> (and (>= list_pos_850 0) (< list_pos_850 (list.length.int x))) (= (- (list.length.int x) 17633) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:4
One large constant for extrapolation
Solving simpler variation replaced 17633 with 3
sat_func def sat(li: List[int], dups=3):
    return len(set(li)) == len(li) - dups
modified_func def sat(li: List[int], dups=wrap_int(3)):
    return sym_len(set(li)) == sym_len(li) - dups
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_851 Int)) (=> (and (>= list_pos_851 0) (< list_pos_851 (list.length.int x))) (= (- (list.length.int x) 3) 1))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle ListSetLen:4

Solving puzzle 711/732: ListMul:0
sat_func def sat(li: List[int], target=[17, 9, -1, 17, 9, -1], n=2):
    return li * n == target
modified_func def sat(li: List[int], target=wrap_list([wrap_int(17), wrap_int(9), -wrap_int(1), wrap_int(17), wrap_int(9), -wrap_int(1)]), n=wrap_int(2)):
    return li * n == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (* 2 x) (cons 17 (cons 9 (cons -1 (cons 17 (cons 9 (cons -1 (as nil (List Int))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.18: expecting an arithmetic subterm")

Could not find any solution for puzzle ListMul:0
Too many constants for extrapolation

Solving puzzle 712/732: ListMul:1
sat_func def sat(li: List[int], target=[-69358, -69358, -69358, -69358, -69358, -69358, -69358], n=7):
    return li * n == target
modified_func def sat(li: List[int], target=wrap_list([-wrap_int(69358), -wrap_int(69358), -wrap_int(69358), -wrap_int(69358), -wrap_int(69358), -wrap_int(69358), -wrap_int(69358)]), n=wrap_int(7)):
    return li * n == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (* 7 x) (cons -69358 (cons -69358 (cons -69358 (cons -69358 (cons -69358 (cons -69358 (cons -69358 (as nil (List Int)))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.18: expecting an arithmetic subterm")

Could not find any solution for puzzle ListMul:1
One large constant for extrapolation
Solving simpler variation replaced 69358 with 3
sat_func def sat(li: List[int], target=[-3, -3, -3, -3, -3, -3, -3], n=7):
    return li * n == target
modified_func def sat(li: List[int], target=wrap_list([-wrap_int(3), -wrap_int(3), -wrap_int(3), -wrap_int(3), -wrap_int(3), -wrap_int(3), -wrap_int(3)]), n=wrap_int(7)):
    return li * n == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (* 7 x) (cons -3 (cons -3 (cons -3 (cons -3 (cons -3 (cons -3 (cons -3 (as nil (List Int)))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.18: expecting an arithmetic subterm")

Could not find any solution for puzzle ListMul:1

Solving puzzle 713/732: ListMul:2
sat_func def sat(li: List[int], target=[-51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344], n=8):
    return li * n == target
modified_func def sat(li: List[int], target=wrap_list([-wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344), -wrap_int(51721), -wrap_int(18394), -wrap_int(51187), -wrap_int(39897), wrap_int(18547), wrap_int(42761), -wrap_int(8992), wrap_int(66683), wrap_int(78344)]), n=wrap_int(8)):
    return li * n == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (* 8 x) (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -8992 (cons 66683 (cons 78344 (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -8992 (cons 66683 (cons 78344 (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -8992 (cons 66683 (cons 78344 (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -8992 (cons 66683 (cons 78344 (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -8992 (cons 66683 (cons 78344 (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -8992 (cons 66683 (cons 78344 (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -8992 (cons 66683 (cons 78344 (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -8992 (cons 66683 (cons 78344 (cons -51721 (cons -18394 (cons -51187 (cons -39897 (cons 18547 (cons 42761 (cons -89...
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.18: expecting an arithmetic subterm")

Could not find any solution for puzzle ListMul:2
Too many constants for extrapolation

Solving puzzle 714/732: ListMul:3
sat_func def sat(li: List[int], target=[], n=0):
    return li * n == target
modified_func def sat(li: List[int], target=wrap_list([]), n=wrap_int(0)):
    return li * n == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (* 0 x) (as nil (List Int))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.18: expecting an arithmetic subterm")

Could not find any solution for puzzle ListMul:3
Too many constants for extrapolation

Solving puzzle 715/732: ListMul:4
sat_func def sat(li: List[int], target=[-25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766, -25821, -22076, 28354, -16195, 51325, 54104, -89614, 9766], n=4):
    return li * n == target
modified_func def sat(li: List[int], target=wrap_list([-wrap_int(25821), -wrap_int(22076), wrap_int(28354), -wrap_int(16195), wrap_int(51325), wrap_int(54104), -wrap_int(89614), wrap_int(9766), -wrap_int(25821), -wrap_int(22076), wrap_int(28354), -wrap_int(16195), wrap_int(51325), wrap_int(54104), -wrap_int(89614), wrap_int(9766), -wrap_int(25821), -wrap_int(22076), wrap_int(28354), -wrap_int(16195), wrap_int(51325), wrap_int(54104), -wrap_int(89614), wrap_int(9766), -wrap_int(25821), -wrap_int(22076), wrap_int(28354), -wrap_int(16195), wrap_int(51325), wrap_int(54104), -wrap_int(89614), wrap_int(9766), -wrap_int(25821), -wrap_int(22076), wrap_int(28354), -wrap_int(16195), wrap_int(51325), wrap_int(54104), -wrap_int(89614), wrap_int(9766), -wrap_int(25821), -wrap_int(22076), wrap_int(28354), -wrap_int(16195), wrap_int(51325), wrap_int(54104), -wrap_int(89614), wrap_int(9766), -wrap_int(25821), -wrap_int(22076), wrap_int(28354), -wrap_int(16195), wrap_int(51325), wrap_int(54104), -wrap_int(89614), wrap_int(9766), -wrap_int(25821), -wrap_int(22076), wrap_int(28354), -wrap_int(16195), wrap_int(51325), wrap_int(54104), -wrap_int(89614), wrap_int(9766)]), n=wrap_int(4)):
    return li * n == target
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (* 4 x) (cons -25821 (cons -22076 (cons 28354 (cons -16195 (cons 51325 (cons 54104 (cons -89614 (cons 9766 (cons -25821 (cons -22076 (cons 28354 (cons -16195 (cons 51325 (cons 54104 (cons -89614 (cons 9766 (cons -25821 (cons -22076 (cons 28354 (cons -16195 (cons 51325 (cons 54104 (cons -89614 (cons 9766 (cons -25821 (cons -22076 (cons 28354 (cons -16195 (cons 51325 (cons 54104 (cons -89614 (cons 9766 (cons -25821 (cons -22076 (cons 28354 (cons -16195 (cons 51325 (cons 54104 (cons -89614 (cons 9766 (cons -25821 (cons -22076 (cons 28354 (cons -16195 (cons 51325 (cons 54104 (cons -89614 (cons 9766 (cons -25821 (cons -22076 (cons 28354 (cons -16195 (cons 51325 (cons 54104 (cons -89614 (cons 9766 (cons -25821 (cons -22076 (cons 28354 (cons -16195 (cons 51325 (cons 54104 (cons -89614 (cons 9766 (as nil (List Int))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
(error "Parse Error: tmp.smt2:99.18: expecting an arithmetic subterm")

Could not find any solution for puzzle ListMul:4
Too many constants for extrapolation

Solving puzzle 716/732: ListLen:0
sat_func def sat(li: List[int], n=85012):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(85012)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 85012))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListLen:0
One large constant for extrapolation
Solving simpler variation replaced 85012 with 3
sat_func def sat(li: List[int], n=3):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(3)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 ((as cons (List Int)) (- 5) (as nil (List Int))))))
)

Found solution [-4, 5, -5]

Solving puzzle 717/732: ListLen:1
sat_func def sat(li: List[int], n=969):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(969)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 969))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListLen:1
One large constant for extrapolation
Solving simpler variation replaced 969 with 3
sat_func def sat(li: List[int], n=3):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(3)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 ((as cons (List Int)) (- 5) (as nil (List Int))))))
)

Found solution [-4, 5, -5]

Solving puzzle 718/732: ListLen:2
sat_func def sat(li: List[int], n=7051):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(7051)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 7051))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListLen:2
One large constant for extrapolation
Solving simpler variation replaced 7051 with 3
sat_func def sat(li: List[int], n=3):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(3)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 ((as cons (List Int)) (- 5) (as nil (List Int))))))
)

Found solution [-4, 5, -5]

Solving puzzle 719/732: ListLen:3
sat_func def sat(li: List[int], n=9):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(9)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 9))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 5) ((as cons (List Int)) (- 6) ((as cons (List Int)) (- 7) ((as cons (List Int)) (- 8) ((as cons (List Int)) (- 9) ((as cons (List Int)) 10 ((as cons (List Int)) (- 10) ((as cons (List Int)) 11 ((as cons (List Int)) (- 11) (as nil (List Int))))))))))))
)

Found solution [-5, -6, -7, -8, -9, 10, -10, 11, -11]
Yes! Solved for puzzle  ListLen:3

Solving puzzle 720/732: ListLen:4
sat_func def sat(li: List[int], n=324):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(324)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 324))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListLen:4
One large constant for extrapolation
Solving simpler variation replaced 324 with 3
sat_func def sat(li: List[int], n=3):
    return len(li) == n
modified_func def sat(li: List[int], n=wrap_int(3)):
    return sym_len(li) == n
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 4) ((as cons (List Int)) 5 ((as cons (List Int)) (- 5) (as nil (List Int))))))
)

Found solution [-4, 5, -5]

Solving puzzle 721/732: ListSlice:0
sat_func def sat(inds: List[int], li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]):
    i, j, k = inds
    return li[i:j:k] == target
modified_func def sat(inds: List[int], li=wrap_list([wrap_int(42), wrap_int(18), wrap_int(21), wrap_int(103), -wrap_int(2), wrap_int(11)]), target=wrap_list([-wrap_int(2), wrap_int(21), wrap_int(42)])):
    i, j, k = inds
    return li[i:j:k] == target
Exception -- for puzzle ListSlice:0 not enough values to unpack (expected 3, got 1)

Solving puzzle 722/732: ListSlice:1
sat_func def sat(inds: List[int], li=[-11, 92, 42, 18, -83, 55, 13, 14, -67, -58, -41], target=[-67]):
    i, j, k = inds
    return li[i:j:k] == target
modified_func def sat(inds: List[int], li=wrap_list([-wrap_int(11), wrap_int(92), wrap_int(42), wrap_int(18), -wrap_int(83), wrap_int(55), wrap_int(13), wrap_int(14), -wrap_int(67), -wrap_int(58), -wrap_int(41)]), target=wrap_list([-wrap_int(67)])):
    i, j, k = inds
    return li[i:j:k] == target
Exception -- for puzzle ListSlice:1 not enough values to unpack (expected 3, got 1)

Solving puzzle 723/732: ListSlice:2
sat_func def sat(inds: List[int], li=[-53, -81, -92, 22, -67], target=[-53, -81, -92]):
    i, j, k = inds
    return li[i:j:k] == target
modified_func def sat(inds: List[int], li=wrap_list([-wrap_int(53), -wrap_int(81), -wrap_int(92), wrap_int(22), -wrap_int(67)]), target=wrap_list([-wrap_int(53), -wrap_int(81), -wrap_int(92)])):
    i, j, k = inds
    return li[i:j:k] == target
Exception -- for puzzle ListSlice:2 not enough values to unpack (expected 3, got 1)

Solving puzzle 724/732: ListSlice:3
sat_func def sat(inds: List[int], li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]):
    i, j, k = inds
    return li[i:j:k] == target
modified_func def sat(inds: List[int], li=wrap_list([-wrap_int(72), wrap_int(70), wrap_int(50), -wrap_int(41), wrap_int(94), -wrap_int(82), -wrap_int(74), wrap_int(8), -wrap_int(23)]), target=wrap_list([-wrap_int(82)])):
    i, j, k = inds
    return li[i:j:k] == target
Exception -- for puzzle ListSlice:3 not enough values to unpack (expected 3, got 1)

Solving puzzle 725/732: ListSlice:4
sat_func def sat(inds: List[int], li=[26, -25, -18, -53, 18, -71, -82, 20, -100, -84, -85], target=[-25]):
    i, j, k = inds
    return li[i:j:k] == target
modified_func def sat(inds: List[int], li=wrap_list([wrap_int(26), -wrap_int(25), -wrap_int(18), -wrap_int(53), wrap_int(18), -wrap_int(71), -wrap_int(82), wrap_int(20), -wrap_int(100), -wrap_int(84), -wrap_int(85)]), target=wrap_list([-wrap_int(25)])):
    i, j, k = inds
    return li[i:j:k] == target
Exception -- for puzzle ListSlice:4 not enough values to unpack (expected 3, got 1)

Solving puzzle 726/732: ListIndex2:0
sat_func def sat(li: List[int], i=29, index=10412):
    return li.index(i) == index
modified_func def sat(li: List[int], i=wrap_int(29), index=wrap_int(10412)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x 29) 10412))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListIndex2:0
One large constant for extrapolation
Solving simpler variation replaced 10412 with 3
sat_func def sat(li: List[int], i=29, index=3):
    return li.index(i) == index
modified_func def sat(li: List[int], i=wrap_int(29), index=wrap_int(3)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x 29) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 30 ((as cons (List Int)) 30 ((as cons (List Int)) 29 ((as cons (List Int)) 0 ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))))
)

Found solution [0, 30, 30, 29, 0, 0, 0]

Solving puzzle 727/732: ListIndex2:1
sat_func def sat(li: List[int], i=-99167, index=48792):
    return li.index(i) == index
modified_func def sat(li: List[int], i=-wrap_int(99167), index=wrap_int(48792)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x -99167) 48792))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListIndex2:1
Two large constants for extrapolation
Solving simpler variation replaced 48792 with 3 and 99167 with 5
sat_func def sat(li: List[int], i=-5, index=3):
    return li.index(i) == index
modified_func def sat(li: List[int], i=-wrap_int(5), index=wrap_int(3)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x -5) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) (- 4) ((as cons (List Int)) (- 4) ((as cons (List Int)) (- 5) ((as cons (List Int)) 0 ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))))
)

Found solution [0, -4, -4, -5, 0, 0, 0]

Solving puzzle 728/732: ListIndex2:2
sat_func def sat(li: List[int], i=-67679, index=87059):
    return li.index(i) == index
modified_func def sat(li: List[int], i=-wrap_int(67679), index=wrap_int(87059)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x -67679) 87059))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListIndex2:2
Two large constants for extrapolation
Solving simpler variation replaced 67679 with 3 and 87059 with 5
sat_func def sat(li: List[int], i=-3, index=5):
    return li.index(i) == index
modified_func def sat(li: List[int], i=-wrap_int(3), index=wrap_int(5)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x -3) 5))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) (- 2) ((as cons (List Int)) (- 2) ((as cons (List Int)) (- 2) ((as cons (List Int)) (- 2) ((as cons (List Int)) (- 3) ((as cons (List Int)) 0 ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))))))
)

Found solution [0, -2, -2, -2, -2, -3, 0, 0, 0]

Solving puzzle 729/732: ListIndex2:3
sat_func def sat(li: List[int], i=81395, index=79231):
    return li.index(i) == index
modified_func def sat(li: List[int], i=wrap_int(81395), index=wrap_int(79231)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x 81395) 79231))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListIndex2:3
Two large constants for extrapolation
Solving simpler variation replaced 79231 with 3 and 81395 with 5
sat_func def sat(li: List[int], i=5, index=3):
    return li.index(i) == index
modified_func def sat(li: List[int], i=wrap_int(5), index=wrap_int(3)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x 5) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 6 ((as cons (List Int)) 6 ((as cons (List Int)) 5 ((as cons (List Int)) 0 ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))))
)

Found solution [0, 6, 6, 5, 0, 0, 0]

Solving puzzle 730/732: ListIndex2:4
sat_func def sat(li: List[int], i=63344, index=1583):
    return li.index(i) == index
modified_func def sat(li: List[int], i=wrap_int(63344), index=wrap_int(1583)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x 63344) 1583))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
cvc5 interrupted by timeout.

Could not find any solution for puzzle ListIndex2:4
Two large constants for extrapolation
Solving simpler variation replaced 1583 with 3 and 63344 with 5
sat_func def sat(li: List[int], i=5, index=3):
    return li.index(i) == index
modified_func def sat(li: List[int], i=wrap_int(5), index=wrap_int(3)):
    return li.index(i) == index
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.index.int x 5) 3))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 6 ((as cons (List Int)) 6 ((as cons (List Int)) 5 ((as cons (List Int)) 0 ((as cons (List Int)) 0 ((as cons (List Int)) 0 (as nil (List Int))))))))))
)

Found solution [0, 6, 6, 5, 0, 0, 0]

Solving puzzle 731/732: Tutorial3:0
sat_func def sat(x: List[int]):
    return len(x) == 2 and sum(x) == 3
modified_func def sat(x: List[int]):
    return (sym_len(x) == wrap_int(2)).__and__(sym_sum(x) == wrap_int(3))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.contains.int ((l (List Int)) (val Int)) Bool
  (ite (= l (as nil (List Int)))
       false
       (ite (= (head l) val)
            true
            (list.contains.int (tail l) val))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.contains.string ((l (List String)) (val String)) Bool
  (ite (= l (as nil (List String)))
       false
       (ite (= (head l) val)
            true
            (list.contains.string (tail l) val))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))

(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (forall ((list_pos_857 Int)) (=> (and (>= list_pos_857 0) (< list_pos_857 (list.length.int x))) (and (= (list.length.int x) 2) (= (+ (list.get.int x list_pos_857) 0) 3)))))
(check-sat)
(get-model)

running backend cvc5
### output for cvc5
unknown
(
(define-fun x () (List Int) (as nil (List Int)))
)

Could not find any solution for puzzle Tutorial3:0
Too many constants for extrapolation

Solving puzzle 732/732: Tutorial4:0
sat_func def sat(s: List[str]):
    return len(set(s)) == 1000 and all((x.count("a") > x.count("b")) and ('b' in x) for x in s)
modified_func def sat(s: List[str]):
    return (sym_len(set(s)) == wrap_int(1000)).__and__(all(sym_generator(((x.count('a') > x.count('b')).__and__(sym_in(wrap_str('b'), x)) for x in s))))
Exception -- for puzzle Tutorial4:0 Symbolic hash not yet implemented

## Current status

The symbolic execution alone currently solves:
- 5% (29 out of 591) of `List[int]` puzzles,
- 11% (16 out of 141) of `List[str]` puzzles,
- 6% (45 out of 732) overall.

with the following errors:
- 10 timeouts after 3 seconds at staging time (while generating the SMTLIB program)
- 340 errors at at staging time
- 48 SMTLIB programs returning `sat` but the original `sat` function failing on synthesized model input,
- 303 SMTLIB programs returning non-`sat` (e.g. `unsat`, `unknown` or timing out after 2 seconds
timeouts after staging (while building the SMTLIB program), errors during staging time, the SMTLIB
- 983 (out of 1715) puzzles not yet even attempted because their type is not `int` or `str`, such as `float`, `list` (of various specialization), etc.

### Extrapolation
- 116 smaller problems tried
- 16 successes on smaller problem

