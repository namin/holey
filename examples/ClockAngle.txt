Inferred ans_type: List[int]
Using bounded list encoding (max size: 200)
sat_func def sat(hands: List[int], target_angle=45):
      h, m = hands
      assert 0 < h <= 12 and 0 <= m < 60
      hour_angle = 30 * h + m / 2
      minute_angle = 6 * m
      return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]

modified_func def sat(hands: List[int], target_angle=wrap_int(45)):
    _unpack_tmp_0 = hands
    _assert(sym_len(_unpack_tmp_0) == 2)
    h = _unpack_tmp_0[0]
    m = _unpack_tmp_0[1]
    _assert((wrap_int(0) < h).__and__(h <= wrap_int(12)).__and__((wrap_int(0) <= m).__and__(m < wrap_int(60))))
    hour_angle = wrap_int(30) * h + m / wrap_int(2)
    minute_angle = wrap_int(6) * m
    return sym_in(abs(hour_angle - minute_angle), wrap_list([target_angle, wrap_int(360) - target_angle]))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1)) 
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))

(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))

(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(define-fun-rec list.index.rec.int ((i Int) (l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       -1
       (ite (= (head l) val)
            i
            (list.index.rec.int (+ 1 i) (tail l) val))))

(define-fun list.index.int ((l (List Int)) (val Int)) Int
  (list.index.rec.int 0 l val))

(define-fun-rec list.length.string ((l (List String))) Int
  (ite (= l (as nil (List String)))
       0
       (+ 1 (list.length.string (tail l)))))

(define-fun-rec list.get.string ((l (List String)) (idx Int)) String
  (ite (< idx 0)
       (list.get.string l (+ (list.length.string l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.string (tail l) (- idx 1)))))

(define-fun-rec list.sum.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (head l) (list.sum.int (tail l)))))

(define-fun-rec list.append.int ((l1 (List Int)) (l2 (List Int))) (List Int)
  (ite (= l1 (as nil (List Int)))
       l2
       (cons (head l1) (list.append.int (tail l1) l2))))

(define-fun-rec list.append.string ((l1 (List String)) (l2 (List String))) (List String)
  (ite (= l1 (as nil (List String)))
       l2
       (cons (head l1) (list.append.string (tail l1) l2))))

(define-fun-rec list.map_add.int ((l (List Int)) (val Int)) (List Int)
  (ite (= l (as nil (List Int)))
       (as nil (List Int))
       (cons (+ (head l) val) (list.map_add.int (tail l) val))))


(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(define-fun list.contains.int ((l (List Int)) (val Int)) Bool
  (> (list.count.int l val) 0))

(define-fun-rec list.count.string ((l (List String)) (val String)) Int
  (ite (= l (as nil (List String)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.string (tail l) val))))

(define-fun list.contains.string ((l (List String)) (val String)) Bool
  (> (list.count.string l val) 0))

(define-fun-rec list.count.bool ((l (List Bool)) (val Bool)) Int
  (ite (= l (as nil (List Bool)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.bool (tail l) val))))

(define-fun-rec list.count.real ((l (List Real)) (val Real)) Int
  (ite (= l (as nil (List Real)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.real (tail l) val))))

(declare-const x (List Int))
(assert (= (list.length.int x) 2))
(assert (> (list.length.int x) 0))
(assert (> (list.length.int x) 1))
(assert (and (and (< 0 (list.get.int x 0)) (<= (list.get.int x 0) 12)) (and (<= 0 (list.get.int x 1)) (< (list.get.int x 1) 60))))
(assert (or (= (ite (>= (- (+ (* 30 (list.get.int x 0)) (/ (list.get.int x 1) 2)) (* 6 (list.get.int x 1))) 0) (- (+ (* 30 (list.get.int x 0)) (/ (list.get.int x 1) 2)) (* 6 (list.get.int x 1))) (- (- (+ (* 30 (list.get.int x 0)) (/ (list.get.int x 1) 2)) (* 6 (list.get.int x 1))))) 45) (= (ite (>= (- (+ (* 30 (list.get.int x 0)) (/ (list.get.int x 1) 2)) (* 6 (list.get.int x 1))) 0) (- (+ (* 30 (list.get.int x 0)) (/ (list.get.int x 1) 2)) (* 6 (list.get.int x 1))) (- (- (+ (* 30 (list.get.int x 0)) (/ (list.get.int x 1) 2)) (* 6 (list.get.int x 1))))) 315)))
(check-sat)
(get-model)

running backend z3
### output for z3
sat
(
  (define-fun x () (List Int)
    (cons 7 (cons 30 (as nil (List Int)))))
)

Found solution [7, 30]
Yes! Solved for puzzle  ./examples/ClockAngle.py
