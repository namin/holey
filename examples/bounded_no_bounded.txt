Inferred ans_type: List[int]
sat_func def sat(li: List[int]):
    return len(li) == 10 and li.count(li[3]) == 2
modified_func def sat(li: List[int]):
    return (sym_len(li) == wrap_int(10)).__and__(li.count(li[wrap_int(3)]) == wrap_int(2))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1))
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))


(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))


(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))


(define-fun-rec list.count.int ((l (List Int)) (val Int)) Int
  (ite (= l (as nil (List Int)))
       0
       (+ (ite (= (head l) val) 1 0)
          (list.count.int (tail l) val))))

(declare-const x (List Int))
(assert (> (list.length.int x) 3))
(assert (and (= (list.length.int x) 10) (= (list.count.int x (list.get.int x 3)) 2)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () (List Int)
    (let ((a!1 (cons 38 (cons 36 (cons 37 (cons 35 nil))))))
(let ((a!2 (cons 33 (cons 11 (cons 34 (cons 11 a!1))))))
  (cons 32 (cons 31 a!2)))))
)
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) 0 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 0 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 1 ((as cons (List Int)) 1 (as nil (List Int)))))))))))))
)

Found solution [32, 31, 33, 11, 34, 11, 38, 36, 37, 35]
Yes! Solved for puzzle  examples/bounded.py
