Inferred ans_type: List[int]
Using bounded list encoding (max size: 200)
sat_func def sat(li: List[int]):
    return (len(li) == 5 and
            li.count(li[3]) == 2)
Using bounded list with size 5
modified_func def sat(li: List[int]):
    return (sym_len(li) == wrap_int(5)).__and__(li.count(li[wrap_int(3)]) == wrap_int(2))
### smt2
(set-logic ALL)
(declare-const x_e0 Int)
(declare-const x_e1 Int)
(declare-const x_e2 Int)
(declare-const x_e3 Int)
(declare-const x_e4 Int)
(assert (= (+ (ite (= x_e0 x_e3) 1 0) (ite (= x_e1 x_e3) 1 0) (ite (= x_e2 x_e3) 1 0) (ite (= x_e3 x_e3) 1 0) (ite (= x_e4 x_e3) 1 0)) 2))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x_e0 () Int
    1)
  (define-fun x_e1 () Int
    1)
  (define-fun x_e2 () Int
    0)
  (define-fun x_e4 () Int
    1)
  (define-fun x_e3 () Int
    0)
)
### output for cvc5
sat
(
(define-fun x_e0 () Int (- 1))
(define-fun x_e1 () Int (- 1))
(define-fun x_e2 () Int 0)
(define-fun x_e3 () Int 0)
(define-fun x_e4 () Int 1)
)

Found solution [1, 1, 0, 0, 1]
Yes! Solved for puzzle  examples/bounded.py
