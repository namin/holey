Inferred ans_type: List[int]
Using bounded list encoding (max size: 200)
sat_func def sat(maxes: List[int], nums=[-15, -6]):
    for i in range(len(nums)):
        if i > 0:
             assert maxes[i] == max(maxes[i - 1], nums[i])
        else:
            assert maxes[0] == nums[0]
    return True
modified_func def sat(maxes: List[int], nums=wrap_list([-wrap_int(15), -wrap_int(6)])):
    for i in sym_range(sym_len(nums)):
        if i > wrap_int(0):
            _assert(maxes[i] == max(maxes[i - wrap_int(1)], nums[i]))
        else:
            _assert(maxes[wrap_int(0)] == nums[wrap_int(0)])
    return True
### smt2
(set-logic ALL)

(declare-datatypes ((List 1))
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))


(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))


(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(declare-const x (List Int))
(assert (> (list.length.int x) 0))
(assert (= (list.get.int x 0) -15))
(assert (> (list.length.int x) 1))
(assert (> (list.length.int x) (- 1 1)))
(assert (=> (> -6 (list.get.int x (- 1 1))) (= (list.get.int x 1) -6)))
(assert (=> (> -6 (list.get.int x (- 1 1))) true))
(assert (> (list.length.int x) 0))
(assert (= (list.get.int x 0) -15))
(assert (> (list.length.int x) 1))
(assert (> (list.length.int x) (- 1 1)))
(assert (=> (not (> -6 (list.get.int x (- 1 1)))) (= (list.get.int x 1) (list.get.int x (- 1 1)))))
(assert (=> (not (> -6 (list.get.int x (- 1 1)))) true))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () (List Int)
    (cons (- 15) (cons (- 6) nil)))
)
### output for cvc5
sat
(
(define-fun x () (List Int) ((as cons (List Int)) (- 15) ((as cons (List Int)) (- 6) (as nil (List Int)))))
)

Found solution [-15, -6]
Yes! Solved for puzzle  examples/RollingMax.py
