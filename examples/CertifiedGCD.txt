Inferred ans_type: List[int]
Using bounded list encoding (max size: 200)
sat_func def sat(ans: List[int], m=200004931, n=66679984):
    gcd, a, b = ans
    return m % gcd == n % gcd == 0 and a * m + b * n == gcd and gcd > 0
modified_func def sat(ans: List[int], m=wrap_int(200004931), n=wrap_int(66679984)):
    _unpack_tmp_0 = ans
    _assert(sym_len(_unpack_tmp_0) == 3)
    gcd = _unpack_tmp_0[0]
    a = _unpack_tmp_0[1]
    b = _unpack_tmp_0[2]
    return (m % gcd == n % gcd).__and__(n % gcd == wrap_int(0)).__and__(a * m + b * n == gcd).__and__(gcd > wrap_int(0))
### smt2
(set-logic ALL)

(declare-datatypes ((List 1))
    ((par (T) ((cons (head T) (tail (List T))) (nil)))))


(define-fun-rec list.length.int ((l (List Int))) Int
  (ite (= l (as nil (List Int)))
       0
       (+ 1 (list.length.int (tail l)))))


(define-fun-rec list.get.int ((l (List Int)) (idx Int)) Int
  (ite (< idx 0)
       (list.get.int l (+ (list.length.int l) idx))
  (ite (= idx 0)
       (head l)
       (list.get.int (tail l) (- idx 1)))))

(declare-const x (List Int))
(assert (= (list.length.int x) 3))
(assert (> (list.length.int x) 0))
(assert (> (list.length.int x) 1))
(assert (> (list.length.int x) 2))
(assert (not (= (list.get.int x 0) 0)))
(assert (not (= (list.get.int x 0) 0)))
(assert (not (= (list.get.int x 0) 0)))
(assert (and (and (and (= (mod 200004931 (list.get.int x 0)) (mod 66679984 (list.get.int x 0))) (= (mod 66679984 (list.get.int x 0)) 0)) (= (+ (* (list.get.int x 1) 200004931) (* (list.get.int x 2) 66679984)) (list.get.int x 0))) (> (list.get.int x 0) 0)))
(check-sat)
(get-model)

running backend z3
running backend cvc5
### output for z3
sat
(
  (define-fun x () (List Int)
    (cons 35021 (cons (- 1) (cons 3 nil))))
  (define-fun div0 ((x!0 Int) (x!1 Int)) Int
    (ite (and (= x!0 66679984) (= x!1 35021)) 1904
      5711))
  (define-fun mod0 ((x!0 Int) (x!1 Int)) Int
    0)
)
### output for cvc5
cvc5 interrupted by timeout.

Found solution [35021, -1, 3]
Yes! Solved for puzzle  examples/CertifiedGCD.py
